var nk=Object.defineProperty;var ik=(e,t,n)=>t in e?nk(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var He=(e,t,n)=>ik(e,typeof t!="symbol"?t+"":t,n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))o(a);new MutationObserver(a=>{for(const l of a)if(l.type==="childList")for(const f of l.addedNodes)f.tagName==="LINK"&&f.rel==="modulepreload"&&o(f)}).observe(document,{childList:!0,subtree:!0});function n(a){const l={};return a.integrity&&(l.integrity=a.integrity),a.referrerPolicy&&(l.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?l.credentials="include":a.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function o(a){if(a.ep)return;a.ep=!0;const l=n(a);fetch(a.href,l)}})();var Fo=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function W_(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Wv={exports:{}},gm={},Gv={exports:{}},Fr={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var fp=Symbol.for("react.element"),ok=Symbol.for("react.portal"),sk=Symbol.for("react.fragment"),ak=Symbol.for("react.strict_mode"),lk=Symbol.for("react.profiler"),uk=Symbol.for("react.provider"),ck=Symbol.for("react.context"),dk=Symbol.for("react.forward_ref"),fk=Symbol.for("react.suspense"),pk=Symbol.for("react.memo"),hk=Symbol.for("react.lazy"),b1=Symbol.iterator;function mk(e){return e===null||typeof e!="object"?null:(e=b1&&e[b1]||e["@@iterator"],typeof e=="function"?e:null)}var Hv={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},qv=Object.assign,Kv={};function yu(e,t,n){this.props=e,this.context=t,this.refs=Kv,this.updater=n||Hv}yu.prototype.isReactComponent={};yu.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};yu.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function Qv(){}Qv.prototype=yu.prototype;function G_(e,t,n){this.props=e,this.context=t,this.refs=Kv,this.updater=n||Hv}var H_=G_.prototype=new Qv;H_.constructor=G_;qv(H_,yu.prototype);H_.isPureReactComponent=!0;var x1=Array.isArray,Xv=Object.prototype.hasOwnProperty,q_={current:null},Yv={key:!0,ref:!0,__self:!0,__source:!0};function Zv(e,t,n){var o,a={},l=null,f=null;if(t!=null)for(o in t.ref!==void 0&&(f=t.ref),t.key!==void 0&&(l=""+t.key),t)Xv.call(t,o)&&!Yv.hasOwnProperty(o)&&(a[o]=t[o]);var _=arguments.length-2;if(_===1)a.children=n;else if(1<_){for(var m=Array(_),g=0;g<_;g++)m[g]=arguments[g+2];a.children=m}if(e&&e.defaultProps)for(o in _=e.defaultProps,_)a[o]===void 0&&(a[o]=_[o]);return{$$typeof:fp,type:e,key:l,ref:f,props:a,_owner:q_.current}}function gk(e,t){return{$$typeof:fp,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function K_(e){return typeof e=="object"&&e!==null&&e.$$typeof===fp}function _k(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var M1=/\/+/g;function yg(e,t){return typeof e=="object"&&e!==null&&e.key!=null?_k(""+e.key):t.toString(36)}function $h(e,t,n,o,a){var l=typeof e;(l==="undefined"||l==="boolean")&&(e=null);var f=!1;if(e===null)f=!0;else switch(l){case"string":case"number":f=!0;break;case"object":switch(e.$$typeof){case fp:case ok:f=!0}}if(f)return f=e,a=a(f),e=o===""?"."+yg(f,0):o,x1(a)?(n="",e!=null&&(n=e.replace(M1,"$&/")+"/"),$h(a,t,n,"",function(g){return g})):a!=null&&(K_(a)&&(a=gk(a,n+(!a.key||f&&f.key===a.key?"":(""+a.key).replace(M1,"$&/")+"/")+e)),t.push(a)),1;if(f=0,o=o===""?".":o+":",x1(e))for(var _=0;_<e.length;_++){l=e[_];var m=o+yg(l,_);f+=$h(l,t,n,m,a)}else if(m=mk(e),typeof m=="function")for(e=m.call(e),_=0;!(l=e.next()).done;)l=l.value,m=o+yg(l,_++),f+=$h(l,t,n,m,a);else if(l==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return f}function dh(e,t,n){if(e==null)return e;var o=[],a=0;return $h(e,o,"","",function(l){return t.call(n,l,a++)}),o}function yk(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var ai={current:null},Ah={transition:null},wk={ReactCurrentDispatcher:ai,ReactCurrentBatchConfig:Ah,ReactCurrentOwner:q_};function Jv(){throw Error("act(...) is not supported in production builds of React.")}Fr.Children={map:dh,forEach:function(e,t,n){dh(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return dh(e,function(){t++}),t},toArray:function(e){return dh(e,function(t){return t})||[]},only:function(e){if(!K_(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};Fr.Component=yu;Fr.Fragment=sk;Fr.Profiler=lk;Fr.PureComponent=G_;Fr.StrictMode=ak;Fr.Suspense=fk;Fr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=wk;Fr.act=Jv;Fr.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var o=qv({},e.props),a=e.key,l=e.ref,f=e._owner;if(t!=null){if(t.ref!==void 0&&(l=t.ref,f=q_.current),t.key!==void 0&&(a=""+t.key),e.type&&e.type.defaultProps)var _=e.type.defaultProps;for(m in t)Xv.call(t,m)&&!Yv.hasOwnProperty(m)&&(o[m]=t[m]===void 0&&_!==void 0?_[m]:t[m])}var m=arguments.length-2;if(m===1)o.children=n;else if(1<m){_=Array(m);for(var g=0;g<m;g++)_[g]=arguments[g+2];o.children=_}return{$$typeof:fp,type:e.type,key:a,ref:l,props:o,_owner:f}};Fr.createContext=function(e){return e={$$typeof:ck,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:uk,_context:e},e.Consumer=e};Fr.createElement=Zv;Fr.createFactory=function(e){var t=Zv.bind(null,e);return t.type=e,t};Fr.createRef=function(){return{current:null}};Fr.forwardRef=function(e){return{$$typeof:dk,render:e}};Fr.isValidElement=K_;Fr.lazy=function(e){return{$$typeof:hk,_payload:{_status:-1,_result:e},_init:yk}};Fr.memo=function(e,t){return{$$typeof:pk,type:e,compare:t===void 0?null:t}};Fr.startTransition=function(e){var t=Ah.transition;Ah.transition={};try{e()}finally{Ah.transition=t}};Fr.unstable_act=Jv;Fr.useCallback=function(e,t){return ai.current.useCallback(e,t)};Fr.useContext=function(e){return ai.current.useContext(e)};Fr.useDebugValue=function(){};Fr.useDeferredValue=function(e){return ai.current.useDeferredValue(e)};Fr.useEffect=function(e,t){return ai.current.useEffect(e,t)};Fr.useId=function(){return ai.current.useId()};Fr.useImperativeHandle=function(e,t,n){return ai.current.useImperativeHandle(e,t,n)};Fr.useInsertionEffect=function(e,t){return ai.current.useInsertionEffect(e,t)};Fr.useLayoutEffect=function(e,t){return ai.current.useLayoutEffect(e,t)};Fr.useMemo=function(e,t){return ai.current.useMemo(e,t)};Fr.useReducer=function(e,t,n){return ai.current.useReducer(e,t,n)};Fr.useRef=function(e){return ai.current.useRef(e)};Fr.useState=function(e){return ai.current.useState(e)};Fr.useSyncExternalStore=function(e,t,n){return ai.current.useSyncExternalStore(e,t,n)};Fr.useTransition=function(){return ai.current.useTransition()};Fr.version="18.3.1";Gv.exports=Fr;var fr=Gv.exports;const vk=W_(fr);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var bk=fr,xk=Symbol.for("react.element"),Mk=Symbol.for("react.fragment"),kk=Object.prototype.hasOwnProperty,Tk=bk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,Sk={key:!0,ref:!0,__self:!0,__source:!0};function e2(e,t,n){var o,a={},l=null,f=null;n!==void 0&&(l=""+n),t.key!==void 0&&(l=""+t.key),t.ref!==void 0&&(f=t.ref);for(o in t)kk.call(t,o)&&!Sk.hasOwnProperty(o)&&(a[o]=t[o]);if(e&&e.defaultProps)for(o in t=e.defaultProps,t)a[o]===void 0&&(a[o]=t[o]);return{$$typeof:xk,type:e,key:l,ref:f,props:a,_owner:Tk.current}}gm.Fragment=Mk;gm.jsx=e2;gm.jsxs=e2;Wv.exports=gm;var Ut=Wv.exports,t2={exports:{}},Pi={},r2={exports:{}},n2={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(Y,se){var Me=Y.length;Y.push(se);e:for(;0<Me;){var X=Me-1>>>1,ge=Y[X];if(0<a(ge,se))Y[X]=se,Y[Me]=ge,Me=X;else break e}}function n(Y){return Y.length===0?null:Y[0]}function o(Y){if(Y.length===0)return null;var se=Y[0],Me=Y.pop();if(Me!==se){Y[0]=Me;e:for(var X=0,ge=Y.length,qe=ge>>>1;X<qe;){var Be=2*(X+1)-1,Ne=Y[Be],We=Be+1,st=Y[We];if(0>a(Ne,Me))We<ge&&0>a(st,Ne)?(Y[X]=st,Y[We]=Me,X=We):(Y[X]=Ne,Y[Be]=Me,X=Be);else if(We<ge&&0>a(st,Me))Y[X]=st,Y[We]=Me,X=We;else break e}}return se}function a(Y,se){var Me=Y.sortIndex-se.sortIndex;return Me!==0?Me:Y.id-se.id}if(typeof performance=="object"&&typeof performance.now=="function"){var l=performance;e.unstable_now=function(){return l.now()}}else{var f=Date,_=f.now();e.unstable_now=function(){return f.now()-_}}var m=[],g=[],M=1,v=null,C=3,k=!1,z=!1,$=!1,S=typeof setTimeout=="function"?setTimeout:null,y=typeof clearTimeout=="function"?clearTimeout:null,x=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function I(Y){for(var se=n(g);se!==null;){if(se.callback===null)o(g);else if(se.startTime<=Y)o(g),se.sortIndex=se.expirationTime,t(m,se);else break;se=n(g)}}function V(Y){if($=!1,I(Y),!z)if(n(m)!==null)z=!0,Xe(O);else{var se=n(g);se!==null&&ye(V,se.startTime-Y)}}function O(Y,se){z=!1,$&&($=!1,y(N),N=-1),k=!0;var Me=C;try{for(I(se),v=n(m);v!==null&&(!(v.expirationTime>se)||Y&&!Ie());){var X=v.callback;if(typeof X=="function"){v.callback=null,C=v.priorityLevel;var ge=X(v.expirationTime<=se);se=e.unstable_now(),typeof ge=="function"?v.callback=ge:v===n(m)&&o(m),I(se)}else o(m);v=n(m)}if(v!==null)var qe=!0;else{var Be=n(g);Be!==null&&ye(V,Be.startTime-se),qe=!1}return qe}finally{v=null,C=Me,k=!1}}var B=!1,j=null,N=-1,oe=5,he=-1;function Ie(){return!(e.unstable_now()-he<oe)}function te(){if(j!==null){var Y=e.unstable_now();he=Y;var se=!0;try{se=j(!0,Y)}finally{se?we():(B=!1,j=null)}}else B=!1}var we;if(typeof x=="function")we=function(){x(te)};else if(typeof MessageChannel<"u"){var L=new MessageChannel,Ce=L.port2;L.port1.onmessage=te,we=function(){Ce.postMessage(null)}}else we=function(){S(te,0)};function Xe(Y){j=Y,B||(B=!0,we())}function ye(Y,se){N=S(function(){Y(e.unstable_now())},se)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(Y){Y.callback=null},e.unstable_continueExecution=function(){z||k||(z=!0,Xe(O))},e.unstable_forceFrameRate=function(Y){0>Y||125<Y?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):oe=0<Y?Math.floor(1e3/Y):5},e.unstable_getCurrentPriorityLevel=function(){return C},e.unstable_getFirstCallbackNode=function(){return n(m)},e.unstable_next=function(Y){switch(C){case 1:case 2:case 3:var se=3;break;default:se=C}var Me=C;C=se;try{return Y()}finally{C=Me}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(Y,se){switch(Y){case 1:case 2:case 3:case 4:case 5:break;default:Y=3}var Me=C;C=Y;try{return se()}finally{C=Me}},e.unstable_scheduleCallback=function(Y,se,Me){var X=e.unstable_now();switch(typeof Me=="object"&&Me!==null?(Me=Me.delay,Me=typeof Me=="number"&&0<Me?X+Me:X):Me=X,Y){case 1:var ge=-1;break;case 2:ge=250;break;case 5:ge=1073741823;break;case 4:ge=1e4;break;default:ge=5e3}return ge=Me+ge,Y={id:M++,callback:se,priorityLevel:Y,startTime:Me,expirationTime:ge,sortIndex:-1},Me>X?(Y.sortIndex=Me,t(g,Y),n(m)===null&&Y===n(g)&&($?(y(N),N=-1):$=!0,ye(V,Me-X))):(Y.sortIndex=ge,t(m,Y),z||k||(z=!0,Xe(O))),Y},e.unstable_shouldYield=Ie,e.unstable_wrapCallback=function(Y){var se=C;return function(){var Me=C;C=se;try{return Y.apply(this,arguments)}finally{C=Me}}}})(n2);r2.exports=n2;var Ek=r2.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ck=fr,Ci=Ek;function St(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i2=new Set,Kf={};function ma(e,t){du(e,t),du(e+"Capture",t)}function du(e,t){for(Kf[e]=t,e=0;e<t.length;e++)i2.add(t[e])}var Lo=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),qg=Object.prototype.hasOwnProperty,Pk=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,k1={},T1={};function $k(e){return qg.call(T1,e)?!0:qg.call(k1,e)?!1:Pk.test(e)?T1[e]=!0:(k1[e]=!0,!1)}function Ak(e,t,n,o){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return o?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function Ik(e,t,n,o){if(t===null||typeof t>"u"||Ak(e,t,n,o))return!0;if(o)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function li(e,t,n,o,a,l,f){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=o,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=l,this.removeEmptyString=f}var Hn={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){Hn[e]=new li(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];Hn[t]=new li(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){Hn[e]=new li(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){Hn[e]=new li(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){Hn[e]=new li(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){Hn[e]=new li(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){Hn[e]=new li(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){Hn[e]=new li(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){Hn[e]=new li(e,5,!1,e.toLowerCase(),null,!1,!1)});var Q_=/[\-:]([a-z])/g;function X_(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(Q_,X_);Hn[t]=new li(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(Q_,X_);Hn[t]=new li(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(Q_,X_);Hn[t]=new li(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){Hn[e]=new li(e,1,!1,e.toLowerCase(),null,!1,!1)});Hn.xlinkHref=new li("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){Hn[e]=new li(e,1,!1,e.toLowerCase(),null,!0,!0)});function Y_(e,t,n,o){var a=Hn.hasOwnProperty(t)?Hn[t]:null;(a!==null?a.type!==0:o||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(Ik(t,n,a,o)&&(n=null),o||a===null?$k(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=n===null?a.type===3?!1:"":n:(t=a.attributeName,o=a.attributeNamespace,n===null?e.removeAttribute(t):(a=a.type,n=a===3||a===4&&n===!0?"":""+n,o?e.setAttributeNS(o,t,n):e.setAttribute(t,n))))}var jo=Ck.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,fh=Symbol.for("react.element"),ql=Symbol.for("react.portal"),Kl=Symbol.for("react.fragment"),Z_=Symbol.for("react.strict_mode"),Kg=Symbol.for("react.profiler"),o2=Symbol.for("react.provider"),s2=Symbol.for("react.context"),J_=Symbol.for("react.forward_ref"),Qg=Symbol.for("react.suspense"),Xg=Symbol.for("react.suspense_list"),e0=Symbol.for("react.memo"),ds=Symbol.for("react.lazy"),a2=Symbol.for("react.offscreen"),S1=Symbol.iterator;function Tf(e){return e===null||typeof e!="object"?null:(e=S1&&e[S1]||e["@@iterator"],typeof e=="function"?e:null)}var pn=Object.assign,wg;function zf(e){if(wg===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);wg=t&&t[1]||""}return`
`+wg+e}var vg=!1;function bg(e,t){if(!e||vg)return"";vg=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(g){var o=g}Reflect.construct(e,[],t)}else{try{t.call()}catch(g){o=g}e.call(t.prototype)}else{try{throw Error()}catch(g){o=g}e()}}catch(g){if(g&&o&&typeof g.stack=="string"){for(var a=g.stack.split(`
`),l=o.stack.split(`
`),f=a.length-1,_=l.length-1;1<=f&&0<=_&&a[f]!==l[_];)_--;for(;1<=f&&0<=_;f--,_--)if(a[f]!==l[_]){if(f!==1||_!==1)do if(f--,_--,0>_||a[f]!==l[_]){var m=`
`+a[f].replace(" at new "," at ");return e.displayName&&m.includes("<anonymous>")&&(m=m.replace("<anonymous>",e.displayName)),m}while(1<=f&&0<=_);break}}}finally{vg=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?zf(e):""}function Fk(e){switch(e.tag){case 5:return zf(e.type);case 16:return zf("Lazy");case 13:return zf("Suspense");case 19:return zf("SuspenseList");case 0:case 2:case 15:return e=bg(e.type,!1),e;case 11:return e=bg(e.type.render,!1),e;case 1:return e=bg(e.type,!0),e;default:return""}}function Yg(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case Kl:return"Fragment";case ql:return"Portal";case Kg:return"Profiler";case Z_:return"StrictMode";case Qg:return"Suspense";case Xg:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case s2:return(e.displayName||"Context")+".Consumer";case o2:return(e._context.displayName||"Context")+".Provider";case J_:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case e0:return t=e.displayName||null,t!==null?t:Yg(e.type)||"Memo";case ds:t=e._payload,e=e._init;try{return Yg(e(t))}catch{}}return null}function zk(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Yg(t);case 8:return t===Z_?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function Ts(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function l2(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function Ok(e){var t=l2(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),o=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var a=n.get,l=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(f){o=""+f,l.call(this,f)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return o},setValue:function(f){o=""+f},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function ph(e){e._valueTracker||(e._valueTracker=Ok(e))}function u2(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),o="";return e&&(o=l2(e)?e.checked?"true":"false":e.value),e=o,e!==n?(t.setValue(e),!0):!1}function Vh(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function Zg(e,t){var n=t.checked;return pn({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function E1(e,t){var n=t.defaultValue==null?"":t.defaultValue,o=t.checked!=null?t.checked:t.defaultChecked;n=Ts(t.value!=null?t.value:n),e._wrapperState={initialChecked:o,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function c2(e,t){t=t.checked,t!=null&&Y_(e,"checked",t,!1)}function Jg(e,t){c2(e,t);var n=Ts(t.value),o=t.type;if(n!=null)o==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(o==="submit"||o==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?e_(e,t.type,n):t.hasOwnProperty("defaultValue")&&e_(e,t.type,Ts(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function C1(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var o=t.type;if(!(o!=="submit"&&o!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function e_(e,t,n){(t!=="number"||Vh(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var Of=Array.isArray;function ou(e,t,n,o){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&o&&(e[n].defaultSelected=!0)}else{for(n=""+Ts(n),t=null,a=0;a<e.length;a++){if(e[a].value===n){e[a].selected=!0,o&&(e[a].defaultSelected=!0);return}t!==null||e[a].disabled||(t=e[a])}t!==null&&(t.selected=!0)}}function t_(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(St(91));return pn({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function P1(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(St(92));if(Of(n)){if(1<n.length)throw Error(St(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:Ts(n)}}function d2(e,t){var n=Ts(t.value),o=Ts(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),o!=null&&(e.defaultValue=""+o)}function $1(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function f2(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function r_(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?f2(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var hh,p2=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,o,a){MSApp.execUnsafeLocalFunction(function(){return e(t,n,o,a)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(hh=hh||document.createElement("div"),hh.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=hh.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function Qf(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var Rf={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Dk=["Webkit","ms","Moz","O"];Object.keys(Rf).forEach(function(e){Dk.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),Rf[t]=Rf[e]})});function h2(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||Rf.hasOwnProperty(e)&&Rf[e]?(""+t).trim():t+"px"}function m2(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var o=n.indexOf("--")===0,a=h2(n,t[n],o);n==="float"&&(n="cssFloat"),o?e.setProperty(n,a):e[n]=a}}var Lk=pn({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function n_(e,t){if(t){if(Lk[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(St(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(St(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(St(61))}if(t.style!=null&&typeof t.style!="object")throw Error(St(62))}}function i_(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var o_=null;function t0(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var s_=null,su=null,au=null;function A1(e){if(e=mp(e)){if(typeof s_!="function")throw Error(St(280));var t=e.stateNode;t&&(t=bm(t),s_(e.stateNode,e.type,t))}}function g2(e){su?au?au.push(e):au=[e]:su=e}function _2(){if(su){var e=su,t=au;if(au=su=null,A1(e),t)for(e=0;e<t.length;e++)A1(t[e])}}function y2(e,t){return e(t)}function w2(){}var xg=!1;function v2(e,t,n){if(xg)return e(t,n);xg=!0;try{return y2(e,t,n)}finally{xg=!1,(su!==null||au!==null)&&(w2(),_2())}}function Xf(e,t){var n=e.stateNode;if(n===null)return null;var o=bm(n);if(o===null)return null;n=o[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(o=!o.disabled)||(e=e.type,o=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!o;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(St(231,t,typeof n));return n}var a_=!1;if(Lo)try{var Sf={};Object.defineProperty(Sf,"passive",{get:function(){a_=!0}}),window.addEventListener("test",Sf,Sf),window.removeEventListener("test",Sf,Sf)}catch{a_=!1}function Bk(e,t,n,o,a,l,f,_,m){var g=Array.prototype.slice.call(arguments,3);try{t.apply(n,g)}catch(M){this.onError(M)}}var Nf=!1,Wh=null,Gh=!1,l_=null,Rk={onError:function(e){Nf=!0,Wh=e}};function Nk(e,t,n,o,a,l,f,_,m){Nf=!1,Wh=null,Bk.apply(Rk,arguments)}function jk(e,t,n,o,a,l,f,_,m){if(Nk.apply(this,arguments),Nf){if(Nf){var g=Wh;Nf=!1,Wh=null}else throw Error(St(198));Gh||(Gh=!0,l_=g)}}function ga(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function b2(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function I1(e){if(ga(e)!==e)throw Error(St(188))}function Uk(e){var t=e.alternate;if(!t){if(t=ga(e),t===null)throw Error(St(188));return t!==e?null:e}for(var n=e,o=t;;){var a=n.return;if(a===null)break;var l=a.alternate;if(l===null){if(o=a.return,o!==null){n=o;continue}break}if(a.child===l.child){for(l=a.child;l;){if(l===n)return I1(a),e;if(l===o)return I1(a),t;l=l.sibling}throw Error(St(188))}if(n.return!==o.return)n=a,o=l;else{for(var f=!1,_=a.child;_;){if(_===n){f=!0,n=a,o=l;break}if(_===o){f=!0,o=a,n=l;break}_=_.sibling}if(!f){for(_=l.child;_;){if(_===n){f=!0,n=l,o=a;break}if(_===o){f=!0,o=l,n=a;break}_=_.sibling}if(!f)throw Error(St(189))}}if(n.alternate!==o)throw Error(St(190))}if(n.tag!==3)throw Error(St(188));return n.stateNode.current===n?e:t}function x2(e){return e=Uk(e),e!==null?M2(e):null}function M2(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=M2(e);if(t!==null)return t;e=e.sibling}return null}var k2=Ci.unstable_scheduleCallback,F1=Ci.unstable_cancelCallback,Vk=Ci.unstable_shouldYield,Wk=Ci.unstable_requestPaint,wn=Ci.unstable_now,Gk=Ci.unstable_getCurrentPriorityLevel,r0=Ci.unstable_ImmediatePriority,T2=Ci.unstable_UserBlockingPriority,Hh=Ci.unstable_NormalPriority,Hk=Ci.unstable_LowPriority,S2=Ci.unstable_IdlePriority,_m=null,mo=null;function qk(e){if(mo&&typeof mo.onCommitFiberRoot=="function")try{mo.onCommitFiberRoot(_m,e,void 0,(e.current.flags&128)===128)}catch{}}var Ji=Math.clz32?Math.clz32:Xk,Kk=Math.log,Qk=Math.LN2;function Xk(e){return e>>>=0,e===0?32:31-(Kk(e)/Qk|0)|0}var mh=64,gh=4194304;function Df(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function qh(e,t){var n=e.pendingLanes;if(n===0)return 0;var o=0,a=e.suspendedLanes,l=e.pingedLanes,f=n&268435455;if(f!==0){var _=f&~a;_!==0?o=Df(_):(l&=f,l!==0&&(o=Df(l)))}else f=n&~a,f!==0?o=Df(f):l!==0&&(o=Df(l));if(o===0)return 0;if(t!==0&&t!==o&&!(t&a)&&(a=o&-o,l=t&-t,a>=l||a===16&&(l&4194240)!==0))return t;if(o&4&&(o|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=o;0<t;)n=31-Ji(t),a=1<<n,o|=e[n],t&=~a;return o}function Yk(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Zk(e,t){for(var n=e.suspendedLanes,o=e.pingedLanes,a=e.expirationTimes,l=e.pendingLanes;0<l;){var f=31-Ji(l),_=1<<f,m=a[f];m===-1?(!(_&n)||_&o)&&(a[f]=Yk(_,t)):m<=t&&(e.expiredLanes|=_),l&=~_}}function u_(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function E2(){var e=mh;return mh<<=1,!(mh&4194240)&&(mh=64),e}function Mg(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function pp(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-Ji(t),e[t]=n}function Jk(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var o=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-Ji(n),l=1<<a;t[a]=0,o[a]=-1,e[a]=-1,n&=~l}}function n0(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var o=31-Ji(n),a=1<<o;a&t|e[o]&t&&(e[o]|=t),n&=~a}}var qr=0;function C2(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var P2,i0,$2,A2,I2,c_=!1,_h=[],_s=null,ys=null,ws=null,Yf=new Map,Zf=new Map,ps=[],eT="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function z1(e,t){switch(e){case"focusin":case"focusout":_s=null;break;case"dragenter":case"dragleave":ys=null;break;case"mouseover":case"mouseout":ws=null;break;case"pointerover":case"pointerout":Yf.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Zf.delete(t.pointerId)}}function Ef(e,t,n,o,a,l){return e===null||e.nativeEvent!==l?(e={blockedOn:t,domEventName:n,eventSystemFlags:o,nativeEvent:l,targetContainers:[a]},t!==null&&(t=mp(t),t!==null&&i0(t)),e):(e.eventSystemFlags|=o,t=e.targetContainers,a!==null&&t.indexOf(a)===-1&&t.push(a),e)}function tT(e,t,n,o,a){switch(t){case"focusin":return _s=Ef(_s,e,t,n,o,a),!0;case"dragenter":return ys=Ef(ys,e,t,n,o,a),!0;case"mouseover":return ws=Ef(ws,e,t,n,o,a),!0;case"pointerover":var l=a.pointerId;return Yf.set(l,Ef(Yf.get(l)||null,e,t,n,o,a)),!0;case"gotpointercapture":return l=a.pointerId,Zf.set(l,Ef(Zf.get(l)||null,e,t,n,o,a)),!0}return!1}function F2(e){var t=oa(e.target);if(t!==null){var n=ga(t);if(n!==null){if(t=n.tag,t===13){if(t=b2(n),t!==null){e.blockedOn=t,I2(e.priority,function(){$2(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Ih(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=d_(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var o=new n.constructor(n.type,n);o_=o,n.target.dispatchEvent(o),o_=null}else return t=mp(n),t!==null&&i0(t),e.blockedOn=n,!1;t.shift()}return!0}function O1(e,t,n){Ih(e)&&n.delete(t)}function rT(){c_=!1,_s!==null&&Ih(_s)&&(_s=null),ys!==null&&Ih(ys)&&(ys=null),ws!==null&&Ih(ws)&&(ws=null),Yf.forEach(O1),Zf.forEach(O1)}function Cf(e,t){e.blockedOn===t&&(e.blockedOn=null,c_||(c_=!0,Ci.unstable_scheduleCallback(Ci.unstable_NormalPriority,rT)))}function Jf(e){function t(a){return Cf(a,e)}if(0<_h.length){Cf(_h[0],e);for(var n=1;n<_h.length;n++){var o=_h[n];o.blockedOn===e&&(o.blockedOn=null)}}for(_s!==null&&Cf(_s,e),ys!==null&&Cf(ys,e),ws!==null&&Cf(ws,e),Yf.forEach(t),Zf.forEach(t),n=0;n<ps.length;n++)o=ps[n],o.blockedOn===e&&(o.blockedOn=null);for(;0<ps.length&&(n=ps[0],n.blockedOn===null);)F2(n),n.blockedOn===null&&ps.shift()}var lu=jo.ReactCurrentBatchConfig,Kh=!0;function nT(e,t,n,o){var a=qr,l=lu.transition;lu.transition=null;try{qr=1,o0(e,t,n,o)}finally{qr=a,lu.transition=l}}function iT(e,t,n,o){var a=qr,l=lu.transition;lu.transition=null;try{qr=4,o0(e,t,n,o)}finally{qr=a,lu.transition=l}}function o0(e,t,n,o){if(Kh){var a=d_(e,t,n,o);if(a===null)Fg(e,t,o,Qh,n),z1(e,o);else if(tT(a,e,t,n,o))o.stopPropagation();else if(z1(e,o),t&4&&-1<eT.indexOf(e)){for(;a!==null;){var l=mp(a);if(l!==null&&P2(l),l=d_(e,t,n,o),l===null&&Fg(e,t,o,Qh,n),l===a)break;a=l}a!==null&&o.stopPropagation()}else Fg(e,t,o,null,n)}}var Qh=null;function d_(e,t,n,o){if(Qh=null,e=t0(o),e=oa(e),e!==null)if(t=ga(e),t===null)e=null;else if(n=t.tag,n===13){if(e=b2(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Qh=e,null}function z2(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Gk()){case r0:return 1;case T2:return 4;case Hh:case Hk:return 16;case S2:return 536870912;default:return 16}default:return 16}}var ms=null,s0=null,Fh=null;function O2(){if(Fh)return Fh;var e,t=s0,n=t.length,o,a="value"in ms?ms.value:ms.textContent,l=a.length;for(e=0;e<n&&t[e]===a[e];e++);var f=n-e;for(o=1;o<=f&&t[n-o]===a[l-o];o++);return Fh=a.slice(e,1<o?1-o:void 0)}function zh(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function yh(){return!0}function D1(){return!1}function $i(e){function t(n,o,a,l,f){this._reactName=n,this._targetInst=a,this.type=o,this.nativeEvent=l,this.target=f,this.currentTarget=null;for(var _ in e)e.hasOwnProperty(_)&&(n=e[_],this[_]=n?n(l):l[_]);return this.isDefaultPrevented=(l.defaultPrevented!=null?l.defaultPrevented:l.returnValue===!1)?yh:D1,this.isPropagationStopped=D1,this}return pn(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=yh)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=yh)},persist:function(){},isPersistent:yh}),t}var wu={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},a0=$i(wu),hp=pn({},wu,{view:0,detail:0}),oT=$i(hp),kg,Tg,Pf,ym=pn({},hp,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:l0,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Pf&&(Pf&&e.type==="mousemove"?(kg=e.screenX-Pf.screenX,Tg=e.screenY-Pf.screenY):Tg=kg=0,Pf=e),kg)},movementY:function(e){return"movementY"in e?e.movementY:Tg}}),L1=$i(ym),sT=pn({},ym,{dataTransfer:0}),aT=$i(sT),lT=pn({},hp,{relatedTarget:0}),Sg=$i(lT),uT=pn({},wu,{animationName:0,elapsedTime:0,pseudoElement:0}),cT=$i(uT),dT=pn({},wu,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),fT=$i(dT),pT=pn({},wu,{data:0}),B1=$i(pT),hT={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},mT={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},gT={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function _T(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=gT[e])?!!t[e]:!1}function l0(){return _T}var yT=pn({},hp,{key:function(e){if(e.key){var t=hT[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=zh(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?mT[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:l0,charCode:function(e){return e.type==="keypress"?zh(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?zh(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),wT=$i(yT),vT=pn({},ym,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),R1=$i(vT),bT=pn({},hp,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:l0}),xT=$i(bT),MT=pn({},wu,{propertyName:0,elapsedTime:0,pseudoElement:0}),kT=$i(MT),TT=pn({},ym,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),ST=$i(TT),ET=[9,13,27,32],u0=Lo&&"CompositionEvent"in window,jf=null;Lo&&"documentMode"in document&&(jf=document.documentMode);var CT=Lo&&"TextEvent"in window&&!jf,D2=Lo&&(!u0||jf&&8<jf&&11>=jf),N1=" ",j1=!1;function L2(e,t){switch(e){case"keyup":return ET.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function B2(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var Ql=!1;function PT(e,t){switch(e){case"compositionend":return B2(t);case"keypress":return t.which!==32?null:(j1=!0,N1);case"textInput":return e=t.data,e===N1&&j1?null:e;default:return null}}function $T(e,t){if(Ql)return e==="compositionend"||!u0&&L2(e,t)?(e=O2(),Fh=s0=ms=null,Ql=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return D2&&t.locale!=="ko"?null:t.data;default:return null}}var AT={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function U1(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!AT[e.type]:t==="textarea"}function R2(e,t,n,o){g2(o),t=Xh(t,"onChange"),0<t.length&&(n=new a0("onChange","change",null,n,o),e.push({event:n,listeners:t}))}var Uf=null,ep=null;function IT(e){X2(e,0)}function wm(e){var t=Zl(e);if(u2(t))return e}function FT(e,t){if(e==="change")return t}var N2=!1;if(Lo){var Eg;if(Lo){var Cg="oninput"in document;if(!Cg){var V1=document.createElement("div");V1.setAttribute("oninput","return;"),Cg=typeof V1.oninput=="function"}Eg=Cg}else Eg=!1;N2=Eg&&(!document.documentMode||9<document.documentMode)}function W1(){Uf&&(Uf.detachEvent("onpropertychange",j2),ep=Uf=null)}function j2(e){if(e.propertyName==="value"&&wm(ep)){var t=[];R2(t,ep,e,t0(e)),v2(IT,t)}}function zT(e,t,n){e==="focusin"?(W1(),Uf=t,ep=n,Uf.attachEvent("onpropertychange",j2)):e==="focusout"&&W1()}function OT(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return wm(ep)}function DT(e,t){if(e==="click")return wm(t)}function LT(e,t){if(e==="input"||e==="change")return wm(t)}function BT(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var to=typeof Object.is=="function"?Object.is:BT;function tp(e,t){if(to(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),o=Object.keys(t);if(n.length!==o.length)return!1;for(o=0;o<n.length;o++){var a=n[o];if(!qg.call(t,a)||!to(e[a],t[a]))return!1}return!0}function G1(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function H1(e,t){var n=G1(e);e=0;for(var o;n;){if(n.nodeType===3){if(o=e+n.textContent.length,e<=t&&o>=t)return{node:n,offset:t-e};e=o}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=G1(n)}}function U2(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?U2(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function V2(){for(var e=window,t=Vh();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=Vh(e.document)}return t}function c0(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function RT(e){var t=V2(),n=e.focusedElem,o=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&U2(n.ownerDocument.documentElement,n)){if(o!==null&&c0(n)){if(t=o.start,e=o.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var a=n.textContent.length,l=Math.min(o.start,a);o=o.end===void 0?l:Math.min(o.end,a),!e.extend&&l>o&&(a=o,o=l,l=a),a=H1(n,l);var f=H1(n,o);a&&f&&(e.rangeCount!==1||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==f.node||e.focusOffset!==f.offset)&&(t=t.createRange(),t.setStart(a.node,a.offset),e.removeAllRanges(),l>o?(e.addRange(t),e.extend(f.node,f.offset)):(t.setEnd(f.node,f.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var NT=Lo&&"documentMode"in document&&11>=document.documentMode,Xl=null,f_=null,Vf=null,p_=!1;function q1(e,t,n){var o=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;p_||Xl==null||Xl!==Vh(o)||(o=Xl,"selectionStart"in o&&c0(o)?o={start:o.selectionStart,end:o.selectionEnd}:(o=(o.ownerDocument&&o.ownerDocument.defaultView||window).getSelection(),o={anchorNode:o.anchorNode,anchorOffset:o.anchorOffset,focusNode:o.focusNode,focusOffset:o.focusOffset}),Vf&&tp(Vf,o)||(Vf=o,o=Xh(f_,"onSelect"),0<o.length&&(t=new a0("onSelect","select",null,t,n),e.push({event:t,listeners:o}),t.target=Xl)))}function wh(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var Yl={animationend:wh("Animation","AnimationEnd"),animationiteration:wh("Animation","AnimationIteration"),animationstart:wh("Animation","AnimationStart"),transitionend:wh("Transition","TransitionEnd")},Pg={},W2={};Lo&&(W2=document.createElement("div").style,"AnimationEvent"in window||(delete Yl.animationend.animation,delete Yl.animationiteration.animation,delete Yl.animationstart.animation),"TransitionEvent"in window||delete Yl.transitionend.transition);function vm(e){if(Pg[e])return Pg[e];if(!Yl[e])return e;var t=Yl[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in W2)return Pg[e]=t[n];return e}var G2=vm("animationend"),H2=vm("animationiteration"),q2=vm("animationstart"),K2=vm("transitionend"),Q2=new Map,K1="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Es(e,t){Q2.set(e,t),ma(t,[e])}for(var $g=0;$g<K1.length;$g++){var Ag=K1[$g],jT=Ag.toLowerCase(),UT=Ag[0].toUpperCase()+Ag.slice(1);Es(jT,"on"+UT)}Es(G2,"onAnimationEnd");Es(H2,"onAnimationIteration");Es(q2,"onAnimationStart");Es("dblclick","onDoubleClick");Es("focusin","onFocus");Es("focusout","onBlur");Es(K2,"onTransitionEnd");du("onMouseEnter",["mouseout","mouseover"]);du("onMouseLeave",["mouseout","mouseover"]);du("onPointerEnter",["pointerout","pointerover"]);du("onPointerLeave",["pointerout","pointerover"]);ma("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));ma("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));ma("onBeforeInput",["compositionend","keypress","textInput","paste"]);ma("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));ma("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));ma("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),VT=new Set("cancel close invalid load scroll toggle".split(" ").concat(Lf));function Q1(e,t,n){var o=e.type||"unknown-event";e.currentTarget=n,jk(o,t,void 0,e),e.currentTarget=null}function X2(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var o=e[n],a=o.event;o=o.listeners;e:{var l=void 0;if(t)for(var f=o.length-1;0<=f;f--){var _=o[f],m=_.instance,g=_.currentTarget;if(_=_.listener,m!==l&&a.isPropagationStopped())break e;Q1(a,_,g),l=m}else for(f=0;f<o.length;f++){if(_=o[f],m=_.instance,g=_.currentTarget,_=_.listener,m!==l&&a.isPropagationStopped())break e;Q1(a,_,g),l=m}}}if(Gh)throw e=l_,Gh=!1,l_=null,e}function on(e,t){var n=t[y_];n===void 0&&(n=t[y_]=new Set);var o=e+"__bubble";n.has(o)||(Y2(t,e,2,!1),n.add(o))}function Ig(e,t,n){var o=0;t&&(o|=4),Y2(n,e,o,t)}var vh="_reactListening"+Math.random().toString(36).slice(2);function rp(e){if(!e[vh]){e[vh]=!0,i2.forEach(function(n){n!=="selectionchange"&&(VT.has(n)||Ig(n,!1,e),Ig(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[vh]||(t[vh]=!0,Ig("selectionchange",!1,t))}}function Y2(e,t,n,o){switch(z2(t)){case 1:var a=nT;break;case 4:a=iT;break;default:a=o0}n=a.bind(null,t,n,e),a=void 0,!a_||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(a=!0),o?a!==void 0?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):a!==void 0?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function Fg(e,t,n,o,a){var l=o;if(!(t&1)&&!(t&2)&&o!==null)e:for(;;){if(o===null)return;var f=o.tag;if(f===3||f===4){var _=o.stateNode.containerInfo;if(_===a||_.nodeType===8&&_.parentNode===a)break;if(f===4)for(f=o.return;f!==null;){var m=f.tag;if((m===3||m===4)&&(m=f.stateNode.containerInfo,m===a||m.nodeType===8&&m.parentNode===a))return;f=f.return}for(;_!==null;){if(f=oa(_),f===null)return;if(m=f.tag,m===5||m===6){o=l=f;continue e}_=_.parentNode}}o=o.return}v2(function(){var g=l,M=t0(n),v=[];e:{var C=Q2.get(e);if(C!==void 0){var k=a0,z=e;switch(e){case"keypress":if(zh(n)===0)break e;case"keydown":case"keyup":k=wT;break;case"focusin":z="focus",k=Sg;break;case"focusout":z="blur",k=Sg;break;case"beforeblur":case"afterblur":k=Sg;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":k=L1;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":k=aT;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":k=xT;break;case G2:case H2:case q2:k=cT;break;case K2:k=kT;break;case"scroll":k=oT;break;case"wheel":k=ST;break;case"copy":case"cut":case"paste":k=fT;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":k=R1}var $=(t&4)!==0,S=!$&&e==="scroll",y=$?C!==null?C+"Capture":null:C;$=[];for(var x=g,I;x!==null;){I=x;var V=I.stateNode;if(I.tag===5&&V!==null&&(I=V,y!==null&&(V=Xf(x,y),V!=null&&$.push(np(x,V,I)))),S)break;x=x.return}0<$.length&&(C=new k(C,z,null,n,M),v.push({event:C,listeners:$}))}}if(!(t&7)){e:{if(C=e==="mouseover"||e==="pointerover",k=e==="mouseout"||e==="pointerout",C&&n!==o_&&(z=n.relatedTarget||n.fromElement)&&(oa(z)||z[Bo]))break e;if((k||C)&&(C=M.window===M?M:(C=M.ownerDocument)?C.defaultView||C.parentWindow:window,k?(z=n.relatedTarget||n.toElement,k=g,z=z?oa(z):null,z!==null&&(S=ga(z),z!==S||z.tag!==5&&z.tag!==6)&&(z=null)):(k=null,z=g),k!==z)){if($=L1,V="onMouseLeave",y="onMouseEnter",x="mouse",(e==="pointerout"||e==="pointerover")&&($=R1,V="onPointerLeave",y="onPointerEnter",x="pointer"),S=k==null?C:Zl(k),I=z==null?C:Zl(z),C=new $(V,x+"leave",k,n,M),C.target=S,C.relatedTarget=I,V=null,oa(M)===g&&($=new $(y,x+"enter",z,n,M),$.target=I,$.relatedTarget=S,V=$),S=V,k&&z)t:{for($=k,y=z,x=0,I=$;I;I=Gl(I))x++;for(I=0,V=y;V;V=Gl(V))I++;for(;0<x-I;)$=Gl($),x--;for(;0<I-x;)y=Gl(y),I--;for(;x--;){if($===y||y!==null&&$===y.alternate)break t;$=Gl($),y=Gl(y)}$=null}else $=null;k!==null&&X1(v,C,k,$,!1),z!==null&&S!==null&&X1(v,S,z,$,!0)}}e:{if(C=g?Zl(g):window,k=C.nodeName&&C.nodeName.toLowerCase(),k==="select"||k==="input"&&C.type==="file")var O=FT;else if(U1(C))if(N2)O=LT;else{O=OT;var B=zT}else(k=C.nodeName)&&k.toLowerCase()==="input"&&(C.type==="checkbox"||C.type==="radio")&&(O=DT);if(O&&(O=O(e,g))){R2(v,O,n,M);break e}B&&B(e,C,g),e==="focusout"&&(B=C._wrapperState)&&B.controlled&&C.type==="number"&&e_(C,"number",C.value)}switch(B=g?Zl(g):window,e){case"focusin":(U1(B)||B.contentEditable==="true")&&(Xl=B,f_=g,Vf=null);break;case"focusout":Vf=f_=Xl=null;break;case"mousedown":p_=!0;break;case"contextmenu":case"mouseup":case"dragend":p_=!1,q1(v,n,M);break;case"selectionchange":if(NT)break;case"keydown":case"keyup":q1(v,n,M)}var j;if(u0)e:{switch(e){case"compositionstart":var N="onCompositionStart";break e;case"compositionend":N="onCompositionEnd";break e;case"compositionupdate":N="onCompositionUpdate";break e}N=void 0}else Ql?L2(e,n)&&(N="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(N="onCompositionStart");N&&(D2&&n.locale!=="ko"&&(Ql||N!=="onCompositionStart"?N==="onCompositionEnd"&&Ql&&(j=O2()):(ms=M,s0="value"in ms?ms.value:ms.textContent,Ql=!0)),B=Xh(g,N),0<B.length&&(N=new B1(N,e,null,n,M),v.push({event:N,listeners:B}),j?N.data=j:(j=B2(n),j!==null&&(N.data=j)))),(j=CT?PT(e,n):$T(e,n))&&(g=Xh(g,"onBeforeInput"),0<g.length&&(M=new B1("onBeforeInput","beforeinput",null,n,M),v.push({event:M,listeners:g}),M.data=j))}X2(v,t)})}function np(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Xh(e,t){for(var n=t+"Capture",o=[];e!==null;){var a=e,l=a.stateNode;a.tag===5&&l!==null&&(a=l,l=Xf(e,n),l!=null&&o.unshift(np(e,l,a)),l=Xf(e,t),l!=null&&o.push(np(e,l,a))),e=e.return}return o}function Gl(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function X1(e,t,n,o,a){for(var l=t._reactName,f=[];n!==null&&n!==o;){var _=n,m=_.alternate,g=_.stateNode;if(m!==null&&m===o)break;_.tag===5&&g!==null&&(_=g,a?(m=Xf(n,l),m!=null&&f.unshift(np(n,m,_))):a||(m=Xf(n,l),m!=null&&f.push(np(n,m,_)))),n=n.return}f.length!==0&&e.push({event:t,listeners:f})}var WT=/\r\n?/g,GT=/\u0000|\uFFFD/g;function Y1(e){return(typeof e=="string"?e:""+e).replace(WT,`
`).replace(GT,"")}function bh(e,t,n){if(t=Y1(t),Y1(e)!==t&&n)throw Error(St(425))}function Yh(){}var h_=null,m_=null;function g_(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var __=typeof setTimeout=="function"?setTimeout:void 0,HT=typeof clearTimeout=="function"?clearTimeout:void 0,Z1=typeof Promise=="function"?Promise:void 0,qT=typeof queueMicrotask=="function"?queueMicrotask:typeof Z1<"u"?function(e){return Z1.resolve(null).then(e).catch(KT)}:__;function KT(e){setTimeout(function(){throw e})}function zg(e,t){var n=t,o=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&a.nodeType===8)if(n=a.data,n==="/$"){if(o===0){e.removeChild(a),Jf(t);return}o--}else n!=="$"&&n!=="$?"&&n!=="$!"||o++;n=a}while(n);Jf(t)}function vs(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function J1(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var vu=Math.random().toString(36).slice(2),ho="__reactFiber$"+vu,ip="__reactProps$"+vu,Bo="__reactContainer$"+vu,y_="__reactEvents$"+vu,QT="__reactListeners$"+vu,XT="__reactHandles$"+vu;function oa(e){var t=e[ho];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Bo]||n[ho]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=J1(e);e!==null;){if(n=e[ho])return n;e=J1(e)}return t}e=n,n=e.parentNode}return null}function mp(e){return e=e[ho]||e[Bo],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function Zl(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(St(33))}function bm(e){return e[ip]||null}var w_=[],Jl=-1;function Cs(e){return{current:e}}function sn(e){0>Jl||(e.current=w_[Jl],w_[Jl]=null,Jl--)}function tn(e,t){Jl++,w_[Jl]=e.current,e.current=t}var Ss={},Jn=Cs(Ss),mi=Cs(!1),ca=Ss;function fu(e,t){var n=e.type.contextTypes;if(!n)return Ss;var o=e.stateNode;if(o&&o.__reactInternalMemoizedUnmaskedChildContext===t)return o.__reactInternalMemoizedMaskedChildContext;var a={},l;for(l in n)a[l]=t[l];return o&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function gi(e){return e=e.childContextTypes,e!=null}function Zh(){sn(mi),sn(Jn)}function ev(e,t,n){if(Jn.current!==Ss)throw Error(St(168));tn(Jn,t),tn(mi,n)}function Z2(e,t,n){var o=e.stateNode;if(t=t.childContextTypes,typeof o.getChildContext!="function")return n;o=o.getChildContext();for(var a in o)if(!(a in t))throw Error(St(108,zk(e)||"Unknown",a));return pn({},n,o)}function Jh(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Ss,ca=Jn.current,tn(Jn,e),tn(mi,mi.current),!0}function tv(e,t,n){var o=e.stateNode;if(!o)throw Error(St(169));n?(e=Z2(e,t,ca),o.__reactInternalMemoizedMergedChildContext=e,sn(mi),sn(Jn),tn(Jn,e)):sn(mi),tn(mi,n)}var Io=null,xm=!1,Og=!1;function J2(e){Io===null?Io=[e]:Io.push(e)}function YT(e){xm=!0,J2(e)}function Ps(){if(!Og&&Io!==null){Og=!0;var e=0,t=qr;try{var n=Io;for(qr=1;e<n.length;e++){var o=n[e];do o=o(!0);while(o!==null)}Io=null,xm=!1}catch(a){throw Io!==null&&(Io=Io.slice(e+1)),k2(r0,Ps),a}finally{qr=t,Og=!1}}return null}var eu=[],tu=0,em=null,tm=0,Bi=[],Ri=0,da=null,zo=1,Oo="";function ra(e,t){eu[tu++]=tm,eu[tu++]=em,em=e,tm=t}function eb(e,t,n){Bi[Ri++]=zo,Bi[Ri++]=Oo,Bi[Ri++]=da,da=e;var o=zo;e=Oo;var a=32-Ji(o)-1;o&=~(1<<a),n+=1;var l=32-Ji(t)+a;if(30<l){var f=a-a%5;l=(o&(1<<f)-1).toString(32),o>>=f,a-=f,zo=1<<32-Ji(t)+a|n<<a|o,Oo=l+e}else zo=1<<l|n<<a|o,Oo=e}function d0(e){e.return!==null&&(ra(e,1),eb(e,1,0))}function f0(e){for(;e===em;)em=eu[--tu],eu[tu]=null,tm=eu[--tu],eu[tu]=null;for(;e===da;)da=Bi[--Ri],Bi[Ri]=null,Oo=Bi[--Ri],Bi[Ri]=null,zo=Bi[--Ri],Bi[Ri]=null}var Ei=null,Si=null,ln=!1,Zi=null;function tb(e,t){var n=Ni(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function rv(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,Ei=e,Si=vs(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,Ei=e,Si=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=da!==null?{id:zo,overflow:Oo}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=Ni(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,Ei=e,Si=null,!0):!1;default:return!1}}function v_(e){return(e.mode&1)!==0&&(e.flags&128)===0}function b_(e){if(ln){var t=Si;if(t){var n=t;if(!rv(e,t)){if(v_(e))throw Error(St(418));t=vs(n.nextSibling);var o=Ei;t&&rv(e,t)?tb(o,n):(e.flags=e.flags&-4097|2,ln=!1,Ei=e)}}else{if(v_(e))throw Error(St(418));e.flags=e.flags&-4097|2,ln=!1,Ei=e}}}function nv(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;Ei=e}function xh(e){if(e!==Ei)return!1;if(!ln)return nv(e),ln=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!g_(e.type,e.memoizedProps)),t&&(t=Si)){if(v_(e))throw rb(),Error(St(418));for(;t;)tb(e,t),t=vs(t.nextSibling)}if(nv(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(St(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){Si=vs(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}Si=null}}else Si=Ei?vs(e.stateNode.nextSibling):null;return!0}function rb(){for(var e=Si;e;)e=vs(e.nextSibling)}function pu(){Si=Ei=null,ln=!1}function p0(e){Zi===null?Zi=[e]:Zi.push(e)}var ZT=jo.ReactCurrentBatchConfig;function $f(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(St(309));var o=n.stateNode}if(!o)throw Error(St(147,e));var a=o,l=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===l?t.ref:(t=function(f){var _=a.refs;f===null?delete _[l]:_[l]=f},t._stringRef=l,t)}if(typeof e!="string")throw Error(St(284));if(!n._owner)throw Error(St(290,e))}return e}function Mh(e,t){throw e=Object.prototype.toString.call(t),Error(St(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function iv(e){var t=e._init;return t(e._payload)}function nb(e){function t(y,x){if(e){var I=y.deletions;I===null?(y.deletions=[x],y.flags|=16):I.push(x)}}function n(y,x){if(!e)return null;for(;x!==null;)t(y,x),x=x.sibling;return null}function o(y,x){for(y=new Map;x!==null;)x.key!==null?y.set(x.key,x):y.set(x.index,x),x=x.sibling;return y}function a(y,x){return y=ks(y,x),y.index=0,y.sibling=null,y}function l(y,x,I){return y.index=I,e?(I=y.alternate,I!==null?(I=I.index,I<x?(y.flags|=2,x):I):(y.flags|=2,x)):(y.flags|=1048576,x)}function f(y){return e&&y.alternate===null&&(y.flags|=2),y}function _(y,x,I,V){return x===null||x.tag!==6?(x=Ug(I,y.mode,V),x.return=y,x):(x=a(x,I),x.return=y,x)}function m(y,x,I,V){var O=I.type;return O===Kl?M(y,x,I.props.children,V,I.key):x!==null&&(x.elementType===O||typeof O=="object"&&O!==null&&O.$$typeof===ds&&iv(O)===x.type)?(V=a(x,I.props),V.ref=$f(y,x,I),V.return=y,V):(V=jh(I.type,I.key,I.props,null,y.mode,V),V.ref=$f(y,x,I),V.return=y,V)}function g(y,x,I,V){return x===null||x.tag!==4||x.stateNode.containerInfo!==I.containerInfo||x.stateNode.implementation!==I.implementation?(x=Vg(I,y.mode,V),x.return=y,x):(x=a(x,I.children||[]),x.return=y,x)}function M(y,x,I,V,O){return x===null||x.tag!==7?(x=ua(I,y.mode,V,O),x.return=y,x):(x=a(x,I),x.return=y,x)}function v(y,x,I){if(typeof x=="string"&&x!==""||typeof x=="number")return x=Ug(""+x,y.mode,I),x.return=y,x;if(typeof x=="object"&&x!==null){switch(x.$$typeof){case fh:return I=jh(x.type,x.key,x.props,null,y.mode,I),I.ref=$f(y,null,x),I.return=y,I;case ql:return x=Vg(x,y.mode,I),x.return=y,x;case ds:var V=x._init;return v(y,V(x._payload),I)}if(Of(x)||Tf(x))return x=ua(x,y.mode,I,null),x.return=y,x;Mh(y,x)}return null}function C(y,x,I,V){var O=x!==null?x.key:null;if(typeof I=="string"&&I!==""||typeof I=="number")return O!==null?null:_(y,x,""+I,V);if(typeof I=="object"&&I!==null){switch(I.$$typeof){case fh:return I.key===O?m(y,x,I,V):null;case ql:return I.key===O?g(y,x,I,V):null;case ds:return O=I._init,C(y,x,O(I._payload),V)}if(Of(I)||Tf(I))return O!==null?null:M(y,x,I,V,null);Mh(y,I)}return null}function k(y,x,I,V,O){if(typeof V=="string"&&V!==""||typeof V=="number")return y=y.get(I)||null,_(x,y,""+V,O);if(typeof V=="object"&&V!==null){switch(V.$$typeof){case fh:return y=y.get(V.key===null?I:V.key)||null,m(x,y,V,O);case ql:return y=y.get(V.key===null?I:V.key)||null,g(x,y,V,O);case ds:var B=V._init;return k(y,x,I,B(V._payload),O)}if(Of(V)||Tf(V))return y=y.get(I)||null,M(x,y,V,O,null);Mh(x,V)}return null}function z(y,x,I,V){for(var O=null,B=null,j=x,N=x=0,oe=null;j!==null&&N<I.length;N++){j.index>N?(oe=j,j=null):oe=j.sibling;var he=C(y,j,I[N],V);if(he===null){j===null&&(j=oe);break}e&&j&&he.alternate===null&&t(y,j),x=l(he,x,N),B===null?O=he:B.sibling=he,B=he,j=oe}if(N===I.length)return n(y,j),ln&&ra(y,N),O;if(j===null){for(;N<I.length;N++)j=v(y,I[N],V),j!==null&&(x=l(j,x,N),B===null?O=j:B.sibling=j,B=j);return ln&&ra(y,N),O}for(j=o(y,j);N<I.length;N++)oe=k(j,y,N,I[N],V),oe!==null&&(e&&oe.alternate!==null&&j.delete(oe.key===null?N:oe.key),x=l(oe,x,N),B===null?O=oe:B.sibling=oe,B=oe);return e&&j.forEach(function(Ie){return t(y,Ie)}),ln&&ra(y,N),O}function $(y,x,I,V){var O=Tf(I);if(typeof O!="function")throw Error(St(150));if(I=O.call(I),I==null)throw Error(St(151));for(var B=O=null,j=x,N=x=0,oe=null,he=I.next();j!==null&&!he.done;N++,he=I.next()){j.index>N?(oe=j,j=null):oe=j.sibling;var Ie=C(y,j,he.value,V);if(Ie===null){j===null&&(j=oe);break}e&&j&&Ie.alternate===null&&t(y,j),x=l(Ie,x,N),B===null?O=Ie:B.sibling=Ie,B=Ie,j=oe}if(he.done)return n(y,j),ln&&ra(y,N),O;if(j===null){for(;!he.done;N++,he=I.next())he=v(y,he.value,V),he!==null&&(x=l(he,x,N),B===null?O=he:B.sibling=he,B=he);return ln&&ra(y,N),O}for(j=o(y,j);!he.done;N++,he=I.next())he=k(j,y,N,he.value,V),he!==null&&(e&&he.alternate!==null&&j.delete(he.key===null?N:he.key),x=l(he,x,N),B===null?O=he:B.sibling=he,B=he);return e&&j.forEach(function(te){return t(y,te)}),ln&&ra(y,N),O}function S(y,x,I,V){if(typeof I=="object"&&I!==null&&I.type===Kl&&I.key===null&&(I=I.props.children),typeof I=="object"&&I!==null){switch(I.$$typeof){case fh:e:{for(var O=I.key,B=x;B!==null;){if(B.key===O){if(O=I.type,O===Kl){if(B.tag===7){n(y,B.sibling),x=a(B,I.props.children),x.return=y,y=x;break e}}else if(B.elementType===O||typeof O=="object"&&O!==null&&O.$$typeof===ds&&iv(O)===B.type){n(y,B.sibling),x=a(B,I.props),x.ref=$f(y,B,I),x.return=y,y=x;break e}n(y,B);break}else t(y,B);B=B.sibling}I.type===Kl?(x=ua(I.props.children,y.mode,V,I.key),x.return=y,y=x):(V=jh(I.type,I.key,I.props,null,y.mode,V),V.ref=$f(y,x,I),V.return=y,y=V)}return f(y);case ql:e:{for(B=I.key;x!==null;){if(x.key===B)if(x.tag===4&&x.stateNode.containerInfo===I.containerInfo&&x.stateNode.implementation===I.implementation){n(y,x.sibling),x=a(x,I.children||[]),x.return=y,y=x;break e}else{n(y,x);break}else t(y,x);x=x.sibling}x=Vg(I,y.mode,V),x.return=y,y=x}return f(y);case ds:return B=I._init,S(y,x,B(I._payload),V)}if(Of(I))return z(y,x,I,V);if(Tf(I))return $(y,x,I,V);Mh(y,I)}return typeof I=="string"&&I!==""||typeof I=="number"?(I=""+I,x!==null&&x.tag===6?(n(y,x.sibling),x=a(x,I),x.return=y,y=x):(n(y,x),x=Ug(I,y.mode,V),x.return=y,y=x),f(y)):n(y,x)}return S}var hu=nb(!0),ib=nb(!1),rm=Cs(null),nm=null,ru=null,h0=null;function m0(){h0=ru=nm=null}function g0(e){var t=rm.current;sn(rm),e._currentValue=t}function x_(e,t,n){for(;e!==null;){var o=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,o!==null&&(o.childLanes|=t)):o!==null&&(o.childLanes&t)!==t&&(o.childLanes|=t),e===n)break;e=e.return}}function uu(e,t){nm=e,h0=ru=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(hi=!0),e.firstContext=null)}function Ui(e){var t=e._currentValue;if(h0!==e)if(e={context:e,memoizedValue:t,next:null},ru===null){if(nm===null)throw Error(St(308));ru=e,nm.dependencies={lanes:0,firstContext:e}}else ru=ru.next=e;return t}var sa=null;function _0(e){sa===null?sa=[e]:sa.push(e)}function ob(e,t,n,o){var a=t.interleaved;return a===null?(n.next=n,_0(t)):(n.next=a.next,a.next=n),t.interleaved=n,Ro(e,o)}function Ro(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var fs=!1;function y0(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function sb(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Do(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function bs(e,t,n){var o=e.updateQueue;if(o===null)return null;if(o=o.shared,Rr&2){var a=o.pending;return a===null?t.next=t:(t.next=a.next,a.next=t),o.pending=t,Ro(e,n)}return a=o.interleaved,a===null?(t.next=t,_0(o)):(t.next=a.next,a.next=t),o.interleaved=t,Ro(e,n)}function Oh(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var o=t.lanes;o&=e.pendingLanes,n|=o,t.lanes=n,n0(e,n)}}function ov(e,t){var n=e.updateQueue,o=e.alternate;if(o!==null&&(o=o.updateQueue,n===o)){var a=null,l=null;if(n=n.firstBaseUpdate,n!==null){do{var f={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};l===null?a=l=f:l=l.next=f,n=n.next}while(n!==null);l===null?a=l=t:l=l.next=t}else a=l=t;n={baseState:o.baseState,firstBaseUpdate:a,lastBaseUpdate:l,shared:o.shared,effects:o.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function im(e,t,n,o){var a=e.updateQueue;fs=!1;var l=a.firstBaseUpdate,f=a.lastBaseUpdate,_=a.shared.pending;if(_!==null){a.shared.pending=null;var m=_,g=m.next;m.next=null,f===null?l=g:f.next=g,f=m;var M=e.alternate;M!==null&&(M=M.updateQueue,_=M.lastBaseUpdate,_!==f&&(_===null?M.firstBaseUpdate=g:_.next=g,M.lastBaseUpdate=m))}if(l!==null){var v=a.baseState;f=0,M=g=m=null,_=l;do{var C=_.lane,k=_.eventTime;if((o&C)===C){M!==null&&(M=M.next={eventTime:k,lane:0,tag:_.tag,payload:_.payload,callback:_.callback,next:null});e:{var z=e,$=_;switch(C=t,k=n,$.tag){case 1:if(z=$.payload,typeof z=="function"){v=z.call(k,v,C);break e}v=z;break e;case 3:z.flags=z.flags&-65537|128;case 0:if(z=$.payload,C=typeof z=="function"?z.call(k,v,C):z,C==null)break e;v=pn({},v,C);break e;case 2:fs=!0}}_.callback!==null&&_.lane!==0&&(e.flags|=64,C=a.effects,C===null?a.effects=[_]:C.push(_))}else k={eventTime:k,lane:C,tag:_.tag,payload:_.payload,callback:_.callback,next:null},M===null?(g=M=k,m=v):M=M.next=k,f|=C;if(_=_.next,_===null){if(_=a.shared.pending,_===null)break;C=_,_=C.next,C.next=null,a.lastBaseUpdate=C,a.shared.pending=null}}while(!0);if(M===null&&(m=v),a.baseState=m,a.firstBaseUpdate=g,a.lastBaseUpdate=M,t=a.shared.interleaved,t!==null){a=t;do f|=a.lane,a=a.next;while(a!==t)}else l===null&&(a.shared.lanes=0);pa|=f,e.lanes=f,e.memoizedState=v}}function sv(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var o=e[t],a=o.callback;if(a!==null){if(o.callback=null,o=n,typeof a!="function")throw Error(St(191,a));a.call(o)}}}var gp={},go=Cs(gp),op=Cs(gp),sp=Cs(gp);function aa(e){if(e===gp)throw Error(St(174));return e}function w0(e,t){switch(tn(sp,t),tn(op,e),tn(go,gp),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:r_(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=r_(t,e)}sn(go),tn(go,t)}function mu(){sn(go),sn(op),sn(sp)}function ab(e){aa(sp.current);var t=aa(go.current),n=r_(t,e.type);t!==n&&(tn(op,e),tn(go,n))}function v0(e){op.current===e&&(sn(go),sn(op))}var dn=Cs(0);function om(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Dg=[];function b0(){for(var e=0;e<Dg.length;e++)Dg[e]._workInProgressVersionPrimary=null;Dg.length=0}var Dh=jo.ReactCurrentDispatcher,Lg=jo.ReactCurrentBatchConfig,fa=0,fn=null,Pn=null,Dn=null,sm=!1,Wf=!1,ap=0,JT=0;function Xn(){throw Error(St(321))}function x0(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!to(e[n],t[n]))return!1;return!0}function M0(e,t,n,o,a,l){if(fa=l,fn=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,Dh.current=e===null||e.memoizedState===null?nS:iS,e=n(o,a),Wf){l=0;do{if(Wf=!1,ap=0,25<=l)throw Error(St(301));l+=1,Dn=Pn=null,t.updateQueue=null,Dh.current=oS,e=n(o,a)}while(Wf)}if(Dh.current=am,t=Pn!==null&&Pn.next!==null,fa=0,Dn=Pn=fn=null,sm=!1,t)throw Error(St(300));return e}function k0(){var e=ap!==0;return ap=0,e}function po(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Dn===null?fn.memoizedState=Dn=e:Dn=Dn.next=e,Dn}function Vi(){if(Pn===null){var e=fn.alternate;e=e!==null?e.memoizedState:null}else e=Pn.next;var t=Dn===null?fn.memoizedState:Dn.next;if(t!==null)Dn=t,Pn=e;else{if(e===null)throw Error(St(310));Pn=e,e={memoizedState:Pn.memoizedState,baseState:Pn.baseState,baseQueue:Pn.baseQueue,queue:Pn.queue,next:null},Dn===null?fn.memoizedState=Dn=e:Dn=Dn.next=e}return Dn}function lp(e,t){return typeof t=="function"?t(e):t}function Bg(e){var t=Vi(),n=t.queue;if(n===null)throw Error(St(311));n.lastRenderedReducer=e;var o=Pn,a=o.baseQueue,l=n.pending;if(l!==null){if(a!==null){var f=a.next;a.next=l.next,l.next=f}o.baseQueue=a=l,n.pending=null}if(a!==null){l=a.next,o=o.baseState;var _=f=null,m=null,g=l;do{var M=g.lane;if((fa&M)===M)m!==null&&(m=m.next={lane:0,action:g.action,hasEagerState:g.hasEagerState,eagerState:g.eagerState,next:null}),o=g.hasEagerState?g.eagerState:e(o,g.action);else{var v={lane:M,action:g.action,hasEagerState:g.hasEagerState,eagerState:g.eagerState,next:null};m===null?(_=m=v,f=o):m=m.next=v,fn.lanes|=M,pa|=M}g=g.next}while(g!==null&&g!==l);m===null?f=o:m.next=_,to(o,t.memoizedState)||(hi=!0),t.memoizedState=o,t.baseState=f,t.baseQueue=m,n.lastRenderedState=o}if(e=n.interleaved,e!==null){a=e;do l=a.lane,fn.lanes|=l,pa|=l,a=a.next;while(a!==e)}else a===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function Rg(e){var t=Vi(),n=t.queue;if(n===null)throw Error(St(311));n.lastRenderedReducer=e;var o=n.dispatch,a=n.pending,l=t.memoizedState;if(a!==null){n.pending=null;var f=a=a.next;do l=e(l,f.action),f=f.next;while(f!==a);to(l,t.memoizedState)||(hi=!0),t.memoizedState=l,t.baseQueue===null&&(t.baseState=l),n.lastRenderedState=l}return[l,o]}function lb(){}function ub(e,t){var n=fn,o=Vi(),a=t(),l=!to(o.memoizedState,a);if(l&&(o.memoizedState=a,hi=!0),o=o.queue,T0(fb.bind(null,n,o,e),[e]),o.getSnapshot!==t||l||Dn!==null&&Dn.memoizedState.tag&1){if(n.flags|=2048,up(9,db.bind(null,n,o,a,t),void 0,null),Ln===null)throw Error(St(349));fa&30||cb(n,t,a)}return a}function cb(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=fn.updateQueue,t===null?(t={lastEffect:null,stores:null},fn.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function db(e,t,n,o){t.value=n,t.getSnapshot=o,pb(t)&&hb(e)}function fb(e,t,n){return n(function(){pb(t)&&hb(e)})}function pb(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!to(e,n)}catch{return!0}}function hb(e){var t=Ro(e,1);t!==null&&eo(t,e,1,-1)}function av(e){var t=po();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:lp,lastRenderedState:e},t.queue=e,e=e.dispatch=rS.bind(null,fn,e),[t.memoizedState,e]}function up(e,t,n,o){return e={tag:e,create:t,destroy:n,deps:o,next:null},t=fn.updateQueue,t===null?(t={lastEffect:null,stores:null},fn.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(o=n.next,n.next=e,e.next=o,t.lastEffect=e)),e}function mb(){return Vi().memoizedState}function Lh(e,t,n,o){var a=po();fn.flags|=e,a.memoizedState=up(1|t,n,void 0,o===void 0?null:o)}function Mm(e,t,n,o){var a=Vi();o=o===void 0?null:o;var l=void 0;if(Pn!==null){var f=Pn.memoizedState;if(l=f.destroy,o!==null&&x0(o,f.deps)){a.memoizedState=up(t,n,l,o);return}}fn.flags|=e,a.memoizedState=up(1|t,n,l,o)}function lv(e,t){return Lh(8390656,8,e,t)}function T0(e,t){return Mm(2048,8,e,t)}function gb(e,t){return Mm(4,2,e,t)}function _b(e,t){return Mm(4,4,e,t)}function yb(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function wb(e,t,n){return n=n!=null?n.concat([e]):null,Mm(4,4,yb.bind(null,t,e),n)}function S0(){}function vb(e,t){var n=Vi();t=t===void 0?null:t;var o=n.memoizedState;return o!==null&&t!==null&&x0(t,o[1])?o[0]:(n.memoizedState=[e,t],e)}function bb(e,t){var n=Vi();t=t===void 0?null:t;var o=n.memoizedState;return o!==null&&t!==null&&x0(t,o[1])?o[0]:(e=e(),n.memoizedState=[e,t],e)}function xb(e,t,n){return fa&21?(to(n,t)||(n=E2(),fn.lanes|=n,pa|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,hi=!0),e.memoizedState=n)}function eS(e,t){var n=qr;qr=n!==0&&4>n?n:4,e(!0);var o=Lg.transition;Lg.transition={};try{e(!1),t()}finally{qr=n,Lg.transition=o}}function Mb(){return Vi().memoizedState}function tS(e,t,n){var o=Ms(e);if(n={lane:o,action:n,hasEagerState:!1,eagerState:null,next:null},kb(e))Tb(t,n);else if(n=ob(e,t,n,o),n!==null){var a=si();eo(n,e,o,a),Sb(n,t,o)}}function rS(e,t,n){var o=Ms(e),a={lane:o,action:n,hasEagerState:!1,eagerState:null,next:null};if(kb(e))Tb(t,a);else{var l=e.alternate;if(e.lanes===0&&(l===null||l.lanes===0)&&(l=t.lastRenderedReducer,l!==null))try{var f=t.lastRenderedState,_=l(f,n);if(a.hasEagerState=!0,a.eagerState=_,to(_,f)){var m=t.interleaved;m===null?(a.next=a,_0(t)):(a.next=m.next,m.next=a),t.interleaved=a;return}}catch{}finally{}n=ob(e,t,a,o),n!==null&&(a=si(),eo(n,e,o,a),Sb(n,t,o))}}function kb(e){var t=e.alternate;return e===fn||t!==null&&t===fn}function Tb(e,t){Wf=sm=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Sb(e,t,n){if(n&4194240){var o=t.lanes;o&=e.pendingLanes,n|=o,t.lanes=n,n0(e,n)}}var am={readContext:Ui,useCallback:Xn,useContext:Xn,useEffect:Xn,useImperativeHandle:Xn,useInsertionEffect:Xn,useLayoutEffect:Xn,useMemo:Xn,useReducer:Xn,useRef:Xn,useState:Xn,useDebugValue:Xn,useDeferredValue:Xn,useTransition:Xn,useMutableSource:Xn,useSyncExternalStore:Xn,useId:Xn,unstable_isNewReconciler:!1},nS={readContext:Ui,useCallback:function(e,t){return po().memoizedState=[e,t===void 0?null:t],e},useContext:Ui,useEffect:lv,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,Lh(4194308,4,yb.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Lh(4194308,4,e,t)},useInsertionEffect:function(e,t){return Lh(4,2,e,t)},useMemo:function(e,t){var n=po();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var o=po();return t=n!==void 0?n(t):t,o.memoizedState=o.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},o.queue=e,e=e.dispatch=tS.bind(null,fn,e),[o.memoizedState,e]},useRef:function(e){var t=po();return e={current:e},t.memoizedState=e},useState:av,useDebugValue:S0,useDeferredValue:function(e){return po().memoizedState=e},useTransition:function(){var e=av(!1),t=e[0];return e=eS.bind(null,e[1]),po().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var o=fn,a=po();if(ln){if(n===void 0)throw Error(St(407));n=n()}else{if(n=t(),Ln===null)throw Error(St(349));fa&30||cb(o,t,n)}a.memoizedState=n;var l={value:n,getSnapshot:t};return a.queue=l,lv(fb.bind(null,o,l,e),[e]),o.flags|=2048,up(9,db.bind(null,o,l,n,t),void 0,null),n},useId:function(){var e=po(),t=Ln.identifierPrefix;if(ln){var n=Oo,o=zo;n=(o&~(1<<32-Ji(o)-1)).toString(32)+n,t=":"+t+"R"+n,n=ap++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=JT++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},iS={readContext:Ui,useCallback:vb,useContext:Ui,useEffect:T0,useImperativeHandle:wb,useInsertionEffect:gb,useLayoutEffect:_b,useMemo:bb,useReducer:Bg,useRef:mb,useState:function(){return Bg(lp)},useDebugValue:S0,useDeferredValue:function(e){var t=Vi();return xb(t,Pn.memoizedState,e)},useTransition:function(){var e=Bg(lp)[0],t=Vi().memoizedState;return[e,t]},useMutableSource:lb,useSyncExternalStore:ub,useId:Mb,unstable_isNewReconciler:!1},oS={readContext:Ui,useCallback:vb,useContext:Ui,useEffect:T0,useImperativeHandle:wb,useInsertionEffect:gb,useLayoutEffect:_b,useMemo:bb,useReducer:Rg,useRef:mb,useState:function(){return Rg(lp)},useDebugValue:S0,useDeferredValue:function(e){var t=Vi();return Pn===null?t.memoizedState=e:xb(t,Pn.memoizedState,e)},useTransition:function(){var e=Rg(lp)[0],t=Vi().memoizedState;return[e,t]},useMutableSource:lb,useSyncExternalStore:ub,useId:Mb,unstable_isNewReconciler:!1};function Xi(e,t){if(e&&e.defaultProps){t=pn({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}function M_(e,t,n,o){t=e.memoizedState,n=n(o,t),n=n==null?t:pn({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var km={isMounted:function(e){return(e=e._reactInternals)?ga(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var o=si(),a=Ms(e),l=Do(o,a);l.payload=t,n!=null&&(l.callback=n),t=bs(e,l,a),t!==null&&(eo(t,e,a,o),Oh(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var o=si(),a=Ms(e),l=Do(o,a);l.tag=1,l.payload=t,n!=null&&(l.callback=n),t=bs(e,l,a),t!==null&&(eo(t,e,a,o),Oh(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=si(),o=Ms(e),a=Do(n,o);a.tag=2,t!=null&&(a.callback=t),t=bs(e,a,o),t!==null&&(eo(t,e,o,n),Oh(t,e,o))}};function uv(e,t,n,o,a,l,f){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(o,l,f):t.prototype&&t.prototype.isPureReactComponent?!tp(n,o)||!tp(a,l):!0}function Eb(e,t,n){var o=!1,a=Ss,l=t.contextType;return typeof l=="object"&&l!==null?l=Ui(l):(a=gi(t)?ca:Jn.current,o=t.contextTypes,l=(o=o!=null)?fu(e,a):Ss),t=new t(n,l),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=km,e.stateNode=t,t._reactInternals=e,o&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=l),t}function cv(e,t,n,o){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,o),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,o),t.state!==e&&km.enqueueReplaceState(t,t.state,null)}function k_(e,t,n,o){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs={},y0(e);var l=t.contextType;typeof l=="object"&&l!==null?a.context=Ui(l):(l=gi(t)?ca:Jn.current,a.context=fu(e,l)),a.state=e.memoizedState,l=t.getDerivedStateFromProps,typeof l=="function"&&(M_(e,t,l,n),a.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof a.getSnapshotBeforeUpdate=="function"||typeof a.UNSAFE_componentWillMount!="function"&&typeof a.componentWillMount!="function"||(t=a.state,typeof a.componentWillMount=="function"&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount=="function"&&a.UNSAFE_componentWillMount(),t!==a.state&&km.enqueueReplaceState(a,a.state,null),im(e,n,a,o),a.state=e.memoizedState),typeof a.componentDidMount=="function"&&(e.flags|=4194308)}function gu(e,t){try{var n="",o=t;do n+=Fk(o),o=o.return;while(o);var a=n}catch(l){a=`
Error generating stack: `+l.message+`
`+l.stack}return{value:e,source:t,stack:a,digest:null}}function Ng(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function T_(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var sS=typeof WeakMap=="function"?WeakMap:Map;function Cb(e,t,n){n=Do(-1,n),n.tag=3,n.payload={element:null};var o=t.value;return n.callback=function(){um||(um=!0,O_=o),T_(e,t)},n}function Pb(e,t,n){n=Do(-1,n),n.tag=3;var o=e.type.getDerivedStateFromError;if(typeof o=="function"){var a=t.value;n.payload=function(){return o(a)},n.callback=function(){T_(e,t)}}var l=e.stateNode;return l!==null&&typeof l.componentDidCatch=="function"&&(n.callback=function(){T_(e,t),typeof o!="function"&&(xs===null?xs=new Set([this]):xs.add(this));var f=t.stack;this.componentDidCatch(t.value,{componentStack:f!==null?f:""})}),n}function dv(e,t,n){var o=e.pingCache;if(o===null){o=e.pingCache=new sS;var a=new Set;o.set(t,a)}else a=o.get(t),a===void 0&&(a=new Set,o.set(t,a));a.has(n)||(a.add(n),e=vS.bind(null,e,t,n),t.then(e,e))}function fv(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function pv(e,t,n,o,a){return e.mode&1?(e.flags|=65536,e.lanes=a,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=Do(-1,1),t.tag=2,bs(n,t,1))),n.lanes|=1),e)}var aS=jo.ReactCurrentOwner,hi=!1;function oi(e,t,n,o){t.child=e===null?ib(t,null,n,o):hu(t,e.child,n,o)}function hv(e,t,n,o,a){n=n.render;var l=t.ref;return uu(t,a),o=M0(e,t,n,o,l,a),n=k0(),e!==null&&!hi?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,No(e,t,a)):(ln&&n&&d0(t),t.flags|=1,oi(e,t,o,a),t.child)}function mv(e,t,n,o,a){if(e===null){var l=n.type;return typeof l=="function"&&!z0(l)&&l.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=l,$b(e,t,l,o,a)):(e=jh(n.type,null,o,t,t.mode,a),e.ref=t.ref,e.return=t,t.child=e)}if(l=e.child,!(e.lanes&a)){var f=l.memoizedProps;if(n=n.compare,n=n!==null?n:tp,n(f,o)&&e.ref===t.ref)return No(e,t,a)}return t.flags|=1,e=ks(l,o),e.ref=t.ref,e.return=t,t.child=e}function $b(e,t,n,o,a){if(e!==null){var l=e.memoizedProps;if(tp(l,o)&&e.ref===t.ref)if(hi=!1,t.pendingProps=o=l,(e.lanes&a)!==0)e.flags&131072&&(hi=!0);else return t.lanes=e.lanes,No(e,t,a)}return S_(e,t,n,o,a)}function Ab(e,t,n){var o=t.pendingProps,a=o.children,l=e!==null?e.memoizedState:null;if(o.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},tn(iu,Ti),Ti|=n;else{if(!(n&1073741824))return e=l!==null?l.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,tn(iu,Ti),Ti|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},o=l!==null?l.baseLanes:n,tn(iu,Ti),Ti|=o}else l!==null?(o=l.baseLanes|n,t.memoizedState=null):o=n,tn(iu,Ti),Ti|=o;return oi(e,t,a,n),t.child}function Ib(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function S_(e,t,n,o,a){var l=gi(n)?ca:Jn.current;return l=fu(t,l),uu(t,a),n=M0(e,t,n,o,l,a),o=k0(),e!==null&&!hi?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,No(e,t,a)):(ln&&o&&d0(t),t.flags|=1,oi(e,t,n,a),t.child)}function gv(e,t,n,o,a){if(gi(n)){var l=!0;Jh(t)}else l=!1;if(uu(t,a),t.stateNode===null)Bh(e,t),Eb(t,n,o),k_(t,n,o,a),o=!0;else if(e===null){var f=t.stateNode,_=t.memoizedProps;f.props=_;var m=f.context,g=n.contextType;typeof g=="object"&&g!==null?g=Ui(g):(g=gi(n)?ca:Jn.current,g=fu(t,g));var M=n.getDerivedStateFromProps,v=typeof M=="function"||typeof f.getSnapshotBeforeUpdate=="function";v||typeof f.UNSAFE_componentWillReceiveProps!="function"&&typeof f.componentWillReceiveProps!="function"||(_!==o||m!==g)&&cv(t,f,o,g),fs=!1;var C=t.memoizedState;f.state=C,im(t,o,f,a),m=t.memoizedState,_!==o||C!==m||mi.current||fs?(typeof M=="function"&&(M_(t,n,M,o),m=t.memoizedState),(_=fs||uv(t,n,_,o,C,m,g))?(v||typeof f.UNSAFE_componentWillMount!="function"&&typeof f.componentWillMount!="function"||(typeof f.componentWillMount=="function"&&f.componentWillMount(),typeof f.UNSAFE_componentWillMount=="function"&&f.UNSAFE_componentWillMount()),typeof f.componentDidMount=="function"&&(t.flags|=4194308)):(typeof f.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=o,t.memoizedState=m),f.props=o,f.state=m,f.context=g,o=_):(typeof f.componentDidMount=="function"&&(t.flags|=4194308),o=!1)}else{f=t.stateNode,sb(e,t),_=t.memoizedProps,g=t.type===t.elementType?_:Xi(t.type,_),f.props=g,v=t.pendingProps,C=f.context,m=n.contextType,typeof m=="object"&&m!==null?m=Ui(m):(m=gi(n)?ca:Jn.current,m=fu(t,m));var k=n.getDerivedStateFromProps;(M=typeof k=="function"||typeof f.getSnapshotBeforeUpdate=="function")||typeof f.UNSAFE_componentWillReceiveProps!="function"&&typeof f.componentWillReceiveProps!="function"||(_!==v||C!==m)&&cv(t,f,o,m),fs=!1,C=t.memoizedState,f.state=C,im(t,o,f,a);var z=t.memoizedState;_!==v||C!==z||mi.current||fs?(typeof k=="function"&&(M_(t,n,k,o),z=t.memoizedState),(g=fs||uv(t,n,g,o,C,z,m)||!1)?(M||typeof f.UNSAFE_componentWillUpdate!="function"&&typeof f.componentWillUpdate!="function"||(typeof f.componentWillUpdate=="function"&&f.componentWillUpdate(o,z,m),typeof f.UNSAFE_componentWillUpdate=="function"&&f.UNSAFE_componentWillUpdate(o,z,m)),typeof f.componentDidUpdate=="function"&&(t.flags|=4),typeof f.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof f.componentDidUpdate!="function"||_===e.memoizedProps&&C===e.memoizedState||(t.flags|=4),typeof f.getSnapshotBeforeUpdate!="function"||_===e.memoizedProps&&C===e.memoizedState||(t.flags|=1024),t.memoizedProps=o,t.memoizedState=z),f.props=o,f.state=z,f.context=m,o=g):(typeof f.componentDidUpdate!="function"||_===e.memoizedProps&&C===e.memoizedState||(t.flags|=4),typeof f.getSnapshotBeforeUpdate!="function"||_===e.memoizedProps&&C===e.memoizedState||(t.flags|=1024),o=!1)}return E_(e,t,n,o,l,a)}function E_(e,t,n,o,a,l){Ib(e,t);var f=(t.flags&128)!==0;if(!o&&!f)return a&&tv(t,n,!1),No(e,t,l);o=t.stateNode,aS.current=t;var _=f&&typeof n.getDerivedStateFromError!="function"?null:o.render();return t.flags|=1,e!==null&&f?(t.child=hu(t,e.child,null,l),t.child=hu(t,null,_,l)):oi(e,t,_,l),t.memoizedState=o.state,a&&tv(t,n,!0),t.child}function Fb(e){var t=e.stateNode;t.pendingContext?ev(e,t.pendingContext,t.pendingContext!==t.context):t.context&&ev(e,t.context,!1),w0(e,t.containerInfo)}function _v(e,t,n,o,a){return pu(),p0(a),t.flags|=256,oi(e,t,n,o),t.child}var C_={dehydrated:null,treeContext:null,retryLane:0};function P_(e){return{baseLanes:e,cachePool:null,transitions:null}}function zb(e,t,n){var o=t.pendingProps,a=dn.current,l=!1,f=(t.flags&128)!==0,_;if((_=f)||(_=e!==null&&e.memoizedState===null?!1:(a&2)!==0),_?(l=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(a|=1),tn(dn,a&1),e===null)return b_(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(f=o.children,e=o.fallback,l?(o=t.mode,l=t.child,f={mode:"hidden",children:f},!(o&1)&&l!==null?(l.childLanes=0,l.pendingProps=f):l=Em(f,o,0,null),e=ua(e,o,n,null),l.return=t,e.return=t,l.sibling=e,t.child=l,t.child.memoizedState=P_(n),t.memoizedState=C_,e):E0(t,f));if(a=e.memoizedState,a!==null&&(_=a.dehydrated,_!==null))return lS(e,t,f,o,_,a,n);if(l){l=o.fallback,f=t.mode,a=e.child,_=a.sibling;var m={mode:"hidden",children:o.children};return!(f&1)&&t.child!==a?(o=t.child,o.childLanes=0,o.pendingProps=m,t.deletions=null):(o=ks(a,m),o.subtreeFlags=a.subtreeFlags&14680064),_!==null?l=ks(_,l):(l=ua(l,f,n,null),l.flags|=2),l.return=t,o.return=t,o.sibling=l,t.child=o,o=l,l=t.child,f=e.child.memoizedState,f=f===null?P_(n):{baseLanes:f.baseLanes|n,cachePool:null,transitions:f.transitions},l.memoizedState=f,l.childLanes=e.childLanes&~n,t.memoizedState=C_,o}return l=e.child,e=l.sibling,o=ks(l,{mode:"visible",children:o.children}),!(t.mode&1)&&(o.lanes=n),o.return=t,o.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=o,t.memoizedState=null,o}function E0(e,t){return t=Em({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function kh(e,t,n,o){return o!==null&&p0(o),hu(t,e.child,null,n),e=E0(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function lS(e,t,n,o,a,l,f){if(n)return t.flags&256?(t.flags&=-257,o=Ng(Error(St(422))),kh(e,t,f,o)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(l=o.fallback,a=t.mode,o=Em({mode:"visible",children:o.children},a,0,null),l=ua(l,a,f,null),l.flags|=2,o.return=t,l.return=t,o.sibling=l,t.child=o,t.mode&1&&hu(t,e.child,null,f),t.child.memoizedState=P_(f),t.memoizedState=C_,l);if(!(t.mode&1))return kh(e,t,f,null);if(a.data==="$!"){if(o=a.nextSibling&&a.nextSibling.dataset,o)var _=o.dgst;return o=_,l=Error(St(419)),o=Ng(l,o,void 0),kh(e,t,f,o)}if(_=(f&e.childLanes)!==0,hi||_){if(o=Ln,o!==null){switch(f&-f){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}a=a&(o.suspendedLanes|f)?0:a,a!==0&&a!==l.retryLane&&(l.retryLane=a,Ro(e,a),eo(o,e,a,-1))}return F0(),o=Ng(Error(St(421))),kh(e,t,f,o)}return a.data==="$?"?(t.flags|=128,t.child=e.child,t=bS.bind(null,e),a._reactRetry=t,null):(e=l.treeContext,Si=vs(a.nextSibling),Ei=t,ln=!0,Zi=null,e!==null&&(Bi[Ri++]=zo,Bi[Ri++]=Oo,Bi[Ri++]=da,zo=e.id,Oo=e.overflow,da=t),t=E0(t,o.children),t.flags|=4096,t)}function yv(e,t,n){e.lanes|=t;var o=e.alternate;o!==null&&(o.lanes|=t),x_(e.return,t,n)}function jg(e,t,n,o,a){var l=e.memoizedState;l===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:o,tail:n,tailMode:a}:(l.isBackwards=t,l.rendering=null,l.renderingStartTime=0,l.last=o,l.tail=n,l.tailMode=a)}function Ob(e,t,n){var o=t.pendingProps,a=o.revealOrder,l=o.tail;if(oi(e,t,o.children,n),o=dn.current,o&2)o=o&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&yv(e,n,t);else if(e.tag===19)yv(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}o&=1}if(tn(dn,o),!(t.mode&1))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;n!==null;)e=n.alternate,e!==null&&om(e)===null&&(a=n),n=n.sibling;n=a,n===null?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),jg(t,!1,a,n,l);break;case"backwards":for(n=null,a=t.child,t.child=null;a!==null;){if(e=a.alternate,e!==null&&om(e)===null){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}jg(t,!0,n,null,l);break;case"together":jg(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Bh(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function No(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),pa|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(St(153));if(t.child!==null){for(e=t.child,n=ks(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=ks(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function uS(e,t,n){switch(t.tag){case 3:Fb(t),pu();break;case 5:ab(t);break;case 1:gi(t.type)&&Jh(t);break;case 4:w0(t,t.stateNode.containerInfo);break;case 10:var o=t.type._context,a=t.memoizedProps.value;tn(rm,o._currentValue),o._currentValue=a;break;case 13:if(o=t.memoizedState,o!==null)return o.dehydrated!==null?(tn(dn,dn.current&1),t.flags|=128,null):n&t.child.childLanes?zb(e,t,n):(tn(dn,dn.current&1),e=No(e,t,n),e!==null?e.sibling:null);tn(dn,dn.current&1);break;case 19:if(o=(n&t.childLanes)!==0,e.flags&128){if(o)return Ob(e,t,n);t.flags|=128}if(a=t.memoizedState,a!==null&&(a.rendering=null,a.tail=null,a.lastEffect=null),tn(dn,dn.current),o)break;return null;case 22:case 23:return t.lanes=0,Ab(e,t,n)}return No(e,t,n)}var Db,$_,Lb,Bb;Db=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};$_=function(){};Lb=function(e,t,n,o){var a=e.memoizedProps;if(a!==o){e=t.stateNode,aa(go.current);var l=null;switch(n){case"input":a=Zg(e,a),o=Zg(e,o),l=[];break;case"select":a=pn({},a,{value:void 0}),o=pn({},o,{value:void 0}),l=[];break;case"textarea":a=t_(e,a),o=t_(e,o),l=[];break;default:typeof a.onClick!="function"&&typeof o.onClick=="function"&&(e.onclick=Yh)}n_(n,o);var f;n=null;for(g in a)if(!o.hasOwnProperty(g)&&a.hasOwnProperty(g)&&a[g]!=null)if(g==="style"){var _=a[g];for(f in _)_.hasOwnProperty(f)&&(n||(n={}),n[f]="")}else g!=="dangerouslySetInnerHTML"&&g!=="children"&&g!=="suppressContentEditableWarning"&&g!=="suppressHydrationWarning"&&g!=="autoFocus"&&(Kf.hasOwnProperty(g)?l||(l=[]):(l=l||[]).push(g,null));for(g in o){var m=o[g];if(_=a!=null?a[g]:void 0,o.hasOwnProperty(g)&&m!==_&&(m!=null||_!=null))if(g==="style")if(_){for(f in _)!_.hasOwnProperty(f)||m&&m.hasOwnProperty(f)||(n||(n={}),n[f]="");for(f in m)m.hasOwnProperty(f)&&_[f]!==m[f]&&(n||(n={}),n[f]=m[f])}else n||(l||(l=[]),l.push(g,n)),n=m;else g==="dangerouslySetInnerHTML"?(m=m?m.__html:void 0,_=_?_.__html:void 0,m!=null&&_!==m&&(l=l||[]).push(g,m)):g==="children"?typeof m!="string"&&typeof m!="number"||(l=l||[]).push(g,""+m):g!=="suppressContentEditableWarning"&&g!=="suppressHydrationWarning"&&(Kf.hasOwnProperty(g)?(m!=null&&g==="onScroll"&&on("scroll",e),l||_===m||(l=[])):(l=l||[]).push(g,m))}n&&(l=l||[]).push("style",n);var g=l;(t.updateQueue=g)&&(t.flags|=4)}};Bb=function(e,t,n,o){n!==o&&(t.flags|=4)};function Af(e,t){if(!ln)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var o=null;n!==null;)n.alternate!==null&&(o=n),n=n.sibling;o===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:o.sibling=null}}function Yn(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,o=0;if(t)for(var a=e.child;a!==null;)n|=a.lanes|a.childLanes,o|=a.subtreeFlags&14680064,o|=a.flags&14680064,a.return=e,a=a.sibling;else for(a=e.child;a!==null;)n|=a.lanes|a.childLanes,o|=a.subtreeFlags,o|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=o,e.childLanes=n,t}function cS(e,t,n){var o=t.pendingProps;switch(f0(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Yn(t),null;case 1:return gi(t.type)&&Zh(),Yn(t),null;case 3:return o=t.stateNode,mu(),sn(mi),sn(Jn),b0(),o.pendingContext&&(o.context=o.pendingContext,o.pendingContext=null),(e===null||e.child===null)&&(xh(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,Zi!==null&&(B_(Zi),Zi=null))),$_(e,t),Yn(t),null;case 5:v0(t);var a=aa(sp.current);if(n=t.type,e!==null&&t.stateNode!=null)Lb(e,t,n,o,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!o){if(t.stateNode===null)throw Error(St(166));return Yn(t),null}if(e=aa(go.current),xh(t)){o=t.stateNode,n=t.type;var l=t.memoizedProps;switch(o[ho]=t,o[ip]=l,e=(t.mode&1)!==0,n){case"dialog":on("cancel",o),on("close",o);break;case"iframe":case"object":case"embed":on("load",o);break;case"video":case"audio":for(a=0;a<Lf.length;a++)on(Lf[a],o);break;case"source":on("error",o);break;case"img":case"image":case"link":on("error",o),on("load",o);break;case"details":on("toggle",o);break;case"input":E1(o,l),on("invalid",o);break;case"select":o._wrapperState={wasMultiple:!!l.multiple},on("invalid",o);break;case"textarea":P1(o,l),on("invalid",o)}n_(n,l),a=null;for(var f in l)if(l.hasOwnProperty(f)){var _=l[f];f==="children"?typeof _=="string"?o.textContent!==_&&(l.suppressHydrationWarning!==!0&&bh(o.textContent,_,e),a=["children",_]):typeof _=="number"&&o.textContent!==""+_&&(l.suppressHydrationWarning!==!0&&bh(o.textContent,_,e),a=["children",""+_]):Kf.hasOwnProperty(f)&&_!=null&&f==="onScroll"&&on("scroll",o)}switch(n){case"input":ph(o),C1(o,l,!0);break;case"textarea":ph(o),$1(o);break;case"select":case"option":break;default:typeof l.onClick=="function"&&(o.onclick=Yh)}o=a,t.updateQueue=o,o!==null&&(t.flags|=4)}else{f=a.nodeType===9?a:a.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=f2(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=f.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof o.is=="string"?e=f.createElement(n,{is:o.is}):(e=f.createElement(n),n==="select"&&(f=e,o.multiple?f.multiple=!0:o.size&&(f.size=o.size))):e=f.createElementNS(e,n),e[ho]=t,e[ip]=o,Db(e,t,!1,!1),t.stateNode=e;e:{switch(f=i_(n,o),n){case"dialog":on("cancel",e),on("close",e),a=o;break;case"iframe":case"object":case"embed":on("load",e),a=o;break;case"video":case"audio":for(a=0;a<Lf.length;a++)on(Lf[a],e);a=o;break;case"source":on("error",e),a=o;break;case"img":case"image":case"link":on("error",e),on("load",e),a=o;break;case"details":on("toggle",e),a=o;break;case"input":E1(e,o),a=Zg(e,o),on("invalid",e);break;case"option":a=o;break;case"select":e._wrapperState={wasMultiple:!!o.multiple},a=pn({},o,{value:void 0}),on("invalid",e);break;case"textarea":P1(e,o),a=t_(e,o),on("invalid",e);break;default:a=o}n_(n,a),_=a;for(l in _)if(_.hasOwnProperty(l)){var m=_[l];l==="style"?m2(e,m):l==="dangerouslySetInnerHTML"?(m=m?m.__html:void 0,m!=null&&p2(e,m)):l==="children"?typeof m=="string"?(n!=="textarea"||m!=="")&&Qf(e,m):typeof m=="number"&&Qf(e,""+m):l!=="suppressContentEditableWarning"&&l!=="suppressHydrationWarning"&&l!=="autoFocus"&&(Kf.hasOwnProperty(l)?m!=null&&l==="onScroll"&&on("scroll",e):m!=null&&Y_(e,l,m,f))}switch(n){case"input":ph(e),C1(e,o,!1);break;case"textarea":ph(e),$1(e);break;case"option":o.value!=null&&e.setAttribute("value",""+Ts(o.value));break;case"select":e.multiple=!!o.multiple,l=o.value,l!=null?ou(e,!!o.multiple,l,!1):o.defaultValue!=null&&ou(e,!!o.multiple,o.defaultValue,!0);break;default:typeof a.onClick=="function"&&(e.onclick=Yh)}switch(n){case"button":case"input":case"select":case"textarea":o=!!o.autoFocus;break e;case"img":o=!0;break e;default:o=!1}}o&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return Yn(t),null;case 6:if(e&&t.stateNode!=null)Bb(e,t,e.memoizedProps,o);else{if(typeof o!="string"&&t.stateNode===null)throw Error(St(166));if(n=aa(sp.current),aa(go.current),xh(t)){if(o=t.stateNode,n=t.memoizedProps,o[ho]=t,(l=o.nodeValue!==n)&&(e=Ei,e!==null))switch(e.tag){case 3:bh(o.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&bh(o.nodeValue,n,(e.mode&1)!==0)}l&&(t.flags|=4)}else o=(n.nodeType===9?n:n.ownerDocument).createTextNode(o),o[ho]=t,t.stateNode=o}return Yn(t),null;case 13:if(sn(dn),o=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(ln&&Si!==null&&t.mode&1&&!(t.flags&128))rb(),pu(),t.flags|=98560,l=!1;else if(l=xh(t),o!==null&&o.dehydrated!==null){if(e===null){if(!l)throw Error(St(318));if(l=t.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(St(317));l[ho]=t}else pu(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;Yn(t),l=!1}else Zi!==null&&(B_(Zi),Zi=null),l=!0;if(!l)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(o=o!==null,o!==(e!==null&&e.memoizedState!==null)&&o&&(t.child.flags|=8192,t.mode&1&&(e===null||dn.current&1?$n===0&&($n=3):F0())),t.updateQueue!==null&&(t.flags|=4),Yn(t),null);case 4:return mu(),$_(e,t),e===null&&rp(t.stateNode.containerInfo),Yn(t),null;case 10:return g0(t.type._context),Yn(t),null;case 17:return gi(t.type)&&Zh(),Yn(t),null;case 19:if(sn(dn),l=t.memoizedState,l===null)return Yn(t),null;if(o=(t.flags&128)!==0,f=l.rendering,f===null)if(o)Af(l,!1);else{if($n!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(f=om(e),f!==null){for(t.flags|=128,Af(l,!1),o=f.updateQueue,o!==null&&(t.updateQueue=o,t.flags|=4),t.subtreeFlags=0,o=n,n=t.child;n!==null;)l=n,e=o,l.flags&=14680066,f=l.alternate,f===null?(l.childLanes=0,l.lanes=e,l.child=null,l.subtreeFlags=0,l.memoizedProps=null,l.memoizedState=null,l.updateQueue=null,l.dependencies=null,l.stateNode=null):(l.childLanes=f.childLanes,l.lanes=f.lanes,l.child=f.child,l.subtreeFlags=0,l.deletions=null,l.memoizedProps=f.memoizedProps,l.memoizedState=f.memoizedState,l.updateQueue=f.updateQueue,l.type=f.type,e=f.dependencies,l.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return tn(dn,dn.current&1|2),t.child}e=e.sibling}l.tail!==null&&wn()>_u&&(t.flags|=128,o=!0,Af(l,!1),t.lanes=4194304)}else{if(!o)if(e=om(f),e!==null){if(t.flags|=128,o=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),Af(l,!0),l.tail===null&&l.tailMode==="hidden"&&!f.alternate&&!ln)return Yn(t),null}else 2*wn()-l.renderingStartTime>_u&&n!==1073741824&&(t.flags|=128,o=!0,Af(l,!1),t.lanes=4194304);l.isBackwards?(f.sibling=t.child,t.child=f):(n=l.last,n!==null?n.sibling=f:t.child=f,l.last=f)}return l.tail!==null?(t=l.tail,l.rendering=t,l.tail=t.sibling,l.renderingStartTime=wn(),t.sibling=null,n=dn.current,tn(dn,o?n&1|2:n&1),t):(Yn(t),null);case 22:case 23:return I0(),o=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==o&&(t.flags|=8192),o&&t.mode&1?Ti&1073741824&&(Yn(t),t.subtreeFlags&6&&(t.flags|=8192)):Yn(t),null;case 24:return null;case 25:return null}throw Error(St(156,t.tag))}function dS(e,t){switch(f0(t),t.tag){case 1:return gi(t.type)&&Zh(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return mu(),sn(mi),sn(Jn),b0(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return v0(t),null;case 13:if(sn(dn),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(St(340));pu()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return sn(dn),null;case 4:return mu(),null;case 10:return g0(t.type._context),null;case 22:case 23:return I0(),null;case 24:return null;default:return null}}var Th=!1,Zn=!1,fS=typeof WeakSet=="function"?WeakSet:Set,Wt=null;function nu(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(o){_n(e,t,o)}else n.current=null}function A_(e,t,n){try{n()}catch(o){_n(e,t,o)}}var wv=!1;function pS(e,t){if(h_=Kh,e=V2(),c0(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var o=n.getSelection&&n.getSelection();if(o&&o.rangeCount!==0){n=o.anchorNode;var a=o.anchorOffset,l=o.focusNode;o=o.focusOffset;try{n.nodeType,l.nodeType}catch{n=null;break e}var f=0,_=-1,m=-1,g=0,M=0,v=e,C=null;t:for(;;){for(var k;v!==n||a!==0&&v.nodeType!==3||(_=f+a),v!==l||o!==0&&v.nodeType!==3||(m=f+o),v.nodeType===3&&(f+=v.nodeValue.length),(k=v.firstChild)!==null;)C=v,v=k;for(;;){if(v===e)break t;if(C===n&&++g===a&&(_=f),C===l&&++M===o&&(m=f),(k=v.nextSibling)!==null)break;v=C,C=v.parentNode}v=k}n=_===-1||m===-1?null:{start:_,end:m}}else n=null}n=n||{start:0,end:0}}else n=null;for(m_={focusedElem:e,selectionRange:n},Kh=!1,Wt=t;Wt!==null;)if(t=Wt,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,Wt=e;else for(;Wt!==null;){t=Wt;try{var z=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(z!==null){var $=z.memoizedProps,S=z.memoizedState,y=t.stateNode,x=y.getSnapshotBeforeUpdate(t.elementType===t.type?$:Xi(t.type,$),S);y.__reactInternalSnapshotBeforeUpdate=x}break;case 3:var I=t.stateNode.containerInfo;I.nodeType===1?I.textContent="":I.nodeType===9&&I.documentElement&&I.removeChild(I.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(St(163))}}catch(V){_n(t,t.return,V)}if(e=t.sibling,e!==null){e.return=t.return,Wt=e;break}Wt=t.return}return z=wv,wv=!1,z}function Gf(e,t,n){var o=t.updateQueue;if(o=o!==null?o.lastEffect:null,o!==null){var a=o=o.next;do{if((a.tag&e)===e){var l=a.destroy;a.destroy=void 0,l!==void 0&&A_(t,n,l)}a=a.next}while(a!==o)}}function Tm(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var o=n.create;n.destroy=o()}n=n.next}while(n!==t)}}function I_(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function Rb(e){var t=e.alternate;t!==null&&(e.alternate=null,Rb(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[ho],delete t[ip],delete t[y_],delete t[QT],delete t[XT])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function Nb(e){return e.tag===5||e.tag===3||e.tag===4}function vv(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||Nb(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function F_(e,t,n){var o=e.tag;if(o===5||o===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=Yh));else if(o!==4&&(e=e.child,e!==null))for(F_(e,t,n),e=e.sibling;e!==null;)F_(e,t,n),e=e.sibling}function z_(e,t,n){var o=e.tag;if(o===5||o===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(o!==4&&(e=e.child,e!==null))for(z_(e,t,n),e=e.sibling;e!==null;)z_(e,t,n),e=e.sibling}var Wn=null,Yi=!1;function cs(e,t,n){for(n=n.child;n!==null;)jb(e,t,n),n=n.sibling}function jb(e,t,n){if(mo&&typeof mo.onCommitFiberUnmount=="function")try{mo.onCommitFiberUnmount(_m,n)}catch{}switch(n.tag){case 5:Zn||nu(n,t);case 6:var o=Wn,a=Yi;Wn=null,cs(e,t,n),Wn=o,Yi=a,Wn!==null&&(Yi?(e=Wn,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):Wn.removeChild(n.stateNode));break;case 18:Wn!==null&&(Yi?(e=Wn,n=n.stateNode,e.nodeType===8?zg(e.parentNode,n):e.nodeType===1&&zg(e,n),Jf(e)):zg(Wn,n.stateNode));break;case 4:o=Wn,a=Yi,Wn=n.stateNode.containerInfo,Yi=!0,cs(e,t,n),Wn=o,Yi=a;break;case 0:case 11:case 14:case 15:if(!Zn&&(o=n.updateQueue,o!==null&&(o=o.lastEffect,o!==null))){a=o=o.next;do{var l=a,f=l.destroy;l=l.tag,f!==void 0&&(l&2||l&4)&&A_(n,t,f),a=a.next}while(a!==o)}cs(e,t,n);break;case 1:if(!Zn&&(nu(n,t),o=n.stateNode,typeof o.componentWillUnmount=="function"))try{o.props=n.memoizedProps,o.state=n.memoizedState,o.componentWillUnmount()}catch(_){_n(n,t,_)}cs(e,t,n);break;case 21:cs(e,t,n);break;case 22:n.mode&1?(Zn=(o=Zn)||n.memoizedState!==null,cs(e,t,n),Zn=o):cs(e,t,n);break;default:cs(e,t,n)}}function bv(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new fS),t.forEach(function(o){var a=xS.bind(null,e,o);n.has(o)||(n.add(o),o.then(a,a))})}}function Qi(e,t){var n=t.deletions;if(n!==null)for(var o=0;o<n.length;o++){var a=n[o];try{var l=e,f=t,_=f;e:for(;_!==null;){switch(_.tag){case 5:Wn=_.stateNode,Yi=!1;break e;case 3:Wn=_.stateNode.containerInfo,Yi=!0;break e;case 4:Wn=_.stateNode.containerInfo,Yi=!0;break e}_=_.return}if(Wn===null)throw Error(St(160));jb(l,f,a),Wn=null,Yi=!1;var m=a.alternate;m!==null&&(m.return=null),a.return=null}catch(g){_n(a,t,g)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)Ub(t,e),t=t.sibling}function Ub(e,t){var n=e.alternate,o=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(Qi(t,e),co(e),o&4){try{Gf(3,e,e.return),Tm(3,e)}catch($){_n(e,e.return,$)}try{Gf(5,e,e.return)}catch($){_n(e,e.return,$)}}break;case 1:Qi(t,e),co(e),o&512&&n!==null&&nu(n,n.return);break;case 5:if(Qi(t,e),co(e),o&512&&n!==null&&nu(n,n.return),e.flags&32){var a=e.stateNode;try{Qf(a,"")}catch($){_n(e,e.return,$)}}if(o&4&&(a=e.stateNode,a!=null)){var l=e.memoizedProps,f=n!==null?n.memoizedProps:l,_=e.type,m=e.updateQueue;if(e.updateQueue=null,m!==null)try{_==="input"&&l.type==="radio"&&l.name!=null&&c2(a,l),i_(_,f);var g=i_(_,l);for(f=0;f<m.length;f+=2){var M=m[f],v=m[f+1];M==="style"?m2(a,v):M==="dangerouslySetInnerHTML"?p2(a,v):M==="children"?Qf(a,v):Y_(a,M,v,g)}switch(_){case"input":Jg(a,l);break;case"textarea":d2(a,l);break;case"select":var C=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!l.multiple;var k=l.value;k!=null?ou(a,!!l.multiple,k,!1):C!==!!l.multiple&&(l.defaultValue!=null?ou(a,!!l.multiple,l.defaultValue,!0):ou(a,!!l.multiple,l.multiple?[]:"",!1))}a[ip]=l}catch($){_n(e,e.return,$)}}break;case 6:if(Qi(t,e),co(e),o&4){if(e.stateNode===null)throw Error(St(162));a=e.stateNode,l=e.memoizedProps;try{a.nodeValue=l}catch($){_n(e,e.return,$)}}break;case 3:if(Qi(t,e),co(e),o&4&&n!==null&&n.memoizedState.isDehydrated)try{Jf(t.containerInfo)}catch($){_n(e,e.return,$)}break;case 4:Qi(t,e),co(e);break;case 13:Qi(t,e),co(e),a=e.child,a.flags&8192&&(l=a.memoizedState!==null,a.stateNode.isHidden=l,!l||a.alternate!==null&&a.alternate.memoizedState!==null||($0=wn())),o&4&&bv(e);break;case 22:if(M=n!==null&&n.memoizedState!==null,e.mode&1?(Zn=(g=Zn)||M,Qi(t,e),Zn=g):Qi(t,e),co(e),o&8192){if(g=e.memoizedState!==null,(e.stateNode.isHidden=g)&&!M&&e.mode&1)for(Wt=e,M=e.child;M!==null;){for(v=Wt=M;Wt!==null;){switch(C=Wt,k=C.child,C.tag){case 0:case 11:case 14:case 15:Gf(4,C,C.return);break;case 1:nu(C,C.return);var z=C.stateNode;if(typeof z.componentWillUnmount=="function"){o=C,n=C.return;try{t=o,z.props=t.memoizedProps,z.state=t.memoizedState,z.componentWillUnmount()}catch($){_n(o,n,$)}}break;case 5:nu(C,C.return);break;case 22:if(C.memoizedState!==null){Mv(v);continue}}k!==null?(k.return=C,Wt=k):Mv(v)}M=M.sibling}e:for(M=null,v=e;;){if(v.tag===5){if(M===null){M=v;try{a=v.stateNode,g?(l=a.style,typeof l.setProperty=="function"?l.setProperty("display","none","important"):l.display="none"):(_=v.stateNode,m=v.memoizedProps.style,f=m!=null&&m.hasOwnProperty("display")?m.display:null,_.style.display=h2("display",f))}catch($){_n(e,e.return,$)}}}else if(v.tag===6){if(M===null)try{v.stateNode.nodeValue=g?"":v.memoizedProps}catch($){_n(e,e.return,$)}}else if((v.tag!==22&&v.tag!==23||v.memoizedState===null||v===e)&&v.child!==null){v.child.return=v,v=v.child;continue}if(v===e)break e;for(;v.sibling===null;){if(v.return===null||v.return===e)break e;M===v&&(M=null),v=v.return}M===v&&(M=null),v.sibling.return=v.return,v=v.sibling}}break;case 19:Qi(t,e),co(e),o&4&&bv(e);break;case 21:break;default:Qi(t,e),co(e)}}function co(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if(Nb(n)){var o=n;break e}n=n.return}throw Error(St(160))}switch(o.tag){case 5:var a=o.stateNode;o.flags&32&&(Qf(a,""),o.flags&=-33);var l=vv(e);z_(e,l,a);break;case 3:case 4:var f=o.stateNode.containerInfo,_=vv(e);F_(e,_,f);break;default:throw Error(St(161))}}catch(m){_n(e,e.return,m)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function hS(e,t,n){Wt=e,Vb(e)}function Vb(e,t,n){for(var o=(e.mode&1)!==0;Wt!==null;){var a=Wt,l=a.child;if(a.tag===22&&o){var f=a.memoizedState!==null||Th;if(!f){var _=a.alternate,m=_!==null&&_.memoizedState!==null||Zn;_=Th;var g=Zn;if(Th=f,(Zn=m)&&!g)for(Wt=a;Wt!==null;)f=Wt,m=f.child,f.tag===22&&f.memoizedState!==null?kv(a):m!==null?(m.return=f,Wt=m):kv(a);for(;l!==null;)Wt=l,Vb(l),l=l.sibling;Wt=a,Th=_,Zn=g}xv(e)}else a.subtreeFlags&8772&&l!==null?(l.return=a,Wt=l):xv(e)}}function xv(e){for(;Wt!==null;){var t=Wt;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:Zn||Tm(5,t);break;case 1:var o=t.stateNode;if(t.flags&4&&!Zn)if(n===null)o.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:Xi(t.type,n.memoizedProps);o.componentDidUpdate(a,n.memoizedState,o.__reactInternalSnapshotBeforeUpdate)}var l=t.updateQueue;l!==null&&sv(t,l,o);break;case 3:var f=t.updateQueue;if(f!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}sv(t,f,n)}break;case 5:var _=t.stateNode;if(n===null&&t.flags&4){n=_;var m=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":m.autoFocus&&n.focus();break;case"img":m.src&&(n.src=m.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var g=t.alternate;if(g!==null){var M=g.memoizedState;if(M!==null){var v=M.dehydrated;v!==null&&Jf(v)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(St(163))}Zn||t.flags&512&&I_(t)}catch(C){_n(t,t.return,C)}}if(t===e){Wt=null;break}if(n=t.sibling,n!==null){n.return=t.return,Wt=n;break}Wt=t.return}}function Mv(e){for(;Wt!==null;){var t=Wt;if(t===e){Wt=null;break}var n=t.sibling;if(n!==null){n.return=t.return,Wt=n;break}Wt=t.return}}function kv(e){for(;Wt!==null;){var t=Wt;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{Tm(4,t)}catch(m){_n(t,n,m)}break;case 1:var o=t.stateNode;if(typeof o.componentDidMount=="function"){var a=t.return;try{o.componentDidMount()}catch(m){_n(t,a,m)}}var l=t.return;try{I_(t)}catch(m){_n(t,l,m)}break;case 5:var f=t.return;try{I_(t)}catch(m){_n(t,f,m)}}}catch(m){_n(t,t.return,m)}if(t===e){Wt=null;break}var _=t.sibling;if(_!==null){_.return=t.return,Wt=_;break}Wt=t.return}}var mS=Math.ceil,lm=jo.ReactCurrentDispatcher,C0=jo.ReactCurrentOwner,ji=jo.ReactCurrentBatchConfig,Rr=0,Ln=null,Mn=null,Gn=0,Ti=0,iu=Cs(0),$n=0,cp=null,pa=0,Sm=0,P0=0,Hf=null,pi=null,$0=0,_u=1/0,Ao=null,um=!1,O_=null,xs=null,Sh=!1,gs=null,cm=0,qf=0,D_=null,Rh=-1,Nh=0;function si(){return Rr&6?wn():Rh!==-1?Rh:Rh=wn()}function Ms(e){return e.mode&1?Rr&2&&Gn!==0?Gn&-Gn:ZT.transition!==null?(Nh===0&&(Nh=E2()),Nh):(e=qr,e!==0||(e=window.event,e=e===void 0?16:z2(e.type)),e):1}function eo(e,t,n,o){if(50<qf)throw qf=0,D_=null,Error(St(185));pp(e,n,o),(!(Rr&2)||e!==Ln)&&(e===Ln&&(!(Rr&2)&&(Sm|=n),$n===4&&hs(e,Gn)),_i(e,o),n===1&&Rr===0&&!(t.mode&1)&&(_u=wn()+500,xm&&Ps()))}function _i(e,t){var n=e.callbackNode;Zk(e,t);var o=qh(e,e===Ln?Gn:0);if(o===0)n!==null&&F1(n),e.callbackNode=null,e.callbackPriority=0;else if(t=o&-o,e.callbackPriority!==t){if(n!=null&&F1(n),t===1)e.tag===0?YT(Tv.bind(null,e)):J2(Tv.bind(null,e)),qT(function(){!(Rr&6)&&Ps()}),n=null;else{switch(C2(o)){case 1:n=r0;break;case 4:n=T2;break;case 16:n=Hh;break;case 536870912:n=S2;break;default:n=Hh}n=Yb(n,Wb.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function Wb(e,t){if(Rh=-1,Nh=0,Rr&6)throw Error(St(327));var n=e.callbackNode;if(cu()&&e.callbackNode!==n)return null;var o=qh(e,e===Ln?Gn:0);if(o===0)return null;if(o&30||o&e.expiredLanes||t)t=dm(e,o);else{t=o;var a=Rr;Rr|=2;var l=Hb();(Ln!==e||Gn!==t)&&(Ao=null,_u=wn()+500,la(e,t));do try{yS();break}catch(_){Gb(e,_)}while(!0);m0(),lm.current=l,Rr=a,Mn!==null?t=0:(Ln=null,Gn=0,t=$n)}if(t!==0){if(t===2&&(a=u_(e),a!==0&&(o=a,t=L_(e,a))),t===1)throw n=cp,la(e,0),hs(e,o),_i(e,wn()),n;if(t===6)hs(e,o);else{if(a=e.current.alternate,!(o&30)&&!gS(a)&&(t=dm(e,o),t===2&&(l=u_(e),l!==0&&(o=l,t=L_(e,l))),t===1))throw n=cp,la(e,0),hs(e,o),_i(e,wn()),n;switch(e.finishedWork=a,e.finishedLanes=o,t){case 0:case 1:throw Error(St(345));case 2:na(e,pi,Ao);break;case 3:if(hs(e,o),(o&130023424)===o&&(t=$0+500-wn(),10<t)){if(qh(e,0)!==0)break;if(a=e.suspendedLanes,(a&o)!==o){si(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=__(na.bind(null,e,pi,Ao),t);break}na(e,pi,Ao);break;case 4:if(hs(e,o),(o&4194240)===o)break;for(t=e.eventTimes,a=-1;0<o;){var f=31-Ji(o);l=1<<f,f=t[f],f>a&&(a=f),o&=~l}if(o=a,o=wn()-o,o=(120>o?120:480>o?480:1080>o?1080:1920>o?1920:3e3>o?3e3:4320>o?4320:1960*mS(o/1960))-o,10<o){e.timeoutHandle=__(na.bind(null,e,pi,Ao),o);break}na(e,pi,Ao);break;case 5:na(e,pi,Ao);break;default:throw Error(St(329))}}}return _i(e,wn()),e.callbackNode===n?Wb.bind(null,e):null}function L_(e,t){var n=Hf;return e.current.memoizedState.isDehydrated&&(la(e,t).flags|=256),e=dm(e,t),e!==2&&(t=pi,pi=n,t!==null&&B_(t)),e}function B_(e){pi===null?pi=e:pi.push.apply(pi,e)}function gS(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var o=0;o<n.length;o++){var a=n[o],l=a.getSnapshot;a=a.value;try{if(!to(l(),a))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function hs(e,t){for(t&=~P0,t&=~Sm,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-Ji(t),o=1<<n;e[n]=-1,t&=~o}}function Tv(e){if(Rr&6)throw Error(St(327));cu();var t=qh(e,0);if(!(t&1))return _i(e,wn()),null;var n=dm(e,t);if(e.tag!==0&&n===2){var o=u_(e);o!==0&&(t=o,n=L_(e,o))}if(n===1)throw n=cp,la(e,0),hs(e,t),_i(e,wn()),n;if(n===6)throw Error(St(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,na(e,pi,Ao),_i(e,wn()),null}function A0(e,t){var n=Rr;Rr|=1;try{return e(t)}finally{Rr=n,Rr===0&&(_u=wn()+500,xm&&Ps())}}function ha(e){gs!==null&&gs.tag===0&&!(Rr&6)&&cu();var t=Rr;Rr|=1;var n=ji.transition,o=qr;try{if(ji.transition=null,qr=1,e)return e()}finally{qr=o,ji.transition=n,Rr=t,!(Rr&6)&&Ps()}}function I0(){Ti=iu.current,sn(iu)}function la(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,HT(n)),Mn!==null)for(n=Mn.return;n!==null;){var o=n;switch(f0(o),o.tag){case 1:o=o.type.childContextTypes,o!=null&&Zh();break;case 3:mu(),sn(mi),sn(Jn),b0();break;case 5:v0(o);break;case 4:mu();break;case 13:sn(dn);break;case 19:sn(dn);break;case 10:g0(o.type._context);break;case 22:case 23:I0()}n=n.return}if(Ln=e,Mn=e=ks(e.current,null),Gn=Ti=t,$n=0,cp=null,P0=Sm=pa=0,pi=Hf=null,sa!==null){for(t=0;t<sa.length;t++)if(n=sa[t],o=n.interleaved,o!==null){n.interleaved=null;var a=o.next,l=n.pending;if(l!==null){var f=l.next;l.next=a,o.next=f}n.pending=o}sa=null}return e}function Gb(e,t){do{var n=Mn;try{if(m0(),Dh.current=am,sm){for(var o=fn.memoizedState;o!==null;){var a=o.queue;a!==null&&(a.pending=null),o=o.next}sm=!1}if(fa=0,Dn=Pn=fn=null,Wf=!1,ap=0,C0.current=null,n===null||n.return===null){$n=1,cp=t,Mn=null;break}e:{var l=e,f=n.return,_=n,m=t;if(t=Gn,_.flags|=32768,m!==null&&typeof m=="object"&&typeof m.then=="function"){var g=m,M=_,v=M.tag;if(!(M.mode&1)&&(v===0||v===11||v===15)){var C=M.alternate;C?(M.updateQueue=C.updateQueue,M.memoizedState=C.memoizedState,M.lanes=C.lanes):(M.updateQueue=null,M.memoizedState=null)}var k=fv(f);if(k!==null){k.flags&=-257,pv(k,f,_,l,t),k.mode&1&&dv(l,g,t),t=k,m=g;var z=t.updateQueue;if(z===null){var $=new Set;$.add(m),t.updateQueue=$}else z.add(m);break e}else{if(!(t&1)){dv(l,g,t),F0();break e}m=Error(St(426))}}else if(ln&&_.mode&1){var S=fv(f);if(S!==null){!(S.flags&65536)&&(S.flags|=256),pv(S,f,_,l,t),p0(gu(m,_));break e}}l=m=gu(m,_),$n!==4&&($n=2),Hf===null?Hf=[l]:Hf.push(l),l=f;do{switch(l.tag){case 3:l.flags|=65536,t&=-t,l.lanes|=t;var y=Cb(l,m,t);ov(l,y);break e;case 1:_=m;var x=l.type,I=l.stateNode;if(!(l.flags&128)&&(typeof x.getDerivedStateFromError=="function"||I!==null&&typeof I.componentDidCatch=="function"&&(xs===null||!xs.has(I)))){l.flags|=65536,t&=-t,l.lanes|=t;var V=Pb(l,_,t);ov(l,V);break e}}l=l.return}while(l!==null)}Kb(n)}catch(O){t=O,Mn===n&&n!==null&&(Mn=n=n.return);continue}break}while(!0)}function Hb(){var e=lm.current;return lm.current=am,e===null?am:e}function F0(){($n===0||$n===3||$n===2)&&($n=4),Ln===null||!(pa&268435455)&&!(Sm&268435455)||hs(Ln,Gn)}function dm(e,t){var n=Rr;Rr|=2;var o=Hb();(Ln!==e||Gn!==t)&&(Ao=null,la(e,t));do try{_S();break}catch(a){Gb(e,a)}while(!0);if(m0(),Rr=n,lm.current=o,Mn!==null)throw Error(St(261));return Ln=null,Gn=0,$n}function _S(){for(;Mn!==null;)qb(Mn)}function yS(){for(;Mn!==null&&!Vk();)qb(Mn)}function qb(e){var t=Xb(e.alternate,e,Ti);e.memoizedProps=e.pendingProps,t===null?Kb(e):Mn=t,C0.current=null}function Kb(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=dS(n,t),n!==null){n.flags&=32767,Mn=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{$n=6,Mn=null;return}}else if(n=cS(n,t,Ti),n!==null){Mn=n;return}if(t=t.sibling,t!==null){Mn=t;return}Mn=t=e}while(t!==null);$n===0&&($n=5)}function na(e,t,n){var o=qr,a=ji.transition;try{ji.transition=null,qr=1,wS(e,t,n,o)}finally{ji.transition=a,qr=o}return null}function wS(e,t,n,o){do cu();while(gs!==null);if(Rr&6)throw Error(St(327));n=e.finishedWork;var a=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(St(177));e.callbackNode=null,e.callbackPriority=0;var l=n.lanes|n.childLanes;if(Jk(e,l),e===Ln&&(Mn=Ln=null,Gn=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||Sh||(Sh=!0,Yb(Hh,function(){return cu(),null})),l=(n.flags&15990)!==0,n.subtreeFlags&15990||l){l=ji.transition,ji.transition=null;var f=qr;qr=1;var _=Rr;Rr|=4,C0.current=null,pS(e,n),Ub(n,e),RT(m_),Kh=!!h_,m_=h_=null,e.current=n,hS(n),Wk(),Rr=_,qr=f,ji.transition=l}else e.current=n;if(Sh&&(Sh=!1,gs=e,cm=a),l=e.pendingLanes,l===0&&(xs=null),qk(n.stateNode),_i(e,wn()),t!==null)for(o=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],o(a.value,{componentStack:a.stack,digest:a.digest});if(um)throw um=!1,e=O_,O_=null,e;return cm&1&&e.tag!==0&&cu(),l=e.pendingLanes,l&1?e===D_?qf++:(qf=0,D_=e):qf=0,Ps(),null}function cu(){if(gs!==null){var e=C2(cm),t=ji.transition,n=qr;try{if(ji.transition=null,qr=16>e?16:e,gs===null)var o=!1;else{if(e=gs,gs=null,cm=0,Rr&6)throw Error(St(331));var a=Rr;for(Rr|=4,Wt=e.current;Wt!==null;){var l=Wt,f=l.child;if(Wt.flags&16){var _=l.deletions;if(_!==null){for(var m=0;m<_.length;m++){var g=_[m];for(Wt=g;Wt!==null;){var M=Wt;switch(M.tag){case 0:case 11:case 15:Gf(8,M,l)}var v=M.child;if(v!==null)v.return=M,Wt=v;else for(;Wt!==null;){M=Wt;var C=M.sibling,k=M.return;if(Rb(M),M===g){Wt=null;break}if(C!==null){C.return=k,Wt=C;break}Wt=k}}}var z=l.alternate;if(z!==null){var $=z.child;if($!==null){z.child=null;do{var S=$.sibling;$.sibling=null,$=S}while($!==null)}}Wt=l}}if(l.subtreeFlags&2064&&f!==null)f.return=l,Wt=f;else e:for(;Wt!==null;){if(l=Wt,l.flags&2048)switch(l.tag){case 0:case 11:case 15:Gf(9,l,l.return)}var y=l.sibling;if(y!==null){y.return=l.return,Wt=y;break e}Wt=l.return}}var x=e.current;for(Wt=x;Wt!==null;){f=Wt;var I=f.child;if(f.subtreeFlags&2064&&I!==null)I.return=f,Wt=I;else e:for(f=x;Wt!==null;){if(_=Wt,_.flags&2048)try{switch(_.tag){case 0:case 11:case 15:Tm(9,_)}}catch(O){_n(_,_.return,O)}if(_===f){Wt=null;break e}var V=_.sibling;if(V!==null){V.return=_.return,Wt=V;break e}Wt=_.return}}if(Rr=a,Ps(),mo&&typeof mo.onPostCommitFiberRoot=="function")try{mo.onPostCommitFiberRoot(_m,e)}catch{}o=!0}return o}finally{qr=n,ji.transition=t}}return!1}function Sv(e,t,n){t=gu(n,t),t=Cb(e,t,1),e=bs(e,t,1),t=si(),e!==null&&(pp(e,1,t),_i(e,t))}function _n(e,t,n){if(e.tag===3)Sv(e,e,n);else for(;t!==null;){if(t.tag===3){Sv(t,e,n);break}else if(t.tag===1){var o=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof o.componentDidCatch=="function"&&(xs===null||!xs.has(o))){e=gu(n,e),e=Pb(t,e,1),t=bs(t,e,1),e=si(),t!==null&&(pp(t,1,e),_i(t,e));break}}t=t.return}}function vS(e,t,n){var o=e.pingCache;o!==null&&o.delete(t),t=si(),e.pingedLanes|=e.suspendedLanes&n,Ln===e&&(Gn&n)===n&&($n===4||$n===3&&(Gn&130023424)===Gn&&500>wn()-$0?la(e,0):P0|=n),_i(e,t)}function Qb(e,t){t===0&&(e.mode&1?(t=gh,gh<<=1,!(gh&130023424)&&(gh=4194304)):t=1);var n=si();e=Ro(e,t),e!==null&&(pp(e,t,n),_i(e,n))}function bS(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),Qb(e,n)}function xS(e,t){var n=0;switch(e.tag){case 13:var o=e.stateNode,a=e.memoizedState;a!==null&&(n=a.retryLane);break;case 19:o=e.stateNode;break;default:throw Error(St(314))}o!==null&&o.delete(t),Qb(e,n)}var Xb;Xb=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||mi.current)hi=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return hi=!1,uS(e,t,n);hi=!!(e.flags&131072)}else hi=!1,ln&&t.flags&1048576&&eb(t,tm,t.index);switch(t.lanes=0,t.tag){case 2:var o=t.type;Bh(e,t),e=t.pendingProps;var a=fu(t,Jn.current);uu(t,n),a=M0(null,t,o,e,a,n);var l=k0();return t.flags|=1,typeof a=="object"&&a!==null&&typeof a.render=="function"&&a.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,gi(o)?(l=!0,Jh(t)):l=!1,t.memoizedState=a.state!==null&&a.state!==void 0?a.state:null,y0(t),a.updater=km,t.stateNode=a,a._reactInternals=t,k_(t,o,e,n),t=E_(null,t,o,!0,l,n)):(t.tag=0,ln&&l&&d0(t),oi(null,t,a,n),t=t.child),t;case 16:o=t.elementType;e:{switch(Bh(e,t),e=t.pendingProps,a=o._init,o=a(o._payload),t.type=o,a=t.tag=kS(o),e=Xi(o,e),a){case 0:t=S_(null,t,o,e,n);break e;case 1:t=gv(null,t,o,e,n);break e;case 11:t=hv(null,t,o,e,n);break e;case 14:t=mv(null,t,o,Xi(o.type,e),n);break e}throw Error(St(306,o,""))}return t;case 0:return o=t.type,a=t.pendingProps,a=t.elementType===o?a:Xi(o,a),S_(e,t,o,a,n);case 1:return o=t.type,a=t.pendingProps,a=t.elementType===o?a:Xi(o,a),gv(e,t,o,a,n);case 3:e:{if(Fb(t),e===null)throw Error(St(387));o=t.pendingProps,l=t.memoizedState,a=l.element,sb(e,t),im(t,o,null,n);var f=t.memoizedState;if(o=f.element,l.isDehydrated)if(l={element:o,isDehydrated:!1,cache:f.cache,pendingSuspenseBoundaries:f.pendingSuspenseBoundaries,transitions:f.transitions},t.updateQueue.baseState=l,t.memoizedState=l,t.flags&256){a=gu(Error(St(423)),t),t=_v(e,t,o,n,a);break e}else if(o!==a){a=gu(Error(St(424)),t),t=_v(e,t,o,n,a);break e}else for(Si=vs(t.stateNode.containerInfo.firstChild),Ei=t,ln=!0,Zi=null,n=ib(t,null,o,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(pu(),o===a){t=No(e,t,n);break e}oi(e,t,o,n)}t=t.child}return t;case 5:return ab(t),e===null&&b_(t),o=t.type,a=t.pendingProps,l=e!==null?e.memoizedProps:null,f=a.children,g_(o,a)?f=null:l!==null&&g_(o,l)&&(t.flags|=32),Ib(e,t),oi(e,t,f,n),t.child;case 6:return e===null&&b_(t),null;case 13:return zb(e,t,n);case 4:return w0(t,t.stateNode.containerInfo),o=t.pendingProps,e===null?t.child=hu(t,null,o,n):oi(e,t,o,n),t.child;case 11:return o=t.type,a=t.pendingProps,a=t.elementType===o?a:Xi(o,a),hv(e,t,o,a,n);case 7:return oi(e,t,t.pendingProps,n),t.child;case 8:return oi(e,t,t.pendingProps.children,n),t.child;case 12:return oi(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(o=t.type._context,a=t.pendingProps,l=t.memoizedProps,f=a.value,tn(rm,o._currentValue),o._currentValue=f,l!==null)if(to(l.value,f)){if(l.children===a.children&&!mi.current){t=No(e,t,n);break e}}else for(l=t.child,l!==null&&(l.return=t);l!==null;){var _=l.dependencies;if(_!==null){f=l.child;for(var m=_.firstContext;m!==null;){if(m.context===o){if(l.tag===1){m=Do(-1,n&-n),m.tag=2;var g=l.updateQueue;if(g!==null){g=g.shared;var M=g.pending;M===null?m.next=m:(m.next=M.next,M.next=m),g.pending=m}}l.lanes|=n,m=l.alternate,m!==null&&(m.lanes|=n),x_(l.return,n,t),_.lanes|=n;break}m=m.next}}else if(l.tag===10)f=l.type===t.type?null:l.child;else if(l.tag===18){if(f=l.return,f===null)throw Error(St(341));f.lanes|=n,_=f.alternate,_!==null&&(_.lanes|=n),x_(f,n,t),f=l.sibling}else f=l.child;if(f!==null)f.return=l;else for(f=l;f!==null;){if(f===t){f=null;break}if(l=f.sibling,l!==null){l.return=f.return,f=l;break}f=f.return}l=f}oi(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,o=t.pendingProps.children,uu(t,n),a=Ui(a),o=o(a),t.flags|=1,oi(e,t,o,n),t.child;case 14:return o=t.type,a=Xi(o,t.pendingProps),a=Xi(o.type,a),mv(e,t,o,a,n);case 15:return $b(e,t,t.type,t.pendingProps,n);case 17:return o=t.type,a=t.pendingProps,a=t.elementType===o?a:Xi(o,a),Bh(e,t),t.tag=1,gi(o)?(e=!0,Jh(t)):e=!1,uu(t,n),Eb(t,o,a),k_(t,o,a,n),E_(null,t,o,!0,e,n);case 19:return Ob(e,t,n);case 22:return Ab(e,t,n)}throw Error(St(156,t.tag))};function Yb(e,t){return k2(e,t)}function MS(e,t,n,o){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=o,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ni(e,t,n,o){return new MS(e,t,n,o)}function z0(e){return e=e.prototype,!(!e||!e.isReactComponent)}function kS(e){if(typeof e=="function")return z0(e)?1:0;if(e!=null){if(e=e.$$typeof,e===J_)return 11;if(e===e0)return 14}return 2}function ks(e,t){var n=e.alternate;return n===null?(n=Ni(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function jh(e,t,n,o,a,l){var f=2;if(o=e,typeof e=="function")z0(e)&&(f=1);else if(typeof e=="string")f=5;else e:switch(e){case Kl:return ua(n.children,a,l,t);case Z_:f=8,a|=8;break;case Kg:return e=Ni(12,n,t,a|2),e.elementType=Kg,e.lanes=l,e;case Qg:return e=Ni(13,n,t,a),e.elementType=Qg,e.lanes=l,e;case Xg:return e=Ni(19,n,t,a),e.elementType=Xg,e.lanes=l,e;case a2:return Em(n,a,l,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case o2:f=10;break e;case s2:f=9;break e;case J_:f=11;break e;case e0:f=14;break e;case ds:f=16,o=null;break e}throw Error(St(130,e==null?e:typeof e,""))}return t=Ni(f,n,t,a),t.elementType=e,t.type=o,t.lanes=l,t}function ua(e,t,n,o){return e=Ni(7,e,o,t),e.lanes=n,e}function Em(e,t,n,o){return e=Ni(22,e,o,t),e.elementType=a2,e.lanes=n,e.stateNode={isHidden:!1},e}function Ug(e,t,n){return e=Ni(6,e,null,t),e.lanes=n,e}function Vg(e,t,n){return t=Ni(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function TS(e,t,n,o,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Mg(0),this.expirationTimes=Mg(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Mg(0),this.identifierPrefix=o,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function O0(e,t,n,o,a,l,f,_,m){return e=new TS(e,t,n,_,m),t===1?(t=1,l===!0&&(t|=8)):t=0,l=Ni(3,null,null,t),e.current=l,l.stateNode=e,l.memoizedState={element:o,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},y0(l),e}function SS(e,t,n){var o=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:ql,key:o==null?null:""+o,children:e,containerInfo:t,implementation:n}}function Zb(e){if(!e)return Ss;e=e._reactInternals;e:{if(ga(e)!==e||e.tag!==1)throw Error(St(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(gi(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(St(171))}if(e.tag===1){var n=e.type;if(gi(n))return Z2(e,n,t)}return t}function Jb(e,t,n,o,a,l,f,_,m){return e=O0(n,o,!0,e,a,l,f,_,m),e.context=Zb(null),n=e.current,o=si(),a=Ms(n),l=Do(o,a),l.callback=t??null,bs(n,l,a),e.current.lanes=a,pp(e,a,o),_i(e,o),e}function Cm(e,t,n,o){var a=t.current,l=si(),f=Ms(a);return n=Zb(n),t.context===null?t.context=n:t.pendingContext=n,t=Do(l,f),t.payload={element:e},o=o===void 0?null:o,o!==null&&(t.callback=o),e=bs(a,t,f),e!==null&&(eo(e,a,f,l),Oh(e,a,f)),f}function fm(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function Ev(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function D0(e,t){Ev(e,t),(e=e.alternate)&&Ev(e,t)}function ES(){return null}var ex=typeof reportError=="function"?reportError:function(e){console.error(e)};function L0(e){this._internalRoot=e}Pm.prototype.render=L0.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(St(409));Cm(e,t,null,null)};Pm.prototype.unmount=L0.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;ha(function(){Cm(null,e,null,null)}),t[Bo]=null}};function Pm(e){this._internalRoot=e}Pm.prototype.unstable_scheduleHydration=function(e){if(e){var t=A2();e={blockedOn:null,target:e,priority:t};for(var n=0;n<ps.length&&t!==0&&t<ps[n].priority;n++);ps.splice(n,0,e),n===0&&F2(e)}};function B0(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function $m(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function Cv(){}function CS(e,t,n,o,a){if(a){if(typeof o=="function"){var l=o;o=function(){var g=fm(f);l.call(g)}}var f=Jb(t,o,e,0,null,!1,!1,"",Cv);return e._reactRootContainer=f,e[Bo]=f.current,rp(e.nodeType===8?e.parentNode:e),ha(),f}for(;a=e.lastChild;)e.removeChild(a);if(typeof o=="function"){var _=o;o=function(){var g=fm(m);_.call(g)}}var m=O0(e,0,!1,null,null,!1,!1,"",Cv);return e._reactRootContainer=m,e[Bo]=m.current,rp(e.nodeType===8?e.parentNode:e),ha(function(){Cm(t,m,n,o)}),m}function Am(e,t,n,o,a){var l=n._reactRootContainer;if(l){var f=l;if(typeof a=="function"){var _=a;a=function(){var m=fm(f);_.call(m)}}Cm(t,f,e,a)}else f=CS(n,t,e,a,o);return fm(f)}P2=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=Df(t.pendingLanes);n!==0&&(n0(t,n|1),_i(t,wn()),!(Rr&6)&&(_u=wn()+500,Ps()))}break;case 13:ha(function(){var o=Ro(e,1);if(o!==null){var a=si();eo(o,e,1,a)}}),D0(e,1)}};i0=function(e){if(e.tag===13){var t=Ro(e,134217728);if(t!==null){var n=si();eo(t,e,134217728,n)}D0(e,134217728)}};$2=function(e){if(e.tag===13){var t=Ms(e),n=Ro(e,t);if(n!==null){var o=si();eo(n,e,t,o)}D0(e,t)}};A2=function(){return qr};I2=function(e,t){var n=qr;try{return qr=e,t()}finally{qr=n}};s_=function(e,t,n){switch(t){case"input":if(Jg(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var o=n[t];if(o!==e&&o.form===e.form){var a=bm(o);if(!a)throw Error(St(90));u2(o),Jg(o,a)}}}break;case"textarea":d2(e,n);break;case"select":t=n.value,t!=null&&ou(e,!!n.multiple,t,!1)}};y2=A0;w2=ha;var PS={usingClientEntryPoint:!1,Events:[mp,Zl,bm,g2,_2,A0]},If={findFiberByHostInstance:oa,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},$S={bundleType:If.bundleType,version:If.version,rendererPackageName:If.rendererPackageName,rendererConfig:If.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:jo.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=x2(e),e===null?null:e.stateNode},findFiberByHostInstance:If.findFiberByHostInstance||ES,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Eh=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Eh.isDisabled&&Eh.supportsFiber)try{_m=Eh.inject($S),mo=Eh}catch{}}Pi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=PS;Pi.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!B0(t))throw Error(St(200));return SS(e,t,null,n)};Pi.createRoot=function(e,t){if(!B0(e))throw Error(St(299));var n=!1,o="",a=ex;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(o=t.identifierPrefix),t.onRecoverableError!==void 0&&(a=t.onRecoverableError)),t=O0(e,1,!1,null,null,n,!1,o,a),e[Bo]=t.current,rp(e.nodeType===8?e.parentNode:e),new L0(t)};Pi.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(St(188)):(e=Object.keys(e).join(","),Error(St(268,e)));return e=x2(t),e=e===null?null:e.stateNode,e};Pi.flushSync=function(e){return ha(e)};Pi.hydrate=function(e,t,n){if(!$m(t))throw Error(St(200));return Am(null,e,t,!0,n)};Pi.hydrateRoot=function(e,t,n){if(!B0(e))throw Error(St(405));var o=n!=null&&n.hydratedSources||null,a=!1,l="",f=ex;if(n!=null&&(n.unstable_strictMode===!0&&(a=!0),n.identifierPrefix!==void 0&&(l=n.identifierPrefix),n.onRecoverableError!==void 0&&(f=n.onRecoverableError)),t=Jb(t,null,e,1,n??null,a,!1,l,f),e[Bo]=t.current,rp(e),o)for(e=0;e<o.length;e++)n=o[e],a=n._getVersion,a=a(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new Pm(t)};Pi.render=function(e,t,n){if(!$m(t))throw Error(St(200));return Am(null,e,t,!1,n)};Pi.unmountComponentAtNode=function(e){if(!$m(e))throw Error(St(40));return e._reactRootContainer?(ha(function(){Am(null,null,e,!1,function(){e._reactRootContainer=null,e[Bo]=null})}),!0):!1};Pi.unstable_batchedUpdates=A0;Pi.unstable_renderSubtreeIntoContainer=function(e,t,n,o){if(!$m(n))throw Error(St(200));if(e==null||e._reactInternals===void 0)throw Error(St(38));return Am(e,t,n,!1,o)};Pi.version="18.3.1-next-f1338f8080-20240426";function tx(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(tx)}catch(e){console.error(e)}}tx(),t2.exports=Pi;var AS=t2.exports,rx,Pv=AS;rx=Pv.createRoot,Pv.hydrateRoot;var nx={exports:{}},IS="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",FS=IS,zS=FS;function ix(){}function ox(){}ox.resetWarningCache=ix;var OS=function(){function e(o,a,l,f,_,m){if(m!==zS){var g=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw g.name="Invariant Violation",g}}e.isRequired=e;function t(){return e}var n={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:ox,resetWarningCache:ix};return n.PropTypes=n,n};nx.exports=OS();var DS=nx.exports;const Xr=W_(DS);function bu(e,t,n,o){function a(l){return l instanceof n?l:new n(function(f){f(l)})}return new(n||(n=Promise))(function(l,f){function _(M){try{g(o.next(M))}catch(v){f(v)}}function m(M){try{g(o.throw(M))}catch(v){f(v)}}function g(M){M.done?l(M.value):a(M.value).then(_,m)}g((o=o.apply(e,t||[])).next())})}function xu(e,t){var n={label:0,sent:function(){if(l[0]&1)throw l[1];return l[1]},trys:[],ops:[]},o,a,l,f=Object.create((typeof Iterator=="function"?Iterator:Object).prototype);return f.next=_(0),f.throw=_(1),f.return=_(2),typeof Symbol=="function"&&(f[Symbol.iterator]=function(){return this}),f;function _(g){return function(M){return m([g,M])}}function m(g){if(o)throw new TypeError("Generator is already executing.");for(;f&&(f=0,g[0]&&(n=0)),n;)try{if(o=1,a&&(l=g[0]&2?a.return:g[0]?a.throw||((l=a.return)&&l.call(a),0):a.next)&&!(l=l.call(a,g[1])).done)return l;switch(a=0,l&&(g=[g[0]&2,l.value]),g[0]){case 0:case 1:l=g;break;case 4:return n.label++,{value:g[1],done:!1};case 5:n.label++,a=g[1],g=[0];continue;case 7:g=n.ops.pop(),n.trys.pop();continue;default:if(l=n.trys,!(l=l.length>0&&l[l.length-1])&&(g[0]===6||g[0]===2)){n=0;continue}if(g[0]===3&&(!l||g[1]>l[0]&&g[1]<l[3])){n.label=g[1];break}if(g[0]===6&&n.label<l[1]){n.label=l[1],l=g;break}if(l&&n.label<l[2]){n.label=l[2],n.ops.push(g);break}l[2]&&n.ops.pop(),n.trys.pop();continue}g=t.call(e,n)}catch(M){g=[6,M],a=0}finally{o=l=0}if(g[0]&5)throw g[1];return{value:g[0]?g[1]:void 0,done:!0}}}function $v(e,t){var n=typeof Symbol=="function"&&e[Symbol.iterator];if(!n)return e;var o=n.call(e),a,l=[],f;try{for(;(t===void 0||t-- >0)&&!(a=o.next()).done;)l.push(a.value)}catch(_){f={error:_}}finally{try{a&&!a.done&&(n=o.return)&&n.call(o)}finally{if(f)throw f.error}}return l}function Av(e,t,n){if(n||arguments.length===2)for(var o=0,a=t.length,l;o<a;o++)(l||!(o in t))&&(l||(l=Array.prototype.slice.call(t,0,o)),l[o]=t[o]);return e.concat(l||Array.prototype.slice.call(t))}var LS=new Map([["aac","audio/aac"],["abw","application/x-abiword"],["arc","application/x-freearc"],["avif","image/avif"],["avi","video/x-msvideo"],["azw","application/vnd.amazon.ebook"],["bin","application/octet-stream"],["bmp","image/bmp"],["bz","application/x-bzip"],["bz2","application/x-bzip2"],["cda","application/x-cdf"],["csh","application/x-csh"],["css","text/css"],["csv","text/csv"],["doc","application/msword"],["docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"],["eot","application/vnd.ms-fontobject"],["epub","application/epub+zip"],["gz","application/gzip"],["gif","image/gif"],["heic","image/heic"],["heif","image/heif"],["htm","text/html"],["html","text/html"],["ico","image/vnd.microsoft.icon"],["ics","text/calendar"],["jar","application/java-archive"],["jpeg","image/jpeg"],["jpg","image/jpeg"],["js","text/javascript"],["json","application/json"],["jsonld","application/ld+json"],["mid","audio/midi"],["midi","audio/midi"],["mjs","text/javascript"],["mp3","audio/mpeg"],["mp4","video/mp4"],["mpeg","video/mpeg"],["mpkg","application/vnd.apple.installer+xml"],["odp","application/vnd.oasis.opendocument.presentation"],["ods","application/vnd.oasis.opendocument.spreadsheet"],["odt","application/vnd.oasis.opendocument.text"],["oga","audio/ogg"],["ogv","video/ogg"],["ogx","application/ogg"],["opus","audio/opus"],["otf","font/otf"],["png","image/png"],["pdf","application/pdf"],["php","application/x-httpd-php"],["ppt","application/vnd.ms-powerpoint"],["pptx","application/vnd.openxmlformats-officedocument.presentationml.presentation"],["rar","application/vnd.rar"],["rtf","application/rtf"],["sh","application/x-sh"],["svg","image/svg+xml"],["swf","application/x-shockwave-flash"],["tar","application/x-tar"],["tif","image/tiff"],["tiff","image/tiff"],["ts","video/mp2t"],["ttf","font/ttf"],["txt","text/plain"],["vsd","application/vnd.visio"],["wav","audio/wav"],["weba","audio/webm"],["webm","video/webm"],["webp","image/webp"],["woff","font/woff"],["woff2","font/woff2"],["xhtml","application/xhtml+xml"],["xls","application/vnd.ms-excel"],["xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],["xml","application/xml"],["xul","application/vnd.mozilla.xul+xml"],["zip","application/zip"],["7z","application/x-7z-compressed"],["mkv","video/x-matroska"],["mov","video/quicktime"],["msg","application/vnd.ms-outlook"]]);function _p(e,t){var n=BS(e);if(typeof n.path!="string"){var o=e.webkitRelativePath;Object.defineProperty(n,"path",{value:typeof t=="string"?t:typeof o=="string"&&o.length>0?o:e.name,writable:!1,configurable:!1,enumerable:!0})}return n}function BS(e){var t=e.name,n=t&&t.lastIndexOf(".")!==-1;if(n&&!e.type){var o=t.split(".").pop().toLowerCase(),a=LS.get(o);a&&Object.defineProperty(e,"type",{value:a,writable:!1,configurable:!1,enumerable:!0})}return e}var RS=[".DS_Store","Thumbs.db"];function NS(e){return bu(this,void 0,void 0,function(){return xu(this,function(t){return pm(e)&&jS(e.dataTransfer)?[2,GS(e.dataTransfer,e.type)]:US(e)?[2,VS(e)]:Array.isArray(e)&&e.every(function(n){return"getFile"in n&&typeof n.getFile=="function"})?[2,WS(e)]:[2,[]]})})}function jS(e){return pm(e)}function US(e){return pm(e)&&pm(e.target)}function pm(e){return typeof e=="object"&&e!==null}function VS(e){return R_(e.target.files).map(function(t){return _p(t)})}function WS(e){return bu(this,void 0,void 0,function(){var t;return xu(this,function(n){switch(n.label){case 0:return[4,Promise.all(e.map(function(o){return o.getFile()}))];case 1:return t=n.sent(),[2,t.map(function(o){return _p(o)})]}})})}function GS(e,t){return bu(this,void 0,void 0,function(){var n,o;return xu(this,function(a){switch(a.label){case 0:return e.items?(n=R_(e.items).filter(function(l){return l.kind==="file"}),t!=="drop"?[2,n]:[4,Promise.all(n.map(HS))]):[3,2];case 1:return o=a.sent(),[2,Iv(sx(o))];case 2:return[2,Iv(R_(e.files).map(function(l){return _p(l)}))]}})})}function Iv(e){return e.filter(function(t){return RS.indexOf(t.name)===-1})}function R_(e){if(e===null)return[];for(var t=[],n=0;n<e.length;n++){var o=e[n];t.push(o)}return t}function HS(e){if(typeof e.webkitGetAsEntry!="function")return Fv(e);var t=e.webkitGetAsEntry();return t&&t.isDirectory?ax(t):Fv(e)}function sx(e){return e.reduce(function(t,n){return Av(Av([],$v(t),!1),$v(Array.isArray(n)?sx(n):[n]),!1)},[])}function Fv(e){var t=e.getAsFile();if(!t)return Promise.reject("".concat(e," is not a File"));var n=_p(t);return Promise.resolve(n)}function qS(e){return bu(this,void 0,void 0,function(){return xu(this,function(t){return[2,e.isDirectory?ax(e):KS(e)]})})}function ax(e){var t=e.createReader();return new Promise(function(n,o){var a=[];function l(){var f=this;t.readEntries(function(_){return bu(f,void 0,void 0,function(){var m,g,M;return xu(this,function(v){switch(v.label){case 0:if(_.length)return[3,5];v.label=1;case 1:return v.trys.push([1,3,,4]),[4,Promise.all(a)];case 2:return m=v.sent(),n(m),[3,4];case 3:return g=v.sent(),o(g),[3,4];case 4:return[3,6];case 5:M=Promise.all(_.map(qS)),a.push(M),l(),v.label=6;case 6:return[2]}})})},function(_){o(_)})}l()})}function KS(e){return bu(this,void 0,void 0,function(){return xu(this,function(t){return[2,new Promise(function(n,o){e.file(function(a){var l=_p(a,e.fullPath);n(l)},function(a){o(a)})})]})})}var QS=function(e,t){if(e&&t){var n=Array.isArray(t)?t:t.split(","),o=e.name||"",a=(e.type||"").toLowerCase(),l=a.replace(/\/.*$/,"");return n.some(function(f){var _=f.trim().toLowerCase();return _.charAt(0)==="."?o.toLowerCase().endsWith(_):_.endsWith("/*")?l===_.replace(/\/.*$/,""):a===_})}return!0};function zv(e){return ZS(e)||YS(e)||ux(e)||XS()}function XS(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function YS(e){if(typeof Symbol<"u"&&e[Symbol.iterator]!=null||e["@@iterator"]!=null)return Array.from(e)}function ZS(e){if(Array.isArray(e))return N_(e)}function Ov(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),n.push.apply(n,o)}return n}function Dv(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?Ov(Object(n),!0).forEach(function(o){lx(e,o,n[o])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Ov(Object(n)).forEach(function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(n,o))})}return e}function lx(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function dp(e,t){return tE(e)||eE(e,t)||ux(e,t)||JS()}function JS(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function ux(e,t){if(e){if(typeof e=="string")return N_(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return N_(e,t)}}function N_(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,o=new Array(t);n<t;n++)o[n]=e[n];return o}function eE(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var o=[],a=!0,l=!1,f,_;try{for(n=n.call(e);!(a=(f=n.next()).done)&&(o.push(f.value),!(t&&o.length===t));a=!0);}catch(m){l=!0,_=m}finally{try{!a&&n.return!=null&&n.return()}finally{if(l)throw _}}return o}}function tE(e){if(Array.isArray(e))return e}var rE="file-invalid-type",nE="file-too-large",iE="file-too-small",oE="too-many-files",sE=function(t){t=Array.isArray(t)&&t.length===1?t[0]:t;var n=Array.isArray(t)?"one of ".concat(t.join(", ")):t;return{code:rE,message:"File type must be ".concat(n)}},Lv=function(t){return{code:nE,message:"File is larger than ".concat(t," ").concat(t===1?"byte":"bytes")}},Bv=function(t){return{code:iE,message:"File is smaller than ".concat(t," ").concat(t===1?"byte":"bytes")}},aE={code:oE,message:"Too many files"};function cx(e,t){var n=e.type==="application/x-moz-file"||QS(e,t);return[n,n?null:sE(t)]}function dx(e,t,n){if(ia(e.size))if(ia(t)&&ia(n)){if(e.size>n)return[!1,Lv(n)];if(e.size<t)return[!1,Bv(t)]}else{if(ia(t)&&e.size<t)return[!1,Bv(t)];if(ia(n)&&e.size>n)return[!1,Lv(n)]}return[!0,null]}function ia(e){return e!=null}function lE(e){var t=e.files,n=e.accept,o=e.minSize,a=e.maxSize,l=e.multiple,f=e.maxFiles,_=e.validator;return!l&&t.length>1||l&&f>=1&&t.length>f?!1:t.every(function(m){var g=cx(m,n),M=dp(g,1),v=M[0],C=dx(m,o,a),k=dp(C,1),z=k[0],$=_?_(m):null;return v&&z&&!$})}function hm(e){return typeof e.isPropagationStopped=="function"?e.isPropagationStopped():typeof e.cancelBubble<"u"?e.cancelBubble:!1}function Ch(e){return e.dataTransfer?Array.prototype.some.call(e.dataTransfer.types,function(t){return t==="Files"||t==="application/x-moz-file"}):!!e.target&&!!e.target.files}function Rv(e){e.preventDefault()}function uE(e){return e.indexOf("MSIE")!==-1||e.indexOf("Trident/")!==-1}function cE(e){return e.indexOf("Edge/")!==-1}function dE(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:window.navigator.userAgent;return uE(e)||cE(e)}function fo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(o){for(var a=arguments.length,l=new Array(a>1?a-1:0),f=1;f<a;f++)l[f-1]=arguments[f];return t.some(function(_){return!hm(o)&&_&&_.apply(void 0,[o].concat(l)),hm(o)})}}function fE(){return"showOpenFilePicker"in window}function pE(e){if(ia(e)){var t=Object.entries(e).filter(function(n){var o=dp(n,2),a=o[0],l=o[1],f=!0;return fx(a)||(console.warn('Skipped "'.concat(a,'" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.')),f=!1),(!Array.isArray(l)||!l.every(px))&&(console.warn('Skipped "'.concat(a,'" because an invalid file extension was provided.')),f=!1),f}).reduce(function(n,o){var a=dp(o,2),l=a[0],f=a[1];return Dv(Dv({},n),{},lx({},l,f))},{});return[{description:"Files",accept:t}]}return e}function hE(e){if(ia(e))return Object.entries(e).reduce(function(t,n){var o=dp(n,2),a=o[0],l=o[1];return[].concat(zv(t),[a],zv(l))},[]).filter(function(t){return fx(t)||px(t)}).join(",")}function mE(e){return e instanceof DOMException&&(e.name==="AbortError"||e.code===e.ABORT_ERR)}function gE(e){return e instanceof DOMException&&(e.name==="SecurityError"||e.code===e.SECURITY_ERR)}function fx(e){return e==="audio/*"||e==="video/*"||e==="image/*"||e==="text/*"||/\w+\/[-+.\w]+/g.test(e)}function px(e){return/^.*\.[\w]+$/.test(e)}var _E=["children"],yE=["open"],wE=["refKey","role","onKeyDown","onFocus","onBlur","onClick","onDragEnter","onDragOver","onDragLeave","onDrop"],vE=["refKey","onChange","onClick"];function bE(e){return kE(e)||ME(e)||hx(e)||xE()}function xE(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function ME(e){if(typeof Symbol<"u"&&e[Symbol.iterator]!=null||e["@@iterator"]!=null)return Array.from(e)}function kE(e){if(Array.isArray(e))return j_(e)}function Wg(e,t){return EE(e)||SE(e,t)||hx(e,t)||TE()}function TE(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function hx(e,t){if(e){if(typeof e=="string")return j_(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return j_(e,t)}}function j_(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,o=new Array(t);n<t;n++)o[n]=e[n];return o}function SE(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var o=[],a=!0,l=!1,f,_;try{for(n=n.call(e);!(a=(f=n.next()).done)&&(o.push(f.value),!(t&&o.length===t));a=!0);}catch(m){l=!0,_=m}finally{try{!a&&n.return!=null&&n.return()}finally{if(l)throw _}}return o}}function EE(e){if(Array.isArray(e))return e}function Nv(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),n.push.apply(n,o)}return n}function cn(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?Nv(Object(n),!0).forEach(function(o){U_(e,o,n[o])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Nv(Object(n)).forEach(function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(n,o))})}return e}function U_(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function mm(e,t){if(e==null)return{};var n=CE(e,t),o,a;if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)o=l[a],!(t.indexOf(o)>=0)&&Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}function CE(e,t){if(e==null)return{};var n={},o=Object.keys(e),a,l;for(l=0;l<o.length;l++)a=o[l],!(t.indexOf(a)>=0)&&(n[a]=e[a]);return n}var R0=fr.forwardRef(function(e,t){var n=e.children,o=mm(e,_E),a=gx(o),l=a.open,f=mm(a,yE);return fr.useImperativeHandle(t,function(){return{open:l}},[l]),vk.createElement(fr.Fragment,null,n(cn(cn({},f),{},{open:l})))});R0.displayName="Dropzone";var mx={disabled:!1,getFilesFromEvent:NS,maxSize:1/0,minSize:0,multiple:!0,maxFiles:0,preventDropOnDocument:!0,noClick:!1,noKeyboard:!1,noDrag:!1,noDragEventsBubbling:!1,validator:null,useFsAccessApi:!0,autoFocus:!1};R0.defaultProps=mx;R0.propTypes={children:Xr.func,accept:Xr.objectOf(Xr.arrayOf(Xr.string)),multiple:Xr.bool,preventDropOnDocument:Xr.bool,noClick:Xr.bool,noKeyboard:Xr.bool,noDrag:Xr.bool,noDragEventsBubbling:Xr.bool,minSize:Xr.number,maxSize:Xr.number,maxFiles:Xr.number,disabled:Xr.bool,getFilesFromEvent:Xr.func,onFileDialogCancel:Xr.func,onFileDialogOpen:Xr.func,useFsAccessApi:Xr.bool,autoFocus:Xr.bool,onDragEnter:Xr.func,onDragLeave:Xr.func,onDragOver:Xr.func,onDrop:Xr.func,onDropAccepted:Xr.func,onDropRejected:Xr.func,onError:Xr.func,validator:Xr.func};var V_={isFocused:!1,isFileDialogActive:!1,isDragActive:!1,isDragAccept:!1,isDragReject:!1,acceptedFiles:[],fileRejections:[]};function gx(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},t=cn(cn({},mx),e),n=t.accept,o=t.disabled,a=t.getFilesFromEvent,l=t.maxSize,f=t.minSize,_=t.multiple,m=t.maxFiles,g=t.onDragEnter,M=t.onDragLeave,v=t.onDragOver,C=t.onDrop,k=t.onDropAccepted,z=t.onDropRejected,$=t.onFileDialogCancel,S=t.onFileDialogOpen,y=t.useFsAccessApi,x=t.autoFocus,I=t.preventDropOnDocument,V=t.noClick,O=t.noKeyboard,B=t.noDrag,j=t.noDragEventsBubbling,N=t.onError,oe=t.validator,he=fr.useMemo(function(){return hE(n)},[n]),Ie=fr.useMemo(function(){return pE(n)},[n]),te=fr.useMemo(function(){return typeof S=="function"?S:jv},[S]),we=fr.useMemo(function(){return typeof $=="function"?$:jv},[$]),L=fr.useRef(null),Ce=fr.useRef(null),Xe=fr.useReducer(PE,V_),ye=Wg(Xe,2),Y=ye[0],se=ye[1],Me=Y.isFocused,X=Y.isFileDialogActive,ge=fr.useRef(typeof window<"u"&&window.isSecureContext&&y&&fE()),qe=function(){!ge.current&&X&&setTimeout(function(){if(Ce.current){var ke=Ce.current.files;ke.length||(se({type:"closeDialog"}),we())}},300)};fr.useEffect(function(){return window.addEventListener("focus",qe,!1),function(){window.removeEventListener("focus",qe,!1)}},[Ce,X,we,ge]);var Be=fr.useRef([]),Ne=function(ke){L.current&&L.current.contains(ke.target)||(ke.preventDefault(),Be.current=[])};fr.useEffect(function(){return I&&(document.addEventListener("dragover",Rv,!1),document.addEventListener("drop",Ne,!1)),function(){I&&(document.removeEventListener("dragover",Rv),document.removeEventListener("drop",Ne))}},[L,I]),fr.useEffect(function(){return!o&&x&&L.current&&L.current.focus(),function(){}},[L,x,o]);var We=fr.useCallback(function(ue){N?N(ue):console.error(ue)},[N]),st=fr.useCallback(function(ue){ue.preventDefault(),ue.persist(),R(ue),Be.current=[].concat(bE(Be.current),[ue.target]),Ch(ue)&&Promise.resolve(a(ue)).then(function(ke){if(!(hm(ue)&&!j)){var Re=ke.length,ht=Re>0&&lE({files:ke,accept:he,minSize:f,maxSize:l,multiple:_,maxFiles:m,validator:oe}),tt=Re>0&&!ht;se({isDragAccept:ht,isDragReject:tt,isDragActive:!0,type:"setDraggedFiles"}),g&&g(ue)}}).catch(function(ke){return We(ke)})},[a,g,We,j,he,f,l,_,m,oe]),pt=fr.useCallback(function(ue){ue.preventDefault(),ue.persist(),R(ue);var ke=Ch(ue);if(ke&&ue.dataTransfer)try{ue.dataTransfer.dropEffect="copy"}catch{}return ke&&v&&v(ue),!1},[v,j]),Ge=fr.useCallback(function(ue){ue.preventDefault(),ue.persist(),R(ue);var ke=Be.current.filter(function(ht){return L.current&&L.current.contains(ht)}),Re=ke.indexOf(ue.target);Re!==-1&&ke.splice(Re,1),Be.current=ke,!(ke.length>0)&&(se({type:"setDraggedFiles",isDragActive:!1,isDragAccept:!1,isDragReject:!1}),Ch(ue)&&M&&M(ue))},[L,M,j]),xe=fr.useCallback(function(ue,ke){var Re=[],ht=[];ue.forEach(function(tt){var wt=cx(tt,he),bt=Wg(wt,2),Ke=bt[0],de=bt[1],Ae=dx(tt,f,l),Ve=Wg(Ae,2),ot=Ve[0],Qe=Ve[1],ft=oe?oe(tt):null;if(Ke&&ot&&!ft)Re.push(tt);else{var xt=[de,Qe];ft&&(xt=xt.concat(ft)),ht.push({file:tt,errors:xt.filter(function(vt){return vt})})}}),(!_&&Re.length>1||_&&m>=1&&Re.length>m)&&(Re.forEach(function(tt){ht.push({file:tt,errors:[aE]})}),Re.splice(0)),se({acceptedFiles:Re,fileRejections:ht,type:"setFiles"}),C&&C(Re,ht,ke),ht.length>0&&z&&z(ht,ke),Re.length>0&&k&&k(Re,ke)},[se,_,he,f,l,m,C,k,z,oe]),je=fr.useCallback(function(ue){ue.preventDefault(),ue.persist(),R(ue),Be.current=[],Ch(ue)&&Promise.resolve(a(ue)).then(function(ke){hm(ue)&&!j||xe(ke,ue)}).catch(function(ke){return We(ke)}),se({type:"reset"})},[a,xe,We,j]),Ye=fr.useCallback(function(){if(ge.current){se({type:"openDialog"}),te();var ue={multiple:_,types:Ie};window.showOpenFilePicker(ue).then(function(ke){return a(ke)}).then(function(ke){xe(ke,null),se({type:"closeDialog"})}).catch(function(ke){mE(ke)?(we(ke),se({type:"closeDialog"})):gE(ke)?(ge.current=!1,Ce.current?(Ce.current.value=null,Ce.current.click()):We(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."))):We(ke)});return}Ce.current&&(se({type:"openDialog"}),te(),Ce.current.value=null,Ce.current.click())},[se,te,we,y,xe,We,Ie,_]),et=fr.useCallback(function(ue){!L.current||!L.current.isEqualNode(ue.target)||(ue.key===" "||ue.key==="Enter"||ue.keyCode===32||ue.keyCode===13)&&(ue.preventDefault(),Ye())},[L,Ye]),A=fr.useCallback(function(){se({type:"focus"})},[]),$e=fr.useCallback(function(){se({type:"blur"})},[]),Pe=fr.useCallback(function(){V||(dE()?setTimeout(Ye,0):Ye())},[V,Ye]),ae=function(ke){return o?null:ke},ne=function(ke){return O?null:ae(ke)},ve=function(ke){return B?null:ae(ke)},R=function(ke){j&&ke.stopPropagation()},ee=fr.useMemo(function(){return function(){var ue=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},ke=ue.refKey,Re=ke===void 0?"ref":ke,ht=ue.role,tt=ue.onKeyDown,wt=ue.onFocus,bt=ue.onBlur,Ke=ue.onClick,de=ue.onDragEnter,Ae=ue.onDragOver,Ve=ue.onDragLeave,ot=ue.onDrop,Qe=mm(ue,wE);return cn(cn(U_({onKeyDown:ne(fo(tt,et)),onFocus:ne(fo(wt,A)),onBlur:ne(fo(bt,$e)),onClick:ae(fo(Ke,Pe)),onDragEnter:ve(fo(de,st)),onDragOver:ve(fo(Ae,pt)),onDragLeave:ve(fo(Ve,Ge)),onDrop:ve(fo(ot,je)),role:typeof ht=="string"&&ht!==""?ht:"presentation"},Re,L),!o&&!O?{tabIndex:0}:{}),Qe)}},[L,et,A,$e,Pe,st,pt,Ge,je,O,B,o]),D=fr.useCallback(function(ue){ue.stopPropagation()},[]),ce=fr.useMemo(function(){return function(){var ue=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},ke=ue.refKey,Re=ke===void 0?"ref":ke,ht=ue.onChange,tt=ue.onClick,wt=mm(ue,vE),bt=U_({accept:he,multiple:_,type:"file",style:{display:"none"},onChange:ae(fo(ht,je)),onClick:ae(fo(tt,D)),tabIndex:-1},Re,Ce);return cn(cn({},bt),wt)}},[Ce,n,_,je,o]);return cn(cn({},Y),{},{isFocused:Me&&!o,getRootProps:ee,getInputProps:ce,rootRef:L,inputRef:Ce,open:ae(Ye)})}function PE(e,t){switch(t.type){case"focus":return cn(cn({},e),{},{isFocused:!0});case"blur":return cn(cn({},e),{},{isFocused:!1});case"openDialog":return cn(cn({},V_),{},{isFileDialogActive:!0});case"closeDialog":return cn(cn({},e),{},{isFileDialogActive:!1});case"setDraggedFiles":return cn(cn({},e),{},{isDragActive:t.isDragActive,isDragAccept:t.isDragAccept,isDragReject:t.isDragReject});case"setFiles":return cn(cn({},e),{},{acceptedFiles:t.acceptedFiles,fileRejections:t.fileRejections});case"reset":return cn({},V_);default:return e}}function jv(){}const $E="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M4.02693%2018.329C4.18385%2019.277%205.0075%2020%206%2020H18C19.1046%2020%2020%2019.1046%2020%2018V14.1901M4.02693%2018.329C4.00922%2018.222%204%2018.1121%204%2018V6C4%204.89543%204.89543%204%206%204H18C19.1046%204%2020%204.89543%2020%206V14.1901M4.02693%2018.329L7.84762%2014.5083C8.52765%2013.9133%209.52219%2013.8482%2010.274%2014.3494L10.7832%2014.6888C11.5078%2015.1719%2012.4619%2015.1305%2013.142%2014.5865L15.7901%2012.4679C16.4651%2011.9279%2017.4053%2011.8856%2018.1228%2012.3484C18.2023%2012.3997%2018.2731%2012.4632%2018.34%2012.5302L20%2014.1901M11%209C11%2010.1046%2010.1046%2011%209%2011C7.89543%2011%207%2010.1046%207%209C7%207.89543%207.89543%207%209%207C10.1046%207%2011%207.89543%2011%209Z'%20stroke='%230fff9a'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";function AE({isDragActive:e,isDragAccept:t,isDragReject:n,getRootProps:o,getInputProps:a}){return Ut.jsxs("div",{...o(),className:`drag-zone p-8 mb-8 border-2 border-dashed rounded-lg text-center cursor-pointer transition-colors duration-300 ease-in-out
    ${t?"border-green-500 bg-green-900/20":""}
    ${n?"border-red-500 bg-red-900/20":""}
    ${e?"border-blue-500 bg-blue-900/20":"border-[#0fff9a] hover:bg-blue-900/10"}
  `,children:[Ut.jsx("input",{...a(),className:"hidden"}),Ut.jsx("img",{src:$E}),Ut.jsx("p",{className:"text-lg mb-2",children:e?"Sueltalas...":"Puedes soltar imagenes aqu"}),Ut.jsx("p",{className:"text-sm text-gray-400",children:"o haz click aqu para seleccionarlas"})]})}function Ph(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var _x={exports:{}};/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/(function(e,t){(function(n){e.exports=n()})(function(){return function n(o,a,l){function f(g,M){if(!a[g]){if(!o[g]){var v=typeof Ph=="function"&&Ph;if(!M&&v)return v(g,!0);if(_)return _(g,!0);var C=new Error("Cannot find module '"+g+"'");throw C.code="MODULE_NOT_FOUND",C}var k=a[g]={exports:{}};o[g][0].call(k.exports,function(z){var $=o[g][1][z];return f($||z)},k,k.exports,n,o,a,l)}return a[g].exports}for(var _=typeof Ph=="function"&&Ph,m=0;m<l.length;m++)f(l[m]);return f}({1:[function(n,o,a){var l=n("./utils"),f=n("./support"),_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";a.encode=function(m){for(var g,M,v,C,k,z,$,S=[],y=0,x=m.length,I=x,V=l.getTypeOf(m)!=="string";y<m.length;)I=x-y,v=V?(g=m[y++],M=y<x?m[y++]:0,y<x?m[y++]:0):(g=m.charCodeAt(y++),M=y<x?m.charCodeAt(y++):0,y<x?m.charCodeAt(y++):0),C=g>>2,k=(3&g)<<4|M>>4,z=1<I?(15&M)<<2|v>>6:64,$=2<I?63&v:64,S.push(_.charAt(C)+_.charAt(k)+_.charAt(z)+_.charAt($));return S.join("")},a.decode=function(m){var g,M,v,C,k,z,$=0,S=0,y="data:";if(m.substr(0,y.length)===y)throw new Error("Invalid base64 input, it looks like a data url.");var x,I=3*(m=m.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if(m.charAt(m.length-1)===_.charAt(64)&&I--,m.charAt(m.length-2)===_.charAt(64)&&I--,I%1!=0)throw new Error("Invalid base64 input, bad content length.");for(x=f.uint8array?new Uint8Array(0|I):new Array(0|I);$<m.length;)g=_.indexOf(m.charAt($++))<<2|(C=_.indexOf(m.charAt($++)))>>4,M=(15&C)<<4|(k=_.indexOf(m.charAt($++)))>>2,v=(3&k)<<6|(z=_.indexOf(m.charAt($++))),x[S++]=g,k!==64&&(x[S++]=M),z!==64&&(x[S++]=v);return x}},{"./support":30,"./utils":32}],2:[function(n,o,a){var l=n("./external"),f=n("./stream/DataWorker"),_=n("./stream/Crc32Probe"),m=n("./stream/DataLengthProbe");function g(M,v,C,k,z){this.compressedSize=M,this.uncompressedSize=v,this.crc32=C,this.compression=k,this.compressedContent=z}g.prototype={getContentWorker:function(){var M=new f(l.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new m("data_length")),v=this;return M.on("end",function(){if(this.streamInfo.data_length!==v.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),M},getCompressedWorker:function(){return new f(l.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},g.createWorkerFrom=function(M,v,C){return M.pipe(new _).pipe(new m("uncompressedSize")).pipe(v.compressWorker(C)).pipe(new m("compressedSize")).withStreamInfo("compression",v)},o.exports=g},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(n,o,a){var l=n("./stream/GenericWorker");a.STORE={magic:"\0\0",compressWorker:function(){return new l("STORE compression")},uncompressWorker:function(){return new l("STORE decompression")}},a.DEFLATE=n("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(n,o,a){var l=n("./utils"),f=function(){for(var _,m=[],g=0;g<256;g++){_=g;for(var M=0;M<8;M++)_=1&_?3988292384^_>>>1:_>>>1;m[g]=_}return m}();o.exports=function(_,m){return _!==void 0&&_.length?l.getTypeOf(_)!=="string"?function(g,M,v,C){var k=f,z=C+v;g^=-1;for(var $=C;$<z;$++)g=g>>>8^k[255&(g^M[$])];return-1^g}(0|m,_,_.length,0):function(g,M,v,C){var k=f,z=C+v;g^=-1;for(var $=C;$<z;$++)g=g>>>8^k[255&(g^M.charCodeAt($))];return-1^g}(0|m,_,_.length,0):0}},{"./utils":32}],5:[function(n,o,a){a.base64=!1,a.binary=!1,a.dir=!1,a.createFolders=!0,a.date=null,a.compression=null,a.compressionOptions=null,a.comment=null,a.unixPermissions=null,a.dosPermissions=null},{}],6:[function(n,o,a){var l=null;l=typeof Promise<"u"?Promise:n("lie"),o.exports={Promise:l}},{lie:37}],7:[function(n,o,a){var l=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Uint32Array<"u",f=n("pako"),_=n("./utils"),m=n("./stream/GenericWorker"),g=l?"uint8array":"array";function M(v,C){m.call(this,"FlateWorker/"+v),this._pako=null,this._pakoAction=v,this._pakoOptions=C,this.meta={}}a.magic="\b\0",_.inherits(M,m),M.prototype.processChunk=function(v){this.meta=v.meta,this._pako===null&&this._createPako(),this._pako.push(_.transformTo(g,v.data),!1)},M.prototype.flush=function(){m.prototype.flush.call(this),this._pako===null&&this._createPako(),this._pako.push([],!0)},M.prototype.cleanUp=function(){m.prototype.cleanUp.call(this),this._pako=null},M.prototype._createPako=function(){this._pako=new f[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var v=this;this._pako.onData=function(C){v.push({data:C,meta:v.meta})}},a.compressWorker=function(v){return new M("Deflate",v)},a.uncompressWorker=function(){return new M("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(n,o,a){function l(k,z){var $,S="";for($=0;$<z;$++)S+=String.fromCharCode(255&k),k>>>=8;return S}function f(k,z,$,S,y,x){var I,V,O=k.file,B=k.compression,j=x!==g.utf8encode,N=_.transformTo("string",x(O.name)),oe=_.transformTo("string",g.utf8encode(O.name)),he=O.comment,Ie=_.transformTo("string",x(he)),te=_.transformTo("string",g.utf8encode(he)),we=oe.length!==O.name.length,L=te.length!==he.length,Ce="",Xe="",ye="",Y=O.dir,se=O.date,Me={crc32:0,compressedSize:0,uncompressedSize:0};z&&!$||(Me.crc32=k.crc32,Me.compressedSize=k.compressedSize,Me.uncompressedSize=k.uncompressedSize);var X=0;z&&(X|=8),j||!we&&!L||(X|=2048);var ge=0,qe=0;Y&&(ge|=16),y==="UNIX"?(qe=798,ge|=function(Ne,We){var st=Ne;return Ne||(st=We?16893:33204),(65535&st)<<16}(O.unixPermissions,Y)):(qe=20,ge|=function(Ne){return 63&(Ne||0)}(O.dosPermissions)),I=se.getUTCHours(),I<<=6,I|=se.getUTCMinutes(),I<<=5,I|=se.getUTCSeconds()/2,V=se.getUTCFullYear()-1980,V<<=4,V|=se.getUTCMonth()+1,V<<=5,V|=se.getUTCDate(),we&&(Xe=l(1,1)+l(M(N),4)+oe,Ce+="up"+l(Xe.length,2)+Xe),L&&(ye=l(1,1)+l(M(Ie),4)+te,Ce+="uc"+l(ye.length,2)+ye);var Be="";return Be+=`
\0`,Be+=l(X,2),Be+=B.magic,Be+=l(I,2),Be+=l(V,2),Be+=l(Me.crc32,4),Be+=l(Me.compressedSize,4),Be+=l(Me.uncompressedSize,4),Be+=l(N.length,2),Be+=l(Ce.length,2),{fileRecord:v.LOCAL_FILE_HEADER+Be+N+Ce,dirRecord:v.CENTRAL_FILE_HEADER+l(qe,2)+Be+l(Ie.length,2)+"\0\0\0\0"+l(ge,4)+l(S,4)+N+Ce+Ie}}var _=n("../utils"),m=n("../stream/GenericWorker"),g=n("../utf8"),M=n("../crc32"),v=n("../signature");function C(k,z,$,S){m.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=z,this.zipPlatform=$,this.encodeFileName=S,this.streamFiles=k,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}_.inherits(C,m),C.prototype.push=function(k){var z=k.meta.percent||0,$=this.entriesCount,S=this._sources.length;this.accumulate?this.contentBuffer.push(k):(this.bytesWritten+=k.data.length,m.prototype.push.call(this,{data:k.data,meta:{currentFile:this.currentFile,percent:$?(z+100*($-S-1))/$:100}}))},C.prototype.openedSource=function(k){this.currentSourceOffset=this.bytesWritten,this.currentFile=k.file.name;var z=this.streamFiles&&!k.file.dir;if(z){var $=f(k,z,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:$.fileRecord,meta:{percent:0}})}else this.accumulate=!0},C.prototype.closedSource=function(k){this.accumulate=!1;var z=this.streamFiles&&!k.file.dir,$=f(k,z,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push($.dirRecord),z)this.push({data:function(S){return v.DATA_DESCRIPTOR+l(S.crc32,4)+l(S.compressedSize,4)+l(S.uncompressedSize,4)}(k),meta:{percent:100}});else for(this.push({data:$.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},C.prototype.flush=function(){for(var k=this.bytesWritten,z=0;z<this.dirRecords.length;z++)this.push({data:this.dirRecords[z],meta:{percent:100}});var $=this.bytesWritten-k,S=function(y,x,I,V,O){var B=_.transformTo("string",O(V));return v.CENTRAL_DIRECTORY_END+"\0\0\0\0"+l(y,2)+l(y,2)+l(x,4)+l(I,4)+l(B.length,2)+B}(this.dirRecords.length,$,k,this.zipComment,this.encodeFileName);this.push({data:S,meta:{percent:100}})},C.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},C.prototype.registerPrevious=function(k){this._sources.push(k);var z=this;return k.on("data",function($){z.processChunk($)}),k.on("end",function(){z.closedSource(z.previous.streamInfo),z._sources.length?z.prepareNextSource():z.end()}),k.on("error",function($){z.error($)}),this},C.prototype.resume=function(){return!!m.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},C.prototype.error=function(k){var z=this._sources;if(!m.prototype.error.call(this,k))return!1;for(var $=0;$<z.length;$++)try{z[$].error(k)}catch{}return!0},C.prototype.lock=function(){m.prototype.lock.call(this);for(var k=this._sources,z=0;z<k.length;z++)k[z].lock()},o.exports=C},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(n,o,a){var l=n("../compressions"),f=n("./ZipFileWorker");a.generateWorker=function(_,m,g){var M=new f(m.streamFiles,g,m.platform,m.encodeFileName),v=0;try{_.forEach(function(C,k){v++;var z=function(x,I){var V=x||I,O=l[V];if(!O)throw new Error(V+" is not a valid compression method !");return O}(k.options.compression,m.compression),$=k.options.compressionOptions||m.compressionOptions||{},S=k.dir,y=k.date;k._compressWorker(z,$).withStreamInfo("file",{name:C,dir:S,date:y,comment:k.comment||"",unixPermissions:k.unixPermissions,dosPermissions:k.dosPermissions}).pipe(M)}),M.entriesCount=v}catch(C){M.error(C)}return M}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(n,o,a){function l(){if(!(this instanceof l))return new l;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var f=new l;for(var _ in this)typeof this[_]!="function"&&(f[_]=this[_]);return f}}(l.prototype=n("./object")).loadAsync=n("./load"),l.support=n("./support"),l.defaults=n("./defaults"),l.version="3.10.1",l.loadAsync=function(f,_){return new l().loadAsync(f,_)},l.external=n("./external"),o.exports=l},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(n,o,a){var l=n("./utils"),f=n("./external"),_=n("./utf8"),m=n("./zipEntries"),g=n("./stream/Crc32Probe"),M=n("./nodejsUtils");function v(C){return new f.Promise(function(k,z){var $=C.decompressed.getContentWorker().pipe(new g);$.on("error",function(S){z(S)}).on("end",function(){$.streamInfo.crc32!==C.decompressed.crc32?z(new Error("Corrupted zip : CRC32 mismatch")):k()}).resume()})}o.exports=function(C,k){var z=this;return k=l.extend(k||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:_.utf8decode}),M.isNode&&M.isStream(C)?f.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):l.prepareContent("the loaded zip file",C,!0,k.optimizedBinaryString,k.base64).then(function($){var S=new m(k);return S.load($),S}).then(function($){var S=[f.Promise.resolve($)],y=$.files;if(k.checkCRC32)for(var x=0;x<y.length;x++)S.push(v(y[x]));return f.Promise.all(S)}).then(function($){for(var S=$.shift(),y=S.files,x=0;x<y.length;x++){var I=y[x],V=I.fileNameStr,O=l.resolve(I.fileNameStr);z.file(O,I.decompressed,{binary:!0,optimizedBinaryString:!0,date:I.date,dir:I.dir,comment:I.fileCommentStr.length?I.fileCommentStr:null,unixPermissions:I.unixPermissions,dosPermissions:I.dosPermissions,createFolders:k.createFolders}),I.dir||(z.file(O).unsafeOriginalName=V)}return S.zipComment.length&&(z.comment=S.zipComment),z})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(n,o,a){var l=n("../utils"),f=n("../stream/GenericWorker");function _(m,g){f.call(this,"Nodejs stream input adapter for "+m),this._upstreamEnded=!1,this._bindStream(g)}l.inherits(_,f),_.prototype._bindStream=function(m){var g=this;(this._stream=m).pause(),m.on("data",function(M){g.push({data:M,meta:{percent:0}})}).on("error",function(M){g.isPaused?this.generatedError=M:g.error(M)}).on("end",function(){g.isPaused?g._upstreamEnded=!0:g.end()})},_.prototype.pause=function(){return!!f.prototype.pause.call(this)&&(this._stream.pause(),!0)},_.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},o.exports=_},{"../stream/GenericWorker":28,"../utils":32}],13:[function(n,o,a){var l=n("readable-stream").Readable;function f(_,m,g){l.call(this,m),this._helper=_;var M=this;_.on("data",function(v,C){M.push(v)||M._helper.pause(),g&&g(C)}).on("error",function(v){M.emit("error",v)}).on("end",function(){M.push(null)})}n("../utils").inherits(f,l),f.prototype._read=function(){this._helper.resume()},o.exports=f},{"../utils":32,"readable-stream":16}],14:[function(n,o,a){o.exports={isNode:typeof Buffer<"u",newBufferFrom:function(l,f){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(l,f);if(typeof l=="number")throw new Error('The "data" argument must not be a number');return new Buffer(l,f)},allocBuffer:function(l){if(Buffer.alloc)return Buffer.alloc(l);var f=new Buffer(l);return f.fill(0),f},isBuffer:function(l){return Buffer.isBuffer(l)},isStream:function(l){return l&&typeof l.on=="function"&&typeof l.pause=="function"&&typeof l.resume=="function"}}},{}],15:[function(n,o,a){function l(O,B,j){var N,oe=_.getTypeOf(B),he=_.extend(j||{},M);he.date=he.date||new Date,he.compression!==null&&(he.compression=he.compression.toUpperCase()),typeof he.unixPermissions=="string"&&(he.unixPermissions=parseInt(he.unixPermissions,8)),he.unixPermissions&&16384&he.unixPermissions&&(he.dir=!0),he.dosPermissions&&16&he.dosPermissions&&(he.dir=!0),he.dir&&(O=y(O)),he.createFolders&&(N=S(O))&&x.call(this,N,!0);var Ie=oe==="string"&&he.binary===!1&&he.base64===!1;j&&j.binary!==void 0||(he.binary=!Ie),(B instanceof v&&B.uncompressedSize===0||he.dir||!B||B.length===0)&&(he.base64=!1,he.binary=!0,B="",he.compression="STORE",oe="string");var te=null;te=B instanceof v||B instanceof m?B:z.isNode&&z.isStream(B)?new $(O,B):_.prepareContent(O,B,he.binary,he.optimizedBinaryString,he.base64);var we=new C(O,te,he);this.files[O]=we}var f=n("./utf8"),_=n("./utils"),m=n("./stream/GenericWorker"),g=n("./stream/StreamHelper"),M=n("./defaults"),v=n("./compressedObject"),C=n("./zipObject"),k=n("./generate"),z=n("./nodejsUtils"),$=n("./nodejs/NodejsStreamInputAdapter"),S=function(O){O.slice(-1)==="/"&&(O=O.substring(0,O.length-1));var B=O.lastIndexOf("/");return 0<B?O.substring(0,B):""},y=function(O){return O.slice(-1)!=="/"&&(O+="/"),O},x=function(O,B){return B=B!==void 0?B:M.createFolders,O=y(O),this.files[O]||l.call(this,O,null,{dir:!0,createFolders:B}),this.files[O]};function I(O){return Object.prototype.toString.call(O)==="[object RegExp]"}var V={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(O){var B,j,N;for(B in this.files)N=this.files[B],(j=B.slice(this.root.length,B.length))&&B.slice(0,this.root.length)===this.root&&O(j,N)},filter:function(O){var B=[];return this.forEach(function(j,N){O(j,N)&&B.push(N)}),B},file:function(O,B,j){if(arguments.length!==1)return O=this.root+O,l.call(this,O,B,j),this;if(I(O)){var N=O;return this.filter(function(he,Ie){return!Ie.dir&&N.test(he)})}var oe=this.files[this.root+O];return oe&&!oe.dir?oe:null},folder:function(O){if(!O)return this;if(I(O))return this.filter(function(oe,he){return he.dir&&O.test(oe)});var B=this.root+O,j=x.call(this,B),N=this.clone();return N.root=j.name,N},remove:function(O){O=this.root+O;var B=this.files[O];if(B||(O.slice(-1)!=="/"&&(O+="/"),B=this.files[O]),B&&!B.dir)delete this.files[O];else for(var j=this.filter(function(oe,he){return he.name.slice(0,O.length)===O}),N=0;N<j.length;N++)delete this.files[j[N].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(O){var B,j={};try{if((j=_.extend(O||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:f.utf8encode})).type=j.type.toLowerCase(),j.compression=j.compression.toUpperCase(),j.type==="binarystring"&&(j.type="string"),!j.type)throw new Error("No output type specified.");_.checkSupport(j.type),j.platform!=="darwin"&&j.platform!=="freebsd"&&j.platform!=="linux"&&j.platform!=="sunos"||(j.platform="UNIX"),j.platform==="win32"&&(j.platform="DOS");var N=j.comment||this.comment||"";B=k.generateWorker(this,j,N)}catch(oe){(B=new m("error")).error(oe)}return new g(B,j.type||"string",j.mimeType)},generateAsync:function(O,B){return this.generateInternalStream(O).accumulate(B)},generateNodeStream:function(O,B){return(O=O||{}).type||(O.type="nodebuffer"),this.generateInternalStream(O).toNodejsStream(B)}};o.exports=V},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(n,o,a){o.exports=n("stream")},{stream:void 0}],17:[function(n,o,a){var l=n("./DataReader");function f(_){l.call(this,_);for(var m=0;m<this.data.length;m++)_[m]=255&_[m]}n("../utils").inherits(f,l),f.prototype.byteAt=function(_){return this.data[this.zero+_]},f.prototype.lastIndexOfSignature=function(_){for(var m=_.charCodeAt(0),g=_.charCodeAt(1),M=_.charCodeAt(2),v=_.charCodeAt(3),C=this.length-4;0<=C;--C)if(this.data[C]===m&&this.data[C+1]===g&&this.data[C+2]===M&&this.data[C+3]===v)return C-this.zero;return-1},f.prototype.readAndCheckSignature=function(_){var m=_.charCodeAt(0),g=_.charCodeAt(1),M=_.charCodeAt(2),v=_.charCodeAt(3),C=this.readData(4);return m===C[0]&&g===C[1]&&M===C[2]&&v===C[3]},f.prototype.readData=function(_){if(this.checkOffset(_),_===0)return[];var m=this.data.slice(this.zero+this.index,this.zero+this.index+_);return this.index+=_,m},o.exports=f},{"../utils":32,"./DataReader":18}],18:[function(n,o,a){var l=n("../utils");function f(_){this.data=_,this.length=_.length,this.index=0,this.zero=0}f.prototype={checkOffset:function(_){this.checkIndex(this.index+_)},checkIndex:function(_){if(this.length<this.zero+_||_<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+_+"). Corrupted zip ?")},setIndex:function(_){this.checkIndex(_),this.index=_},skip:function(_){this.setIndex(this.index+_)},byteAt:function(){},readInt:function(_){var m,g=0;for(this.checkOffset(_),m=this.index+_-1;m>=this.index;m--)g=(g<<8)+this.byteAt(m);return this.index+=_,g},readString:function(_){return l.transformTo("string",this.readData(_))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var _=this.readInt(4);return new Date(Date.UTC(1980+(_>>25&127),(_>>21&15)-1,_>>16&31,_>>11&31,_>>5&63,(31&_)<<1))}},o.exports=f},{"../utils":32}],19:[function(n,o,a){var l=n("./Uint8ArrayReader");function f(_){l.call(this,_)}n("../utils").inherits(f,l),f.prototype.readData=function(_){this.checkOffset(_);var m=this.data.slice(this.zero+this.index,this.zero+this.index+_);return this.index+=_,m},o.exports=f},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(n,o,a){var l=n("./DataReader");function f(_){l.call(this,_)}n("../utils").inherits(f,l),f.prototype.byteAt=function(_){return this.data.charCodeAt(this.zero+_)},f.prototype.lastIndexOfSignature=function(_){return this.data.lastIndexOf(_)-this.zero},f.prototype.readAndCheckSignature=function(_){return _===this.readData(4)},f.prototype.readData=function(_){this.checkOffset(_);var m=this.data.slice(this.zero+this.index,this.zero+this.index+_);return this.index+=_,m},o.exports=f},{"../utils":32,"./DataReader":18}],21:[function(n,o,a){var l=n("./ArrayReader");function f(_){l.call(this,_)}n("../utils").inherits(f,l),f.prototype.readData=function(_){if(this.checkOffset(_),_===0)return new Uint8Array(0);var m=this.data.subarray(this.zero+this.index,this.zero+this.index+_);return this.index+=_,m},o.exports=f},{"../utils":32,"./ArrayReader":17}],22:[function(n,o,a){var l=n("../utils"),f=n("../support"),_=n("./ArrayReader"),m=n("./StringReader"),g=n("./NodeBufferReader"),M=n("./Uint8ArrayReader");o.exports=function(v){var C=l.getTypeOf(v);return l.checkSupport(C),C!=="string"||f.uint8array?C==="nodebuffer"?new g(v):f.uint8array?new M(l.transformTo("uint8array",v)):new _(l.transformTo("array",v)):new m(v)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(n,o,a){a.LOCAL_FILE_HEADER="PK",a.CENTRAL_FILE_HEADER="PK",a.CENTRAL_DIRECTORY_END="PK",a.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK\x07",a.ZIP64_CENTRAL_DIRECTORY_END="PK",a.DATA_DESCRIPTOR="PK\x07\b"},{}],24:[function(n,o,a){var l=n("./GenericWorker"),f=n("../utils");function _(m){l.call(this,"ConvertWorker to "+m),this.destType=m}f.inherits(_,l),_.prototype.processChunk=function(m){this.push({data:f.transformTo(this.destType,m.data),meta:m.meta})},o.exports=_},{"../utils":32,"./GenericWorker":28}],25:[function(n,o,a){var l=n("./GenericWorker"),f=n("../crc32");function _(){l.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}n("../utils").inherits(_,l),_.prototype.processChunk=function(m){this.streamInfo.crc32=f(m.data,this.streamInfo.crc32||0),this.push(m)},o.exports=_},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(n,o,a){var l=n("../utils"),f=n("./GenericWorker");function _(m){f.call(this,"DataLengthProbe for "+m),this.propName=m,this.withStreamInfo(m,0)}l.inherits(_,f),_.prototype.processChunk=function(m){if(m){var g=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=g+m.data.length}f.prototype.processChunk.call(this,m)},o.exports=_},{"../utils":32,"./GenericWorker":28}],27:[function(n,o,a){var l=n("../utils"),f=n("./GenericWorker");function _(m){f.call(this,"DataWorker");var g=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,m.then(function(M){g.dataIsReady=!0,g.data=M,g.max=M&&M.length||0,g.type=l.getTypeOf(M),g.isPaused||g._tickAndRepeat()},function(M){g.error(M)})}l.inherits(_,f),_.prototype.cleanUp=function(){f.prototype.cleanUp.call(this),this.data=null},_.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,l.delay(this._tickAndRepeat,[],this)),!0)},_.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(l.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},_.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var m=null,g=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":m=this.data.substring(this.index,g);break;case"uint8array":m=this.data.subarray(this.index,g);break;case"array":case"nodebuffer":m=this.data.slice(this.index,g)}return this.index=g,this.push({data:m,meta:{percent:this.max?this.index/this.max*100:0}})},o.exports=_},{"../utils":32,"./GenericWorker":28}],28:[function(n,o,a){function l(f){this.name=f||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}l.prototype={push:function(f){this.emit("data",f)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(f){this.emit("error",f)}return!0},error:function(f){return!this.isFinished&&(this.isPaused?this.generatedError=f:(this.isFinished=!0,this.emit("error",f),this.previous&&this.previous.error(f),this.cleanUp()),!0)},on:function(f,_){return this._listeners[f].push(_),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(f,_){if(this._listeners[f])for(var m=0;m<this._listeners[f].length;m++)this._listeners[f][m].call(this,_)},pipe:function(f){return f.registerPrevious(this)},registerPrevious:function(f){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=f.streamInfo,this.mergeStreamInfo(),this.previous=f;var _=this;return f.on("data",function(m){_.processChunk(m)}),f.on("end",function(){_.end()}),f.on("error",function(m){_.error(m)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var f=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),f=!0),this.previous&&this.previous.resume(),!f},flush:function(){},processChunk:function(f){this.push(f)},withStreamInfo:function(f,_){return this.extraStreamInfo[f]=_,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var f in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,f)&&(this.streamInfo[f]=this.extraStreamInfo[f])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var f="Worker "+this.name;return this.previous?this.previous+" -> "+f:f}},o.exports=l},{}],29:[function(n,o,a){var l=n("../utils"),f=n("./ConvertWorker"),_=n("./GenericWorker"),m=n("../base64"),g=n("../support"),M=n("../external"),v=null;if(g.nodestream)try{v=n("../nodejs/NodejsStreamOutputAdapter")}catch{}function C(z,$){return new M.Promise(function(S,y){var x=[],I=z._internalType,V=z._outputType,O=z._mimeType;z.on("data",function(B,j){x.push(B),$&&$(j)}).on("error",function(B){x=[],y(B)}).on("end",function(){try{var B=function(j,N,oe){switch(j){case"blob":return l.newBlob(l.transformTo("arraybuffer",N),oe);case"base64":return m.encode(N);default:return l.transformTo(j,N)}}(V,function(j,N){var oe,he=0,Ie=null,te=0;for(oe=0;oe<N.length;oe++)te+=N[oe].length;switch(j){case"string":return N.join("");case"array":return Array.prototype.concat.apply([],N);case"uint8array":for(Ie=new Uint8Array(te),oe=0;oe<N.length;oe++)Ie.set(N[oe],he),he+=N[oe].length;return Ie;case"nodebuffer":return Buffer.concat(N);default:throw new Error("concat : unsupported type '"+j+"'")}}(I,x),O);S(B)}catch(j){y(j)}x=[]}).resume()})}function k(z,$,S){var y=$;switch($){case"blob":case"arraybuffer":y="uint8array";break;case"base64":y="string"}try{this._internalType=y,this._outputType=$,this._mimeType=S,l.checkSupport(y),this._worker=z.pipe(new f(y)),z.lock()}catch(x){this._worker=new _("error"),this._worker.error(x)}}k.prototype={accumulate:function(z){return C(this,z)},on:function(z,$){var S=this;return z==="data"?this._worker.on(z,function(y){$.call(S,y.data,y.meta)}):this._worker.on(z,function(){l.delay($,arguments,S)}),this},resume:function(){return l.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(z){if(l.checkSupport("nodestream"),this._outputType!=="nodebuffer")throw new Error(this._outputType+" is not supported by this method");return new v(this,{objectMode:this._outputType!=="nodebuffer"},z)}},o.exports=k},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(n,o,a){if(a.base64=!0,a.array=!0,a.string=!0,a.arraybuffer=typeof ArrayBuffer<"u"&&typeof Uint8Array<"u",a.nodebuffer=typeof Buffer<"u",a.uint8array=typeof Uint8Array<"u",typeof ArrayBuffer>"u")a.blob=!1;else{var l=new ArrayBuffer(0);try{a.blob=new Blob([l],{type:"application/zip"}).size===0}catch{try{var f=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);f.append(l),a.blob=f.getBlob("application/zip").size===0}catch{a.blob=!1}}}try{a.nodestream=!!n("readable-stream").Readable}catch{a.nodestream=!1}},{"readable-stream":16}],31:[function(n,o,a){for(var l=n("./utils"),f=n("./support"),_=n("./nodejsUtils"),m=n("./stream/GenericWorker"),g=new Array(256),M=0;M<256;M++)g[M]=252<=M?6:248<=M?5:240<=M?4:224<=M?3:192<=M?2:1;g[254]=g[254]=1;function v(){m.call(this,"utf-8 decode"),this.leftOver=null}function C(){m.call(this,"utf-8 encode")}a.utf8encode=function(k){return f.nodebuffer?_.newBufferFrom(k,"utf-8"):function(z){var $,S,y,x,I,V=z.length,O=0;for(x=0;x<V;x++)(64512&(S=z.charCodeAt(x)))==55296&&x+1<V&&(64512&(y=z.charCodeAt(x+1)))==56320&&(S=65536+(S-55296<<10)+(y-56320),x++),O+=S<128?1:S<2048?2:S<65536?3:4;for($=f.uint8array?new Uint8Array(O):new Array(O),x=I=0;I<O;x++)(64512&(S=z.charCodeAt(x)))==55296&&x+1<V&&(64512&(y=z.charCodeAt(x+1)))==56320&&(S=65536+(S-55296<<10)+(y-56320),x++),S<128?$[I++]=S:(S<2048?$[I++]=192|S>>>6:(S<65536?$[I++]=224|S>>>12:($[I++]=240|S>>>18,$[I++]=128|S>>>12&63),$[I++]=128|S>>>6&63),$[I++]=128|63&S);return $}(k)},a.utf8decode=function(k){return f.nodebuffer?l.transformTo("nodebuffer",k).toString("utf-8"):function(z){var $,S,y,x,I=z.length,V=new Array(2*I);for($=S=0;$<I;)if((y=z[$++])<128)V[S++]=y;else if(4<(x=g[y]))V[S++]=65533,$+=x-1;else{for(y&=x===2?31:x===3?15:7;1<x&&$<I;)y=y<<6|63&z[$++],x--;1<x?V[S++]=65533:y<65536?V[S++]=y:(y-=65536,V[S++]=55296|y>>10&1023,V[S++]=56320|1023&y)}return V.length!==S&&(V.subarray?V=V.subarray(0,S):V.length=S),l.applyFromCharCode(V)}(k=l.transformTo(f.uint8array?"uint8array":"array",k))},l.inherits(v,m),v.prototype.processChunk=function(k){var z=l.transformTo(f.uint8array?"uint8array":"array",k.data);if(this.leftOver&&this.leftOver.length){if(f.uint8array){var $=z;(z=new Uint8Array($.length+this.leftOver.length)).set(this.leftOver,0),z.set($,this.leftOver.length)}else z=this.leftOver.concat(z);this.leftOver=null}var S=function(x,I){var V;for((I=I||x.length)>x.length&&(I=x.length),V=I-1;0<=V&&(192&x[V])==128;)V--;return V<0||V===0?I:V+g[x[V]]>I?V:I}(z),y=z;S!==z.length&&(f.uint8array?(y=z.subarray(0,S),this.leftOver=z.subarray(S,z.length)):(y=z.slice(0,S),this.leftOver=z.slice(S,z.length))),this.push({data:a.utf8decode(y),meta:k.meta})},v.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:a.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},a.Utf8DecodeWorker=v,l.inherits(C,m),C.prototype.processChunk=function(k){this.push({data:a.utf8encode(k.data),meta:k.meta})},a.Utf8EncodeWorker=C},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(n,o,a){var l=n("./support"),f=n("./base64"),_=n("./nodejsUtils"),m=n("./external");function g($){return $}function M($,S){for(var y=0;y<$.length;++y)S[y]=255&$.charCodeAt(y);return S}n("setimmediate"),a.newBlob=function($,S){a.checkSupport("blob");try{return new Blob([$],{type:S})}catch{try{var y=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return y.append($),y.getBlob(S)}catch{throw new Error("Bug : can't construct the Blob.")}}};var v={stringifyByChunk:function($,S,y){var x=[],I=0,V=$.length;if(V<=y)return String.fromCharCode.apply(null,$);for(;I<V;)S==="array"||S==="nodebuffer"?x.push(String.fromCharCode.apply(null,$.slice(I,Math.min(I+y,V)))):x.push(String.fromCharCode.apply(null,$.subarray(I,Math.min(I+y,V)))),I+=y;return x.join("")},stringifyByChar:function($){for(var S="",y=0;y<$.length;y++)S+=String.fromCharCode($[y]);return S},applyCanBeUsed:{uint8array:function(){try{return l.uint8array&&String.fromCharCode.apply(null,new Uint8Array(1)).length===1}catch{return!1}}(),nodebuffer:function(){try{return l.nodebuffer&&String.fromCharCode.apply(null,_.allocBuffer(1)).length===1}catch{return!1}}()}};function C($){var S=65536,y=a.getTypeOf($),x=!0;if(y==="uint8array"?x=v.applyCanBeUsed.uint8array:y==="nodebuffer"&&(x=v.applyCanBeUsed.nodebuffer),x)for(;1<S;)try{return v.stringifyByChunk($,y,S)}catch{S=Math.floor(S/2)}return v.stringifyByChar($)}function k($,S){for(var y=0;y<$.length;y++)S[y]=$[y];return S}a.applyFromCharCode=C;var z={};z.string={string:g,array:function($){return M($,new Array($.length))},arraybuffer:function($){return z.string.uint8array($).buffer},uint8array:function($){return M($,new Uint8Array($.length))},nodebuffer:function($){return M($,_.allocBuffer($.length))}},z.array={string:C,array:g,arraybuffer:function($){return new Uint8Array($).buffer},uint8array:function($){return new Uint8Array($)},nodebuffer:function($){return _.newBufferFrom($)}},z.arraybuffer={string:function($){return C(new Uint8Array($))},array:function($){return k(new Uint8Array($),new Array($.byteLength))},arraybuffer:g,uint8array:function($){return new Uint8Array($)},nodebuffer:function($){return _.newBufferFrom(new Uint8Array($))}},z.uint8array={string:C,array:function($){return k($,new Array($.length))},arraybuffer:function($){return $.buffer},uint8array:g,nodebuffer:function($){return _.newBufferFrom($)}},z.nodebuffer={string:C,array:function($){return k($,new Array($.length))},arraybuffer:function($){return z.nodebuffer.uint8array($).buffer},uint8array:function($){return k($,new Uint8Array($.length))},nodebuffer:g},a.transformTo=function($,S){if(S=S||"",!$)return S;a.checkSupport($);var y=a.getTypeOf(S);return z[y][$](S)},a.resolve=function($){for(var S=$.split("/"),y=[],x=0;x<S.length;x++){var I=S[x];I==="."||I===""&&x!==0&&x!==S.length-1||(I===".."?y.pop():y.push(I))}return y.join("/")},a.getTypeOf=function($){return typeof $=="string"?"string":Object.prototype.toString.call($)==="[object Array]"?"array":l.nodebuffer&&_.isBuffer($)?"nodebuffer":l.uint8array&&$ instanceof Uint8Array?"uint8array":l.arraybuffer&&$ instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function($){if(!l[$.toLowerCase()])throw new Error($+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function($){var S,y,x="";for(y=0;y<($||"").length;y++)x+="\\x"+((S=$.charCodeAt(y))<16?"0":"")+S.toString(16).toUpperCase();return x},a.delay=function($,S,y){setImmediate(function(){$.apply(y||null,S||[])})},a.inherits=function($,S){function y(){}y.prototype=S.prototype,$.prototype=new y},a.extend=function(){var $,S,y={};for($=0;$<arguments.length;$++)for(S in arguments[$])Object.prototype.hasOwnProperty.call(arguments[$],S)&&y[S]===void 0&&(y[S]=arguments[$][S]);return y},a.prepareContent=function($,S,y,x,I){return m.Promise.resolve(S).then(function(V){return l.blob&&(V instanceof Blob||["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(V))!==-1)&&typeof FileReader<"u"?new m.Promise(function(O,B){var j=new FileReader;j.onload=function(N){O(N.target.result)},j.onerror=function(N){B(N.target.error)},j.readAsArrayBuffer(V)}):V}).then(function(V){var O=a.getTypeOf(V);return O?(O==="arraybuffer"?V=a.transformTo("uint8array",V):O==="string"&&(I?V=f.decode(V):y&&x!==!0&&(V=function(B){return M(B,l.uint8array?new Uint8Array(B.length):new Array(B.length))}(V))),V):m.Promise.reject(new Error("Can't read the data of '"+$+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(n,o,a){var l=n("./reader/readerFor"),f=n("./utils"),_=n("./signature"),m=n("./zipEntry"),g=n("./support");function M(v){this.files=[],this.loadOptions=v}M.prototype={checkSignature:function(v){if(!this.reader.readAndCheckSignature(v)){this.reader.index-=4;var C=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+f.pretty(C)+", expected "+f.pretty(v)+")")}},isSignature:function(v,C){var k=this.reader.index;this.reader.setIndex(v);var z=this.reader.readString(4)===C;return this.reader.setIndex(k),z},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var v=this.reader.readData(this.zipCommentLength),C=g.uint8array?"uint8array":"array",k=f.transformTo(C,v);this.zipComment=this.loadOptions.decodeFileName(k)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var v,C,k,z=this.zip64EndOfCentralSize-44;0<z;)v=this.reader.readInt(2),C=this.reader.readInt(4),k=this.reader.readData(C),this.zip64ExtensibleData[v]={id:v,length:C,value:k}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var v,C;for(v=0;v<this.files.length;v++)C=this.files[v],this.reader.setIndex(C.localHeaderOffset),this.checkSignature(_.LOCAL_FILE_HEADER),C.readLocalPart(this.reader),C.handleUTF8(),C.processAttributes()},readCentralDir:function(){var v;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(_.CENTRAL_FILE_HEADER);)(v=new m({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(v);if(this.centralDirRecords!==this.files.length&&this.centralDirRecords!==0&&this.files.length===0)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var v=this.reader.lastIndexOfSignature(_.CENTRAL_DIRECTORY_END);if(v<0)throw this.isSignature(0,_.LOCAL_FILE_HEADER)?new Error("Corrupted zip: can't find end of central directory"):new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");this.reader.setIndex(v);var C=v;if(this.checkSignature(_.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===f.MAX_VALUE_16BITS||this.diskWithCentralDirStart===f.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===f.MAX_VALUE_16BITS||this.centralDirRecords===f.MAX_VALUE_16BITS||this.centralDirSize===f.MAX_VALUE_32BITS||this.centralDirOffset===f.MAX_VALUE_32BITS){if(this.zip64=!0,(v=this.reader.lastIndexOfSignature(_.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(v),this.checkSignature(_.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,_.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(_.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(_.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var k=this.centralDirOffset+this.centralDirSize;this.zip64&&(k+=20,k+=12+this.zip64EndOfCentralSize);var z=C-k;if(0<z)this.isSignature(C,_.CENTRAL_FILE_HEADER)||(this.reader.zero=z);else if(z<0)throw new Error("Corrupted zip: missing "+Math.abs(z)+" bytes.")},prepareReader:function(v){this.reader=l(v)},load:function(v){this.prepareReader(v),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},o.exports=M},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(n,o,a){var l=n("./reader/readerFor"),f=n("./utils"),_=n("./compressedObject"),m=n("./crc32"),g=n("./utf8"),M=n("./compressions"),v=n("./support");function C(k,z){this.options=k,this.loadOptions=z}C.prototype={isEncrypted:function(){return(1&this.bitFlag)==1},useUTF8:function(){return(2048&this.bitFlag)==2048},readLocalPart:function(k){var z,$;if(k.skip(22),this.fileNameLength=k.readInt(2),$=k.readInt(2),this.fileName=k.readData(this.fileNameLength),k.skip($),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if((z=function(S){for(var y in M)if(Object.prototype.hasOwnProperty.call(M,y)&&M[y].magic===S)return M[y];return null}(this.compressionMethod))===null)throw new Error("Corrupted zip : compression "+f.pretty(this.compressionMethod)+" unknown (inner file : "+f.transformTo("string",this.fileName)+")");this.decompressed=new _(this.compressedSize,this.uncompressedSize,this.crc32,z,k.readData(this.compressedSize))},readCentralPart:function(k){this.versionMadeBy=k.readInt(2),k.skip(2),this.bitFlag=k.readInt(2),this.compressionMethod=k.readString(2),this.date=k.readDate(),this.crc32=k.readInt(4),this.compressedSize=k.readInt(4),this.uncompressedSize=k.readInt(4);var z=k.readInt(2);if(this.extraFieldsLength=k.readInt(2),this.fileCommentLength=k.readInt(2),this.diskNumberStart=k.readInt(2),this.internalFileAttributes=k.readInt(2),this.externalFileAttributes=k.readInt(4),this.localHeaderOffset=k.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");k.skip(z),this.readExtraFields(k),this.parseZIP64ExtraField(k),this.fileComment=k.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var k=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),k==0&&(this.dosPermissions=63&this.externalFileAttributes),k==3&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||this.fileNameStr.slice(-1)!=="/"||(this.dir=!0)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var k=l(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=k.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=k.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=k.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=k.readInt(4))}},readExtraFields:function(k){var z,$,S,y=k.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});k.index+4<y;)z=k.readInt(2),$=k.readInt(2),S=k.readData($),this.extraFields[z]={id:z,length:$,value:S};k.setIndex(y)},handleUTF8:function(){var k=v.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=g.utf8decode(this.fileName),this.fileCommentStr=g.utf8decode(this.fileComment);else{var z=this.findExtraFieldUnicodePath();if(z!==null)this.fileNameStr=z;else{var $=f.transformTo(k,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName($)}var S=this.findExtraFieldUnicodeComment();if(S!==null)this.fileCommentStr=S;else{var y=f.transformTo(k,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(y)}}},findExtraFieldUnicodePath:function(){var k=this.extraFields[28789];if(k){var z=l(k.value);return z.readInt(1)!==1||m(this.fileName)!==z.readInt(4)?null:g.utf8decode(z.readData(k.length-5))}return null},findExtraFieldUnicodeComment:function(){var k=this.extraFields[25461];if(k){var z=l(k.value);return z.readInt(1)!==1||m(this.fileComment)!==z.readInt(4)?null:g.utf8decode(z.readData(k.length-5))}return null}},o.exports=C},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(n,o,a){function l(z,$,S){this.name=z,this.dir=S.dir,this.date=S.date,this.comment=S.comment,this.unixPermissions=S.unixPermissions,this.dosPermissions=S.dosPermissions,this._data=$,this._dataBinary=S.binary,this.options={compression:S.compression,compressionOptions:S.compressionOptions}}var f=n("./stream/StreamHelper"),_=n("./stream/DataWorker"),m=n("./utf8"),g=n("./compressedObject"),M=n("./stream/GenericWorker");l.prototype={internalStream:function(z){var $=null,S="string";try{if(!z)throw new Error("No output type specified.");var y=(S=z.toLowerCase())==="string"||S==="text";S!=="binarystring"&&S!=="text"||(S="string"),$=this._decompressWorker();var x=!this._dataBinary;x&&!y&&($=$.pipe(new m.Utf8EncodeWorker)),!x&&y&&($=$.pipe(new m.Utf8DecodeWorker))}catch(I){($=new M("error")).error(I)}return new f($,S,"")},async:function(z,$){return this.internalStream(z).accumulate($)},nodeStream:function(z,$){return this.internalStream(z||"nodebuffer").toNodejsStream($)},_compressWorker:function(z,$){if(this._data instanceof g&&this._data.compression.magic===z.magic)return this._data.getCompressedWorker();var S=this._decompressWorker();return this._dataBinary||(S=S.pipe(new m.Utf8EncodeWorker)),g.createWorkerFrom(S,z,$)},_decompressWorker:function(){return this._data instanceof g?this._data.getContentWorker():this._data instanceof M?this._data:new _(this._data)}};for(var v=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],C=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},k=0;k<v.length;k++)l.prototype[v[k]]=C;o.exports=l},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(n,o,a){(function(l){var f,_,m=l.MutationObserver||l.WebKitMutationObserver;if(m){var g=0,M=new m(z),v=l.document.createTextNode("");M.observe(v,{characterData:!0}),f=function(){v.data=g=++g%2}}else if(l.setImmediate||l.MessageChannel===void 0)f="document"in l&&"onreadystatechange"in l.document.createElement("script")?function(){var $=l.document.createElement("script");$.onreadystatechange=function(){z(),$.onreadystatechange=null,$.parentNode.removeChild($),$=null},l.document.documentElement.appendChild($)}:function(){setTimeout(z,0)};else{var C=new l.MessageChannel;C.port1.onmessage=z,f=function(){C.port2.postMessage(0)}}var k=[];function z(){var $,S;_=!0;for(var y=k.length;y;){for(S=k,k=[],$=-1;++$<y;)S[$]();y=k.length}_=!1}o.exports=function($){k.push($)!==1||_||f()}}).call(this,typeof Fo<"u"?Fo:typeof self<"u"?self:typeof window<"u"?window:{})},{}],37:[function(n,o,a){var l=n("immediate");function f(){}var _={},m=["REJECTED"],g=["FULFILLED"],M=["PENDING"];function v(y){if(typeof y!="function")throw new TypeError("resolver must be a function");this.state=M,this.queue=[],this.outcome=void 0,y!==f&&$(this,y)}function C(y,x,I){this.promise=y,typeof x=="function"&&(this.onFulfilled=x,this.callFulfilled=this.otherCallFulfilled),typeof I=="function"&&(this.onRejected=I,this.callRejected=this.otherCallRejected)}function k(y,x,I){l(function(){var V;try{V=x(I)}catch(O){return _.reject(y,O)}V===y?_.reject(y,new TypeError("Cannot resolve promise with itself")):_.resolve(y,V)})}function z(y){var x=y&&y.then;if(y&&(typeof y=="object"||typeof y=="function")&&typeof x=="function")return function(){x.apply(y,arguments)}}function $(y,x){var I=!1;function V(j){I||(I=!0,_.reject(y,j))}function O(j){I||(I=!0,_.resolve(y,j))}var B=S(function(){x(O,V)});B.status==="error"&&V(B.value)}function S(y,x){var I={};try{I.value=y(x),I.status="success"}catch(V){I.status="error",I.value=V}return I}(o.exports=v).prototype.finally=function(y){if(typeof y!="function")return this;var x=this.constructor;return this.then(function(I){return x.resolve(y()).then(function(){return I})},function(I){return x.resolve(y()).then(function(){throw I})})},v.prototype.catch=function(y){return this.then(null,y)},v.prototype.then=function(y,x){if(typeof y!="function"&&this.state===g||typeof x!="function"&&this.state===m)return this;var I=new this.constructor(f);return this.state!==M?k(I,this.state===g?y:x,this.outcome):this.queue.push(new C(I,y,x)),I},C.prototype.callFulfilled=function(y){_.resolve(this.promise,y)},C.prototype.otherCallFulfilled=function(y){k(this.promise,this.onFulfilled,y)},C.prototype.callRejected=function(y){_.reject(this.promise,y)},C.prototype.otherCallRejected=function(y){k(this.promise,this.onRejected,y)},_.resolve=function(y,x){var I=S(z,x);if(I.status==="error")return _.reject(y,I.value);var V=I.value;if(V)$(y,V);else{y.state=g,y.outcome=x;for(var O=-1,B=y.queue.length;++O<B;)y.queue[O].callFulfilled(x)}return y},_.reject=function(y,x){y.state=m,y.outcome=x;for(var I=-1,V=y.queue.length;++I<V;)y.queue[I].callRejected(x);return y},v.resolve=function(y){return y instanceof this?y:_.resolve(new this(f),y)},v.reject=function(y){var x=new this(f);return _.reject(x,y)},v.all=function(y){var x=this;if(Object.prototype.toString.call(y)!=="[object Array]")return this.reject(new TypeError("must be an array"));var I=y.length,V=!1;if(!I)return this.resolve([]);for(var O=new Array(I),B=0,j=-1,N=new this(f);++j<I;)oe(y[j],j);return N;function oe(he,Ie){x.resolve(he).then(function(te){O[Ie]=te,++B!==I||V||(V=!0,_.resolve(N,O))},function(te){V||(V=!0,_.reject(N,te))})}},v.race=function(y){var x=this;if(Object.prototype.toString.call(y)!=="[object Array]")return this.reject(new TypeError("must be an array"));var I=y.length,V=!1;if(!I)return this.resolve([]);for(var O=-1,B=new this(f);++O<I;)j=y[O],x.resolve(j).then(function(N){V||(V=!0,_.resolve(B,N))},function(N){V||(V=!0,_.reject(B,N))});var j;return B}},{immediate:36}],38:[function(n,o,a){var l={};(0,n("./lib/utils/common").assign)(l,n("./lib/deflate"),n("./lib/inflate"),n("./lib/zlib/constants")),o.exports=l},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(n,o,a){var l=n("./zlib/deflate"),f=n("./utils/common"),_=n("./utils/strings"),m=n("./zlib/messages"),g=n("./zlib/zstream"),M=Object.prototype.toString,v=0,C=-1,k=0,z=8;function $(y){if(!(this instanceof $))return new $(y);this.options=f.assign({level:C,method:z,chunkSize:16384,windowBits:15,memLevel:8,strategy:k,to:""},y||{});var x=this.options;x.raw&&0<x.windowBits?x.windowBits=-x.windowBits:x.gzip&&0<x.windowBits&&x.windowBits<16&&(x.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new g,this.strm.avail_out=0;var I=l.deflateInit2(this.strm,x.level,x.method,x.windowBits,x.memLevel,x.strategy);if(I!==v)throw new Error(m[I]);if(x.header&&l.deflateSetHeader(this.strm,x.header),x.dictionary){var V;if(V=typeof x.dictionary=="string"?_.string2buf(x.dictionary):M.call(x.dictionary)==="[object ArrayBuffer]"?new Uint8Array(x.dictionary):x.dictionary,(I=l.deflateSetDictionary(this.strm,V))!==v)throw new Error(m[I]);this._dict_set=!0}}function S(y,x){var I=new $(x);if(I.push(y,!0),I.err)throw I.msg||m[I.err];return I.result}$.prototype.push=function(y,x){var I,V,O=this.strm,B=this.options.chunkSize;if(this.ended)return!1;V=x===~~x?x:x===!0?4:0,typeof y=="string"?O.input=_.string2buf(y):M.call(y)==="[object ArrayBuffer]"?O.input=new Uint8Array(y):O.input=y,O.next_in=0,O.avail_in=O.input.length;do{if(O.avail_out===0&&(O.output=new f.Buf8(B),O.next_out=0,O.avail_out=B),(I=l.deflate(O,V))!==1&&I!==v)return this.onEnd(I),!(this.ended=!0);O.avail_out!==0&&(O.avail_in!==0||V!==4&&V!==2)||(this.options.to==="string"?this.onData(_.buf2binstring(f.shrinkBuf(O.output,O.next_out))):this.onData(f.shrinkBuf(O.output,O.next_out)))}while((0<O.avail_in||O.avail_out===0)&&I!==1);return V===4?(I=l.deflateEnd(this.strm),this.onEnd(I),this.ended=!0,I===v):V!==2||(this.onEnd(v),!(O.avail_out=0))},$.prototype.onData=function(y){this.chunks.push(y)},$.prototype.onEnd=function(y){y===v&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=f.flattenChunks(this.chunks)),this.chunks=[],this.err=y,this.msg=this.strm.msg},a.Deflate=$,a.deflate=S,a.deflateRaw=function(y,x){return(x=x||{}).raw=!0,S(y,x)},a.gzip=function(y,x){return(x=x||{}).gzip=!0,S(y,x)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(n,o,a){var l=n("./zlib/inflate"),f=n("./utils/common"),_=n("./utils/strings"),m=n("./zlib/constants"),g=n("./zlib/messages"),M=n("./zlib/zstream"),v=n("./zlib/gzheader"),C=Object.prototype.toString;function k($){if(!(this instanceof k))return new k($);this.options=f.assign({chunkSize:16384,windowBits:0,to:""},$||{});var S=this.options;S.raw&&0<=S.windowBits&&S.windowBits<16&&(S.windowBits=-S.windowBits,S.windowBits===0&&(S.windowBits=-15)),!(0<=S.windowBits&&S.windowBits<16)||$&&$.windowBits||(S.windowBits+=32),15<S.windowBits&&S.windowBits<48&&!(15&S.windowBits)&&(S.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new M,this.strm.avail_out=0;var y=l.inflateInit2(this.strm,S.windowBits);if(y!==m.Z_OK)throw new Error(g[y]);this.header=new v,l.inflateGetHeader(this.strm,this.header)}function z($,S){var y=new k(S);if(y.push($,!0),y.err)throw y.msg||g[y.err];return y.result}k.prototype.push=function($,S){var y,x,I,V,O,B,j=this.strm,N=this.options.chunkSize,oe=this.options.dictionary,he=!1;if(this.ended)return!1;x=S===~~S?S:S===!0?m.Z_FINISH:m.Z_NO_FLUSH,typeof $=="string"?j.input=_.binstring2buf($):C.call($)==="[object ArrayBuffer]"?j.input=new Uint8Array($):j.input=$,j.next_in=0,j.avail_in=j.input.length;do{if(j.avail_out===0&&(j.output=new f.Buf8(N),j.next_out=0,j.avail_out=N),(y=l.inflate(j,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&oe&&(B=typeof oe=="string"?_.string2buf(oe):C.call(oe)==="[object ArrayBuffer]"?new Uint8Array(oe):oe,y=l.inflateSetDictionary(this.strm,B)),y===m.Z_BUF_ERROR&&he===!0&&(y=m.Z_OK,he=!1),y!==m.Z_STREAM_END&&y!==m.Z_OK)return this.onEnd(y),!(this.ended=!0);j.next_out&&(j.avail_out!==0&&y!==m.Z_STREAM_END&&(j.avail_in!==0||x!==m.Z_FINISH&&x!==m.Z_SYNC_FLUSH)||(this.options.to==="string"?(I=_.utf8border(j.output,j.next_out),V=j.next_out-I,O=_.buf2string(j.output,I),j.next_out=V,j.avail_out=N-V,V&&f.arraySet(j.output,j.output,I,V,0),this.onData(O)):this.onData(f.shrinkBuf(j.output,j.next_out)))),j.avail_in===0&&j.avail_out===0&&(he=!0)}while((0<j.avail_in||j.avail_out===0)&&y!==m.Z_STREAM_END);return y===m.Z_STREAM_END&&(x=m.Z_FINISH),x===m.Z_FINISH?(y=l.inflateEnd(this.strm),this.onEnd(y),this.ended=!0,y===m.Z_OK):x!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(j.avail_out=0))},k.prototype.onData=function($){this.chunks.push($)},k.prototype.onEnd=function($){$===m.Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=f.flattenChunks(this.chunks)),this.chunks=[],this.err=$,this.msg=this.strm.msg},a.Inflate=k,a.inflate=z,a.inflateRaw=function($,S){return(S=S||{}).raw=!0,z($,S)},a.ungzip=z},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(n,o,a){var l=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Int32Array<"u";a.assign=function(m){for(var g=Array.prototype.slice.call(arguments,1);g.length;){var M=g.shift();if(M){if(typeof M!="object")throw new TypeError(M+"must be non-object");for(var v in M)M.hasOwnProperty(v)&&(m[v]=M[v])}}return m},a.shrinkBuf=function(m,g){return m.length===g?m:m.subarray?m.subarray(0,g):(m.length=g,m)};var f={arraySet:function(m,g,M,v,C){if(g.subarray&&m.subarray)m.set(g.subarray(M,M+v),C);else for(var k=0;k<v;k++)m[C+k]=g[M+k]},flattenChunks:function(m){var g,M,v,C,k,z;for(g=v=0,M=m.length;g<M;g++)v+=m[g].length;for(z=new Uint8Array(v),g=C=0,M=m.length;g<M;g++)k=m[g],z.set(k,C),C+=k.length;return z}},_={arraySet:function(m,g,M,v,C){for(var k=0;k<v;k++)m[C+k]=g[M+k]},flattenChunks:function(m){return[].concat.apply([],m)}};a.setTyped=function(m){m?(a.Buf8=Uint8Array,a.Buf16=Uint16Array,a.Buf32=Int32Array,a.assign(a,f)):(a.Buf8=Array,a.Buf16=Array,a.Buf32=Array,a.assign(a,_))},a.setTyped(l)},{}],42:[function(n,o,a){var l=n("./common"),f=!0,_=!0;try{String.fromCharCode.apply(null,[0])}catch{f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{_=!1}for(var m=new l.Buf8(256),g=0;g<256;g++)m[g]=252<=g?6:248<=g?5:240<=g?4:224<=g?3:192<=g?2:1;function M(v,C){if(C<65537&&(v.subarray&&_||!v.subarray&&f))return String.fromCharCode.apply(null,l.shrinkBuf(v,C));for(var k="",z=0;z<C;z++)k+=String.fromCharCode(v[z]);return k}m[254]=m[254]=1,a.string2buf=function(v){var C,k,z,$,S,y=v.length,x=0;for($=0;$<y;$++)(64512&(k=v.charCodeAt($)))==55296&&$+1<y&&(64512&(z=v.charCodeAt($+1)))==56320&&(k=65536+(k-55296<<10)+(z-56320),$++),x+=k<128?1:k<2048?2:k<65536?3:4;for(C=new l.Buf8(x),$=S=0;S<x;$++)(64512&(k=v.charCodeAt($)))==55296&&$+1<y&&(64512&(z=v.charCodeAt($+1)))==56320&&(k=65536+(k-55296<<10)+(z-56320),$++),k<128?C[S++]=k:(k<2048?C[S++]=192|k>>>6:(k<65536?C[S++]=224|k>>>12:(C[S++]=240|k>>>18,C[S++]=128|k>>>12&63),C[S++]=128|k>>>6&63),C[S++]=128|63&k);return C},a.buf2binstring=function(v){return M(v,v.length)},a.binstring2buf=function(v){for(var C=new l.Buf8(v.length),k=0,z=C.length;k<z;k++)C[k]=v.charCodeAt(k);return C},a.buf2string=function(v,C){var k,z,$,S,y=C||v.length,x=new Array(2*y);for(k=z=0;k<y;)if(($=v[k++])<128)x[z++]=$;else if(4<(S=m[$]))x[z++]=65533,k+=S-1;else{for($&=S===2?31:S===3?15:7;1<S&&k<y;)$=$<<6|63&v[k++],S--;1<S?x[z++]=65533:$<65536?x[z++]=$:($-=65536,x[z++]=55296|$>>10&1023,x[z++]=56320|1023&$)}return M(x,z)},a.utf8border=function(v,C){var k;for((C=C||v.length)>v.length&&(C=v.length),k=C-1;0<=k&&(192&v[k])==128;)k--;return k<0||k===0?C:k+m[v[k]]>C?k:C}},{"./common":41}],43:[function(n,o,a){o.exports=function(l,f,_,m){for(var g=65535&l|0,M=l>>>16&65535|0,v=0;_!==0;){for(_-=v=2e3<_?2e3:_;M=M+(g=g+f[m++]|0)|0,--v;);g%=65521,M%=65521}return g|M<<16|0}},{}],44:[function(n,o,a){o.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(n,o,a){var l=function(){for(var f,_=[],m=0;m<256;m++){f=m;for(var g=0;g<8;g++)f=1&f?3988292384^f>>>1:f>>>1;_[m]=f}return _}();o.exports=function(f,_,m,g){var M=l,v=g+m;f^=-1;for(var C=g;C<v;C++)f=f>>>8^M[255&(f^_[C])];return-1^f}},{}],46:[function(n,o,a){var l,f=n("../utils/common"),_=n("./trees"),m=n("./adler32"),g=n("./crc32"),M=n("./messages"),v=0,C=4,k=0,z=-2,$=-1,S=4,y=2,x=8,I=9,V=286,O=30,B=19,j=2*V+1,N=15,oe=3,he=258,Ie=he+oe+1,te=42,we=113,L=1,Ce=2,Xe=3,ye=4;function Y(A,$e){return A.msg=M[$e],$e}function se(A){return(A<<1)-(4<A?9:0)}function Me(A){for(var $e=A.length;0<=--$e;)A[$e]=0}function X(A){var $e=A.state,Pe=$e.pending;Pe>A.avail_out&&(Pe=A.avail_out),Pe!==0&&(f.arraySet(A.output,$e.pending_buf,$e.pending_out,Pe,A.next_out),A.next_out+=Pe,$e.pending_out+=Pe,A.total_out+=Pe,A.avail_out-=Pe,$e.pending-=Pe,$e.pending===0&&($e.pending_out=0))}function ge(A,$e){_._tr_flush_block(A,0<=A.block_start?A.block_start:-1,A.strstart-A.block_start,$e),A.block_start=A.strstart,X(A.strm)}function qe(A,$e){A.pending_buf[A.pending++]=$e}function Be(A,$e){A.pending_buf[A.pending++]=$e>>>8&255,A.pending_buf[A.pending++]=255&$e}function Ne(A,$e){var Pe,ae,ne=A.max_chain_length,ve=A.strstart,R=A.prev_length,ee=A.nice_match,D=A.strstart>A.w_size-Ie?A.strstart-(A.w_size-Ie):0,ce=A.window,ue=A.w_mask,ke=A.prev,Re=A.strstart+he,ht=ce[ve+R-1],tt=ce[ve+R];A.prev_length>=A.good_match&&(ne>>=2),ee>A.lookahead&&(ee=A.lookahead);do if(ce[(Pe=$e)+R]===tt&&ce[Pe+R-1]===ht&&ce[Pe]===ce[ve]&&ce[++Pe]===ce[ve+1]){ve+=2,Pe++;do;while(ce[++ve]===ce[++Pe]&&ce[++ve]===ce[++Pe]&&ce[++ve]===ce[++Pe]&&ce[++ve]===ce[++Pe]&&ce[++ve]===ce[++Pe]&&ce[++ve]===ce[++Pe]&&ce[++ve]===ce[++Pe]&&ce[++ve]===ce[++Pe]&&ve<Re);if(ae=he-(Re-ve),ve=Re-he,R<ae){if(A.match_start=$e,ee<=(R=ae))break;ht=ce[ve+R-1],tt=ce[ve+R]}}while(($e=ke[$e&ue])>D&&--ne!=0);return R<=A.lookahead?R:A.lookahead}function We(A){var $e,Pe,ae,ne,ve,R,ee,D,ce,ue,ke=A.w_size;do{if(ne=A.window_size-A.lookahead-A.strstart,A.strstart>=ke+(ke-Ie)){for(f.arraySet(A.window,A.window,ke,ke,0),A.match_start-=ke,A.strstart-=ke,A.block_start-=ke,$e=Pe=A.hash_size;ae=A.head[--$e],A.head[$e]=ke<=ae?ae-ke:0,--Pe;);for($e=Pe=ke;ae=A.prev[--$e],A.prev[$e]=ke<=ae?ae-ke:0,--Pe;);ne+=ke}if(A.strm.avail_in===0)break;if(R=A.strm,ee=A.window,D=A.strstart+A.lookahead,ce=ne,ue=void 0,ue=R.avail_in,ce<ue&&(ue=ce),Pe=ue===0?0:(R.avail_in-=ue,f.arraySet(ee,R.input,R.next_in,ue,D),R.state.wrap===1?R.adler=m(R.adler,ee,ue,D):R.state.wrap===2&&(R.adler=g(R.adler,ee,ue,D)),R.next_in+=ue,R.total_in+=ue,ue),A.lookahead+=Pe,A.lookahead+A.insert>=oe)for(ve=A.strstart-A.insert,A.ins_h=A.window[ve],A.ins_h=(A.ins_h<<A.hash_shift^A.window[ve+1])&A.hash_mask;A.insert&&(A.ins_h=(A.ins_h<<A.hash_shift^A.window[ve+oe-1])&A.hash_mask,A.prev[ve&A.w_mask]=A.head[A.ins_h],A.head[A.ins_h]=ve,ve++,A.insert--,!(A.lookahead+A.insert<oe)););}while(A.lookahead<Ie&&A.strm.avail_in!==0)}function st(A,$e){for(var Pe,ae;;){if(A.lookahead<Ie){if(We(A),A.lookahead<Ie&&$e===v)return L;if(A.lookahead===0)break}if(Pe=0,A.lookahead>=oe&&(A.ins_h=(A.ins_h<<A.hash_shift^A.window[A.strstart+oe-1])&A.hash_mask,Pe=A.prev[A.strstart&A.w_mask]=A.head[A.ins_h],A.head[A.ins_h]=A.strstart),Pe!==0&&A.strstart-Pe<=A.w_size-Ie&&(A.match_length=Ne(A,Pe)),A.match_length>=oe)if(ae=_._tr_tally(A,A.strstart-A.match_start,A.match_length-oe),A.lookahead-=A.match_length,A.match_length<=A.max_lazy_match&&A.lookahead>=oe){for(A.match_length--;A.strstart++,A.ins_h=(A.ins_h<<A.hash_shift^A.window[A.strstart+oe-1])&A.hash_mask,Pe=A.prev[A.strstart&A.w_mask]=A.head[A.ins_h],A.head[A.ins_h]=A.strstart,--A.match_length!=0;);A.strstart++}else A.strstart+=A.match_length,A.match_length=0,A.ins_h=A.window[A.strstart],A.ins_h=(A.ins_h<<A.hash_shift^A.window[A.strstart+1])&A.hash_mask;else ae=_._tr_tally(A,0,A.window[A.strstart]),A.lookahead--,A.strstart++;if(ae&&(ge(A,!1),A.strm.avail_out===0))return L}return A.insert=A.strstart<oe-1?A.strstart:oe-1,$e===C?(ge(A,!0),A.strm.avail_out===0?Xe:ye):A.last_lit&&(ge(A,!1),A.strm.avail_out===0)?L:Ce}function pt(A,$e){for(var Pe,ae,ne;;){if(A.lookahead<Ie){if(We(A),A.lookahead<Ie&&$e===v)return L;if(A.lookahead===0)break}if(Pe=0,A.lookahead>=oe&&(A.ins_h=(A.ins_h<<A.hash_shift^A.window[A.strstart+oe-1])&A.hash_mask,Pe=A.prev[A.strstart&A.w_mask]=A.head[A.ins_h],A.head[A.ins_h]=A.strstart),A.prev_length=A.match_length,A.prev_match=A.match_start,A.match_length=oe-1,Pe!==0&&A.prev_length<A.max_lazy_match&&A.strstart-Pe<=A.w_size-Ie&&(A.match_length=Ne(A,Pe),A.match_length<=5&&(A.strategy===1||A.match_length===oe&&4096<A.strstart-A.match_start)&&(A.match_length=oe-1)),A.prev_length>=oe&&A.match_length<=A.prev_length){for(ne=A.strstart+A.lookahead-oe,ae=_._tr_tally(A,A.strstart-1-A.prev_match,A.prev_length-oe),A.lookahead-=A.prev_length-1,A.prev_length-=2;++A.strstart<=ne&&(A.ins_h=(A.ins_h<<A.hash_shift^A.window[A.strstart+oe-1])&A.hash_mask,Pe=A.prev[A.strstart&A.w_mask]=A.head[A.ins_h],A.head[A.ins_h]=A.strstart),--A.prev_length!=0;);if(A.match_available=0,A.match_length=oe-1,A.strstart++,ae&&(ge(A,!1),A.strm.avail_out===0))return L}else if(A.match_available){if((ae=_._tr_tally(A,0,A.window[A.strstart-1]))&&ge(A,!1),A.strstart++,A.lookahead--,A.strm.avail_out===0)return L}else A.match_available=1,A.strstart++,A.lookahead--}return A.match_available&&(ae=_._tr_tally(A,0,A.window[A.strstart-1]),A.match_available=0),A.insert=A.strstart<oe-1?A.strstart:oe-1,$e===C?(ge(A,!0),A.strm.avail_out===0?Xe:ye):A.last_lit&&(ge(A,!1),A.strm.avail_out===0)?L:Ce}function Ge(A,$e,Pe,ae,ne){this.good_length=A,this.max_lazy=$e,this.nice_length=Pe,this.max_chain=ae,this.func=ne}function xe(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=x,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new f.Buf16(2*j),this.dyn_dtree=new f.Buf16(2*(2*O+1)),this.bl_tree=new f.Buf16(2*(2*B+1)),Me(this.dyn_ltree),Me(this.dyn_dtree),Me(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new f.Buf16(N+1),this.heap=new f.Buf16(2*V+1),Me(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new f.Buf16(2*V+1),Me(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function je(A){var $e;return A&&A.state?(A.total_in=A.total_out=0,A.data_type=y,($e=A.state).pending=0,$e.pending_out=0,$e.wrap<0&&($e.wrap=-$e.wrap),$e.status=$e.wrap?te:we,A.adler=$e.wrap===2?0:1,$e.last_flush=v,_._tr_init($e),k):Y(A,z)}function Ye(A){var $e=je(A);return $e===k&&function(Pe){Pe.window_size=2*Pe.w_size,Me(Pe.head),Pe.max_lazy_match=l[Pe.level].max_lazy,Pe.good_match=l[Pe.level].good_length,Pe.nice_match=l[Pe.level].nice_length,Pe.max_chain_length=l[Pe.level].max_chain,Pe.strstart=0,Pe.block_start=0,Pe.lookahead=0,Pe.insert=0,Pe.match_length=Pe.prev_length=oe-1,Pe.match_available=0,Pe.ins_h=0}(A.state),$e}function et(A,$e,Pe,ae,ne,ve){if(!A)return z;var R=1;if($e===$&&($e=6),ae<0?(R=0,ae=-ae):15<ae&&(R=2,ae-=16),ne<1||I<ne||Pe!==x||ae<8||15<ae||$e<0||9<$e||ve<0||S<ve)return Y(A,z);ae===8&&(ae=9);var ee=new xe;return(A.state=ee).strm=A,ee.wrap=R,ee.gzhead=null,ee.w_bits=ae,ee.w_size=1<<ee.w_bits,ee.w_mask=ee.w_size-1,ee.hash_bits=ne+7,ee.hash_size=1<<ee.hash_bits,ee.hash_mask=ee.hash_size-1,ee.hash_shift=~~((ee.hash_bits+oe-1)/oe),ee.window=new f.Buf8(2*ee.w_size),ee.head=new f.Buf16(ee.hash_size),ee.prev=new f.Buf16(ee.w_size),ee.lit_bufsize=1<<ne+6,ee.pending_buf_size=4*ee.lit_bufsize,ee.pending_buf=new f.Buf8(ee.pending_buf_size),ee.d_buf=1*ee.lit_bufsize,ee.l_buf=3*ee.lit_bufsize,ee.level=$e,ee.strategy=ve,ee.method=Pe,Ye(A)}l=[new Ge(0,0,0,0,function(A,$e){var Pe=65535;for(Pe>A.pending_buf_size-5&&(Pe=A.pending_buf_size-5);;){if(A.lookahead<=1){if(We(A),A.lookahead===0&&$e===v)return L;if(A.lookahead===0)break}A.strstart+=A.lookahead,A.lookahead=0;var ae=A.block_start+Pe;if((A.strstart===0||A.strstart>=ae)&&(A.lookahead=A.strstart-ae,A.strstart=ae,ge(A,!1),A.strm.avail_out===0)||A.strstart-A.block_start>=A.w_size-Ie&&(ge(A,!1),A.strm.avail_out===0))return L}return A.insert=0,$e===C?(ge(A,!0),A.strm.avail_out===0?Xe:ye):(A.strstart>A.block_start&&(ge(A,!1),A.strm.avail_out),L)}),new Ge(4,4,8,4,st),new Ge(4,5,16,8,st),new Ge(4,6,32,32,st),new Ge(4,4,16,16,pt),new Ge(8,16,32,32,pt),new Ge(8,16,128,128,pt),new Ge(8,32,128,256,pt),new Ge(32,128,258,1024,pt),new Ge(32,258,258,4096,pt)],a.deflateInit=function(A,$e){return et(A,$e,x,15,8,0)},a.deflateInit2=et,a.deflateReset=Ye,a.deflateResetKeep=je,a.deflateSetHeader=function(A,$e){return A&&A.state?A.state.wrap!==2?z:(A.state.gzhead=$e,k):z},a.deflate=function(A,$e){var Pe,ae,ne,ve;if(!A||!A.state||5<$e||$e<0)return A?Y(A,z):z;if(ae=A.state,!A.output||!A.input&&A.avail_in!==0||ae.status===666&&$e!==C)return Y(A,A.avail_out===0?-5:z);if(ae.strm=A,Pe=ae.last_flush,ae.last_flush=$e,ae.status===te)if(ae.wrap===2)A.adler=0,qe(ae,31),qe(ae,139),qe(ae,8),ae.gzhead?(qe(ae,(ae.gzhead.text?1:0)+(ae.gzhead.hcrc?2:0)+(ae.gzhead.extra?4:0)+(ae.gzhead.name?8:0)+(ae.gzhead.comment?16:0)),qe(ae,255&ae.gzhead.time),qe(ae,ae.gzhead.time>>8&255),qe(ae,ae.gzhead.time>>16&255),qe(ae,ae.gzhead.time>>24&255),qe(ae,ae.level===9?2:2<=ae.strategy||ae.level<2?4:0),qe(ae,255&ae.gzhead.os),ae.gzhead.extra&&ae.gzhead.extra.length&&(qe(ae,255&ae.gzhead.extra.length),qe(ae,ae.gzhead.extra.length>>8&255)),ae.gzhead.hcrc&&(A.adler=g(A.adler,ae.pending_buf,ae.pending,0)),ae.gzindex=0,ae.status=69):(qe(ae,0),qe(ae,0),qe(ae,0),qe(ae,0),qe(ae,0),qe(ae,ae.level===9?2:2<=ae.strategy||ae.level<2?4:0),qe(ae,3),ae.status=we);else{var R=x+(ae.w_bits-8<<4)<<8;R|=(2<=ae.strategy||ae.level<2?0:ae.level<6?1:ae.level===6?2:3)<<6,ae.strstart!==0&&(R|=32),R+=31-R%31,ae.status=we,Be(ae,R),ae.strstart!==0&&(Be(ae,A.adler>>>16),Be(ae,65535&A.adler)),A.adler=1}if(ae.status===69)if(ae.gzhead.extra){for(ne=ae.pending;ae.gzindex<(65535&ae.gzhead.extra.length)&&(ae.pending!==ae.pending_buf_size||(ae.gzhead.hcrc&&ae.pending>ne&&(A.adler=g(A.adler,ae.pending_buf,ae.pending-ne,ne)),X(A),ne=ae.pending,ae.pending!==ae.pending_buf_size));)qe(ae,255&ae.gzhead.extra[ae.gzindex]),ae.gzindex++;ae.gzhead.hcrc&&ae.pending>ne&&(A.adler=g(A.adler,ae.pending_buf,ae.pending-ne,ne)),ae.gzindex===ae.gzhead.extra.length&&(ae.gzindex=0,ae.status=73)}else ae.status=73;if(ae.status===73)if(ae.gzhead.name){ne=ae.pending;do{if(ae.pending===ae.pending_buf_size&&(ae.gzhead.hcrc&&ae.pending>ne&&(A.adler=g(A.adler,ae.pending_buf,ae.pending-ne,ne)),X(A),ne=ae.pending,ae.pending===ae.pending_buf_size)){ve=1;break}ve=ae.gzindex<ae.gzhead.name.length?255&ae.gzhead.name.charCodeAt(ae.gzindex++):0,qe(ae,ve)}while(ve!==0);ae.gzhead.hcrc&&ae.pending>ne&&(A.adler=g(A.adler,ae.pending_buf,ae.pending-ne,ne)),ve===0&&(ae.gzindex=0,ae.status=91)}else ae.status=91;if(ae.status===91)if(ae.gzhead.comment){ne=ae.pending;do{if(ae.pending===ae.pending_buf_size&&(ae.gzhead.hcrc&&ae.pending>ne&&(A.adler=g(A.adler,ae.pending_buf,ae.pending-ne,ne)),X(A),ne=ae.pending,ae.pending===ae.pending_buf_size)){ve=1;break}ve=ae.gzindex<ae.gzhead.comment.length?255&ae.gzhead.comment.charCodeAt(ae.gzindex++):0,qe(ae,ve)}while(ve!==0);ae.gzhead.hcrc&&ae.pending>ne&&(A.adler=g(A.adler,ae.pending_buf,ae.pending-ne,ne)),ve===0&&(ae.status=103)}else ae.status=103;if(ae.status===103&&(ae.gzhead.hcrc?(ae.pending+2>ae.pending_buf_size&&X(A),ae.pending+2<=ae.pending_buf_size&&(qe(ae,255&A.adler),qe(ae,A.adler>>8&255),A.adler=0,ae.status=we)):ae.status=we),ae.pending!==0){if(X(A),A.avail_out===0)return ae.last_flush=-1,k}else if(A.avail_in===0&&se($e)<=se(Pe)&&$e!==C)return Y(A,-5);if(ae.status===666&&A.avail_in!==0)return Y(A,-5);if(A.avail_in!==0||ae.lookahead!==0||$e!==v&&ae.status!==666){var ee=ae.strategy===2?function(D,ce){for(var ue;;){if(D.lookahead===0&&(We(D),D.lookahead===0)){if(ce===v)return L;break}if(D.match_length=0,ue=_._tr_tally(D,0,D.window[D.strstart]),D.lookahead--,D.strstart++,ue&&(ge(D,!1),D.strm.avail_out===0))return L}return D.insert=0,ce===C?(ge(D,!0),D.strm.avail_out===0?Xe:ye):D.last_lit&&(ge(D,!1),D.strm.avail_out===0)?L:Ce}(ae,$e):ae.strategy===3?function(D,ce){for(var ue,ke,Re,ht,tt=D.window;;){if(D.lookahead<=he){if(We(D),D.lookahead<=he&&ce===v)return L;if(D.lookahead===0)break}if(D.match_length=0,D.lookahead>=oe&&0<D.strstart&&(ke=tt[Re=D.strstart-1])===tt[++Re]&&ke===tt[++Re]&&ke===tt[++Re]){ht=D.strstart+he;do;while(ke===tt[++Re]&&ke===tt[++Re]&&ke===tt[++Re]&&ke===tt[++Re]&&ke===tt[++Re]&&ke===tt[++Re]&&ke===tt[++Re]&&ke===tt[++Re]&&Re<ht);D.match_length=he-(ht-Re),D.match_length>D.lookahead&&(D.match_length=D.lookahead)}if(D.match_length>=oe?(ue=_._tr_tally(D,1,D.match_length-oe),D.lookahead-=D.match_length,D.strstart+=D.match_length,D.match_length=0):(ue=_._tr_tally(D,0,D.window[D.strstart]),D.lookahead--,D.strstart++),ue&&(ge(D,!1),D.strm.avail_out===0))return L}return D.insert=0,ce===C?(ge(D,!0),D.strm.avail_out===0?Xe:ye):D.last_lit&&(ge(D,!1),D.strm.avail_out===0)?L:Ce}(ae,$e):l[ae.level].func(ae,$e);if(ee!==Xe&&ee!==ye||(ae.status=666),ee===L||ee===Xe)return A.avail_out===0&&(ae.last_flush=-1),k;if(ee===Ce&&($e===1?_._tr_align(ae):$e!==5&&(_._tr_stored_block(ae,0,0,!1),$e===3&&(Me(ae.head),ae.lookahead===0&&(ae.strstart=0,ae.block_start=0,ae.insert=0))),X(A),A.avail_out===0))return ae.last_flush=-1,k}return $e!==C?k:ae.wrap<=0?1:(ae.wrap===2?(qe(ae,255&A.adler),qe(ae,A.adler>>8&255),qe(ae,A.adler>>16&255),qe(ae,A.adler>>24&255),qe(ae,255&A.total_in),qe(ae,A.total_in>>8&255),qe(ae,A.total_in>>16&255),qe(ae,A.total_in>>24&255)):(Be(ae,A.adler>>>16),Be(ae,65535&A.adler)),X(A),0<ae.wrap&&(ae.wrap=-ae.wrap),ae.pending!==0?k:1)},a.deflateEnd=function(A){var $e;return A&&A.state?($e=A.state.status)!==te&&$e!==69&&$e!==73&&$e!==91&&$e!==103&&$e!==we&&$e!==666?Y(A,z):(A.state=null,$e===we?Y(A,-3):k):z},a.deflateSetDictionary=function(A,$e){var Pe,ae,ne,ve,R,ee,D,ce,ue=$e.length;if(!A||!A.state||(ve=(Pe=A.state).wrap)===2||ve===1&&Pe.status!==te||Pe.lookahead)return z;for(ve===1&&(A.adler=m(A.adler,$e,ue,0)),Pe.wrap=0,ue>=Pe.w_size&&(ve===0&&(Me(Pe.head),Pe.strstart=0,Pe.block_start=0,Pe.insert=0),ce=new f.Buf8(Pe.w_size),f.arraySet(ce,$e,ue-Pe.w_size,Pe.w_size,0),$e=ce,ue=Pe.w_size),R=A.avail_in,ee=A.next_in,D=A.input,A.avail_in=ue,A.next_in=0,A.input=$e,We(Pe);Pe.lookahead>=oe;){for(ae=Pe.strstart,ne=Pe.lookahead-(oe-1);Pe.ins_h=(Pe.ins_h<<Pe.hash_shift^Pe.window[ae+oe-1])&Pe.hash_mask,Pe.prev[ae&Pe.w_mask]=Pe.head[Pe.ins_h],Pe.head[Pe.ins_h]=ae,ae++,--ne;);Pe.strstart=ae,Pe.lookahead=oe-1,We(Pe)}return Pe.strstart+=Pe.lookahead,Pe.block_start=Pe.strstart,Pe.insert=Pe.lookahead,Pe.lookahead=0,Pe.match_length=Pe.prev_length=oe-1,Pe.match_available=0,A.next_in=ee,A.input=D,A.avail_in=R,Pe.wrap=ve,k},a.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(n,o,a){o.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(n,o,a){o.exports=function(l,f){var _,m,g,M,v,C,k,z,$,S,y,x,I,V,O,B,j,N,oe,he,Ie,te,we,L,Ce;_=l.state,m=l.next_in,L=l.input,g=m+(l.avail_in-5),M=l.next_out,Ce=l.output,v=M-(f-l.avail_out),C=M+(l.avail_out-257),k=_.dmax,z=_.wsize,$=_.whave,S=_.wnext,y=_.window,x=_.hold,I=_.bits,V=_.lencode,O=_.distcode,B=(1<<_.lenbits)-1,j=(1<<_.distbits)-1;e:do{I<15&&(x+=L[m++]<<I,I+=8,x+=L[m++]<<I,I+=8),N=V[x&B];t:for(;;){if(x>>>=oe=N>>>24,I-=oe,(oe=N>>>16&255)===0)Ce[M++]=65535&N;else{if(!(16&oe)){if(!(64&oe)){N=V[(65535&N)+(x&(1<<oe)-1)];continue t}if(32&oe){_.mode=12;break e}l.msg="invalid literal/length code",_.mode=30;break e}he=65535&N,(oe&=15)&&(I<oe&&(x+=L[m++]<<I,I+=8),he+=x&(1<<oe)-1,x>>>=oe,I-=oe),I<15&&(x+=L[m++]<<I,I+=8,x+=L[m++]<<I,I+=8),N=O[x&j];r:for(;;){if(x>>>=oe=N>>>24,I-=oe,!(16&(oe=N>>>16&255))){if(!(64&oe)){N=O[(65535&N)+(x&(1<<oe)-1)];continue r}l.msg="invalid distance code",_.mode=30;break e}if(Ie=65535&N,I<(oe&=15)&&(x+=L[m++]<<I,(I+=8)<oe&&(x+=L[m++]<<I,I+=8)),k<(Ie+=x&(1<<oe)-1)){l.msg="invalid distance too far back",_.mode=30;break e}if(x>>>=oe,I-=oe,(oe=M-v)<Ie){if($<(oe=Ie-oe)&&_.sane){l.msg="invalid distance too far back",_.mode=30;break e}if(we=y,(te=0)===S){if(te+=z-oe,oe<he){for(he-=oe;Ce[M++]=y[te++],--oe;);te=M-Ie,we=Ce}}else if(S<oe){if(te+=z+S-oe,(oe-=S)<he){for(he-=oe;Ce[M++]=y[te++],--oe;);if(te=0,S<he){for(he-=oe=S;Ce[M++]=y[te++],--oe;);te=M-Ie,we=Ce}}}else if(te+=S-oe,oe<he){for(he-=oe;Ce[M++]=y[te++],--oe;);te=M-Ie,we=Ce}for(;2<he;)Ce[M++]=we[te++],Ce[M++]=we[te++],Ce[M++]=we[te++],he-=3;he&&(Ce[M++]=we[te++],1<he&&(Ce[M++]=we[te++]))}else{for(te=M-Ie;Ce[M++]=Ce[te++],Ce[M++]=Ce[te++],Ce[M++]=Ce[te++],2<(he-=3););he&&(Ce[M++]=Ce[te++],1<he&&(Ce[M++]=Ce[te++]))}break}}break}}while(m<g&&M<C);m-=he=I>>3,x&=(1<<(I-=he<<3))-1,l.next_in=m,l.next_out=M,l.avail_in=m<g?g-m+5:5-(m-g),l.avail_out=M<C?C-M+257:257-(M-C),_.hold=x,_.bits=I}},{}],49:[function(n,o,a){var l=n("../utils/common"),f=n("./adler32"),_=n("./crc32"),m=n("./inffast"),g=n("./inftrees"),M=1,v=2,C=0,k=-2,z=1,$=852,S=592;function y(te){return(te>>>24&255)+(te>>>8&65280)+((65280&te)<<8)+((255&te)<<24)}function x(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new l.Buf16(320),this.work=new l.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function I(te){var we;return te&&te.state?(we=te.state,te.total_in=te.total_out=we.total=0,te.msg="",we.wrap&&(te.adler=1&we.wrap),we.mode=z,we.last=0,we.havedict=0,we.dmax=32768,we.head=null,we.hold=0,we.bits=0,we.lencode=we.lendyn=new l.Buf32($),we.distcode=we.distdyn=new l.Buf32(S),we.sane=1,we.back=-1,C):k}function V(te){var we;return te&&te.state?((we=te.state).wsize=0,we.whave=0,we.wnext=0,I(te)):k}function O(te,we){var L,Ce;return te&&te.state?(Ce=te.state,we<0?(L=0,we=-we):(L=1+(we>>4),we<48&&(we&=15)),we&&(we<8||15<we)?k:(Ce.window!==null&&Ce.wbits!==we&&(Ce.window=null),Ce.wrap=L,Ce.wbits=we,V(te))):k}function B(te,we){var L,Ce;return te?(Ce=new x,(te.state=Ce).window=null,(L=O(te,we))!==C&&(te.state=null),L):k}var j,N,oe=!0;function he(te){if(oe){var we;for(j=new l.Buf32(512),N=new l.Buf32(32),we=0;we<144;)te.lens[we++]=8;for(;we<256;)te.lens[we++]=9;for(;we<280;)te.lens[we++]=7;for(;we<288;)te.lens[we++]=8;for(g(M,te.lens,0,288,j,0,te.work,{bits:9}),we=0;we<32;)te.lens[we++]=5;g(v,te.lens,0,32,N,0,te.work,{bits:5}),oe=!1}te.lencode=j,te.lenbits=9,te.distcode=N,te.distbits=5}function Ie(te,we,L,Ce){var Xe,ye=te.state;return ye.window===null&&(ye.wsize=1<<ye.wbits,ye.wnext=0,ye.whave=0,ye.window=new l.Buf8(ye.wsize)),Ce>=ye.wsize?(l.arraySet(ye.window,we,L-ye.wsize,ye.wsize,0),ye.wnext=0,ye.whave=ye.wsize):(Ce<(Xe=ye.wsize-ye.wnext)&&(Xe=Ce),l.arraySet(ye.window,we,L-Ce,Xe,ye.wnext),(Ce-=Xe)?(l.arraySet(ye.window,we,L-Ce,Ce,0),ye.wnext=Ce,ye.whave=ye.wsize):(ye.wnext+=Xe,ye.wnext===ye.wsize&&(ye.wnext=0),ye.whave<ye.wsize&&(ye.whave+=Xe))),0}a.inflateReset=V,a.inflateReset2=O,a.inflateResetKeep=I,a.inflateInit=function(te){return B(te,15)},a.inflateInit2=B,a.inflate=function(te,we){var L,Ce,Xe,ye,Y,se,Me,X,ge,qe,Be,Ne,We,st,pt,Ge,xe,je,Ye,et,A,$e,Pe,ae,ne=0,ve=new l.Buf8(4),R=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!te||!te.state||!te.output||!te.input&&te.avail_in!==0)return k;(L=te.state).mode===12&&(L.mode=13),Y=te.next_out,Xe=te.output,Me=te.avail_out,ye=te.next_in,Ce=te.input,se=te.avail_in,X=L.hold,ge=L.bits,qe=se,Be=Me,$e=C;e:for(;;)switch(L.mode){case z:if(L.wrap===0){L.mode=13;break}for(;ge<16;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if(2&L.wrap&&X===35615){ve[L.check=0]=255&X,ve[1]=X>>>8&255,L.check=_(L.check,ve,2,0),ge=X=0,L.mode=2;break}if(L.flags=0,L.head&&(L.head.done=!1),!(1&L.wrap)||(((255&X)<<8)+(X>>8))%31){te.msg="incorrect header check",L.mode=30;break}if((15&X)!=8){te.msg="unknown compression method",L.mode=30;break}if(ge-=4,A=8+(15&(X>>>=4)),L.wbits===0)L.wbits=A;else if(A>L.wbits){te.msg="invalid window size",L.mode=30;break}L.dmax=1<<A,te.adler=L.check=1,L.mode=512&X?10:12,ge=X=0;break;case 2:for(;ge<16;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if(L.flags=X,(255&L.flags)!=8){te.msg="unknown compression method",L.mode=30;break}if(57344&L.flags){te.msg="unknown header flags set",L.mode=30;break}L.head&&(L.head.text=X>>8&1),512&L.flags&&(ve[0]=255&X,ve[1]=X>>>8&255,L.check=_(L.check,ve,2,0)),ge=X=0,L.mode=3;case 3:for(;ge<32;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}L.head&&(L.head.time=X),512&L.flags&&(ve[0]=255&X,ve[1]=X>>>8&255,ve[2]=X>>>16&255,ve[3]=X>>>24&255,L.check=_(L.check,ve,4,0)),ge=X=0,L.mode=4;case 4:for(;ge<16;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}L.head&&(L.head.xflags=255&X,L.head.os=X>>8),512&L.flags&&(ve[0]=255&X,ve[1]=X>>>8&255,L.check=_(L.check,ve,2,0)),ge=X=0,L.mode=5;case 5:if(1024&L.flags){for(;ge<16;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}L.length=X,L.head&&(L.head.extra_len=X),512&L.flags&&(ve[0]=255&X,ve[1]=X>>>8&255,L.check=_(L.check,ve,2,0)),ge=X=0}else L.head&&(L.head.extra=null);L.mode=6;case 6:if(1024&L.flags&&(se<(Ne=L.length)&&(Ne=se),Ne&&(L.head&&(A=L.head.extra_len-L.length,L.head.extra||(L.head.extra=new Array(L.head.extra_len)),l.arraySet(L.head.extra,Ce,ye,Ne,A)),512&L.flags&&(L.check=_(L.check,Ce,Ne,ye)),se-=Ne,ye+=Ne,L.length-=Ne),L.length))break e;L.length=0,L.mode=7;case 7:if(2048&L.flags){if(se===0)break e;for(Ne=0;A=Ce[ye+Ne++],L.head&&A&&L.length<65536&&(L.head.name+=String.fromCharCode(A)),A&&Ne<se;);if(512&L.flags&&(L.check=_(L.check,Ce,Ne,ye)),se-=Ne,ye+=Ne,A)break e}else L.head&&(L.head.name=null);L.length=0,L.mode=8;case 8:if(4096&L.flags){if(se===0)break e;for(Ne=0;A=Ce[ye+Ne++],L.head&&A&&L.length<65536&&(L.head.comment+=String.fromCharCode(A)),A&&Ne<se;);if(512&L.flags&&(L.check=_(L.check,Ce,Ne,ye)),se-=Ne,ye+=Ne,A)break e}else L.head&&(L.head.comment=null);L.mode=9;case 9:if(512&L.flags){for(;ge<16;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if(X!==(65535&L.check)){te.msg="header crc mismatch",L.mode=30;break}ge=X=0}L.head&&(L.head.hcrc=L.flags>>9&1,L.head.done=!0),te.adler=L.check=0,L.mode=12;break;case 10:for(;ge<32;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}te.adler=L.check=y(X),ge=X=0,L.mode=11;case 11:if(L.havedict===0)return te.next_out=Y,te.avail_out=Me,te.next_in=ye,te.avail_in=se,L.hold=X,L.bits=ge,2;te.adler=L.check=1,L.mode=12;case 12:if(we===5||we===6)break e;case 13:if(L.last){X>>>=7&ge,ge-=7&ge,L.mode=27;break}for(;ge<3;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}switch(L.last=1&X,ge-=1,3&(X>>>=1)){case 0:L.mode=14;break;case 1:if(he(L),L.mode=20,we!==6)break;X>>>=2,ge-=2;break e;case 2:L.mode=17;break;case 3:te.msg="invalid block type",L.mode=30}X>>>=2,ge-=2;break;case 14:for(X>>>=7&ge,ge-=7&ge;ge<32;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if((65535&X)!=(X>>>16^65535)){te.msg="invalid stored block lengths",L.mode=30;break}if(L.length=65535&X,ge=X=0,L.mode=15,we===6)break e;case 15:L.mode=16;case 16:if(Ne=L.length){if(se<Ne&&(Ne=se),Me<Ne&&(Ne=Me),Ne===0)break e;l.arraySet(Xe,Ce,ye,Ne,Y),se-=Ne,ye+=Ne,Me-=Ne,Y+=Ne,L.length-=Ne;break}L.mode=12;break;case 17:for(;ge<14;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if(L.nlen=257+(31&X),X>>>=5,ge-=5,L.ndist=1+(31&X),X>>>=5,ge-=5,L.ncode=4+(15&X),X>>>=4,ge-=4,286<L.nlen||30<L.ndist){te.msg="too many length or distance symbols",L.mode=30;break}L.have=0,L.mode=18;case 18:for(;L.have<L.ncode;){for(;ge<3;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}L.lens[R[L.have++]]=7&X,X>>>=3,ge-=3}for(;L.have<19;)L.lens[R[L.have++]]=0;if(L.lencode=L.lendyn,L.lenbits=7,Pe={bits:L.lenbits},$e=g(0,L.lens,0,19,L.lencode,0,L.work,Pe),L.lenbits=Pe.bits,$e){te.msg="invalid code lengths set",L.mode=30;break}L.have=0,L.mode=19;case 19:for(;L.have<L.nlen+L.ndist;){for(;Ge=(ne=L.lencode[X&(1<<L.lenbits)-1])>>>16&255,xe=65535&ne,!((pt=ne>>>24)<=ge);){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if(xe<16)X>>>=pt,ge-=pt,L.lens[L.have++]=xe;else{if(xe===16){for(ae=pt+2;ge<ae;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if(X>>>=pt,ge-=pt,L.have===0){te.msg="invalid bit length repeat",L.mode=30;break}A=L.lens[L.have-1],Ne=3+(3&X),X>>>=2,ge-=2}else if(xe===17){for(ae=pt+3;ge<ae;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}ge-=pt,A=0,Ne=3+(7&(X>>>=pt)),X>>>=3,ge-=3}else{for(ae=pt+7;ge<ae;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}ge-=pt,A=0,Ne=11+(127&(X>>>=pt)),X>>>=7,ge-=7}if(L.have+Ne>L.nlen+L.ndist){te.msg="invalid bit length repeat",L.mode=30;break}for(;Ne--;)L.lens[L.have++]=A}}if(L.mode===30)break;if(L.lens[256]===0){te.msg="invalid code -- missing end-of-block",L.mode=30;break}if(L.lenbits=9,Pe={bits:L.lenbits},$e=g(M,L.lens,0,L.nlen,L.lencode,0,L.work,Pe),L.lenbits=Pe.bits,$e){te.msg="invalid literal/lengths set",L.mode=30;break}if(L.distbits=6,L.distcode=L.distdyn,Pe={bits:L.distbits},$e=g(v,L.lens,L.nlen,L.ndist,L.distcode,0,L.work,Pe),L.distbits=Pe.bits,$e){te.msg="invalid distances set",L.mode=30;break}if(L.mode=20,we===6)break e;case 20:L.mode=21;case 21:if(6<=se&&258<=Me){te.next_out=Y,te.avail_out=Me,te.next_in=ye,te.avail_in=se,L.hold=X,L.bits=ge,m(te,Be),Y=te.next_out,Xe=te.output,Me=te.avail_out,ye=te.next_in,Ce=te.input,se=te.avail_in,X=L.hold,ge=L.bits,L.mode===12&&(L.back=-1);break}for(L.back=0;Ge=(ne=L.lencode[X&(1<<L.lenbits)-1])>>>16&255,xe=65535&ne,!((pt=ne>>>24)<=ge);){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if(Ge&&!(240&Ge)){for(je=pt,Ye=Ge,et=xe;Ge=(ne=L.lencode[et+((X&(1<<je+Ye)-1)>>je)])>>>16&255,xe=65535&ne,!(je+(pt=ne>>>24)<=ge);){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}X>>>=je,ge-=je,L.back+=je}if(X>>>=pt,ge-=pt,L.back+=pt,L.length=xe,Ge===0){L.mode=26;break}if(32&Ge){L.back=-1,L.mode=12;break}if(64&Ge){te.msg="invalid literal/length code",L.mode=30;break}L.extra=15&Ge,L.mode=22;case 22:if(L.extra){for(ae=L.extra;ge<ae;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}L.length+=X&(1<<L.extra)-1,X>>>=L.extra,ge-=L.extra,L.back+=L.extra}L.was=L.length,L.mode=23;case 23:for(;Ge=(ne=L.distcode[X&(1<<L.distbits)-1])>>>16&255,xe=65535&ne,!((pt=ne>>>24)<=ge);){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if(!(240&Ge)){for(je=pt,Ye=Ge,et=xe;Ge=(ne=L.distcode[et+((X&(1<<je+Ye)-1)>>je)])>>>16&255,xe=65535&ne,!(je+(pt=ne>>>24)<=ge);){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}X>>>=je,ge-=je,L.back+=je}if(X>>>=pt,ge-=pt,L.back+=pt,64&Ge){te.msg="invalid distance code",L.mode=30;break}L.offset=xe,L.extra=15&Ge,L.mode=24;case 24:if(L.extra){for(ae=L.extra;ge<ae;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}L.offset+=X&(1<<L.extra)-1,X>>>=L.extra,ge-=L.extra,L.back+=L.extra}if(L.offset>L.dmax){te.msg="invalid distance too far back",L.mode=30;break}L.mode=25;case 25:if(Me===0)break e;if(Ne=Be-Me,L.offset>Ne){if((Ne=L.offset-Ne)>L.whave&&L.sane){te.msg="invalid distance too far back",L.mode=30;break}We=Ne>L.wnext?(Ne-=L.wnext,L.wsize-Ne):L.wnext-Ne,Ne>L.length&&(Ne=L.length),st=L.window}else st=Xe,We=Y-L.offset,Ne=L.length;for(Me<Ne&&(Ne=Me),Me-=Ne,L.length-=Ne;Xe[Y++]=st[We++],--Ne;);L.length===0&&(L.mode=21);break;case 26:if(Me===0)break e;Xe[Y++]=L.length,Me--,L.mode=21;break;case 27:if(L.wrap){for(;ge<32;){if(se===0)break e;se--,X|=Ce[ye++]<<ge,ge+=8}if(Be-=Me,te.total_out+=Be,L.total+=Be,Be&&(te.adler=L.check=L.flags?_(L.check,Xe,Be,Y-Be):f(L.check,Xe,Be,Y-Be)),Be=Me,(L.flags?X:y(X))!==L.check){te.msg="incorrect data check",L.mode=30;break}ge=X=0}L.mode=28;case 28:if(L.wrap&&L.flags){for(;ge<32;){if(se===0)break e;se--,X+=Ce[ye++]<<ge,ge+=8}if(X!==(4294967295&L.total)){te.msg="incorrect length check",L.mode=30;break}ge=X=0}L.mode=29;case 29:$e=1;break e;case 30:$e=-3;break e;case 31:return-4;case 32:default:return k}return te.next_out=Y,te.avail_out=Me,te.next_in=ye,te.avail_in=se,L.hold=X,L.bits=ge,(L.wsize||Be!==te.avail_out&&L.mode<30&&(L.mode<27||we!==4))&&Ie(te,te.output,te.next_out,Be-te.avail_out)?(L.mode=31,-4):(qe-=te.avail_in,Be-=te.avail_out,te.total_in+=qe,te.total_out+=Be,L.total+=Be,L.wrap&&Be&&(te.adler=L.check=L.flags?_(L.check,Xe,Be,te.next_out-Be):f(L.check,Xe,Be,te.next_out-Be)),te.data_type=L.bits+(L.last?64:0)+(L.mode===12?128:0)+(L.mode===20||L.mode===15?256:0),(qe==0&&Be===0||we===4)&&$e===C&&($e=-5),$e)},a.inflateEnd=function(te){if(!te||!te.state)return k;var we=te.state;return we.window&&(we.window=null),te.state=null,C},a.inflateGetHeader=function(te,we){var L;return te&&te.state&&2&(L=te.state).wrap?((L.head=we).done=!1,C):k},a.inflateSetDictionary=function(te,we){var L,Ce=we.length;return te&&te.state?(L=te.state).wrap!==0&&L.mode!==11?k:L.mode===11&&f(1,we,Ce,0)!==L.check?-3:Ie(te,we,Ce,Ce)?(L.mode=31,-4):(L.havedict=1,C):k},a.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(n,o,a){var l=n("../utils/common"),f=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],_=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],g=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];o.exports=function(M,v,C,k,z,$,S,y){var x,I,V,O,B,j,N,oe,he,Ie=y.bits,te=0,we=0,L=0,Ce=0,Xe=0,ye=0,Y=0,se=0,Me=0,X=0,ge=null,qe=0,Be=new l.Buf16(16),Ne=new l.Buf16(16),We=null,st=0;for(te=0;te<=15;te++)Be[te]=0;for(we=0;we<k;we++)Be[v[C+we]]++;for(Xe=Ie,Ce=15;1<=Ce&&Be[Ce]===0;Ce--);if(Ce<Xe&&(Xe=Ce),Ce===0)return z[$++]=20971520,z[$++]=20971520,y.bits=1,0;for(L=1;L<Ce&&Be[L]===0;L++);for(Xe<L&&(Xe=L),te=se=1;te<=15;te++)if(se<<=1,(se-=Be[te])<0)return-1;if(0<se&&(M===0||Ce!==1))return-1;for(Ne[1]=0,te=1;te<15;te++)Ne[te+1]=Ne[te]+Be[te];for(we=0;we<k;we++)v[C+we]!==0&&(S[Ne[v[C+we]]++]=we);if(j=M===0?(ge=We=S,19):M===1?(ge=f,qe-=257,We=_,st-=257,256):(ge=m,We=g,-1),te=L,B=$,Y=we=X=0,V=-1,O=(Me=1<<(ye=Xe))-1,M===1&&852<Me||M===2&&592<Me)return 1;for(;;){for(N=te-Y,he=S[we]<j?(oe=0,S[we]):S[we]>j?(oe=We[st+S[we]],ge[qe+S[we]]):(oe=96,0),x=1<<te-Y,L=I=1<<ye;z[B+(X>>Y)+(I-=x)]=N<<24|oe<<16|he|0,I!==0;);for(x=1<<te-1;X&x;)x>>=1;if(x!==0?(X&=x-1,X+=x):X=0,we++,--Be[te]==0){if(te===Ce)break;te=v[C+S[we]]}if(Xe<te&&(X&O)!==V){for(Y===0&&(Y=Xe),B+=L,se=1<<(ye=te-Y);ye+Y<Ce&&!((se-=Be[ye+Y])<=0);)ye++,se<<=1;if(Me+=1<<ye,M===1&&852<Me||M===2&&592<Me)return 1;z[V=X&O]=Xe<<24|ye<<16|B-$|0}}return X!==0&&(z[B+X]=te-Y<<24|64<<16|0),y.bits=Xe,0}},{"../utils/common":41}],51:[function(n,o,a){o.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(n,o,a){var l=n("../utils/common"),f=0,_=1;function m(ne){for(var ve=ne.length;0<=--ve;)ne[ve]=0}var g=0,M=29,v=256,C=v+1+M,k=30,z=19,$=2*C+1,S=15,y=16,x=7,I=256,V=16,O=17,B=18,j=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],N=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],oe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],he=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],Ie=new Array(2*(C+2));m(Ie);var te=new Array(2*k);m(te);var we=new Array(512);m(we);var L=new Array(256);m(L);var Ce=new Array(M);m(Ce);var Xe,ye,Y,se=new Array(k);function Me(ne,ve,R,ee,D){this.static_tree=ne,this.extra_bits=ve,this.extra_base=R,this.elems=ee,this.max_length=D,this.has_stree=ne&&ne.length}function X(ne,ve){this.dyn_tree=ne,this.max_code=0,this.stat_desc=ve}function ge(ne){return ne<256?we[ne]:we[256+(ne>>>7)]}function qe(ne,ve){ne.pending_buf[ne.pending++]=255&ve,ne.pending_buf[ne.pending++]=ve>>>8&255}function Be(ne,ve,R){ne.bi_valid>y-R?(ne.bi_buf|=ve<<ne.bi_valid&65535,qe(ne,ne.bi_buf),ne.bi_buf=ve>>y-ne.bi_valid,ne.bi_valid+=R-y):(ne.bi_buf|=ve<<ne.bi_valid&65535,ne.bi_valid+=R)}function Ne(ne,ve,R){Be(ne,R[2*ve],R[2*ve+1])}function We(ne,ve){for(var R=0;R|=1&ne,ne>>>=1,R<<=1,0<--ve;);return R>>>1}function st(ne,ve,R){var ee,D,ce=new Array(S+1),ue=0;for(ee=1;ee<=S;ee++)ce[ee]=ue=ue+R[ee-1]<<1;for(D=0;D<=ve;D++){var ke=ne[2*D+1];ke!==0&&(ne[2*D]=We(ce[ke]++,ke))}}function pt(ne){var ve;for(ve=0;ve<C;ve++)ne.dyn_ltree[2*ve]=0;for(ve=0;ve<k;ve++)ne.dyn_dtree[2*ve]=0;for(ve=0;ve<z;ve++)ne.bl_tree[2*ve]=0;ne.dyn_ltree[2*I]=1,ne.opt_len=ne.static_len=0,ne.last_lit=ne.matches=0}function Ge(ne){8<ne.bi_valid?qe(ne,ne.bi_buf):0<ne.bi_valid&&(ne.pending_buf[ne.pending++]=ne.bi_buf),ne.bi_buf=0,ne.bi_valid=0}function xe(ne,ve,R,ee){var D=2*ve,ce=2*R;return ne[D]<ne[ce]||ne[D]===ne[ce]&&ee[ve]<=ee[R]}function je(ne,ve,R){for(var ee=ne.heap[R],D=R<<1;D<=ne.heap_len&&(D<ne.heap_len&&xe(ve,ne.heap[D+1],ne.heap[D],ne.depth)&&D++,!xe(ve,ee,ne.heap[D],ne.depth));)ne.heap[R]=ne.heap[D],R=D,D<<=1;ne.heap[R]=ee}function Ye(ne,ve,R){var ee,D,ce,ue,ke=0;if(ne.last_lit!==0)for(;ee=ne.pending_buf[ne.d_buf+2*ke]<<8|ne.pending_buf[ne.d_buf+2*ke+1],D=ne.pending_buf[ne.l_buf+ke],ke++,ee===0?Ne(ne,D,ve):(Ne(ne,(ce=L[D])+v+1,ve),(ue=j[ce])!==0&&Be(ne,D-=Ce[ce],ue),Ne(ne,ce=ge(--ee),R),(ue=N[ce])!==0&&Be(ne,ee-=se[ce],ue)),ke<ne.last_lit;);Ne(ne,I,ve)}function et(ne,ve){var R,ee,D,ce=ve.dyn_tree,ue=ve.stat_desc.static_tree,ke=ve.stat_desc.has_stree,Re=ve.stat_desc.elems,ht=-1;for(ne.heap_len=0,ne.heap_max=$,R=0;R<Re;R++)ce[2*R]!==0?(ne.heap[++ne.heap_len]=ht=R,ne.depth[R]=0):ce[2*R+1]=0;for(;ne.heap_len<2;)ce[2*(D=ne.heap[++ne.heap_len]=ht<2?++ht:0)]=1,ne.depth[D]=0,ne.opt_len--,ke&&(ne.static_len-=ue[2*D+1]);for(ve.max_code=ht,R=ne.heap_len>>1;1<=R;R--)je(ne,ce,R);for(D=Re;R=ne.heap[1],ne.heap[1]=ne.heap[ne.heap_len--],je(ne,ce,1),ee=ne.heap[1],ne.heap[--ne.heap_max]=R,ne.heap[--ne.heap_max]=ee,ce[2*D]=ce[2*R]+ce[2*ee],ne.depth[D]=(ne.depth[R]>=ne.depth[ee]?ne.depth[R]:ne.depth[ee])+1,ce[2*R+1]=ce[2*ee+1]=D,ne.heap[1]=D++,je(ne,ce,1),2<=ne.heap_len;);ne.heap[--ne.heap_max]=ne.heap[1],function(tt,wt){var bt,Ke,de,Ae,Ve,ot,Qe=wt.dyn_tree,ft=wt.max_code,xt=wt.stat_desc.static_tree,vt=wt.stat_desc.has_stree,$t=wt.stat_desc.extra_bits,kt=wt.stat_desc.extra_base,rt=wt.stat_desc.max_length,Nt=0;for(Ae=0;Ae<=S;Ae++)tt.bl_count[Ae]=0;for(Qe[2*tt.heap[tt.heap_max]+1]=0,bt=tt.heap_max+1;bt<$;bt++)rt<(Ae=Qe[2*Qe[2*(Ke=tt.heap[bt])+1]+1]+1)&&(Ae=rt,Nt++),Qe[2*Ke+1]=Ae,ft<Ke||(tt.bl_count[Ae]++,Ve=0,kt<=Ke&&(Ve=$t[Ke-kt]),ot=Qe[2*Ke],tt.opt_len+=ot*(Ae+Ve),vt&&(tt.static_len+=ot*(xt[2*Ke+1]+Ve)));if(Nt!==0){do{for(Ae=rt-1;tt.bl_count[Ae]===0;)Ae--;tt.bl_count[Ae]--,tt.bl_count[Ae+1]+=2,tt.bl_count[rt]--,Nt-=2}while(0<Nt);for(Ae=rt;Ae!==0;Ae--)for(Ke=tt.bl_count[Ae];Ke!==0;)ft<(de=tt.heap[--bt])||(Qe[2*de+1]!==Ae&&(tt.opt_len+=(Ae-Qe[2*de+1])*Qe[2*de],Qe[2*de+1]=Ae),Ke--)}}(ne,ve),st(ce,ht,ne.bl_count)}function A(ne,ve,R){var ee,D,ce=-1,ue=ve[1],ke=0,Re=7,ht=4;for(ue===0&&(Re=138,ht=3),ve[2*(R+1)+1]=65535,ee=0;ee<=R;ee++)D=ue,ue=ve[2*(ee+1)+1],++ke<Re&&D===ue||(ke<ht?ne.bl_tree[2*D]+=ke:D!==0?(D!==ce&&ne.bl_tree[2*D]++,ne.bl_tree[2*V]++):ke<=10?ne.bl_tree[2*O]++:ne.bl_tree[2*B]++,ce=D,ht=(ke=0)===ue?(Re=138,3):D===ue?(Re=6,3):(Re=7,4))}function $e(ne,ve,R){var ee,D,ce=-1,ue=ve[1],ke=0,Re=7,ht=4;for(ue===0&&(Re=138,ht=3),ee=0;ee<=R;ee++)if(D=ue,ue=ve[2*(ee+1)+1],!(++ke<Re&&D===ue)){if(ke<ht)for(;Ne(ne,D,ne.bl_tree),--ke!=0;);else D!==0?(D!==ce&&(Ne(ne,D,ne.bl_tree),ke--),Ne(ne,V,ne.bl_tree),Be(ne,ke-3,2)):ke<=10?(Ne(ne,O,ne.bl_tree),Be(ne,ke-3,3)):(Ne(ne,B,ne.bl_tree),Be(ne,ke-11,7));ce=D,ht=(ke=0)===ue?(Re=138,3):D===ue?(Re=6,3):(Re=7,4)}}m(se);var Pe=!1;function ae(ne,ve,R,ee){Be(ne,(g<<1)+(ee?1:0),3),function(D,ce,ue,ke){Ge(D),qe(D,ue),qe(D,~ue),l.arraySet(D.pending_buf,D.window,ce,ue,D.pending),D.pending+=ue}(ne,ve,R)}a._tr_init=function(ne){Pe||(function(){var ve,R,ee,D,ce,ue=new Array(S+1);for(D=ee=0;D<M-1;D++)for(Ce[D]=ee,ve=0;ve<1<<j[D];ve++)L[ee++]=D;for(L[ee-1]=D,D=ce=0;D<16;D++)for(se[D]=ce,ve=0;ve<1<<N[D];ve++)we[ce++]=D;for(ce>>=7;D<k;D++)for(se[D]=ce<<7,ve=0;ve<1<<N[D]-7;ve++)we[256+ce++]=D;for(R=0;R<=S;R++)ue[R]=0;for(ve=0;ve<=143;)Ie[2*ve+1]=8,ve++,ue[8]++;for(;ve<=255;)Ie[2*ve+1]=9,ve++,ue[9]++;for(;ve<=279;)Ie[2*ve+1]=7,ve++,ue[7]++;for(;ve<=287;)Ie[2*ve+1]=8,ve++,ue[8]++;for(st(Ie,C+1,ue),ve=0;ve<k;ve++)te[2*ve+1]=5,te[2*ve]=We(ve,5);Xe=new Me(Ie,j,v+1,C,S),ye=new Me(te,N,0,k,S),Y=new Me(new Array(0),oe,0,z,x)}(),Pe=!0),ne.l_desc=new X(ne.dyn_ltree,Xe),ne.d_desc=new X(ne.dyn_dtree,ye),ne.bl_desc=new X(ne.bl_tree,Y),ne.bi_buf=0,ne.bi_valid=0,pt(ne)},a._tr_stored_block=ae,a._tr_flush_block=function(ne,ve,R,ee){var D,ce,ue=0;0<ne.level?(ne.strm.data_type===2&&(ne.strm.data_type=function(ke){var Re,ht=4093624447;for(Re=0;Re<=31;Re++,ht>>>=1)if(1&ht&&ke.dyn_ltree[2*Re]!==0)return f;if(ke.dyn_ltree[18]!==0||ke.dyn_ltree[20]!==0||ke.dyn_ltree[26]!==0)return _;for(Re=32;Re<v;Re++)if(ke.dyn_ltree[2*Re]!==0)return _;return f}(ne)),et(ne,ne.l_desc),et(ne,ne.d_desc),ue=function(ke){var Re;for(A(ke,ke.dyn_ltree,ke.l_desc.max_code),A(ke,ke.dyn_dtree,ke.d_desc.max_code),et(ke,ke.bl_desc),Re=z-1;3<=Re&&ke.bl_tree[2*he[Re]+1]===0;Re--);return ke.opt_len+=3*(Re+1)+5+5+4,Re}(ne),D=ne.opt_len+3+7>>>3,(ce=ne.static_len+3+7>>>3)<=D&&(D=ce)):D=ce=R+5,R+4<=D&&ve!==-1?ae(ne,ve,R,ee):ne.strategy===4||ce===D?(Be(ne,2+(ee?1:0),3),Ye(ne,Ie,te)):(Be(ne,4+(ee?1:0),3),function(ke,Re,ht,tt){var wt;for(Be(ke,Re-257,5),Be(ke,ht-1,5),Be(ke,tt-4,4),wt=0;wt<tt;wt++)Be(ke,ke.bl_tree[2*he[wt]+1],3);$e(ke,ke.dyn_ltree,Re-1),$e(ke,ke.dyn_dtree,ht-1)}(ne,ne.l_desc.max_code+1,ne.d_desc.max_code+1,ue+1),Ye(ne,ne.dyn_ltree,ne.dyn_dtree)),pt(ne),ee&&Ge(ne)},a._tr_tally=function(ne,ve,R){return ne.pending_buf[ne.d_buf+2*ne.last_lit]=ve>>>8&255,ne.pending_buf[ne.d_buf+2*ne.last_lit+1]=255&ve,ne.pending_buf[ne.l_buf+ne.last_lit]=255&R,ne.last_lit++,ve===0?ne.dyn_ltree[2*R]++:(ne.matches++,ve--,ne.dyn_ltree[2*(L[R]+v+1)]++,ne.dyn_dtree[2*ge(ve)]++),ne.last_lit===ne.lit_bufsize-1},a._tr_align=function(ne){Be(ne,2,3),Ne(ne,I,Ie),function(ve){ve.bi_valid===16?(qe(ve,ve.bi_buf),ve.bi_buf=0,ve.bi_valid=0):8<=ve.bi_valid&&(ve.pending_buf[ve.pending++]=255&ve.bi_buf,ve.bi_buf>>=8,ve.bi_valid-=8)}(ne)}},{"../utils/common":41}],53:[function(n,o,a){o.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(n,o,a){(function(l){(function(f,_){if(!f.setImmediate){var m,g,M,v,C=1,k={},z=!1,$=f.document,S=Object.getPrototypeOf&&Object.getPrototypeOf(f);S=S&&S.setTimeout?S:f,m={}.toString.call(f.process)==="[object process]"?function(V){process.nextTick(function(){x(V)})}:function(){if(f.postMessage&&!f.importScripts){var V=!0,O=f.onmessage;return f.onmessage=function(){V=!1},f.postMessage("","*"),f.onmessage=O,V}}()?(v="setImmediate$"+Math.random()+"$",f.addEventListener?f.addEventListener("message",I,!1):f.attachEvent("onmessage",I),function(V){f.postMessage(v+V,"*")}):f.MessageChannel?((M=new MessageChannel).port1.onmessage=function(V){x(V.data)},function(V){M.port2.postMessage(V)}):$&&"onreadystatechange"in $.createElement("script")?(g=$.documentElement,function(V){var O=$.createElement("script");O.onreadystatechange=function(){x(V),O.onreadystatechange=null,g.removeChild(O),O=null},g.appendChild(O)}):function(V){setTimeout(x,0,V)},S.setImmediate=function(V){typeof V!="function"&&(V=new Function(""+V));for(var O=new Array(arguments.length-1),B=0;B<O.length;B++)O[B]=arguments[B+1];var j={callback:V,args:O};return k[C]=j,m(C),C++},S.clearImmediate=y}function y(V){delete k[V]}function x(V){if(z)setTimeout(x,0,V);else{var O=k[V];if(O){z=!0;try{(function(B){var j=B.callback,N=B.args;switch(N.length){case 0:j();break;case 1:j(N[0]);break;case 2:j(N[0],N[1]);break;case 3:j(N[0],N[1],N[2]);break;default:j.apply(_,N)}})(O)}finally{y(V),z=!1}}}}function I(V){V.source===f&&typeof V.data=="string"&&V.data.indexOf(v)===0&&x(+V.data.slice(v.length))}})(typeof self>"u"?l===void 0?this:l:self)}).call(this,typeof Fo<"u"?Fo:typeof self<"u"?self:typeof window<"u"?window:{})},{}]},{},[10])(10)})})(_x);var IE=_x.exports;const FE=W_(IE);var yx={exports:{}};(function(e,t){(function(n,o){o()})(Fo,function(){function n(g,M){return typeof M>"u"?M={autoBom:!1}:typeof M!="object"&&(console.warn("Deprecated: Expected third argument to be a object"),M={autoBom:!M}),M.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(g.type)?new Blob(["\uFEFF",g],{type:g.type}):g}function o(g,M,v){var C=new XMLHttpRequest;C.open("GET",g),C.responseType="blob",C.onload=function(){m(C.response,M,v)},C.onerror=function(){console.error("could not download file")},C.send()}function a(g){var M=new XMLHttpRequest;M.open("HEAD",g,!1);try{M.send()}catch{}return 200<=M.status&&299>=M.status}function l(g){try{g.dispatchEvent(new MouseEvent("click"))}catch{var M=document.createEvent("MouseEvents");M.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),g.dispatchEvent(M)}}var f=typeof window=="object"&&window.window===window?window:typeof self=="object"&&self.self===self?self:typeof Fo=="object"&&Fo.global===Fo?Fo:void 0,_=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),m=f.saveAs||(typeof window!="object"||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!_?function(g,M,v){var C=f.URL||f.webkitURL,k=document.createElement("a");M=M||g.name||"download",k.download=M,k.rel="noopener",typeof g=="string"?(k.href=g,k.origin===location.origin?l(k):a(k.href)?o(g,M,v):l(k,k.target="_blank")):(k.href=C.createObjectURL(g),setTimeout(function(){C.revokeObjectURL(k.href)},4e4),setTimeout(function(){l(k)},0))}:"msSaveOrOpenBlob"in navigator?function(g,M,v){if(M=M||g.name||"download",typeof g!="string")navigator.msSaveOrOpenBlob(n(g,v),M);else if(a(g))o(g,M,v);else{var C=document.createElement("a");C.href=g,C.target="_blank",setTimeout(function(){l(C)})}}:function(g,M,v,C){if(C=C||open("","_blank"),C&&(C.document.title=C.document.body.innerText="downloading..."),typeof g=="string")return o(g,M,v);var k=g.type==="application/octet-stream",z=/constructor/i.test(f.HTMLElement)||f.safari,$=/CriOS\/[\d]+/.test(navigator.userAgent);if(($||k&&z||_)&&typeof FileReader<"u"){var S=new FileReader;S.onloadend=function(){var I=S.result;I=$?I:I.replace(/^data:[^;]*;/,"data:attachment/file;"),C?C.location.href=I:location=I,C=null},S.readAsDataURL(g)}else{var y=f.URL||f.webkitURL,x=y.createObjectURL(g);C?C.location=x:location.href=x,C=null,setTimeout(function(){y.revokeObjectURL(x)},4e4)}});f.saveAs=m.saveAs=m,e.exports=m})})(yx);var zE=yx.exports;const OE=async e=>{try{const n=await(await fetch(e)).blob(),o=new ClipboardItem({[n.type]:n});await navigator.clipboard.write([o])}catch(t){console.error("Failed to copy image: ",t)}},DE=e=>{const t=document.createElement("a");t.href=e,t.download="image.png",document.body.appendChild(t),t.click(),document.body.removeChild(t)},LE=async(e,t)=>{const n=new FE,o=e.map((l,f)=>new Promise(_=>{const m=document.createElement("canvas"),g=m.getContext("2d"),M=new Image;M.src=t[f]||l,M.onload=()=>{m.width=M.width,m.height=M.height,g.drawImage(M,0,0),m.toBlob(v=>{v&&n.file(`image-${f+1}.png`,v),_(null)},"image/png")}}));await Promise.all(o);const a=await n.generateAsync({type:"blob"});zE.saveAs(a,"images.zip")};function BE({isProcessing:e,images:t,processImages:n,isDownloadReady:o,processedImages:a,clearAll:l}){if(e)return Ut.jsx(Ut.Fragment,{});const f=Ut.jsxs("button",{onClick:l,className:"delete-button",children:[Ut.jsx("i",{className:"fa-solid fa-trash-can"}),"Borrar fotos"]});return Ut.jsx("div",{className:"results-actions flex flex-row items-center gap-4 mb-8",children:a.length>0?Ut.jsxs(Ut.Fragment,{children:[Ut.jsxs("button",{onClick:()=>LE(t,a),disabled:!o,className:"download-button px-3 py-1  text-white rounded-md focus:outline-none focus:ring-2  disabled:bg-gray-700 disabled:cursor-not-allowed transition-colors duration-200 text-sm",children:[Ut.jsx("i",{className:"fa-solid fa-download"}),"Descargar imagenes"]}),f]}):Ut.jsxs(Ut.Fragment,{children:[Ut.jsxs("button",{onClick:n,disabled:e||t.length===0,className:"process-button",children:[Ut.jsx("i",{className:"fa-solid fa-wand-magic-sparkles"}),e?"Borrando fondos...":"Eliminar fondos"]}),f]})})}function RE({images:e,processedImages:t,removeImage:n,isProcessing:o}){const[a,l]=fr.useState(!1),[f,_]=fr.useState(!1),m=g=>Ut.jsx("div",{"transition-style":g,style:{height:"100%",width:"100%",position:"absolute",top:0},children:Ut.jsx("div",{style:{height:"100%",width:"100%",borderRadius:"0.5rem",background:"#0fff9a"}})});return fr.useEffect(()=>{o?(console.log("entering"),_(!1),l(!0)):!o&&a&&(console.log("closing"),l(!1),_(!0))},[o]),Ut.jsx("div",{className:"gap-6 results-gallery",children:e.map((g,M)=>Ut.jsxs("div",{className:"relative group",children:[Ut.jsx("img",{src:t[M]||g,alt:`Image ${M+1}`,className:"rounded-lg object-cover w-full h-48"}),t[M]&&Ut.jsxs("div",{className:"photo-actions absolute inset-0 bg-black bg-opacity-70 opacity-0 group-hover:opacity-100 transition-opacity duration-300 rounded-lg flex items-center justify-center",children:[Ut.jsx("i",{className:"fa-solid fa-download cursor-pointer",onClick:()=>DE(t[M]||g)}),Ut.jsx("i",{className:"fa-regular fa-copy",onClick:()=>OE(t[M]||g)})]}),Ut.jsx("button",{onClick:()=>n(M),className:"absolute top-2 right-2 bg-black bg-opacity-50 text-white w-6 h-6 rounded-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300 hover:bg-opacity-70","aria-label":`Remove image ${M+1}`,children:""}),a&&m("in:circle:center"),f&&m("out:circle:center"),Ut.jsx("div",{className:"loader-container",style:{opacity:a?1:0},children:Ut.jsx("div",{className:"inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-black mb-4"})})]},M))})}function NE({error:e}){return Ut.jsx("div",{className:"min-h-screen bg-black text-white flex items-center justify-center",children:Ut.jsxs("div",{className:"text-center",children:[Ut.jsx("h2",{className:"text-4xl mb-2",children:"ERROR"}),Ut.jsx("p",{className:"text-xl max-w-[500px]",children:e.message})]})})}function jE(){return Ut.jsx("div",{className:"min-h-screen bg-black text-white flex items-center justify-center",children:Ut.jsxs("div",{className:"text-center",children:[Ut.jsx("div",{className:"inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-white mb-4"}),Ut.jsx("p",{className:"text-lg",children:"Cargando..."})]})})}var $o={},wx={"./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":(e,t,n)=>{e.exports=n.p+"ort-wasm-simd-threaded.jsep.wasm"},"?2ce3":()=>{},"?7a2c":()=>{},"?a42a":()=>{},"?2b25":()=>{},"?569f":()=>{},"?3f59":()=>{},"?154a":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(e,t,n)=>{n.r(t),n.d(t,{Environment:()=>$e,Interpreter:()=>Pe,Template:()=>ve,parse:()=>Me,tokenize:()=>v});var o=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),a=Object.freeze({set:o.Set,for:o.For,in:o.In,is:o.Is,if:o.If,else:o.Else,endif:o.EndIf,elif:o.ElseIf,endfor:o.EndFor,and:o.And,or:o.Or,not:o.Not,"not in":o.NotIn,macro:o.Macro,endmacro:o.EndMacro,true:o.BooleanLiteral,false:o.BooleanLiteral,True:o.BooleanLiteral,False:o.BooleanLiteral}),l=class{constructor(R,ee){this.value=R,this.type=ee}};function f(R){return/\w/.test(R)}function _(R){return/[0-9]/.test(R)}var m=[["{%",o.OpenStatement],["%}",o.CloseStatement],["{{",o.OpenExpression],["}}",o.CloseExpression],["(",o.OpenParen],[")",o.CloseParen],["{",o.OpenCurlyBracket],["}",o.CloseCurlyBracket],["[",o.OpenSquareBracket],["]",o.CloseSquareBracket],[",",o.Comma],[".",o.Dot],[":",o.Colon],["|",o.Pipe],["<=",o.ComparisonBinaryOperator],[">=",o.ComparisonBinaryOperator],["==",o.ComparisonBinaryOperator],["!=",o.ComparisonBinaryOperator],["<",o.ComparisonBinaryOperator],[">",o.ComparisonBinaryOperator],["+",o.AdditiveBinaryOperator],["-",o.AdditiveBinaryOperator],["*",o.MultiplicativeBinaryOperator],["/",o.MultiplicativeBinaryOperator],["%",o.MultiplicativeBinaryOperator],["=",o.Equals]],g=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function M(R,ee={}){return R.endsWith(`
`)&&(R=R.slice(0,-1)),R=R.replace(/{#.*?#}/gs,"{##}"),ee.lstrip_blocks&&(R=R.replace(/^[ \t]*({[#%])/gm,"$1")),ee.trim_blocks&&(R=R.replace(/([#%]})\n/g,"$1")),R.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function v(R,ee={}){var Re,ht,tt;const D=[],ce=M(R,ee);let ue=0;const ke=wt=>{let bt="";for(;wt(ce[ue]);){if(ce[ue]==="\\"){if(++ue,ue>=ce.length)throw new SyntaxError("Unexpected end of input");const Ke=ce[ue++],de=g.get(Ke);if(de===void 0)throw new SyntaxError(`Unexpected escaped character: ${Ke}`);bt+=de;continue}if(bt+=ce[ue++],ue>=ce.length)throw new SyntaxError("Unexpected end of input")}return bt};e:for(;ue<ce.length;){const wt=(Re=D.at(-1))==null?void 0:Re.type;if(wt===void 0||wt===o.CloseStatement||wt===o.CloseExpression){let Ke="";for(;ue<ce.length&&!(ce[ue]==="{"&&(ce[ue+1]==="%"||ce[ue+1]==="{"));)Ke+=ce[ue++];if(Ke.length>0){D.push(new l(Ke,o.Text));continue}}ke(Ke=>/\s/.test(Ke));const bt=ce[ue];if(bt==="-"||bt==="+"){const Ke=(ht=D.at(-1))==null?void 0:ht.type;if(Ke===o.Text||Ke===void 0)throw new SyntaxError(`Unexpected character: ${bt}`);switch(Ke){case o.Identifier:case o.NumericLiteral:case o.BooleanLiteral:case o.StringLiteral:case o.CloseParen:case o.CloseSquareBracket:break;default:{++ue;const de=ke(_);D.push(new l(`${bt}${de}`,de.length>0?o.NumericLiteral:o.UnaryOperator));continue}}}for(const[Ke,de]of m)if(ce.slice(ue,ue+Ke.length)===Ke){D.push(new l(Ke,de)),ue+=Ke.length;continue e}if(bt==="'"||bt==='"'){++ue;const Ke=ke(de=>de!==bt);D.push(new l(Ke,o.StringLiteral)),++ue;continue}if(_(bt)){const Ke=ke(_);D.push(new l(Ke,o.NumericLiteral));continue}if(f(bt)){const Ke=ke(f),de=Object.hasOwn(a,Ke)?a[Ke]:o.Identifier;de===o.In&&((tt=D.at(-1))==null?void 0:tt.type)===o.Not?(D.pop(),D.push(new l("not in",o.NotIn))):D.push(new l(Ke,de));continue}throw new SyntaxError(`Unexpected character: ${bt}`)}return D}var C=class{constructor(){He(this,"type","Statement")}},k=class extends C{constructor(ee){super();He(this,"type","Program");this.body=ee}},z=class extends C{constructor(ee,D,ce){super();He(this,"type","If");this.test=ee,this.body=D,this.alternate=ce}},$=class extends C{constructor(ee,D,ce,ue){super();He(this,"type","For");this.loopvar=ee,this.iterable=D,this.body=ce,this.defaultBlock=ue}},S=class extends C{constructor(ee,D){super();He(this,"type","Set");this.assignee=ee,this.value=D}},y=class extends C{constructor(ee,D,ce){super();He(this,"type","Macro");this.name=ee,this.args=D,this.body=ce}},x=class extends C{constructor(){super(...arguments);He(this,"type","Expression")}},I=class extends x{constructor(ee,D,ce){super();He(this,"type","MemberExpression");this.object=ee,this.property=D,this.computed=ce}},V=class extends x{constructor(ee,D){super();He(this,"type","CallExpression");this.callee=ee,this.args=D}},O=class extends x{constructor(ee){super();He(this,"type","Identifier");this.value=ee}},B=class extends x{constructor(ee){super();He(this,"type","Literal");this.value=ee}},j=class extends B{constructor(){super(...arguments);He(this,"type","NumericLiteral")}},N=class extends B{constructor(){super(...arguments);He(this,"type","StringLiteral")}},oe=class extends B{constructor(){super(...arguments);He(this,"type","BooleanLiteral")}},he=class extends B{constructor(){super(...arguments);He(this,"type","ArrayLiteral")}},Ie=class extends B{constructor(){super(...arguments);He(this,"type","TupleLiteral")}},te=class extends B{constructor(){super(...arguments);He(this,"type","ObjectLiteral")}},we=class extends x{constructor(ee,D,ce){super();He(this,"type","BinaryExpression");this.operator=ee,this.left=D,this.right=ce}},L=class extends x{constructor(ee,D){super();He(this,"type","FilterExpression");this.operand=ee,this.filter=D}},Ce=class extends x{constructor(ee,D){super();He(this,"type","SelectExpression");this.iterable=ee,this.test=D}},Xe=class extends x{constructor(ee,D,ce){super();He(this,"type","TestExpression");this.operand=ee,this.negate=D,this.test=ce}},ye=class extends x{constructor(ee,D){super();He(this,"type","UnaryExpression");this.operator=ee,this.argument=D}},Y=class extends x{constructor(ee=void 0,D=void 0,ce=void 0){super();He(this,"type","SliceExpression");this.start=ee,this.stop=D,this.step=ce}},se=class extends x{constructor(ee,D){super();He(this,"type","KeywordArgumentExpression");this.key=ee,this.value=D}};function Me(R){const ee=new k([]);let D=0;function ce(mt,Tt){const Lt=R[D++];if(!Lt||Lt.type!==mt)throw new Error(`Parser Error: ${Tt}. ${Lt.type} !== ${mt}.`);return Lt}function ue(){switch(R[D].type){case o.Text:return ht();case o.OpenStatement:return tt();case o.OpenExpression:return wt();default:throw new SyntaxError(`Unexpected token type: ${R[D].type}`)}}function ke(...mt){return D+mt.length<=R.length&&mt.some((Tt,Lt)=>Tt!==R[D+Lt].type)}function Re(...mt){return D+mt.length<=R.length&&mt.every((Tt,Lt)=>Tt===R[D+Lt].type)}function ht(){return new N(ce(o.Text,"Expected text token").value)}function tt(){ce(o.OpenStatement,"Expected opening statement token");let mt;switch(R[D].type){case o.Set:++D,mt=bt(),ce(o.CloseStatement,"Expected closing statement token");break;case o.If:++D,mt=Ke(),ce(o.OpenStatement,"Expected {% token"),ce(o.EndIf,"Expected endif token"),ce(o.CloseStatement,"Expected %} token");break;case o.Macro:++D,mt=de(),ce(o.OpenStatement,"Expected {% token"),ce(o.EndMacro,"Expected endmacro token"),ce(o.CloseStatement,"Expected %} token");break;case o.For:++D,mt=Ve(),ce(o.OpenStatement,"Expected {% token"),ce(o.EndFor,"Expected endfor token"),ce(o.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${R[D].type}`)}return mt}function wt(){ce(o.OpenExpression,"Expected opening expression token");const mt=ot();return ce(o.CloseExpression,"Expected closing expression token"),mt}function bt(){const mt=ot();if(Re(o.Equals)){++D;const Tt=bt();return new S(mt,Tt)}return mt}function Ke(){var nn,yi,Ai,Qr,kn,Yr,wi,Nr;const mt=ot();ce(o.CloseStatement,"Expected closing statement token");const Tt=[],Lt=[];for(;!(((nn=R[D])==null?void 0:nn.type)===o.OpenStatement&&(((yi=R[D+1])==null?void 0:yi.type)===o.ElseIf||((Ai=R[D+1])==null?void 0:Ai.type)===o.Else||((Qr=R[D+1])==null?void 0:Qr.type)===o.EndIf));)Tt.push(ue());if(((kn=R[D])==null?void 0:kn.type)===o.OpenStatement&&((Yr=R[D+1])==null?void 0:Yr.type)!==o.EndIf)if(++D,Re(o.ElseIf))ce(o.ElseIf,"Expected elseif token"),Lt.push(Ke());else for(ce(o.Else,"Expected else token"),ce(o.CloseStatement,"Expected closing statement token");!(((wi=R[D])==null?void 0:wi.type)===o.OpenStatement&&((Nr=R[D+1])==null?void 0:Nr.type)===o.EndIf);)Lt.push(ue());return new z(mt,Tt,Lt)}function de(){const mt=kr();if(mt.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const Tt=Rt();ce(o.CloseStatement,"Expected closing statement token");const Lt=[];for(;ke(o.OpenStatement,o.EndMacro);)Lt.push(ue());return new y(mt,Tt,Lt)}function Ae(mt=!1){const Tt=mt?kr:ot,Lt=[Tt()],nn=Re(o.Comma);for(;nn&&(++D,Lt.push(Tt()),!!Re(o.Comma)););return nn?new Ie(Lt):Lt[0]}function Ve(){const mt=Ae(!0);if(!(mt instanceof O||mt instanceof Ie))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${mt.type} instead`);ce(o.In,"Expected `in` keyword following loop variable");const Tt=ot();ce(o.CloseStatement,"Expected closing statement token");const Lt=[];for(;ke(o.OpenStatement,o.EndFor)&&ke(o.OpenStatement,o.Else);)Lt.push(ue());const nn=[];if(Re(o.OpenStatement,o.Else))for(++D,++D,ce(o.CloseStatement,"Expected closing statement token");ke(o.OpenStatement,o.EndFor);)nn.push(ue());return new $(mt,Tt,Lt,nn)}function ot(){return Qe()}function Qe(){const mt=ft();if(Re(o.If)){++D;const Tt=ft();if(Re(o.Else)){++D;const Lt=ft();return new z(Tt,[mt],[Lt])}else return new Ce(mt,Tt)}return mt}function ft(){let mt=xt();for(;Re(o.Or);){const Tt=R[D];++D;const Lt=xt();mt=new we(Tt,mt,Lt)}return mt}function xt(){let mt=vt();for(;Re(o.And);){const Tt=R[D];++D;const Lt=vt();mt=new we(Tt,mt,Lt)}return mt}function vt(){let mt;for(;Re(o.Not);){const Tt=R[D];++D;const Lt=vt();mt=new ye(Tt,Lt)}return mt??$t()}function $t(){let mt=kt();for(;Re(o.ComparisonBinaryOperator)||Re(o.In)||Re(o.NotIn);){const Tt=R[D];++D;const Lt=kt();mt=new we(Tt,mt,Lt)}return mt}function kt(){let mt=tr();for(;Re(o.AdditiveBinaryOperator);){const Tt=R[D];++D;const Lt=tr();mt=new we(Tt,mt,Lt)}return mt}function rt(){const mt=Gt();return Re(o.OpenParen)?Nt(mt):mt}function Nt(mt){let Tt=new V(mt,Rt());return Re(o.OpenParen)&&(Tt=Nt(Tt)),Tt}function Rt(){ce(o.OpenParen,"Expected opening parenthesis for arguments list");const mt=Qt();return ce(o.CloseParen,"Expected closing parenthesis for arguments list"),mt}function Qt(){const mt=[];for(;!Re(o.CloseParen);){let Tt=ot();if(Re(o.Equals)){if(++D,!(Tt instanceof O))throw new SyntaxError("Expected identifier for keyword argument");const Lt=ot();Tt=new se(Tt,Lt)}mt.push(Tt),Re(o.Comma)&&++D}return mt}function Ht(){const mt=[];let Tt=!1;for(;!Re(o.CloseSquareBracket);)Re(o.Colon)?(mt.push(void 0),++D,Tt=!0):(mt.push(ot()),Re(o.Colon)&&(++D,Tt=!0));if(mt.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(Tt){if(mt.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new Y(...mt)}return mt[0]}function Gt(){let mt=kr();for(;Re(o.Dot)||Re(o.OpenSquareBracket);){const Tt=R[D];++D;let Lt;const nn=Tt.type!==o.Dot;if(nn)Lt=Ht(),ce(o.CloseSquareBracket,"Expected closing square bracket");else if(Lt=kr(),Lt.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");mt=new I(mt,Lt,nn)}return mt}function tr(){let mt=ir();for(;Re(o.MultiplicativeBinaryOperator);){const Tt=R[D];++D;const Lt=ir();mt=new we(Tt,mt,Lt)}return mt}function ir(){let mt=lr();for(;Re(o.Is);){++D;const Tt=Re(o.Not);Tt&&++D;let Lt=kr();if(Lt instanceof oe&&(Lt=new O(Lt.value.toString())),!(Lt instanceof O))throw new SyntaxError("Expected identifier for the test");mt=new Xe(mt,Tt,Lt)}return mt}function lr(){let mt=rt();for(;Re(o.Pipe);){++D;let Tt=kr();if(!(Tt instanceof O))throw new SyntaxError("Expected identifier for the filter");Re(o.OpenParen)&&(Tt=Nt(Tt)),mt=new L(mt,Tt)}return mt}function kr(){const mt=R[D];switch(mt.type){case o.NumericLiteral:return++D,new j(Number(mt.value));case o.StringLiteral:return++D,new N(mt.value);case o.BooleanLiteral:return++D,new oe(mt.value.toLowerCase()==="true");case o.Identifier:return++D,new O(mt.value);case o.OpenParen:{++D;const Tt=Ae();if(R[D].type!==o.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${R[D].type} instead`);return++D,Tt}case o.OpenSquareBracket:{++D;const Tt=[];for(;!Re(o.CloseSquareBracket);)Tt.push(ot()),Re(o.Comma)&&++D;return++D,new he(Tt)}case o.OpenCurlyBracket:{++D;const Tt=new Map;for(;!Re(o.CloseCurlyBracket);){const Lt=ot();ce(o.Colon,"Expected colon between key and value in object literal");const nn=ot();Tt.set(Lt,nn),Re(o.Comma)&&++D}return++D,new te(Tt)}default:throw new SyntaxError(`Unexpected token: ${mt.type}`)}}for(;D<R.length;)ee.body.push(ue());return ee}function X(R,ee,D=1){ee===void 0&&(ee=R,R=0);const ce=[];for(let ue=R;ue<ee;ue+=D)ce.push(ue);return ce}function ge(R,ee,D,ce=1){const ue=Math.sign(ce);ue>=0?(ee=(ee??(ee=0))<0?Math.max(R.length+ee,0):Math.min(ee,R.length),D=(D??(D=R.length))<0?Math.max(R.length+D,0):Math.min(D,R.length)):(ee=(ee??(ee=R.length-1))<0?Math.max(R.length+ee,-1):Math.min(ee,R.length-1),D=(D??(D=-1))<-1?Math.max(R.length+D,-1):Math.min(D,R.length-1));const ke=[];for(let Re=ee;ue*Re<ue*D;Re+=ce)ke.push(R[Re]);return ke}function qe(R){return R.replace(/\b\w/g,ee=>ee.toUpperCase())}var Be=class{constructor(R=void 0){He(this,"type","RuntimeValue");He(this,"value");He(this,"builtins",new Map);this.value=R}__bool__(){return new st(!!this.value)}},Ne=class extends Be{constructor(){super(...arguments);He(this,"type","NumericValue")}},We=class extends Be{constructor(){super(...arguments);He(this,"type","StringValue");He(this,"builtins",new Map([["upper",new Ye(()=>new We(this.value.toUpperCase()))],["lower",new Ye(()=>new We(this.value.toLowerCase()))],["strip",new Ye(()=>new We(this.value.trim()))],["title",new Ye(()=>new We(qe(this.value)))],["length",new Ne(this.value.length)]]))}},st=class extends Be{constructor(){super(...arguments);He(this,"type","BooleanValue")}},pt=class extends Be{constructor(){super(...arguments);He(this,"type","ObjectValue");He(this,"builtins",new Map([["get",new Ye(([ee,D])=>{if(!(ee instanceof We))throw new Error(`Object key must be a string: got ${ee.type}`);return this.value.get(ee.value)??D??new et})],["items",new Ye(()=>new xe(Array.from(this.value.entries()).map(([ee,D])=>new xe([new We(ee),D]))))]]))}__bool__(){return new st(this.value.size>0)}},Ge=class extends pt{constructor(){super(...arguments);He(this,"type","KeywordArgumentsValue")}},xe=class extends Be{constructor(){super(...arguments);He(this,"type","ArrayValue");He(this,"builtins",new Map([["length",new Ne(this.value.length)]]))}__bool__(){return new st(this.value.length>0)}},je=class extends xe{constructor(){super(...arguments);He(this,"type","TupleValue")}},Ye=class extends Be{constructor(){super(...arguments);He(this,"type","FunctionValue")}},et=class extends Be{constructor(){super(...arguments);He(this,"type","NullValue")}},A=class extends Be{constructor(){super(...arguments);He(this,"type","UndefinedValue")}},$e=class{constructor(R){He(this,"variables",new Map([["namespace",new Ye(R=>{if(R.length===0)return new pt(new Map);if(R.length!==1||!(R[0]instanceof pt))throw new Error("`namespace` expects either zero arguments or a single object argument");return R[0]})]]));He(this,"tests",new Map([["boolean",R=>R.type==="BooleanValue"],["callable",R=>R instanceof Ye],["odd",R=>{if(R.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${R.type}`);return R.value%2!==0}],["even",R=>{if(R.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${R.type}`);return R.value%2===0}],["false",R=>R.type==="BooleanValue"&&!R.value],["true",R=>R.type==="BooleanValue"&&R.value],["string",R=>R.type==="StringValue"],["number",R=>R.type==="NumericValue"],["integer",R=>R.type==="NumericValue"&&Number.isInteger(R.value)],["iterable",R=>R instanceof xe||R instanceof We],["lower",R=>{const ee=R.value;return R.type==="StringValue"&&ee===ee.toLowerCase()}],["upper",R=>{const ee=R.value;return R.type==="StringValue"&&ee===ee.toUpperCase()}],["none",R=>R.type==="NullValue"],["defined",R=>R.type!=="UndefinedValue"],["undefined",R=>R.type==="UndefinedValue"],["equalto",(R,ee)=>R.value===ee.value],["eq",(R,ee)=>R.value===ee.value]]));this.parent=R}set(R,ee){return this.declareVariable(R,ae(ee))}declareVariable(R,ee){if(this.variables.has(R))throw new SyntaxError(`Variable already declared: ${R}`);return this.variables.set(R,ee),ee}setVariable(R,ee){return this.variables.set(R,ee),ee}resolve(R){if(this.variables.has(R))return this;if(this.parent)return this.parent.resolve(R);throw new Error(`Unknown variable: ${R}`)}lookupVariable(R){try{return this.resolve(R).variables.get(R)??new A}catch{return new A}}},Pe=class{constructor(R){He(this,"global");this.global=R??new $e}run(R){return this.evaluate(R,this.global)}evaluateBinaryExpression(R,ee){const D=this.evaluate(R.left,ee);switch(R.operator.value){case"and":return D.__bool__().value?this.evaluate(R.right,ee):D;case"or":return D.__bool__().value?D:this.evaluate(R.right,ee)}const ce=this.evaluate(R.right,ee);switch(R.operator.value){case"==":return new st(D.value==ce.value);case"!=":return new st(D.value!=ce.value)}if(D instanceof A||ce instanceof A)throw new Error("Cannot perform operation on undefined values");if(D instanceof et||ce instanceof et)throw new Error("Cannot perform operation on null values");if(D instanceof Ne&&ce instanceof Ne)switch(R.operator.value){case"+":return new Ne(D.value+ce.value);case"-":return new Ne(D.value-ce.value);case"*":return new Ne(D.value*ce.value);case"/":return new Ne(D.value/ce.value);case"%":return new Ne(D.value%ce.value);case"<":return new st(D.value<ce.value);case">":return new st(D.value>ce.value);case">=":return new st(D.value>=ce.value);case"<=":return new st(D.value<=ce.value)}else if(D instanceof xe&&ce instanceof xe)switch(R.operator.value){case"+":return new xe(D.value.concat(ce.value))}else if(ce instanceof xe){const ue=ce.value.find(ke=>ke.value===D.value)!==void 0;switch(R.operator.value){case"in":return new st(ue);case"not in":return new st(!ue)}}if(D instanceof We||ce instanceof We)switch(R.operator.value){case"+":return new We(D.value.toString()+ce.value.toString())}if(D instanceof We&&ce instanceof We)switch(R.operator.value){case"in":return new st(ce.value.includes(D.value));case"not in":return new st(!ce.value.includes(D.value))}if(D instanceof We&&ce instanceof pt)switch(R.operator.value){case"in":return new st(ce.value.has(D.value));case"not in":return new st(!ce.value.has(D.value))}throw new SyntaxError(`Unknown operator "${R.operator.value}" between ${D.type} and ${ce.type}`)}evaluateArguments(R,ee){const D=[],ce=new Map;for(const ue of R)if(ue.type==="KeywordArgumentExpression"){const ke=ue;ce.set(ke.key.value,this.evaluate(ke.value,ee))}else{if(ce.size>0)throw new Error("Positional arguments must come before keyword arguments");D.push(this.evaluate(ue,ee))}return[D,ce]}evaluateFilterExpression(R,ee){const D=this.evaluate(R.operand,ee);if(R.filter.type==="Identifier"){const ce=R.filter;if(ce.value==="tojson")return new We(ne(D));if(D instanceof xe)switch(ce.value){case"list":return D;case"first":return D.value[0];case"last":return D.value[D.value.length-1];case"length":return new Ne(D.value.length);case"reverse":return new xe(D.value.reverse());case"sort":return new xe(D.value.sort((ue,ke)=>{if(ue.type!==ke.type)throw new Error(`Cannot compare different types: ${ue.type} and ${ke.type}`);switch(ue.type){case"NumericValue":return ue.value-ke.value;case"StringValue":return ue.value.localeCompare(ke.value);default:throw new Error(`Cannot compare type: ${ue.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${ce.value}`)}else if(D instanceof We)switch(ce.value){case"length":return new Ne(D.value.length);case"upper":return new We(D.value.toUpperCase());case"lower":return new We(D.value.toLowerCase());case"title":return new We(qe(D.value));case"capitalize":return new We(D.value.charAt(0).toUpperCase()+D.value.slice(1));case"trim":return new We(D.value.trim());case"indent":return new We(D.value.split(`
`).map((ue,ke)=>ke===0||ue.length===0?ue:"    "+ue).join(`
`));case"string":return D;default:throw new Error(`Unknown StringValue filter: ${ce.value}`)}else if(D instanceof Ne)switch(ce.value){case"abs":return new Ne(Math.abs(D.value));default:throw new Error(`Unknown NumericValue filter: ${ce.value}`)}else if(D instanceof pt)switch(ce.value){case"items":return new xe(Array.from(D.value.entries()).map(([ue,ke])=>new xe([new We(ue),ke])));case"length":return new Ne(D.value.size);default:throw new Error(`Unknown ObjectValue filter: ${ce.value}`)}throw new Error(`Cannot apply filter "${ce.value}" to type: ${D.type}`)}else if(R.filter.type==="CallExpression"){const ce=R.filter;if(ce.callee.type!=="Identifier")throw new Error(`Unknown filter: ${ce.callee.type}`);const ue=ce.callee.value;if(ue==="tojson"){const[,ke]=this.evaluateArguments(ce.args,ee),Re=ke.get("indent")??new et;if(!(Re instanceof Ne||Re instanceof et))throw new Error("If set, indent must be a number");return new We(ne(D,Re.value))}if(D instanceof xe){switch(ue){case"selectattr":{if(D.value.some(bt=>!(bt instanceof pt)))throw new Error("`selectattr` can only be applied to array of objects");if(ce.args.some(bt=>bt.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[ke,Re,ht]=ce.args.map(bt=>this.evaluate(bt,ee));let tt;if(Re){const bt=ee.tests.get(Re.value);if(!bt)throw new Error(`Unknown test: ${Re.value}`);tt=bt}else tt=(...bt)=>bt[0].__bool__().value;const wt=D.value.filter(bt=>{const Ke=bt.value.get(ke.value);return Ke?tt(Ke,ht):!1});return new xe(wt)}case"map":{const[,ke]=this.evaluateArguments(ce.args,ee);if(ke.has("attribute")){const Re=ke.get("attribute");if(!(Re instanceof We))throw new Error("attribute must be a string");const ht=ke.get("default"),tt=D.value.map(wt=>{if(!(wt instanceof pt))throw new Error("items in map must be an object");return wt.value.get(Re.value)??ht??new A});return new xe(tt)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${ue}`)}else if(D instanceof We){switch(ue){case"indent":{const[ke,Re]=this.evaluateArguments(ce.args,ee),ht=ke.at(0)??Re.get("width")??new Ne(4);if(!(ht instanceof Ne))throw new Error("width must be a number");const tt=ke.at(1)??Re.get("first")??new st(!1),wt=ke.at(2)??Re.get("blank")??new st(!1),bt=D.value.split(`
`),Ke=" ".repeat(ht.value),de=bt.map((Ae,Ve)=>!tt.value&&Ve===0||!wt.value&&Ae.length===0?Ae:Ke+Ae);return new We(de.join(`
`))}}throw new Error(`Unknown StringValue filter: ${ue}`)}else throw new Error(`Cannot apply filter "${ue}" to type: ${D.type}`)}throw new Error(`Unknown filter: ${R.filter.type}`)}evaluateTestExpression(R,ee){const D=this.evaluate(R.operand,ee),ce=ee.tests.get(R.test.value);if(!ce)throw new Error(`Unknown test: ${R.test.value}`);const ue=ce(D);return new st(R.negate?!ue:ue)}evaluateUnaryExpression(R,ee){const D=this.evaluate(R.argument,ee);switch(R.operator.value){case"not":return new st(!D.value);default:throw new SyntaxError(`Unknown operator: ${R.operator.value}`)}}evalProgram(R,ee){return this.evaluateBlock(R.body,ee)}evaluateBlock(R,ee){let D="";for(const ce of R){const ue=this.evaluate(ce,ee);ue.type!=="NullValue"&&ue.type!=="UndefinedValue"&&(D+=ue.value)}return new We(D)}evaluateIdentifier(R,ee){return ee.lookupVariable(R.value)}evaluateCallExpression(R,ee){const[D,ce]=this.evaluateArguments(R.args,ee);ce.size>0&&D.push(new Ge(ce));const ue=this.evaluate(R.callee,ee);if(ue.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${ue.type}`);return ue.value(D,ee)}evaluateSliceExpression(R,ee,D){if(!(R instanceof xe||R instanceof We))throw new Error("Slice object must be an array or string");const ce=this.evaluate(ee.start,D),ue=this.evaluate(ee.stop,D),ke=this.evaluate(ee.step,D);if(!(ce instanceof Ne||ce instanceof A))throw new Error("Slice start must be numeric or undefined");if(!(ue instanceof Ne||ue instanceof A))throw new Error("Slice stop must be numeric or undefined");if(!(ke instanceof Ne||ke instanceof A))throw new Error("Slice step must be numeric or undefined");return R instanceof xe?new xe(ge(R.value,ce.value,ue.value,ke.value)):new We(ge(Array.from(R.value),ce.value,ue.value,ke.value).join(""))}evaluateMemberExpression(R,ee){const D=this.evaluate(R.object,ee);let ce;if(R.computed){if(R.property.type==="SliceExpression")return this.evaluateSliceExpression(D,R.property,ee);ce=this.evaluate(R.property,ee)}else ce=new We(R.property.value);let ue;if(D instanceof pt){if(!(ce instanceof We))throw new Error(`Cannot access property with non-string: got ${ce.type}`);ue=D.value.get(ce.value)??D.builtins.get(ce.value)}else if(D instanceof xe||D instanceof We)if(ce instanceof Ne)ue=D.value.at(ce.value),D instanceof We&&(ue=new We(D.value.at(ce.value)));else if(ce instanceof We)ue=D.builtins.get(ce.value);else throw new Error(`Cannot access property with non-string/non-number: got ${ce.type}`);else{if(!(ce instanceof We))throw new Error(`Cannot access property with non-string: got ${ce.type}`);ue=D.builtins.get(ce.value)}return ue instanceof Be?ue:new A}evaluateSet(R,ee){const D=this.evaluate(R.value,ee);if(R.assignee.type==="Identifier"){const ce=R.assignee.value;ee.setVariable(ce,D)}else if(R.assignee.type==="MemberExpression"){const ce=R.assignee,ue=this.evaluate(ce.object,ee);if(!(ue instanceof pt))throw new Error("Cannot assign to member of non-object");if(ce.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");ue.value.set(ce.property.value,D)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(R.assignee)}`);return new et}evaluateIf(R,ee){const D=this.evaluate(R.test,ee);return this.evaluateBlock(D.__bool__().value?R.body:R.alternate,ee)}evaluateFor(R,ee){const D=new $e(ee);let ce,ue;if(R.iterable.type==="SelectExpression"){const wt=R.iterable;ue=this.evaluate(wt.iterable,D),ce=wt.test}else ue=this.evaluate(R.iterable,D);if(!(ue instanceof xe))throw new Error(`Expected iterable type in for loop: got ${ue.type}`);const ke=[],Re=[];for(let wt=0;wt<ue.value.length;++wt){const bt=new $e(D),Ke=ue.value[wt];let de;if(R.loopvar.type==="Identifier")de=Ae=>Ae.setVariable(R.loopvar.value,Ke);else if(R.loopvar.type==="TupleLiteral"){const Ae=R.loopvar;if(Ke.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${Ke.type}`);const Ve=Ke;if(Ae.value.length!==Ve.value.length)throw new Error(`Too ${Ae.value.length>Ve.value.length?"few":"many"} items to unpack`);de=ot=>{for(let Qe=0;Qe<Ae.value.length;++Qe){if(Ae.value[Qe].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${Ae.value[Qe].type}`);ot.setVariable(Ae.value[Qe].value,Ve.value[Qe])}}}else throw new Error(`Invalid loop variable(s): ${R.loopvar.type}`);ce&&(de(bt),!this.evaluate(ce,bt).__bool__().value)||(ke.push(Ke),Re.push(de))}let ht="",tt=!0;for(let wt=0;wt<ke.length;++wt){const bt=new Map([["index",new Ne(wt+1)],["index0",new Ne(wt)],["revindex",new Ne(ke.length-wt)],["revindex0",new Ne(ke.length-wt-1)],["first",new st(wt===0)],["last",new st(wt===ke.length-1)],["length",new Ne(ke.length)],["previtem",wt>0?ke[wt-1]:new A],["nextitem",wt<ke.length-1?ke[wt+1]:new A]]);D.setVariable("loop",new pt(bt)),Re[wt](D);const Ke=this.evaluateBlock(R.body,D);ht+=Ke.value,tt=!1}if(tt){const wt=this.evaluateBlock(R.defaultBlock,D);ht+=wt.value}return new We(ht)}evaluateMacro(R,ee){return ee.setVariable(R.name.value,new Ye((D,ce)=>{var Re;const ue=new $e(ce);D=D.slice();let ke;((Re=D.at(-1))==null?void 0:Re.type)==="KeywordArgumentsValue"&&(ke=D.pop());for(let ht=0;ht<R.args.length;++ht){const tt=R.args[ht],wt=D[ht];if(tt.type==="Identifier"){const bt=tt;if(!wt)throw new Error(`Missing positional argument: ${bt.value}`);ue.setVariable(bt.value,wt)}else if(tt.type==="KeywordArgumentExpression"){const bt=tt,Ke=wt??(ke==null?void 0:ke.value.get(bt.key.value))??this.evaluate(bt.value,ue);ue.setVariable(bt.key.value,Ke)}else throw new Error(`Unknown argument type: ${tt.type}`)}return this.evaluateBlock(R.body,ue)})),new et}evaluate(R,ee){if(R===void 0)return new A;switch(R.type){case"Program":return this.evalProgram(R,ee);case"Set":return this.evaluateSet(R,ee);case"If":return this.evaluateIf(R,ee);case"For":return this.evaluateFor(R,ee);case"Macro":return this.evaluateMacro(R,ee);case"NumericLiteral":return new Ne(Number(R.value));case"StringLiteral":return new We(R.value);case"BooleanLiteral":return new st(R.value);case"ArrayLiteral":return new xe(R.value.map(D=>this.evaluate(D,ee)));case"TupleLiteral":return new je(R.value.map(D=>this.evaluate(D,ee)));case"ObjectLiteral":{const D=new Map;for(const[ce,ue]of R.value){const ke=this.evaluate(ce,ee);if(!(ke instanceof We))throw new Error(`Object keys must be strings: got ${ke.type}`);D.set(ke.value,this.evaluate(ue,ee))}return new pt(D)}case"Identifier":return this.evaluateIdentifier(R,ee);case"CallExpression":return this.evaluateCallExpression(R,ee);case"MemberExpression":return this.evaluateMemberExpression(R,ee);case"UnaryExpression":return this.evaluateUnaryExpression(R,ee);case"BinaryExpression":return this.evaluateBinaryExpression(R,ee);case"FilterExpression":return this.evaluateFilterExpression(R,ee);case"TestExpression":return this.evaluateTestExpression(R,ee);default:throw new SyntaxError(`Unknown node type: ${R.type}`)}}};function ae(R){switch(typeof R){case"number":return new Ne(R);case"string":return new We(R);case"boolean":return new st(R);case"undefined":return new A;case"object":return R===null?new et:Array.isArray(R)?new xe(R.map(ae)):new pt(new Map(Object.entries(R).map(([ee,D])=>[ee,ae(D)])));case"function":return new Ye((ee,D)=>{const ce=R(...ee.map(ue=>ue.value))??null;return ae(ce)});default:throw new Error(`Cannot convert to runtime value: ${R}`)}}function ne(R,ee,D){const ce=D??0;switch(R.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(R.value);case"ArrayValue":case"ObjectValue":{const ue=ee?" ".repeat(ee):"",ke=`
`+ue.repeat(ce),Re=ke+ue;if(R.type==="ArrayValue"){const ht=R.value.map(tt=>ne(tt,ee,ce+1));return ee?`[${Re}${ht.join(`,${Re}`)}${ke}]`:`[${ht.join(", ")}]`}else{const ht=Array.from(R.value.entries()).map(([tt,wt])=>{const bt=`"${tt}": ${ne(wt,ee,ce+1)}`;return ee?`${Re}${bt}`:bt});return ee?`{${ht.join(",")}${ke}}`:`{${ht.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${R.type}`)}}var ve=class{constructor(R){He(this,"parsed");const ee=v(R,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=Me(ee)}render(R){const ee=new $e;ee.set("false",!1),ee.set("true",!0),ee.set("raise_exception",ue=>{throw new Error(ue)}),ee.set("range",X);for(const[ue,ke]of Object.entries(R))ee.set(ue,ke);return new Pe(ee).run(this.parsed).value}}},"./node_modules/onnxruntime-common/dist/esm/backend-impl.js":(e,t,n)=>{n.r(t),n.d(t,{registerBackend:()=>l,resolveBackendAndExecutionProviders:()=>_});const o=new Map,a=[],l=(m,g,M)=>{if(g&&typeof g.init=="function"&&typeof g.createInferenceSessionHandler=="function"){const v=o.get(m);if(v===void 0)o.set(m,{backend:g,priority:M});else{if(v.priority>M)return;if(v.priority===M&&v.backend!==g)throw new Error(`cannot register backend "${m}" using priority ${M}`)}if(M>=0){const C=a.indexOf(m);C!==-1&&a.splice(C,1);for(let k=0;k<a.length;k++)if(o.get(a[k]).priority<=M){a.splice(k,0,m);return}a.push(m)}return}throw new TypeError("not a valid backend")},f=async m=>{const g=o.get(m);if(!g)return"backend not found.";if(g.initialized)return g.backend;if(g.aborted)return g.error;{const M=!!g.initPromise;try{return M||(g.initPromise=g.backend.init(m)),await g.initPromise,g.initialized=!0,g.backend}catch(v){return M||(g.error=`${v}`,g.aborted=!0),g.error}finally{delete g.initPromise}}},_=async m=>{const g=m.executionProviders||[],M=g.map(S=>typeof S=="string"?S:S.name),v=M.length===0?a:M;let C;const k=[],z=new Set;for(const S of v){const y=await f(S);typeof y=="string"?k.push({name:S,err:y}):(C||(C=y),C===y&&z.add(S))}if(!C)throw new Error(`no available backend found. ERR: ${k.map(S=>`[${S.name}] ${S.err}`).join(", ")}`);for(const{name:S,err:y}of k)M.includes(S)&&console.warn(`removing requested execution provider "${S}" from session options because it is not available: ${y}`);const $=g.filter(S=>z.has(typeof S=="string"?S:S.name));return[C,new Proxy(m,{get:(S,y)=>y==="executionProviders"?$:Reflect.get(S,y)})]}},"./node_modules/onnxruntime-common/dist/esm/backend.js":(e,t,n)=>{n.r(t),n.d(t,{registerBackend:()=>o.registerBackend});var o=n("./node_modules/onnxruntime-common/dist/esm/backend-impl.js")},"./node_modules/onnxruntime-common/dist/esm/env-impl.js":(e,t,n)=>{n.r(t),n.d(t,{env:()=>l});var o=n("./node_modules/onnxruntime-common/dist/esm/version.js");let a="warning";const l={wasm:{},webgl:{},webgpu:{},versions:{common:o.version},set logLevel(f){if(f!==void 0){if(typeof f!="string"||["verbose","info","warning","error","fatal"].indexOf(f)===-1)throw new Error(`Unsupported logging level: ${f}`);a=f}},get logLevel(){return a}};Object.defineProperty(l,"logLevel",{enumerable:!0})},"./node_modules/onnxruntime-common/dist/esm/env.js":(e,t,n)=>{n.r(t),n.d(t,{env:()=>a});var o=n("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const a=o.env},"./node_modules/onnxruntime-common/dist/esm/index.js":(e,t,n)=>{n.r(t),n.d(t,{InferenceSession:()=>l.InferenceSession,TRACE:()=>_.TRACE,TRACE_FUNC_BEGIN:()=>_.TRACE_FUNC_BEGIN,TRACE_FUNC_END:()=>_.TRACE_FUNC_END,Tensor:()=>f.Tensor,TrainingSession:()=>m.TrainingSession,env:()=>a.env,registerBackend:()=>o.registerBackend});var o=n("./node_modules/onnxruntime-common/dist/esm/backend.js"),a=n("./node_modules/onnxruntime-common/dist/esm/env.js"),l=n("./node_modules/onnxruntime-common/dist/esm/inference-session.js"),f=n("./node_modules/onnxruntime-common/dist/esm/tensor.js");n("./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js"),n("./node_modules/onnxruntime-common/dist/esm/tensor-factory.js");var _=n("./node_modules/onnxruntime-common/dist/esm/trace.js");n("./node_modules/onnxruntime-common/dist/esm/onnx-model.js"),n("./node_modules/onnxruntime-common/dist/esm/onnx-value.js");var m=n("./node_modules/onnxruntime-common/dist/esm/training-session.js")},"./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js":(e,t,n)=>{n.r(t),n.d(t,{InferenceSession:()=>f});var o=n("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),a=n("./node_modules/onnxruntime-common/dist/esm/tensor.js"),l=n("./node_modules/onnxruntime-common/dist/esm/trace.js");class f{constructor(m){this.handler=m}async run(m,g,M){(0,l.TRACE_FUNC_BEGIN)();const v={};let C={};if(typeof m!="object"||m===null||m instanceof a.Tensor||Array.isArray(m))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let k=!0;if(typeof g=="object"){if(g===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(g instanceof a.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(g)){if(g.length===0)throw new TypeError("'fetches' cannot be an empty array.");k=!1;for(const S of g){if(typeof S!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(S)===-1)throw new RangeError(`'fetches' contains invalid output name: ${S}.`);v[S]=null}if(typeof M=="object"&&M!==null)C=M;else if(typeof M<"u")throw new TypeError("'options' must be an object.")}else{let S=!1;const y=Object.getOwnPropertyNames(g);for(const x of this.outputNames)if(y.indexOf(x)!==-1){const I=g[x];(I===null||I instanceof a.Tensor)&&(S=!0,k=!1,v[x]=I)}if(S){if(typeof M=="object"&&M!==null)C=M;else if(typeof M<"u")throw new TypeError("'options' must be an object.")}else C=g}}else if(typeof g<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const S of this.inputNames)if(typeof m[S]>"u")throw new Error(`input '${S}' is missing in 'feeds'.`);if(k)for(const S of this.outputNames)v[S]=null;const z=await this.handler.run(m,v,C),$={};for(const S in z)if(Object.hasOwnProperty.call(z,S)){const y=z[S];y instanceof a.Tensor?$[S]=y:$[S]=new a.Tensor(y.type,y.data,y.dims)}return(0,l.TRACE_FUNC_END)(),$}async release(){return this.handler.dispose()}static async create(m,g,M,v){(0,l.TRACE_FUNC_BEGIN)();let C,k={};if(typeof m=="string"){if(C=m,typeof g=="object"&&g!==null)k=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else if(m instanceof Uint8Array){if(C=m,typeof g=="object"&&g!==null)k=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else if(m instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&m instanceof SharedArrayBuffer){const y=m;let x=0,I=m.byteLength;if(typeof g=="object"&&g!==null)k=g;else if(typeof g=="number"){if(x=g,!Number.isSafeInteger(x))throw new RangeError("'byteOffset' must be an integer.");if(x<0||x>=y.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${y.byteLength}).`);if(I=m.byteLength-x,typeof M=="number"){if(I=M,!Number.isSafeInteger(I))throw new RangeError("'byteLength' must be an integer.");if(I<=0||x+I>y.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${y.byteLength-x}].`);if(typeof v=="object"&&v!==null)k=v;else if(typeof v<"u")throw new TypeError("'options' must be an object.")}else if(typeof M<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof g<"u")throw new TypeError("'options' must be an object.");C=new Uint8Array(y,x,I)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[z,$]=await(0,o.resolveBackendAndExecutionProviders)(k),S=await z.createInferenceSessionHandler(C,$);return(0,l.TRACE_FUNC_END)(),new f(S)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}},"./node_modules/onnxruntime-common/dist/esm/inference-session.js":(e,t,n)=>{n.r(t),n.d(t,{InferenceSession:()=>a});var o=n("./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js");const a=o.InferenceSession},"./node_modules/onnxruntime-common/dist/esm/onnx-model.js":(e,t,n)=>{n.r(t)},"./node_modules/onnxruntime-common/dist/esm/onnx-value.js":(e,t,n)=>{n.r(t)},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js":(e,t,n)=>{n.r(t),n.d(t,{tensorToDataURL:()=>o,tensorToImageData:()=>a});const o=(l,f)=>{const _=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);_.width=l.dims[3],_.height=l.dims[2];const m=_.getContext("2d");if(m!=null){let g,M;(f==null?void 0:f.tensorLayout)!==void 0&&f.tensorLayout==="NHWC"?(g=l.dims[2],M=l.dims[3]):(g=l.dims[3],M=l.dims[2]);const v=(f==null?void 0:f.format)!==void 0?f.format:"RGB",C=f==null?void 0:f.norm;let k,z;C===void 0||C.mean===void 0?k=[255,255,255,255]:typeof C.mean=="number"?k=[C.mean,C.mean,C.mean,C.mean]:(k=[C.mean[0],C.mean[1],C.mean[2],0],C.mean[3]!==void 0&&(k[3]=C.mean[3])),C===void 0||C.bias===void 0?z=[0,0,0,0]:typeof C.bias=="number"?z=[C.bias,C.bias,C.bias,C.bias]:(z=[C.bias[0],C.bias[1],C.bias[2],0],C.bias[3]!==void 0&&(z[3]=C.bias[3]));const $=M*g;let S=0,y=$,x=$*2,I=-1;v==="RGBA"?(S=0,y=$,x=$*2,I=$*3):v==="RGB"?(S=0,y=$,x=$*2):v==="RBG"&&(S=0,x=$,y=$*2);for(let V=0;V<M;V++)for(let O=0;O<g;O++){const B=(l.data[S++]-z[0])*k[0],j=(l.data[y++]-z[1])*k[1],N=(l.data[x++]-z[2])*k[2],oe=I===-1?255:(l.data[I++]-z[3])*k[3];m.fillStyle="rgba("+B+","+j+","+N+","+oe+")",m.fillRect(O,V,1,1)}if("toDataURL"in _)return _.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},a=(l,f)=>{const _=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let m;if(_!=null){let g,M,v;(f==null?void 0:f.tensorLayout)!==void 0&&f.tensorLayout==="NHWC"?(g=l.dims[2],M=l.dims[1],v=l.dims[3]):(g=l.dims[3],M=l.dims[2],v=l.dims[1]);const C=f!==void 0&&f.format!==void 0?f.format:"RGB",k=f==null?void 0:f.norm;let z,$;k===void 0||k.mean===void 0?z=[255,255,255,255]:typeof k.mean=="number"?z=[k.mean,k.mean,k.mean,k.mean]:(z=[k.mean[0],k.mean[1],k.mean[2],255],k.mean[3]!==void 0&&(z[3]=k.mean[3])),k===void 0||k.bias===void 0?$=[0,0,0,0]:typeof k.bias=="number"?$=[k.bias,k.bias,k.bias,k.bias]:($=[k.bias[0],k.bias[1],k.bias[2],0],k.bias[3]!==void 0&&($[3]=k.bias[3]));const S=M*g;if(f!==void 0&&(f.format!==void 0&&v===4&&f.format!=="RGBA"||v===3&&f.format!=="RGB"&&f.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const y=4;let x=0,I=1,V=2,O=3,B=0,j=S,N=S*2,oe=-1;C==="RGBA"?(B=0,j=S,N=S*2,oe=S*3):C==="RGB"?(B=0,j=S,N=S*2):C==="RBG"&&(B=0,N=S,j=S*2),m=_.createImageData(g,M);for(let he=0;he<M*g;x+=y,I+=y,V+=y,O+=y,he++)m.data[x]=(l.data[B++]-$[0])*z[0],m.data[I]=(l.data[j++]-$[1])*z[1],m.data[V]=(l.data[N++]-$[2])*z[2],m.data[O]=oe===-1?255:(l.data[oe++]-$[3])*z[3]}else throw new Error("Can not access image data");return m}},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js":(e,t,n)=>{n.r(t)},"./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js":(e,t,n)=>{n.r(t),n.d(t,{bufferToTensor:()=>a,tensorFromGpuBuffer:()=>_,tensorFromImage:()=>l,tensorFromPinnedBuffer:()=>m,tensorFromTexture:()=>f});var o=n("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const a=(g,M)=>{if(g===void 0)throw new Error("Image buffer must be defined");if(M.height===void 0||M.width===void 0)throw new Error("Image height and width must be defined");if(M.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:v,width:C}=M,k=M.norm??{mean:255,bias:0};let z,$;typeof k.mean=="number"?z=[k.mean,k.mean,k.mean,k.mean]:z=[k.mean[0],k.mean[1],k.mean[2],k.mean[3]??255],typeof k.bias=="number"?$=[k.bias,k.bias,k.bias,k.bias]:$=[k.bias[0],k.bias[1],k.bias[2],k.bias[3]??0];const S=M.format!==void 0?M.format:"RGBA",y=M.tensorFormat!==void 0&&M.tensorFormat!==void 0?M.tensorFormat:"RGB",x=v*C,I=y==="RGBA"?new Float32Array(x*4):new Float32Array(x*3);let V=4,O=0,B=1,j=2,N=3,oe=0,he=x,Ie=x*2,te=-1;S==="RGB"&&(V=3,O=0,B=1,j=2,N=-1),y==="RGBA"?te=x*3:y==="RBG"?(oe=0,Ie=x,he=x*2):y==="BGR"&&(Ie=0,he=x,oe=x*2);for(let L=0;L<x;L++,O+=V,j+=V,B+=V,N+=V)I[oe++]=(g[O]+$[0])/z[0],I[he++]=(g[B]+$[1])/z[1],I[Ie++]=(g[j]+$[2])/z[2],te!==-1&&N!==-1&&(I[te++]=(g[N]+$[3])/z[3]);return y==="RGBA"?new o.Tensor("float32",I,[1,4,v,C]):new o.Tensor("float32",I,[1,3,v,C])},l=async(g,M)=>{const v=typeof HTMLImageElement<"u"&&g instanceof HTMLImageElement,C=typeof ImageData<"u"&&g instanceof ImageData,k=typeof ImageBitmap<"u"&&g instanceof ImageBitmap,z=typeof g=="string";let $,S=M??{};const y=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},x=I=>I instanceof HTMLCanvasElement||I instanceof OffscreenCanvas?I.getContext("2d"):null;if(v){const I=y();I.width=g.width,I.height=g.height;const V=x(I);if(V!=null){let O=g.height,B=g.width;if(M!==void 0&&M.resizedHeight!==void 0&&M.resizedWidth!==void 0&&(O=M.resizedHeight,B=M.resizedWidth),M!==void 0){if(S=M,M.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");S.tensorFormat="RGBA",S.height=O,S.width=B}else S.tensorFormat="RGBA",S.height=O,S.width=B;V.drawImage(g,0,0),$=V.getImageData(0,0,B,O).data}else throw new Error("Can not access image data")}else if(C){let I,V;if(M!==void 0&&M.resizedWidth!==void 0&&M.resizedHeight!==void 0?(I=M.resizedHeight,V=M.resizedWidth):(I=g.height,V=g.width),M!==void 0&&(S=M),S.format="RGBA",S.height=I,S.width=V,M!==void 0){const O=y();O.width=V,O.height=I;const B=x(O);if(B!=null)B.putImageData(g,0,0),$=B.getImageData(0,0,V,I).data;else throw new Error("Can not access image data")}else $=g.data}else if(k){if(M===void 0)throw new Error("Please provide image config with format for Imagebitmap");const I=y();I.width=g.width,I.height=g.height;const V=x(I);if(V!=null){const O=g.height,B=g.width;return V.drawImage(g,0,0,B,O),$=V.getImageData(0,0,B,O).data,S.height=O,S.width=B,a($,S)}else throw new Error("Can not access image data")}else{if(z)return new Promise((I,V)=>{const O=y(),B=x(O);if(!g||!B)return V();const j=new Image;j.crossOrigin="Anonymous",j.src=g,j.onload=()=>{O.width=j.width,O.height=j.height,B.drawImage(j,0,0,O.width,O.height);const N=B.getImageData(0,0,O.width,O.height);S.height=O.height,S.width=O.width,I(a(N.data,S))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if($!==void 0)return a($,S);throw new Error("Input data provided is not supported - aborted tensor creation")},f=(g,M)=>{const{width:v,height:C,download:k,dispose:z}=M,$=[1,C,v,4];return new o.Tensor({location:"texture",type:"float32",texture:g,dims:$,download:k,dispose:z})},_=(g,M)=>{const{dataType:v,dims:C,download:k,dispose:z}=M;return new o.Tensor({location:"gpu-buffer",type:v??"float32",gpuBuffer:g,dims:C,download:k,dispose:z})},m=(g,M,v)=>new o.Tensor({location:"cpu-pinned",type:g,data:M,dims:v??[M.length]})},"./node_modules/onnxruntime-common/dist/esm/tensor-factory.js":(e,t,n)=>{n.r(t)},"./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js":(e,t,n)=>{n.r(t),n.d(t,{NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP:()=>a,NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP:()=>o,checkTypedArray:()=>f});const o=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),a=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let l=!1;const f=()=>{if(!l){l=!0;const _=typeof BigInt64Array<"u"&&BigInt64Array.from,m=typeof BigUint64Array<"u"&&BigUint64Array.from,g=typeof Float16Array<"u"&&Float16Array.from;_&&(o.set("int64",BigInt64Array),a.set(BigInt64Array,"int64")),m&&(o.set("uint64",BigUint64Array),a.set(BigUint64Array,"uint64")),g?(o.set("float16",Float16Array),a.set(Float16Array,"float16")):o.set("float16",Uint16Array)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-impl.js":(e,t,n)=>{n.r(t),n.d(t,{Tensor:()=>_});var o=n("./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js"),a=n("./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js"),l=n("./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js"),f=n("./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js");class _{constructor(g,M,v){(0,l.checkTypedArray)();let C,k;if(typeof g=="object"&&"location"in g)switch(this.dataLocation=g.location,C=g.type,k=g.dims,g.location){case"cpu-pinned":{const $=l.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(C);if(!$)throw new TypeError(`unsupported type "${C}" to create tensor from pinned buffer`);if(!(g.data instanceof $))throw new TypeError(`buffer should be of type ${$.name}`);this.cpuData=g.data;break}case"texture":{if(C!=="float32")throw new TypeError(`unsupported type "${C}" to create tensor from texture`);this.gpuTextureData=g.texture,this.downloader=g.download,this.disposer=g.dispose;break}case"gpu-buffer":{if(C!=="float32"&&C!=="float16"&&C!=="int32"&&C!=="int64"&&C!=="uint32"&&C!=="uint8"&&C!=="bool")throw new TypeError(`unsupported type "${C}" to create tensor from gpu buffer`);this.gpuBufferData=g.gpuBuffer,this.downloader=g.download,this.disposer=g.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let $,S;if(typeof g=="string")if(C=g,S=v,g==="string"){if(!Array.isArray(M))throw new TypeError("A string tensor's data must be a string array.");$=M}else{const y=l.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(g);if(y===void 0)throw new TypeError(`Unsupported tensor type: ${g}.`);if(Array.isArray(M)){if(g==="float16"&&y===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");g==="uint64"||g==="int64"?$=y.from(M,BigInt):$=y.from(M)}else if(M instanceof y)$=M;else throw new TypeError(`A ${C} tensor's data must be type of ${y}`)}else if(S=M,Array.isArray(g)){if(g.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const y=typeof g[0];if(y==="string")C="string",$=g;else if(y==="boolean")C="bool",$=Uint8Array.from(g);else throw new TypeError(`Invalid element type of data array: ${y}.`)}else{const y=l.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(g.constructor);if(y===void 0)throw new TypeError(`Unsupported type for tensor data: ${g.constructor}.`);C=y,$=g}if(S===void 0)S=[$.length];else if(!Array.isArray(S))throw new TypeError("A tensor's dims must be a number array");k=S,this.cpuData=$,this.dataLocation="cpu"}const z=(0,f.calculateSize)(k);if(this.cpuData&&z!==this.cpuData.length)throw new Error(`Tensor's size(${z}) does not match data length(${this.cpuData.length}).`);this.type=C,this.dims=k,this.size=z}static async fromImage(g,M){return(0,a.tensorFromImage)(g,M)}static fromTexture(g,M){return(0,a.tensorFromTexture)(g,M)}static fromGpuBuffer(g,M){return(0,a.tensorFromGpuBuffer)(g,M)}static fromPinnedBuffer(g,M,v){return(0,a.tensorFromPinnedBuffer)(g,M,v)}toDataURL(g){return(0,o.tensorToDataURL)(this,g)}toImageData(g){return(0,o.tensorToImageData)(this,g)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(g){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const M=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=M,g&&this.disposer&&(this.disposer(),this.disposer=void 0),M}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(g){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return(0,f.tensorReshape)(this,g)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js":(e,t,n)=>{n.r(t),n.d(t,{calculateSize:()=>a,tensorReshape:()=>l});var o=n("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const a=f=>{let _=1;for(let m=0;m<f.length;m++){const g=f[m];if(typeof g!="number"||!Number.isSafeInteger(g))throw new TypeError(`dims[${m}] must be an integer, got: ${g}`);if(g<0)throw new RangeError(`dims[${m}] must be a non-negative integer, got: ${g}`);_*=g}return _},l=(f,_)=>{switch(f.location){case"cpu":return new o.Tensor(f.type,f.data,_);case"cpu-pinned":return new o.Tensor({location:"cpu-pinned",data:f.data,type:f.type,dims:_});case"texture":return new o.Tensor({location:"texture",texture:f.texture,type:f.type,dims:_});case"gpu-buffer":return new o.Tensor({location:"gpu-buffer",gpuBuffer:f.gpuBuffer,type:f.type,dims:_});default:throw new Error(`tensorReshape: tensor location ${f.location} is not supported`)}}},"./node_modules/onnxruntime-common/dist/esm/tensor.js":(e,t,n)=>{n.r(t),n.d(t,{Tensor:()=>a});var o=n("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const a=o.Tensor},"./node_modules/onnxruntime-common/dist/esm/trace.js":(e,t,n)=>{n.r(t),n.d(t,{TRACE:()=>a,TRACE_FUNC_BEGIN:()=>f,TRACE_FUNC_END:()=>_});var o=n("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const a=(m,g)=>{(typeof o.env.trace>"u"?!o.env.wasm.trace:!o.env.trace)||console.timeStamp(`${m}::ORT::${g}`)},l=(m,g)=>{var C;const M=((C=new Error().stack)==null?void 0:C.split(/\r\n|\r|\n/g))||[];let v=!1;for(let k=0;k<M.length;k++){if(v&&!M[k].includes("TRACE_FUNC")){let z=`FUNC_${m}::${M[k].trim().split(" ")[1]}`;g&&(z+=`::${g}`),a("CPU",z);return}M[k].includes("TRACE_FUNC")&&(v=!0)}},f=m=>{(typeof o.env.trace>"u"?!o.env.wasm.trace:!o.env.trace)||l("BEGIN",m)},_=m=>{(typeof o.env.trace>"u"?!o.env.wasm.trace:!o.env.trace)||l("END",m)}},"./node_modules/onnxruntime-common/dist/esm/training-session-impl.js":(e,t,n)=>{n.r(t),n.d(t,{TrainingSession:()=>f});var o=n("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),a=n("./node_modules/onnxruntime-common/dist/esm/tensor.js");const l="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";class f{constructor(m,g,M){this.handler=m,this.hasOptimizerModel=g,this.hasEvalModel=M}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(m,g){const M=m.evalModel||"",v=m.optimizerModel||"",C=g||{},[k,z]=await(0,o.resolveBackendAndExecutionProviders)(C);if(k.createTrainingSessionHandler){const $=await k.createTrainingSessionHandler(m.checkpointState,m.trainModel,M,v,z);return new f($,!!m.optimizerModel,!!m.evalModel)}else throw new Error(l)}typeNarrowingForRunStep(m,g,M,v,C){const k={};let z={};if(typeof M!="object"||M===null||M instanceof a.Tensor||Array.isArray(M))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let $=!0;if(typeof v=="object"){if(v===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(v instanceof a.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(v)){if(v.length===0)throw new TypeError("'fetches' cannot be an empty array.");$=!1;for(const S of v){if(typeof S!="string")throw new TypeError("'fetches' must be a string array or an object.");if(g.indexOf(S)===-1)throw new RangeError(`'fetches' contains invalid output name: ${S}.`);k[S]=null}if(typeof C=="object"&&C!==null)z=C;else if(typeof C<"u")throw new TypeError("'options' must be an object.")}else{let S=!1;const y=Object.getOwnPropertyNames(v);for(const x of g)if(y.indexOf(x)!==-1){const I=v[x];(I===null||I instanceof a.Tensor)&&(S=!0,$=!1,k[x]=I)}if(S){if(typeof C=="object"&&C!==null)z=C;else if(typeof C<"u")throw new TypeError("'options' must be an object.")}else z=v}}else if(typeof v<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const S of m)if(typeof M[S]>"u")throw new Error(`input '${S}' is missing in 'feeds'.`);if($)for(const S of g)k[S]=null;return[k,z]}convertHandlerReturnTypeToMapOfTensors(m){const g={};for(const M in m)if(Object.hasOwnProperty.call(m,M)){const v=m[M];v instanceof a.Tensor?g[M]=v:g[M]=new a.Tensor(v.type,v.data,v.dims)}return g}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(m,g,M){const[v,C]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,m,g,M),k=await this.handler.runTrainStep(m,v,C);return this.convertHandlerReturnTypeToMapOfTensors(k)}async runOptimizerStep(m){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(m||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(m,g,M){if(this.hasEvalModel){const[v,C]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,m,g,M),k=await this.handler.runEvalStep(m,v,C);return this.convertHandlerReturnTypeToMapOfTensors(k)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(m=!0){return this.handler.getParametersSize(m)}async loadParametersBuffer(m,g=!0){const M=await this.getParametersSize(g);if(m.length!==4*M)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(m,g)}async getContiguousParameters(m=!0){return this.handler.getContiguousParameters(m)}async release(){return this.handler.dispose()}}},"./node_modules/onnxruntime-common/dist/esm/training-session.js":(e,t,n)=>{n.r(t),n.d(t,{TrainingSession:()=>a});var o=n("./node_modules/onnxruntime-common/dist/esm/training-session-impl.js");const a=o.TrainingSession},"./node_modules/onnxruntime-common/dist/esm/version.js":(e,t,n)=>{n.r(t),n.d(t,{version:()=>o});const o="1.19.0"},"./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs":(e,t,n)=>{n.r(t),n.d(t,{InferenceSession:()=>ne,TRACE:()=>je,TRACE_FUNC_BEGIN:()=>et,TRACE_FUNC_END:()=>A,Tensor:()=>Ge,TrainingSession:()=>ht,default:()=>Rx,env:()=>N,registerBackend:()=>z});/*!
 * ONNX Runtime Web v1.20.0-dev.20240827-1d059b8702
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var o=Object.defineProperty,a=Object.getOwnPropertyDescriptor,l=Object.getOwnPropertyNames,f=Object.prototype.hasOwnProperty,_=(r=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(r,{get:(i,s)=>(typeof require<"u"?require:i)[s]}):r)(function(r){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+r+'" is not supported')}),m=(r,i)=>()=>(r&&(i=r(r=0)),i),g=(r,i)=>{for(var s in i)o(r,s,{get:i[s],enumerable:!0})},M=(r,i,s,u)=>{if(i&&typeof i=="object"||typeof i=="function")for(let d of l(i))!f.call(r,d)&&d!==s&&o(r,d,{get:()=>i[d],enumerable:!(u=a(i,d))||u.enumerable});return r},v=r=>M(o({},"__esModule",{value:!0}),r),C,k,z,$,S,y=m(()=>{C=new Map,k=[],z=(r,i,s)=>{if(i&&typeof i.init=="function"&&typeof i.createInferenceSessionHandler=="function"){let u=C.get(r);if(u===void 0)C.set(r,{backend:i,priority:s});else{if(u.priority>s)return;if(u.priority===s&&u.backend!==i)throw new Error(`cannot register backend "${r}" using priority ${s}`)}if(s>=0){let d=k.indexOf(r);d!==-1&&k.splice(d,1);for(let p=0;p<k.length;p++)if(C.get(k[p]).priority<=s){k.splice(p,0,r);return}k.push(r)}return}throw new TypeError("not a valid backend")},$=async r=>{let i=C.get(r);if(!i)return"backend not found.";if(i.initialized)return i.backend;if(i.aborted)return i.error;{let s=!!i.initPromise;try{return s||(i.initPromise=i.backend.init(r)),await i.initPromise,i.initialized=!0,i.backend}catch(u){return s||(i.error=`${u}`,i.aborted=!0),i.error}finally{delete i.initPromise}}},S=async r=>{let i=r.executionProviders||[],s=i.map(T=>typeof T=="string"?T:T.name),u=s.length===0?k:s,d,p=[],c=new Set;for(let T of u){let E=await $(T);typeof E=="string"?p.push({name:T,err:E}):(d||(d=E),d===E&&c.add(T))}if(!d)throw new Error(`no available backend found. ERR: ${p.map(T=>`[${T.name}] ${T.err}`).join(", ")}`);for(let{name:T,err:E}of p)s.includes(T)&&console.warn(`removing requested execution provider "${T}" from session options because it is not available: ${E}`);let b=i.filter(T=>c.has(typeof T=="string"?T:T.name));return[d,new Proxy(r,{get:(T,E)=>E==="executionProviders"?b:Reflect.get(T,E)})]}}),x=m(()=>{y()}),I,V=m(()=>{I="1.20.0-dev.20240827-5d54dc1462"}),O,B,j=m(()=>{V(),O="warning",B={wasm:{},webgl:{},webgpu:{},versions:{common:I},set logLevel(r){if(r!==void 0){if(typeof r!="string"||["verbose","info","warning","error","fatal"].indexOf(r)===-1)throw new Error(`Unsupported logging level: ${r}`);O=r}},get logLevel(){return O}},Object.defineProperty(B,"logLevel",{enumerable:!0})}),N,oe=m(()=>{j(),N=B}),he,Ie,te=m(()=>{he=(r,i)=>{let s=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);s.width=r.dims[3],s.height=r.dims[2];let u=s.getContext("2d");if(u!=null){let d,p;(i==null?void 0:i.tensorLayout)!==void 0&&i.tensorLayout==="NHWC"?(d=r.dims[2],p=r.dims[3]):(d=r.dims[3],p=r.dims[2]);let c=(i==null?void 0:i.format)!==void 0?i.format:"RGB",b=i==null?void 0:i.norm,T,E;b===void 0||b.mean===void 0?T=[255,255,255,255]:typeof b.mean=="number"?T=[b.mean,b.mean,b.mean,b.mean]:(T=[b.mean[0],b.mean[1],b.mean[2],0],b.mean[3]!==void 0&&(T[3]=b.mean[3])),b===void 0||b.bias===void 0?E=[0,0,0,0]:typeof b.bias=="number"?E=[b.bias,b.bias,b.bias,b.bias]:(E=[b.bias[0],b.bias[1],b.bias[2],0],b.bias[3]!==void 0&&(E[3]=b.bias[3]));let q=p*d,H=0,w=q,Z=q*2,re=-1;c==="RGBA"?(H=0,w=q,Z=q*2,re=q*3):c==="RGB"?(H=0,w=q,Z=q*2):c==="RBG"&&(H=0,Z=q,w=q*2);for(let le=0;le<p;le++)for(let _e=0;_e<d;_e++){let be=(r.data[H++]-E[0])*T[0],me=(r.data[w++]-E[1])*T[1],Fe=(r.data[Z++]-E[2])*T[2],Se=re===-1?255:(r.data[re++]-E[3])*T[3];u.fillStyle="rgba("+be+","+me+","+Fe+","+Se+")",u.fillRect(_e,le,1,1)}if("toDataURL"in s)return s.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Ie=(r,i)=>{let s=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),u;if(s!=null){let d,p,c;(i==null?void 0:i.tensorLayout)!==void 0&&i.tensorLayout==="NHWC"?(d=r.dims[2],p=r.dims[1],c=r.dims[3]):(d=r.dims[3],p=r.dims[2],c=r.dims[1]);let b=i!==void 0&&i.format!==void 0?i.format:"RGB",T=i==null?void 0:i.norm,E,q;T===void 0||T.mean===void 0?E=[255,255,255,255]:typeof T.mean=="number"?E=[T.mean,T.mean,T.mean,T.mean]:(E=[T.mean[0],T.mean[1],T.mean[2],255],T.mean[3]!==void 0&&(E[3]=T.mean[3])),T===void 0||T.bias===void 0?q=[0,0,0,0]:typeof T.bias=="number"?q=[T.bias,T.bias,T.bias,T.bias]:(q=[T.bias[0],T.bias[1],T.bias[2],0],T.bias[3]!==void 0&&(q[3]=T.bias[3]));let H=p*d;if(i!==void 0&&(i.format!==void 0&&c===4&&i.format!=="RGBA"||c===3&&i.format!=="RGB"&&i.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let w=4,Z=0,re=1,le=2,_e=3,be=0,me=H,Fe=H*2,Se=-1;b==="RGBA"?(be=0,me=H,Fe=H*2,Se=H*3):b==="RGB"?(be=0,me=H,Fe=H*2):b==="RBG"&&(be=0,Fe=H,me=H*2),u=s.createImageData(d,p);for(let ze=0;ze<p*d;Z+=w,re+=w,le+=w,_e+=w,ze++)u.data[Z]=(r.data[be++]-q[0])*E[0],u.data[re]=(r.data[me++]-q[1])*E[1],u.data[le]=(r.data[Fe++]-q[2])*E[2],u.data[_e]=Se===-1?255:(r.data[Se++]-q[3])*E[3]}else throw new Error("Can not access image data");return u}}),we,L,Ce,Xe,ye,Y=m(()=>{pt(),we=(r,i)=>{if(r===void 0)throw new Error("Image buffer must be defined");if(i.height===void 0||i.width===void 0)throw new Error("Image height and width must be defined");if(i.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:s,width:u}=i,d=i.norm??{mean:255,bias:0},p,c;typeof d.mean=="number"?p=[d.mean,d.mean,d.mean,d.mean]:p=[d.mean[0],d.mean[1],d.mean[2],d.mean[3]??255],typeof d.bias=="number"?c=[d.bias,d.bias,d.bias,d.bias]:c=[d.bias[0],d.bias[1],d.bias[2],d.bias[3]??0];let b=i.format!==void 0?i.format:"RGBA",T=i.tensorFormat!==void 0&&i.tensorFormat!==void 0?i.tensorFormat:"RGB",E=s*u,q=T==="RGBA"?new Float32Array(E*4):new Float32Array(E*3),H=4,w=0,Z=1,re=2,le=3,_e=0,be=E,me=E*2,Fe=-1;b==="RGB"&&(H=3,w=0,Z=1,re=2,le=-1),T==="RGBA"?Fe=E*3:T==="RBG"?(_e=0,me=E,be=E*2):T==="BGR"&&(me=0,be=E,_e=E*2);for(let Se=0;Se<E;Se++,w+=H,re+=H,Z+=H,le+=H)q[_e++]=(r[w]+c[0])/p[0],q[be++]=(r[Z]+c[1])/p[1],q[me++]=(r[re]+c[2])/p[2],Fe!==-1&&le!==-1&&(q[Fe++]=(r[le]+c[3])/p[3]);return T==="RGBA"?new st("float32",q,[1,4,s,u]):new st("float32",q,[1,3,s,u])},L=async(r,i)=>{let s=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,u=typeof ImageData<"u"&&r instanceof ImageData,d=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,p=typeof r=="string",c,b=i??{},T=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},E=q=>q instanceof HTMLCanvasElement||q instanceof OffscreenCanvas?q.getContext("2d"):null;if(s){let q=T();q.width=r.width,q.height=r.height;let H=E(q);if(H!=null){let w=r.height,Z=r.width;if(i!==void 0&&i.resizedHeight!==void 0&&i.resizedWidth!==void 0&&(w=i.resizedHeight,Z=i.resizedWidth),i!==void 0){if(b=i,i.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");b.tensorFormat="RGBA",b.height=w,b.width=Z}else b.tensorFormat="RGBA",b.height=w,b.width=Z;H.drawImage(r,0,0),c=H.getImageData(0,0,Z,w).data}else throw new Error("Can not access image data")}else if(u){let q,H;if(i!==void 0&&i.resizedWidth!==void 0&&i.resizedHeight!==void 0?(q=i.resizedHeight,H=i.resizedWidth):(q=r.height,H=r.width),i!==void 0&&(b=i),b.format="RGBA",b.height=q,b.width=H,i!==void 0){let w=T();w.width=H,w.height=q;let Z=E(w);if(Z!=null)Z.putImageData(r,0,0),c=Z.getImageData(0,0,H,q).data;else throw new Error("Can not access image data")}else c=r.data}else if(d){if(i===void 0)throw new Error("Please provide image config with format for Imagebitmap");let q=T();q.width=r.width,q.height=r.height;let H=E(q);if(H!=null){let w=r.height,Z=r.width;return H.drawImage(r,0,0,Z,w),c=H.getImageData(0,0,Z,w).data,b.height=w,b.width=Z,we(c,b)}else throw new Error("Can not access image data")}else{if(p)return new Promise((q,H)=>{let w=T(),Z=E(w);if(!r||!Z)return H();let re=new Image;re.crossOrigin="Anonymous",re.src=r,re.onload=()=>{w.width=re.width,w.height=re.height,Z.drawImage(re,0,0,w.width,w.height);let le=Z.getImageData(0,0,w.width,w.height);b.height=w.height,b.width=w.width,q(we(le.data,b))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(c!==void 0)return we(c,b);throw new Error("Input data provided is not supported - aborted tensor creation")},Ce=(r,i)=>{let{width:s,height:u,download:d,dispose:p}=i,c=[1,u,s,4];return new st({location:"texture",type:"float32",texture:r,dims:c,download:d,dispose:p})},Xe=(r,i)=>{let{dataType:s,dims:u,download:d,dispose:p}=i;return new st({location:"gpu-buffer",type:s??"float32",gpuBuffer:r,dims:u,download:d,dispose:p})},ye=(r,i,s)=>new st({location:"cpu-pinned",type:r,data:i,dims:s??[i.length]})}),se,Me,X,ge,qe=m(()=>{se=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Me=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),X=!1,ge=()=>{if(!X){X=!0;let r=typeof BigInt64Array<"u"&&BigInt64Array.from,i=typeof BigUint64Array<"u"&&BigUint64Array.from,s=typeof Float16Array<"u"&&Float16Array.from;r&&(se.set("int64",BigInt64Array),Me.set(BigInt64Array,"int64")),i&&(se.set("uint64",BigUint64Array),Me.set(BigUint64Array,"uint64")),s?(se.set("float16",Float16Array),Me.set(Float16Array,"float16")):se.set("float16",Uint16Array)}}}),Be,Ne,We=m(()=>{pt(),Be=r=>{let i=1;for(let s=0;s<r.length;s++){let u=r[s];if(typeof u!="number"||!Number.isSafeInteger(u))throw new TypeError(`dims[${s}] must be an integer, got: ${u}`);if(u<0)throw new RangeError(`dims[${s}] must be a non-negative integer, got: ${u}`);i*=u}return i},Ne=(r,i)=>{switch(r.location){case"cpu":return new st(r.type,r.data,i);case"cpu-pinned":return new st({location:"cpu-pinned",data:r.data,type:r.type,dims:i});case"texture":return new st({location:"texture",texture:r.texture,type:r.type,dims:i});case"gpu-buffer":return new st({location:"gpu-buffer",gpuBuffer:r.gpuBuffer,type:r.type,dims:i});default:throw new Error(`tensorReshape: tensor location ${r.location} is not supported`)}}}),st,pt=m(()=>{te(),Y(),qe(),We(),st=class{constructor(r,i,s){ge();let u,d;if(typeof r=="object"&&"location"in r)switch(this.dataLocation=r.location,u=r.type,d=r.dims,r.location){case"cpu-pinned":{let c=se.get(u);if(!c)throw new TypeError(`unsupported type "${u}" to create tensor from pinned buffer`);if(!(r.data instanceof c))throw new TypeError(`buffer should be of type ${c.name}`);this.cpuData=r.data;break}case"texture":{if(u!=="float32")throw new TypeError(`unsupported type "${u}" to create tensor from texture`);this.gpuTextureData=r.texture,this.downloader=r.download,this.disposer=r.dispose;break}case"gpu-buffer":{if(u!=="float32"&&u!=="float16"&&u!=="int32"&&u!=="int64"&&u!=="uint32"&&u!=="uint8"&&u!=="bool"&&u!=="uint4"&&u!=="int4")throw new TypeError(`unsupported type "${u}" to create tensor from gpu buffer`);this.gpuBufferData=r.gpuBuffer,this.downloader=r.download,this.disposer=r.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let c,b;if(typeof r=="string")if(u=r,b=s,r==="string"){if(!Array.isArray(i))throw new TypeError("A string tensor's data must be a string array.");c=i}else{let T=se.get(r);if(T===void 0)throw new TypeError(`Unsupported tensor type: ${r}.`);if(Array.isArray(i)){if(r==="float16"&&T===Uint16Array||r==="uint4"||r==="int4")throw new TypeError(`Creating a ${r} tensor from number array is not supported. Please use ${T.name} as data.`);r==="uint64"||r==="int64"?c=T.from(i,BigInt):c=T.from(i)}else if(i instanceof T)c=i;else throw new TypeError(`A ${u} tensor's data must be type of ${T}`)}else if(b=i,Array.isArray(r)){if(r.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let T=typeof r[0];if(T==="string")u="string",c=r;else if(T==="boolean")u="bool",c=Uint8Array.from(r);else throw new TypeError(`Invalid element type of data array: ${T}.`)}else{let T=Me.get(r.constructor);if(T===void 0)throw new TypeError(`Unsupported type for tensor data: ${r.constructor}.`);u=T,c=r}if(b===void 0)b=[c.length];else if(!Array.isArray(b))throw new TypeError("A tensor's dims must be a number array");d=b,this.cpuData=c,this.dataLocation="cpu"}let p=Be(d);if(this.cpuData&&p!==this.cpuData.length&&!((u==="uint4"||u==="int4")&&Math.ceil(p/2)===this.cpuData.length))throw new Error(`Tensor's size(${p}) does not match data length(${this.cpuData.length}).`);this.type=u,this.dims=d,this.size=p}static async fromImage(r,i){return L(r,i)}static fromTexture(r,i){return Ce(r,i)}static fromGpuBuffer(r,i){return Xe(r,i)}static fromPinnedBuffer(r,i,s){return ye(r,i,s)}toDataURL(r){return he(this,r)}toImageData(r){return Ie(this,r)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(r){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let i=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=i,r&&this.disposer&&(this.disposer(),this.disposer=void 0),i}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(r){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Ne(this,r)}}}),Ge,xe=m(()=>{pt(),Ge=st}),je,Ye,et,A,$e=m(()=>{j(),je=(r,i)=>{(typeof B.trace>"u"?!B.wasm.trace:!B.trace)||console.timeStamp(`${r}::ORT::${i}`)},Ye=(r,i)=>{var d;let s=((d=new Error().stack)==null?void 0:d.split(/\r\n|\r|\n/g))||[],u=!1;for(let p=0;p<s.length;p++){if(u&&!s[p].includes("TRACE_FUNC")){let c=`FUNC_${r}::${s[p].trim().split(" ")[1]}`;i&&(c+=`::${i}`),je("CPU",c);return}s[p].includes("TRACE_FUNC")&&(u=!0)}},et=r=>{(typeof B.trace>"u"?!B.wasm.trace:!B.trace)||Ye("BEGIN",r)},A=r=>{(typeof B.trace>"u"?!B.wasm.trace:!B.trace)||Ye("END",r)}}),Pe,ae=m(()=>{y(),xe(),$e(),Pe=class vx{constructor(i){this.handler=i}async run(i,s,u){et();let d={},p={};if(typeof i!="object"||i===null||i instanceof Ge||Array.isArray(i))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof s=="object"){if(s===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(s instanceof Ge)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(s)){if(s.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(let E of s){if(typeof E!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(E)===-1)throw new RangeError(`'fetches' contains invalid output name: ${E}.`);d[E]=null}if(typeof u=="object"&&u!==null)p=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else{let E=!1,q=Object.getOwnPropertyNames(s);for(let H of this.outputNames)if(q.indexOf(H)!==-1){let w=s[H];(w===null||w instanceof Ge)&&(E=!0,c=!1,d[H]=w)}if(E){if(typeof u=="object"&&u!==null)p=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else p=s}}else if(typeof s<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let E of this.inputNames)if(typeof i[E]>"u")throw new Error(`input '${E}' is missing in 'feeds'.`);if(c)for(let E of this.outputNames)d[E]=null;let b=await this.handler.run(i,d,p),T={};for(let E in b)if(Object.hasOwnProperty.call(b,E)){let q=b[E];q instanceof Ge?T[E]=q:T[E]=new Ge(q.type,q.data,q.dims)}return A(),T}async release(){return this.handler.dispose()}static async create(i,s,u,d){et();let p,c={};if(typeof i=="string"){if(p=i,typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(i instanceof Uint8Array){if(p=i,typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer){let q=i,H=0,w=i.byteLength;if(typeof s=="object"&&s!==null)c=s;else if(typeof s=="number"){if(H=s,!Number.isSafeInteger(H))throw new RangeError("'byteOffset' must be an integer.");if(H<0||H>=q.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${q.byteLength}).`);if(w=i.byteLength-H,typeof u=="number"){if(w=u,!Number.isSafeInteger(w))throw new RangeError("'byteLength' must be an integer.");if(w<=0||H+w>q.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${q.byteLength-H}].`);if(typeof d=="object"&&d!==null)c=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(typeof u<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof s<"u")throw new TypeError("'options' must be an object.");p=new Uint8Array(q,H,w)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[b,T]=await S(c),E=await b.createInferenceSessionHandler(p,T);return A(),new vx(E)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),ne,ve=m(()=>{ae(),ne=Pe}),R=m(()=>{}),ee=m(()=>{}),D=m(()=>{}),ce=m(()=>{}),ue,ke,Re=m(()=>{y(),xe(),ue="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",ke=class bx{constructor(i,s,u){this.handler=i,this.hasOptimizerModel=s,this.hasEvalModel=u}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(i,s){let u=i.evalModel||"",d=i.optimizerModel||"",p=s||{},[c,b]=await S(p);if(c.createTrainingSessionHandler){let T=await c.createTrainingSessionHandler(i.checkpointState,i.trainModel,u,d,b);return new bx(T,!!i.optimizerModel,!!i.evalModel)}else throw new Error(ue)}typeNarrowingForRunStep(i,s,u,d,p){let c={},b={};if(typeof u!="object"||u===null||u instanceof Ge||Array.isArray(u))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let T=!0;if(typeof d=="object"){if(d===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(d instanceof Ge)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(d)){if(d.length===0)throw new TypeError("'fetches' cannot be an empty array.");T=!1;for(let E of d){if(typeof E!="string")throw new TypeError("'fetches' must be a string array or an object.");if(s.indexOf(E)===-1)throw new RangeError(`'fetches' contains invalid output name: ${E}.`);c[E]=null}if(typeof p=="object"&&p!==null)b=p;else if(typeof p<"u")throw new TypeError("'options' must be an object.")}else{let E=!1,q=Object.getOwnPropertyNames(d);for(let H of s)if(q.indexOf(H)!==-1){let w=d[H];(w===null||w instanceof Ge)&&(E=!0,T=!1,c[H]=w)}if(E){if(typeof p=="object"&&p!==null)b=p;else if(typeof p<"u")throw new TypeError("'options' must be an object.")}else b=d}}else if(typeof d<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let E of i)if(typeof u[E]>"u")throw new Error(`input '${E}' is missing in 'feeds'.`);if(T)for(let E of s)c[E]=null;return[c,b]}convertHandlerReturnTypeToMapOfTensors(i){let s={};for(let u in i)if(Object.hasOwnProperty.call(i,u)){let d=i[u];d instanceof Ge?s[u]=d:s[u]=new Ge(d.type,d.data,d.dims)}return s}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(i,s,u){let[d,p]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,i,s,u),c=await this.handler.runTrainStep(i,d,p);return this.convertHandlerReturnTypeToMapOfTensors(c)}async runOptimizerStep(i){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(i||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(i,s,u){if(this.hasEvalModel){let[d,p]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,i,s,u),c=await this.handler.runEvalStep(i,d,p);return this.convertHandlerReturnTypeToMapOfTensors(c)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(i=!0){return this.handler.getParametersSize(i)}async loadParametersBuffer(i,s=!0){let u=await this.getParametersSize(s);if(i.length!==4*u)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(i,s)}async getContiguousParameters(i=!0){return this.handler.getContiguousParameters(i)}async release(){return this.handler.dispose()}}}),ht,tt=m(()=>{Re(),ht=ke}),wt={};g(wt,{InferenceSession:()=>ne,TRACE:()=>je,TRACE_FUNC_BEGIN:()=>et,TRACE_FUNC_END:()=>A,Tensor:()=>Ge,TrainingSession:()=>ht,env:()=>N,registerBackend:()=>z});var bt=m(()=>{x(),oe(),ve(),xe(),R(),ee(),$e(),D(),ce(),tt()}),Ke=m(()=>{}),de={};g(de,{default:()=>ot});var Ae,Ve,ot,Qe=m(()=>{var r;jy(),kn(),lr(),Ae="ort-wasm-proxy-worker",Ve=((r=globalThis.self)==null?void 0:r.name)===Ae,Ve&&(self.onmessage=i=>{let{type:s,in:u}=i.data;try{switch(s){case"init-wasm":Ai(u.wasm).then(()=>{Rm(u).then(()=>{postMessage({type:s})},d=>{postMessage({type:s,err:d})})},d=>{postMessage({type:s,err:d})});break;case"init-ep":{let{epName:d,env:p}=u;Nm(p,d).then(()=>{postMessage({type:s})},c=>{postMessage({type:s,err:c})});break}case"copy-from":{let{buffer:d}=u,p=Kp(d);postMessage({type:s,out:p});break}case"create":{let{model:d,options:p}=u;jm(d,p).then(c=>{postMessage({type:s,out:c})},c=>{postMessage({type:s,err:c})});break}case"release":Um(u),postMessage({type:s});break;case"run":{let{sessionId:d,inputIndices:p,inputs:c,outputIndices:b,options:T}=u;Wm(d,p,c,b,new Array(b.length).fill(null),T).then(E=>{E.some(q=>q[3]!=="cpu")?postMessage({type:s,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:s,out:E},Hm([...c,...E]))},E=>{postMessage({type:s,err:E})});break}case"end-profiling":Gm(u),postMessage({type:s});break;default:}}catch(d){postMessage({type:s,err:d})}}),ot=Ve?null:i=>new Worker(i??rt,{type:"module",name:Ae})}),ft={};g(ft,{default:()=>$t});var xt,vt,$t,kt=m(()=>{var r;vt=(xt=import.meta.url,async function(i={}){function s(){return Er.buffer!=wr.buffer&&Un(),wr}function u(){return Er.buffer!=wr.buffer&&Un(),Or}function d(){return Er.buffer!=wr.buffer&&Un(),ut}function p(){return Er.buffer!=wr.buffer&&Un(),At}function c(){return Er.buffer!=wr.buffer&&Un(),ar}function b(){return Er.buffer!=wr.buffer&&Un(),Gr}function T(){return Er.buffer!=wr.buffer&&Un(),gn}function E(){return Er.buffer!=wr.buffer&&Un(),Yp}var q,H,w=Object.assign({},i),Z=new Promise((h,F)=>{q=h,H=F}),re=typeof window=="object",le=typeof importScripts=="function",_e=le&&self.name=="em-pthread";w.mountExternalData=(h,F)=>{h.startsWith("./")&&(h=h.substring(2)),(w.Fb||(w.Fb=new Map)).set(h,F)},w.unmountExternalData=()=>{delete w.Fb};var be=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let me=()=>{let h=(K,J,pe)=>(...De)=>{let ct=lo,yt=J==null?void 0:J();De=K(...De);let Ft=J==null?void 0:J();return yt!==Ft&&(K=Ft,pe(yt),J=pe=null),lo!=ct?new Promise((Bt,er)=>{cg={resolve:Bt,reject:er}}):De},F=K=>async(...J)=>{var pe;try{if(w.Eb)throw Error("Session already started");let De=w.Eb={bc:J[0],errors:[]},ct=await K(...J);if(w.Eb!==De)throw Error("Session mismatch");(pe=w.Mb)==null||pe.flush();let yt=De.errors;if(0<yt.length){let Ft=await Promise.all(yt);if(Ft=Ft.filter(Bt=>Bt),0<Ft.length)throw Error(Ft.join(`
`))}return ct}finally{w.Eb=null}};w._OrtCreateSession=h(w._OrtCreateSession,()=>w._OrtCreateSession,K=>w._OrtCreateSession=K),w._OrtRun=F(h(w._OrtRun,()=>w._OrtRun,K=>w._OrtRun=K)),w._OrtRunWithBinding=F(h(w._OrtRunWithBinding,()=>w._OrtRunWithBinding,K=>w._OrtRunWithBinding=K)),w._OrtBindInput=h(w._OrtBindInput,()=>w._OrtBindInput,K=>w._OrtBindInput=K),me=void 0};w.jsepInit=(h,F)=>{if(me==null||me(),h==="webgpu"){[w.Mb,w.Tb,w.Xb,w.Nb,w.Wb,w.jb,w.Yb,w.$b,w.Ub,w.Vb,w.Zb]=F;let K=w.Mb;w.jsepRegisterBuffer=(J,pe,De,ct)=>K.registerBuffer(J,pe,De,ct),w.jsepGetBuffer=J=>K.getBuffer(J),w.jsepCreateDownloader=(J,pe,De)=>K.createDownloader(J,pe,De),w.jsepOnReleaseSession=J=>{K.onReleaseSession(J)},w.jsepOnRunStart=J=>K.onRunStart(J)}};var Fe,Se,ze=Object.assign({},w),dt="./this.program",lt=(h,F)=>{throw F},Mt="";(re||le)&&(le?Mt=self.location.href:typeof document<"u"&&document.currentScript&&(Mt=document.currentScript.src),xt&&(Mt=xt),Mt=Mt.startsWith("blob:")?"":Mt.substr(0,Mt.replace(/[?#].*/,"").lastIndexOf("/")+1),le&&(Se=h=>{var F=new XMLHttpRequest;return F.open("GET",h,!1),F.responseType="arraybuffer",F.send(null),new Uint8Array(F.response)}),Fe=(h,F,K)=>{var J=new XMLHttpRequest;J.open("GET",h,!0),J.responseType="arraybuffer",J.onload=()=>{J.status==200||J.status==0&&J.response?F(J.response):K()},J.onerror=K,J.send(null)});var Dt,Vt=console.log.bind(console),hr=console.error.bind(console),xr=Vt,nr=hr;if(Object.assign(w,ze),ze=null,_e){let h=function(F){try{var K=F.data,J=K.cmd;if(J==="load"){let pe=[];self.onmessage=De=>pe.push(De),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let De of pe)h(De);self.onmessage=h};for(let De of K.handlers)w[De]&&!w[De].proxy||(w[De]=(...ct)=>{postMessage({Lb:"callHandler",kc:De,args:ct})},De=="print"&&(xr=w[De]),De=="printErr"&&(nr=w[De]));Er=K.wasmMemory,Un(),Wr(K.wasmModule)}else if(J==="run"){hg(K.pthread_ptr,0,0,1,0,0),ag(K.pthread_ptr),Ux(),fw(),Jr||(u1(),Jr=!0);try{Vx(K.start_routine,K.arg)}catch(pe){if(pe!="unwind")throw pe}}else J==="cancel"?Wl()&&uh(-1):K.target!=="setimmediate"&&(J==="checkMailbox"?Jr&&eh():J&&(nr(`worker: received unknown command ${J}`),nr(K)))}catch(pe){throw c1(),pe}};var Wr,Jr=!1;nr=function(...F){F=F.join(" "),console.error(F)},self.alert=function(...F){postMessage({Lb:"alert",text:F.join(" "),mc:Wl()})},w.instantiateWasm=(F,K)=>new Promise(J=>{Wr=pe=>{pe=new WebAssembly.Instance(pe,aw()),K(pe),J()}}),self.onunhandledrejection=F=>{throw F.reason||F},self.onmessage=h}w.wasmBinary&&(Dt=w.wasmBinary);var Er,Hr,rr,wr,Or,ut,At,ar,Gr,gn,Cn,is,Yp,ki=!1;function Un(){var h=Er.buffer;w.HEAP8=wr=new Int8Array(h),w.HEAP16=ut=new Int16Array(h),w.HEAPU8=Or=new Uint8Array(h),w.HEAPU16=At=new Uint16Array(h),w.HEAP32=ar=new Int32Array(h),w.HEAPU32=Gr=new Uint32Array(h),w.HEAPF32=gn=new Float32Array(h),w.HEAPF64=Yp=new Float64Array(h),w.HEAP64=Cn=new BigInt64Array(h),w.HEAPU64=is=new BigUint64Array(h)}if(!_e){if(!((Er=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof be))throw nr("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");Un()}var Mf=[],Vn=[],ii=[],Oi=0,os=null;function Zp(){if(--Oi==0&&os){var h=os;os=null,h()}}function jl(h){throw nr(h="Aborted("+h+")"),ki=!0,rr=1,h=new WebAssembly.RuntimeError(h+". Build with -sASSERTIONS for more info."),H(h),h}var Qm,nw=h=>h.startsWith("data:application/octet-stream;base64,"),iw=h=>h.startsWith("file://");function ow(h){if(h==Qm&&Dt)return new Uint8Array(Dt);if(Se)return Se(h);throw"both async and sync fetching of the wasm failed"}function sw(h,F,K){return function(J){if(!Dt&&(re||le)){if(typeof fetch=="function"&&!iw(J))return fetch(J,{credentials:"same-origin"}).then(pe=>{if(!pe.ok)throw`failed to load wasm binary file at '${J}'`;return pe.arrayBuffer()}).catch(()=>ow(J));if(Fe)return new Promise((pe,De)=>{Fe(J,ct=>pe(new Uint8Array(ct)),De)})}return Promise.resolve().then(()=>ow(J))}(h).then(J=>WebAssembly.instantiate(J,F)).then(K,J=>{nr(`failed to asynchronously prepare wasm: ${J}`),jl(J)})}function aw(){return{a:{M:jx,za:Nx,b:Gx,$:gw,z:ww,pa:vw,X:xw,Z:Mw,qa:kw,na:Tw,ga:Sw,ma:Ew,J:Cw,Y:Pw,V:$w,oa:Aw,W:Iw,va:Hx,D:qx,P:Kx,O:Xx,C:Zx,s:Jx,p:eM,E:tM,y:lM,Q:uM,ta:cM,ja:dM,T:fM,aa:pM,F:hM,ia:ag,sa:mM,u:gM,B:wM,o:vM,m:xM,c:og,n:MM,k:SM,Aa:EM,r:CM,g:PM,v:$M,l:AM,f:IM,i:FM,j:zM,h:OM,e:DM,da:LM,ea:BM,fa:RM,ba:Hw,ca:qw,S:NM,d:jM,N:UM,G:VM,K:WM,w:GM,ra:HM,U:qM,t:Qw,x:KM,L:QM,R:XM,ya:YM,xa:ZM,ka:Zw,la:Jw,_:eg,A:e1,I:t1,ha:r1,H:n1,a:Er,wa:Jm,ua:s1,q:tk}}}var Xm={858916:(h,F,K,J)=>{if(w===void 0||!w.Fb)return 1;if((h=On(h>>>0)).startsWith("./")&&(h=h.substring(2)),!(h=w.Fb.get(h)))return 2;if(J>>>=0,(F>>>=0)+(K>>>=0)>h.byteLength)return 3;try{return u().set(h.subarray(F,F+K),J>>>0),0}catch{return 4}},859417:()=>{w.Ub()},859448:()=>{w.Vb()},859477:()=>{w.Zb()},859502:h=>w.Tb(h),859535:h=>w.Xb(h),859567:(h,F,K)=>{w.Nb(h,F,K,!0)},859606:(h,F,K)=>{w.Nb(h,F,K)},859639:()=>typeof wasmOffsetConverter<"u",859696:h=>{w.jb("Abs",h,void 0)},859747:h=>{w.jb("Neg",h,void 0)},859798:h=>{w.jb("Floor",h,void 0)},859851:h=>{w.jb("Ceil",h,void 0)},859903:h=>{w.jb("Reciprocal",h,void 0)},859961:h=>{w.jb("Sqrt",h,void 0)},860013:h=>{w.jb("Exp",h,void 0)},860064:h=>{w.jb("Erf",h,void 0)},860115:h=>{w.jb("Sigmoid",h,void 0)},860170:(h,F,K)=>{w.jb("HardSigmoid",h,{alpha:F,beta:K})},860249:h=>{w.jb("Log",h,void 0)},860300:h=>{w.jb("Sin",h,void 0)},860351:h=>{w.jb("Cos",h,void 0)},860402:h=>{w.jb("Tan",h,void 0)},860453:h=>{w.jb("Asin",h,void 0)},860505:h=>{w.jb("Acos",h,void 0)},860557:h=>{w.jb("Atan",h,void 0)},860609:h=>{w.jb("Sinh",h,void 0)},860661:h=>{w.jb("Cosh",h,void 0)},860713:h=>{w.jb("Asinh",h,void 0)},860766:h=>{w.jb("Acosh",h,void 0)},860819:h=>{w.jb("Atanh",h,void 0)},860872:h=>{w.jb("Tanh",h,void 0)},860924:h=>{w.jb("Not",h,void 0)},860975:(h,F,K)=>{w.jb("Clip",h,{min:F,max:K})},861044:h=>{w.jb("Clip",h,void 0)},861096:(h,F)=>{w.jb("Elu",h,{alpha:F})},861154:h=>{w.jb("Gelu",h,void 0)},861206:h=>{w.jb("Relu",h,void 0)},861258:(h,F)=>{w.jb("LeakyRelu",h,{alpha:F})},861322:(h,F)=>{w.jb("ThresholdedRelu",h,{alpha:F})},861392:(h,F)=>{w.jb("Cast",h,{to:F})},861450:h=>{w.jb("Add",h,void 0)},861501:h=>{w.jb("Sub",h,void 0)},861552:h=>{w.jb("Mul",h,void 0)},861603:h=>{w.jb("Div",h,void 0)},861654:h=>{w.jb("Pow",h,void 0)},861705:h=>{w.jb("Equal",h,void 0)},861758:h=>{w.jb("Greater",h,void 0)},861813:h=>{w.jb("GreaterOrEqual",h,void 0)},861875:h=>{w.jb("Less",h,void 0)},861927:h=>{w.jb("LessOrEqual",h,void 0)},861986:(h,F,K,J,pe)=>{w.jb("ReduceMean",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},862145:(h,F,K,J,pe)=>{w.jb("ReduceMax",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},862303:(h,F,K,J,pe)=>{w.jb("ReduceMin",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},862461:(h,F,K,J,pe)=>{w.jb("ReduceProd",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},862620:(h,F,K,J,pe)=>{w.jb("ReduceSum",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},862778:(h,F,K,J,pe)=>{w.jb("ReduceL1",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},862935:(h,F,K,J,pe)=>{w.jb("ReduceL2",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},863092:(h,F,K,J,pe)=>{w.jb("ReduceLogSum",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},863253:(h,F,K,J,pe)=>{w.jb("ReduceSumSquare",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},863417:(h,F,K,J,pe)=>{w.jb("ReduceLogSumExp",h,{keepDims:!!F,noopWithEmptyAxes:!!K,axes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},863581:h=>{w.jb("Where",h,void 0)},863634:(h,F,K)=>{w.jb("Transpose",h,{perm:F?Array.from(c().subarray(F>>>0,K>>>0)):[]})},863742:(h,F,K,J)=>{w.jb("DepthToSpace",h,{blocksize:F,mode:On(K),format:J?"NHWC":"NCHW"})},863875:(h,F,K,J)=>{w.jb("DepthToSpace",h,{blocksize:F,mode:On(K),format:J?"NHWC":"NCHW"})},864008:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er,Ir,Ur,it,Cr)=>{w.jb("ConvTranspose",h,{format:Ft?"NHWC":"NCHW",autoPad:F,dilations:[K],group:J,kernelShape:[pe],pads:[De,ct],strides:[yt],wIsConst:()=>!!s()[Bt>>>0],outputPadding:er?Array.from(c().subarray(er>>>0,Ir>>>0)):[],outputShape:Ur?Array.from(c().subarray(Ur>>>0,it>>>0)):[],activation:On(Cr)})},864409:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er,Ir,Ur,it)=>{w.jb("ConvTranspose",h,{format:yt?"NHWC":"NCHW",autoPad:F,dilations:Array.from(c().subarray(K>>>0,2+(K>>>0)>>>0)),group:J,kernelShape:Array.from(c().subarray(pe>>>0,2+(pe>>>0)>>>0)),pads:Array.from(c().subarray(De>>>0,4+(De>>>0)>>>0)),strides:Array.from(c().subarray(ct>>>0,2+(ct>>>0)>>>0)),wIsConst:()=>!!s()[Ft>>>0],outputPadding:Bt?Array.from(c().subarray(Bt>>>0,er>>>0)):[],outputShape:Ir?Array.from(c().subarray(Ir>>>0,Ur>>>0)):[],activation:On(it)})},864974:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er,Ir,Ur,it,Cr)=>{w.jb("ConvTranspose",h,{format:Ft?"NHWC":"NCHW",autoPad:F,dilations:[K],group:J,kernelShape:[pe],pads:[De,ct],strides:[yt],wIsConst:()=>!!s()[Bt>>>0],outputPadding:er?Array.from(c().subarray(er>>>0,Ir>>>0)):[],outputShape:Ur?Array.from(c().subarray(Ur>>>0,it>>>0)):[],activation:On(Cr)})},865375:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er,Ir,Ur,it)=>{w.jb("ConvTranspose",h,{format:yt?"NHWC":"NCHW",autoPad:F,dilations:Array.from(c().subarray(K>>>0,2+(K>>>0)>>>0)),group:J,kernelShape:Array.from(c().subarray(pe>>>0,2+(pe>>>0)>>>0)),pads:Array.from(c().subarray(De>>>0,4+(De>>>0)>>>0)),strides:Array.from(c().subarray(ct>>>0,2+(ct>>>0)>>>0)),wIsConst:()=>!!s()[Ft>>>0],outputPadding:Bt?Array.from(c().subarray(Bt>>>0,er>>>0)):[],outputShape:Ir?Array.from(c().subarray(Ir>>>0,Ur>>>0)):[],activation:On(it)})},865940:(h,F)=>{w.jb("GlobalAveragePool",h,{format:F?"NHWC":"NCHW"})},866031:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er,Ir,Ur,it)=>{w.jb("AveragePool",h,{format:it?"NHWC":"NCHW",auto_pad:F,ceil_mode:K,count_include_pad:J,storage_order:pe,dilations:De?Array.from(c().subarray(De>>>0,ct>>>0)):[],kernel_shape:yt?Array.from(c().subarray(yt>>>0,Ft>>>0)):[],pads:Bt?Array.from(c().subarray(Bt>>>0,er>>>0)):[],strides:Ir?Array.from(c().subarray(Ir>>>0,Ur>>>0)):[]})},866446:(h,F)=>{w.jb("GlobalAveragePool",h,{format:F?"NHWC":"NCHW"})},866537:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er,Ir,Ur,it)=>{w.jb("AveragePool",h,{format:it?"NHWC":"NCHW",auto_pad:F,ceil_mode:K,count_include_pad:J,storage_order:pe,dilations:De?Array.from(c().subarray(De>>>0,ct>>>0)):[],kernel_shape:yt?Array.from(c().subarray(yt>>>0,Ft>>>0)):[],pads:Bt?Array.from(c().subarray(Bt>>>0,er>>>0)):[],strides:Ir?Array.from(c().subarray(Ir>>>0,Ur>>>0)):[]})},866952:(h,F)=>{w.jb("GlobalMaxPool",h,{format:F?"NHWC":"NCHW"})},867039:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er,Ir,Ur,it)=>{w.jb("MaxPool",h,{format:it?"NHWC":"NCHW",auto_pad:F,ceil_mode:K,count_include_pad:J,storage_order:pe,dilations:De?Array.from(c().subarray(De>>>0,ct>>>0)):[],kernel_shape:yt?Array.from(c().subarray(yt>>>0,Ft>>>0)):[],pads:Bt?Array.from(c().subarray(Bt>>>0,er>>>0)):[],strides:Ir?Array.from(c().subarray(Ir>>>0,Ur>>>0)):[]})},867450:(h,F)=>{w.jb("GlobalMaxPool",h,{format:F?"NHWC":"NCHW"})},867537:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er,Ir,Ur,it)=>{w.jb("MaxPool",h,{format:it?"NHWC":"NCHW",auto_pad:F,ceil_mode:K,count_include_pad:J,storage_order:pe,dilations:De?Array.from(c().subarray(De>>>0,ct>>>0)):[],kernel_shape:yt?Array.from(c().subarray(yt>>>0,Ft>>>0)):[],pads:Bt?Array.from(c().subarray(Bt>>>0,er>>>0)):[],strides:Ir?Array.from(c().subarray(Ir>>>0,Ur>>>0)):[]})},867948:(h,F,K,J,pe)=>{w.jb("Gemm",h,{alpha:F,beta:K,transA:J,transB:pe})},868052:h=>{w.jb("MatMul",h,void 0)},868106:(h,F,K,J)=>{w.jb("ArgMax",h,{keepDims:!!F,selectLastIndex:!!K,axis:J})},868214:(h,F,K,J)=>{w.jb("ArgMin",h,{keepDims:!!F,selectLastIndex:!!K,axis:J})},868322:(h,F)=>{w.jb("Softmax",h,{axis:F})},868385:(h,F)=>{w.jb("Concat",h,{axis:F})},868445:(h,F,K,J,pe)=>{w.jb("Split",h,{axis:F,numOutputs:K,splitSizes:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},868585:h=>{w.jb("Expand",h,void 0)},868639:(h,F)=>{w.jb("Gather",h,{axis:Number(F)})},868710:(h,F)=>{w.jb("GatherElements",h,{axis:Number(F)})},868789:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er)=>{w.jb("Resize",h,{antialias:F,axes:K?Array.from(c().subarray(K>>>0,J>>>0)):[],coordinateTransformMode:On(pe),cubicCoeffA:De,excludeOutside:ct,extrapolationValue:yt,keepAspectRatioPolicy:On(Ft),mode:On(Bt),nearestMode:On(er)})},869135:(h,F,K,J,pe,De,ct)=>{w.jb("Slice",h,{starts:F?Array.from(c().subarray(F>>>0,K>>>0)):[],ends:J?Array.from(c().subarray(J>>>0,pe>>>0)):[],axes:De?Array.from(c().subarray(De>>>0,ct>>>0)):[]})},869351:h=>{w.jb("Tile",h,void 0)},869403:(h,F,K)=>{w.jb("InstanceNormalization",h,{epsilon:F,format:K?"NHWC":"NCHW"})},869517:(h,F,K)=>{w.jb("InstanceNormalization",h,{epsilon:F,format:K?"NHWC":"NCHW"})},869631:h=>{w.jb("Range",h,void 0)},869684:(h,F)=>{w.jb("Einsum",h,{equation:On(F)})},869765:(h,F,K,J,pe)=>{w.jb("Pad",h,{mode:F,value:K,pads:J?Array.from(c().subarray(J>>>0,pe>>>0)):[]})},869892:(h,F,K,J,pe,De)=>{w.jb("BatchNormalization",h,{epsilon:F,momentum:K,spatial:!!pe,trainingMode:!!J,format:De?"NHWC":"NCHW"})},870061:(h,F,K,J,pe,De)=>{w.jb("BatchNormalization",h,{epsilon:F,momentum:K,spatial:!!pe,trainingMode:!!J,format:De?"NHWC":"NCHW"})},870230:(h,F,K)=>{w.jb("CumSum",h,{exclusive:Number(F),reverse:Number(K)})},870327:(h,F,K)=>{w.jb("DequantizeLinear",h,{axis:F,blockSize:K})},870417:(h,F,K,J,pe,De,ct,yt,Ft)=>{w.jb("Attention",h,{numHeads:F,isUnidirectional:K,maskFilterValue:J,scale:pe,doRotary:De,qkvHiddenSizes:ct?Array.from(c().subarray(Number(yt)>>>0,Number(yt)+ct>>>0)):[],pastPresentShareBuffer:!!Ft})},870689:h=>{w.jb("BiasAdd",h,void 0)},870744:h=>{w.jb("BiasSplitGelu",h,void 0)},870805:h=>{w.jb("FastGelu",h,void 0)},870861:(h,F,K,J,pe,De,ct,yt,Ft,Bt,er,Ir,Ur,it,Cr,un)=>{w.jb("Conv",h,{format:Ir?"NHWC":"NCHW",auto_pad:F,dilations:K?Array.from(c().subarray(K>>>0,J>>>0)):[],group:pe,kernel_shape:De?Array.from(c().subarray(De>>>0,ct>>>0)):[],pads:yt?Array.from(c().subarray(yt>>>0,Ft>>>0)):[],strides:Bt?Array.from(c().subarray(Bt>>>0,er>>>0)):[],w_is_const:()=>!!s()[Ur>>>0],activation:On(it),activation_params:Cr?Array.from(T().subarray(Cr>>>0,un>>>0)):[]})},871357:h=>{w.jb("Gelu",h,void 0)},871409:(h,F,K,J)=>{w.jb("GroupQueryAttention",h,{numHeads:F,kvNumHeads:K,scale:J})},871522:(h,F,K,J)=>{w.jb("LayerNormalization",h,{axis:F,epsilon:K,simplified:!!J})},871633:(h,F,K,J)=>{w.jb("LayerNormalization",h,{axis:F,epsilon:K,simplified:!!J})},871744:(h,F,K,J,pe,De)=>{w.jb("MatMulNBits",h,{k:F,n:K,accuracyLevel:J,bits:pe,blockSize:De})},871871:(h,F,K,J,pe,De)=>{w.jb("MultiHeadAttention",h,{numHeads:F,isUnidirectional:K,maskFilterValue:J,scale:pe,doRotary:De})},872030:(h,F)=>{w.jb("QuickGelu",h,{alpha:F})},872094:(h,F,K,J,pe)=>{w.jb("RotaryEmbedding",h,{interleaved:!!F,numHeads:K,rotaryEmbeddingDim:J,scale:pe})},872233:(h,F,K)=>{w.jb("SkipLayerNormalization",h,{epsilon:F,simplified:!!K})},872335:(h,F,K)=>{w.jb("SkipLayerNormalization",h,{epsilon:F,simplified:!!K})},872437:(h,F,K,J)=>{w.jb("GatherBlockQuantized",h,{gatherAxis:F,quantizeAxis:K,blockSize:J})},872558:h=>{w.Yb(h)},872592:(h,F)=>w.$b(h,F,w.Eb.bc,w.Eb.errors)};function Nx(h,F,K){return jw(async()=>{await w.Wb(h,F,K)})}function jx(){return typeof wasmOffsetConverter<"u"}function Ym(h){this.name="ExitStatus",this.message=`Program terminated with exit(${h})`,this.status=h}var Zm=h=>{h.terminate(),h.onmessage=()=>{}},lw=h=>{ss.length==0&&(hw(),pw(ss[0]));var F=ss.pop();if(!F)return 6;ea.push(F),so[h.Ab]=F,F.Ab=h.Ab;var K={cmd:"run",start_routine:h.cc,arg:h.Pb,pthread_ptr:h.Ab};return F.postMessage(K,h.ic),0},Js=0,an=(h,F,...K)=>{for(var J=2*K.length,pe=_g(),De=gg(8*J),ct=De>>>3,yt=0;yt<K.length;yt++){var Ft=K[yt];typeof Ft=="bigint"?(Cn[ct+2*yt]=1n,Cn[ct+2*yt+1]=Ft):(Cn[ct+2*yt]=0n,E()[ct+2*yt+1>>>0]=Ft)}return h=d1(h,0,J,De,F),ch(pe),h};function Jm(h){if(_e)return an(0,1,h);if(rr=h,!(0<Js)){for(var F of ea)Zm(F);for(F of ss)Zm(F);ss=[],ea=[],so=[],ki=!0}lt(h,new Ym(h))}function uw(h){if(_e)return an(1,0,h);eg(h)}var eg=h=>{if(rr=h,_e)throw uw(h),"unwind";Jm(h)},ss=[],ea=[],cw=[],so={},dw=h=>{var F=h.Ab;delete so[F],ss.push(h),ea.splice(ea.indexOf(h),1),h.Ab=0,mg(F)};function fw(){cw.forEach(h=>h())}var pw=h=>new Promise(F=>{h.onmessage=pe=>{var De=(pe=pe.data).cmd;if(pe.targetThread&&pe.targetThread!=Wl()){var ct=so[pe.targetThread];ct?ct.postMessage(pe,pe.transferList):nr(`Internal error! Worker sent a message "${De}" to target pthread ${pe.targetThread}, but that thread no longer exists!`)}else De==="checkMailbox"?eh():De==="spawnThread"?lw(pe):De==="cleanupThread"?dw(so[pe.thread]):De==="killThread"?(pe=pe.thread,De=so[pe],delete so[pe],Zm(De),mg(pe),ea.splice(ea.indexOf(De),1),De.Ab=0):De==="cancelThread"?so[pe.thread].postMessage({cmd:"cancel"}):De==="loaded"?(h.loaded=!0,F(h)):De==="alert"?alert(`Thread ${pe.threadId}: ${pe.text}`):pe.target==="setimmediate"?h.postMessage(pe):De==="callHandler"?w[pe.handler](...pe.args):De&&nr(`worker sent an unknown command ${De}`)},h.onerror=pe=>{throw nr(`worker sent an error! ${pe.filename}:${pe.lineno}: ${pe.message}`),pe};var K,J=[];for(K of[])w.hasOwnProperty(K)&&J.push(K);h.postMessage({cmd:"load",handlers:J,wasmMemory:Er,wasmModule:Hr})});function hw(){var h=new Worker(new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});ss.push(h)}var Jp=h=>{for(;0<h.length;)h.shift()(w)},Ux=()=>{var h=Wl(),F=b()[h+52>>>2>>>0];h=b()[h+56>>>2>>>0],p1(F,F-h),ch(F)},Vx=(h,F)=>{Js=0,h=h1(h,F),0<Js?rr=h:uh(h)};class Wx{constructor(F){this.Ib=F-24}}function Gx(h,F,K){var J=new Wx(h>>>=0);throw F>>>=0,K>>>=0,b()[J.Ib+16>>>2>>>0]=0,b()[J.Ib+4>>>2>>>0]=F,b()[J.Ib+8>>>2>>>0]=K,h}function mw(h,F,K,J){return _e?an(2,1,h,F,K,J):gw(h,F,K,J)}function gw(h,F,K,J){if(h>>>=0,F>>>=0,K>>>=0,J>>>=0,be===void 0)return nr("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var pe=[];return _e&&pe.length===0?mw(h,F,K,J):(h={cc:K,Ab:h,Pb:J,ic:pe},_e?(h.Lb="spawnThread",postMessage(h,pe),0):lw(h))}var _w=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,yw=(h,F,K)=>{var J=(F>>>=0)+K;for(K=F;h[K]&&!(K>=J);)++K;if(16<K-F&&h.buffer&&_w)return _w.decode(h.buffer instanceof be?h.slice(F,K):h.subarray(F,K));for(J="";F<K;){var pe=h[F++];if(128&pe){var De=63&h[F++];if((224&pe)==192)J+=String.fromCharCode((31&pe)<<6|De);else{var ct=63&h[F++];65536>(pe=(240&pe)==224?(15&pe)<<12|De<<6|ct:(7&pe)<<18|De<<12|ct<<6|63&h[F++])?J+=String.fromCharCode(pe):(pe-=65536,J+=String.fromCharCode(55296|pe>>10,56320|1023&pe))}}else J+=String.fromCharCode(pe)}return J},On=(h,F)=>(h>>>=0)?yw(u(),h,F):"";function ww(h,F,K){return _e?an(3,1,h,F,K):0}function vw(h,F){if(_e)return an(4,1,h,F)}var tg=h=>{for(var F=0,K=0;K<h.length;++K){var J=h.charCodeAt(K);127>=J?F++:2047>=J?F+=2:55296<=J&&57343>=J?(F+=4,++K):F+=3}return F},bw=(h,F,K,J)=>{if(!(0<J))return 0;var pe=K>>>=0;J=K+J-1;for(var De=0;De<h.length;++De){var ct=h.charCodeAt(De);if(55296<=ct&&57343>=ct&&(ct=65536+((1023&ct)<<10)|1023&h.charCodeAt(++De)),127>=ct){if(K>=J)break;F[K++>>>0]=ct}else{if(2047>=ct){if(K+1>=J)break;F[K++>>>0]=192|ct>>6}else{if(65535>=ct){if(K+2>=J)break;F[K++>>>0]=224|ct>>12}else{if(K+3>=J)break;F[K++>>>0]=240|ct>>18,F[K++>>>0]=128|ct>>12&63}F[K++>>>0]=128|ct>>6&63}F[K++>>>0]=128|63&ct}}return F[K>>>0]=0,K-pe},Ul=(h,F,K)=>bw(h,u(),F,K);function xw(h,F){if(_e)return an(5,1,h,F)}function Mw(h,F,K){if(_e)return an(6,1,h,F,K)}function kw(h,F,K){return _e?an(7,1,h,F,K):0}function Tw(h,F){if(_e)return an(8,1,h,F)}function Sw(h,F,K){if(_e)return an(9,1,h,F,K)}function Ew(h,F,K,J){if(_e)return an(10,1,h,F,K,J)}function Cw(h,F,K,J){if(_e)return an(11,1,h,F,K,J)}function Pw(h,F,K,J){if(_e)return an(12,1,h,F,K,J)}function $w(h){if(_e)return an(13,1,h)}function Aw(h,F){if(_e)return an(14,1,h,F)}function Iw(h,F,K){if(_e)return an(15,1,h,F,K)}var Fw,as,Hx=()=>{jl("")},ao=h=>{for(var F="";u()[h>>>0];)F+=Fw[u()[h++>>>0]];return F},rg={},ng={};function Co(h,F,K={}){if(!("argPackAdvance"in F))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(J,pe,De={}){var ct=pe.name;if(!J)throw new as(`type "${ct}" must have a positive integer typeid pointer`);if(ng.hasOwnProperty(J)){if(De.Rb)return;throw new as(`Cannot register type '${ct}' twice`)}ng[J]=pe,rg.hasOwnProperty(J)&&(pe=rg[J],delete rg[J],pe.forEach(yt=>yt()))}(h,F,K)}var zw=(h,F,K)=>{switch(F){case 1:return K?J=>s()[J>>>0]:J=>u()[J>>>0];case 2:return K?J=>d()[J>>>1>>>0]:J=>p()[J>>>1>>>0];case 4:return K?J=>c()[J>>>2>>>0]:J=>b()[J>>>2>>>0];case 8:return K?J=>Cn[J>>>3]:J=>is[J>>>3];default:throw new TypeError(`invalid integer width (${F}): ${h}`)}};function qx(h,F,K){K>>>=0,Co(h>>>=0,{name:F=ao(F>>>0),fromWireType:J=>J,toWireType:function(J,pe){if(typeof pe!="bigint"&&typeof pe!="number")throw pe=pe===null?"null":(J=typeof pe)=="object"||J==="array"||J==="function"?pe.toString():""+pe,new TypeError(`Cannot convert "${pe}" to ${this.name}`);return typeof pe=="number"&&(pe=BigInt(pe)),pe},argPackAdvance:ls,readValueFromPointer:zw(F,K,F.indexOf("u")==-1),Db:null})}var ls=8;function Kx(h,F,K,J){Co(h>>>=0,{name:F=ao(F>>>0),fromWireType:function(pe){return!!pe},toWireType:function(pe,De){return De?K:J},argPackAdvance:ls,readValueFromPointer:function(pe){return this.fromWireType(u()[pe>>>0])},Db:null})}var ig=[],Po=[];function og(h){9<(h>>>=0)&&--Po[h+1]==0&&(Po[h]=void 0,ig.push(h))}var Di=h=>{if(!h)throw new as("Cannot use deleted val. handle = "+h);return Po[h]},Li=h=>{switch(h){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let F=ig.pop()||Po.length;return Po[F]=h,Po[F+1]=1,F}};function sg(h){return this.fromWireType(b()[h>>>2>>>0])}var Qx={name:"emscripten::val",fromWireType:h=>{var F=Di(h);return og(h),F},toWireType:(h,F)=>Li(F),argPackAdvance:ls,readValueFromPointer:sg,Db:null};function Xx(h){return Co(h>>>0,Qx)}var Yx=(h,F)=>{switch(F){case 4:return function(K){return this.fromWireType(T()[K>>>2>>>0])};case 8:return function(K){return this.fromWireType(E()[K>>>3>>>0])};default:throw new TypeError(`invalid float width (${F}): ${h}`)}};function Zx(h,F,K){K>>>=0,Co(h>>>=0,{name:F=ao(F>>>0),fromWireType:J=>J,toWireType:(J,pe)=>pe,argPackAdvance:ls,readValueFromPointer:Yx(F,K),Db:null})}function Jx(h,F,K,J,pe){if(h>>>=0,K>>>=0,F=ao(F>>>0),pe===-1&&(pe=4294967295),pe=yt=>yt,J===0){var De=32-8*K;pe=yt=>yt<<De>>>De}var ct=F.includes("unsigned")?function(yt,Ft){return Ft>>>0}:function(yt,Ft){return Ft};Co(h,{name:F,fromWireType:pe,toWireType:ct,argPackAdvance:ls,readValueFromPointer:zw(F,K,J!==0),Db:null})}function eM(h,F,K){function J(De){var ct=b()[De>>>2>>>0];return De=b()[De+4>>>2>>>0],new pe(s().buffer,De,ct)}var pe=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][F];Co(h>>>=0,{name:K=ao(K>>>0),fromWireType:J,argPackAdvance:ls,readValueFromPointer:J},{Rb:!0})}function tM(h,F){h>>>=0;var K=(F=ao(F>>>0))==="std::string";Co(h,{name:F,fromWireType:function(J){var pe=b()[J>>>2>>>0],De=J+4;if(K)for(var ct=De,yt=0;yt<=pe;++yt){var Ft=De+yt;if(yt==pe||u()[Ft>>>0]==0){if(ct=On(ct,Ft-ct),Bt===void 0)var Bt=ct;else Bt+="\0",Bt+=ct;ct=Ft+1}}else{for(Bt=Array(pe),yt=0;yt<pe;++yt)Bt[yt]=String.fromCharCode(u()[De+yt>>>0]);Bt=Bt.join("")}return uo(J),Bt},toWireType:function(J,pe){pe instanceof ArrayBuffer&&(pe=new Uint8Array(pe));var De=typeof pe=="string";if(!(De||pe instanceof Uint8Array||pe instanceof Uint8ClampedArray||pe instanceof Int8Array))throw new as("Cannot pass non-string to std::string");var ct=K&&De?tg(pe):pe.length,yt=lh(4+ct+1),Ft=yt+4;if(b()[yt>>>2>>>0]=ct,K&&De)Ul(pe,Ft,ct+1);else if(De)for(De=0;De<ct;++De){var Bt=pe.charCodeAt(De);if(255<Bt)throw uo(Ft),new as("String has UTF-16 code units that do not fit in 8 bits");u()[Ft+De>>>0]=Bt}else for(De=0;De<ct;++De)u()[Ft+De>>>0]=pe[De];return J!==null&&J.push(uo,yt),yt},argPackAdvance:ls,readValueFromPointer:sg,Db(J){uo(J)}})}var Ow=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,rM=(h,F)=>{for(var K=h>>1,J=K+F/2;!(K>=J)&&p()[K>>>0];)++K;if(32<(K<<=1)-h&&Ow)return Ow.decode(u().slice(h,K));for(K="",J=0;!(J>=F/2);++J){var pe=d()[h+2*J>>>1>>>0];if(pe==0)break;K+=String.fromCharCode(pe)}return K},nM=(h,F,K)=>{if(K??(K=2147483647),2>K)return 0;var J=F;K=(K-=2)<2*h.length?K/2:h.length;for(var pe=0;pe<K;++pe){var De=h.charCodeAt(pe);d()[F>>>1>>>0]=De,F+=2}return d()[F>>>1>>>0]=0,F-J},iM=h=>2*h.length,oM=(h,F)=>{for(var K=0,J="";!(K>=F/4);){var pe=c()[h+4*K>>>2>>>0];if(pe==0)break;++K,65536<=pe?(pe-=65536,J+=String.fromCharCode(55296|pe>>10,56320|1023&pe)):J+=String.fromCharCode(pe)}return J},sM=(h,F,K)=>{if(F>>>=0,K??(K=2147483647),4>K)return 0;var J=F;K=J+K-4;for(var pe=0;pe<h.length;++pe){var De=h.charCodeAt(pe);if(55296<=De&&57343>=De&&(De=65536+((1023&De)<<10)|1023&h.charCodeAt(++pe)),c()[F>>>2>>>0]=De,(F+=4)+4>K)break}return c()[F>>>2>>>0]=0,F-J},aM=h=>{for(var F=0,K=0;K<h.length;++K){var J=h.charCodeAt(K);55296<=J&&57343>=J&&++K,F+=4}return F};function lM(h,F,K){if(h>>>=0,F>>>=0,K=ao(K>>>=0),F===2)var J=rM,pe=nM,De=iM,ct=yt=>p()[yt>>>1>>>0];else F===4&&(J=oM,pe=sM,De=aM,ct=yt=>b()[yt>>>2>>>0]);Co(h,{name:K,fromWireType:yt=>{for(var Ft,Bt=b()[yt>>>2>>>0],er=yt+4,Ir=0;Ir<=Bt;++Ir){var Ur=yt+4+Ir*F;Ir!=Bt&&ct(Ur)!=0||(er=J(er,Ur-er),Ft===void 0?Ft=er:(Ft+="\0",Ft+=er),er=Ur+F)}return uo(yt),Ft},toWireType:(yt,Ft)=>{if(typeof Ft!="string")throw new as(`Cannot pass non-string to C++ string type ${K}`);var Bt=De(Ft),er=lh(4+Bt+F);return b()[er>>>2>>>0]=Bt/F,pe(Ft,er+4,Bt+F),yt!==null&&yt.push(uo,er),er},argPackAdvance:ls,readValueFromPointer:sg,Db(yt){uo(yt)}})}function uM(h,F){Co(h>>>=0,{Sb:!0,name:F=ao(F>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var cM=()=>1;function dM(h){hg(h>>>0,!le,1,!re,131072,!1),fw()}var Dw=h=>{if(!ki)try{if(h(),!(0<Js))try{_e?uh(rr):eg(rr)}catch(F){F instanceof Ym||F=="unwind"||lt(1,F)}}catch(F){F instanceof Ym||F=="unwind"||lt(1,F)}};function ag(h){h>>>=0,typeof Atomics.jc=="function"&&(Atomics.jc(c(),h>>>2,h).value.then(eh),h+=128,Atomics.store(c(),h>>>2,1))}var eh=()=>{var h=Wl();h&&(ag(h),Dw(f1))};function fM(h,F){(h>>>=0)==F>>>0?setTimeout(eh):_e?postMessage({targetThread:h,cmd:"checkMailbox"}):(h=so[h])&&h.postMessage({cmd:"checkMailbox"})}var lg=[];function pM(h,F,K,J,pe){for(F>>>=0,J/=2,lg.length=J,K=pe>>>0>>>3,pe=0;pe<J;pe++)lg[pe]=Cn[K+2*pe]?Cn[K+2*pe+1]:E()[K+2*pe+1>>>0];return(F?Xm[F]:rk[h])(...lg)}function hM(h){h>>>=0,_e?postMessage({cmd:"cleanupThread",thread:h}):dw(so[h])}function mM(h){}var ug=(h,F)=>{var K=ng[h];if(K===void 0)throw h=l1(h),K=ao(h),uo(h),new as(`${F} has unknown type ${K}`);return K},Lw=(h,F,K)=>{var J=[];return h=h.toWireType(J,K),J.length&&(b()[F>>>2>>>0]=Li(J)),h};function gM(h,F,K){return F>>>=0,K>>>=0,h=Di(h>>>0),F=ug(F,"emval::as"),Lw(F,K,h)}var th=h=>{try{h()}catch(F){jl(F)}},us=0,lo=null,Bw=0,rh=[],Rw={},Nw={},_M=0,cg=null,yM=[];function jw(h){return function(F){if(!ki){if(us===0){var K=!1,J=!1;F((pe=0)=>{if(!ki&&(Bw=pe,K=!0,J)){us=2,th(()=>_1(lo)),typeof Browser<"u"&&Browser.Jb.Qb&&Browser.Jb.resume(),pe=!1;try{var De=function(){var Ft=c()[lo+8>>>2>>>0];return Ft=Yt[Nw[Ft]],--Js,Ft()}()}catch(Ft){De=Ft,pe=!0}var ct=!1;if(!lo){var yt=cg;yt&&(cg=null,(pe?yt.reject:yt.resolve)(De),ct=!0)}if(pe&&!ct)throw De}}),J=!0,K||(us=1,lo=function(){var pe=lh(65548),De=pe+12;b()[pe>>>2>>>0]=De,b()[pe+4>>>2>>>0]=De+65536,De=rh[0];var ct=Rw[De];return ct===void 0&&(ct=_M++,Rw[De]=ct,Nw[ct]=De),De=ct,c()[pe+8>>>2>>>0]=De,pe}(),typeof Browser<"u"&&Browser.Jb.Qb&&Browser.Jb.pause(),th(()=>m1(lo)))}else us===2?(us=0,th(y1),uo(lo),lo=null,yM.forEach(Dw)):jl(`invalid state: ${us}`);return Bw}}(F=>{h().then(F)})}function wM(h){return h>>>=0,jw(()=>(h=Di(h)).then(Li))}var nh=[];function vM(h,F,K,J){return K>>>=0,J>>>=0,(h=nh[h>>>0])(null,F=Di(F>>>0),K,J)}var bM={},ih=h=>{var F=bM[h];return F===void 0?ao(h):F};function xM(h,F,K,J,pe){return K>>>=0,J>>>=0,pe>>>=0,(h=nh[h>>>0])(F=Di(F>>>0),F[K=ih(K)],J,pe)}var Uw=()=>typeof globalThis=="object"?globalThis:Function("return this")();function MM(h){return(h>>>=0)==0?Li(Uw()):(h=ih(h),Li(Uw()[h]))}var kM=h=>{var F=nh.length;return nh.push(h),F},TM=(h,F)=>{for(var K=Array(h),J=0;J<h;++J)K[J]=ug(b()[F+4*J>>>2>>>0],"parameter "+J);return K},Vw=(h,F)=>Object.defineProperty(F,"name",{value:h});function SM(h,F,K){var J=(F=TM(h,F>>>0)).shift();h--;var pe=`return function (obj, func, destructorsRef, args) {
`,De=0,ct=[];K===0&&ct.push("obj");for(var yt=["retType"],Ft=[J],Bt=0;Bt<h;++Bt)ct.push("arg"+Bt),yt.push("argType"+Bt),Ft.push(F[Bt]),pe+=`  var arg${Bt} = argType${Bt}.readValueFromPointer(args${De?"+"+De:""});
`,De+=F[Bt].argPackAdvance;return pe+=`  var rv = ${K===1?"new func":"func.call"}(${ct.join(", ")});
`,J.Sb||(yt.push("emval_returnValue"),Ft.push(Lw),pe+=`  return emval_returnValue(retType, destructorsRef, rv);
`),yt.push(pe+`};
`),h=function(er){var Ir=Function;if(!(Ir instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof Ir} which is not a function`);var Ur=Vw(Ir.name||"unknownFunctionName",function(){});return Ur.prototype=Ir.prototype,Ur=new Ur,(er=Ir.apply(Ur,er))instanceof Object?er:Ur}(yt)(...Ft),K=`methodCaller<(${F.map(er=>er.name).join(", ")}) => ${J.name}>`,kM(Vw(K,h))}function EM(h){return h=ih(h>>>0),Li(w[h])}function CM(h,F){return F>>>=0,h=Di(h>>>0),F=Di(F),Li(h[F])}function PM(h){9<(h>>>=0)&&(Po[h+1]+=1)}function $M(){return Li([])}function AM(h){h=Di(h>>>0);for(var F=Array(h.length),K=0;K<h.length;K++)F[K]=h[K];return Li(F)}function IM(h){return Li(ih(h>>>0))}function FM(){return Li({})}function zM(h){for(var F=Di(h>>>=0);F.length;){var K=F.pop();F.pop()(K)}og(h)}function OM(h,F,K){F>>>=0,K>>>=0,h=Di(h>>>0),F=Di(F),K=Di(K),h[F]=K}function DM(h,F){return F>>>=0,h=(h=ug(h>>>0,"_emval_take_value")).readValueFromPointer(F),Li(h)}function LM(h,F){h=-9007199254740992>h||9007199254740992<h?NaN:Number(h),F>>>=0,h=new Date(1e3*h),c()[F>>>2>>>0]=h.getUTCSeconds(),c()[F+4>>>2>>>0]=h.getUTCMinutes(),c()[F+8>>>2>>>0]=h.getUTCHours(),c()[F+12>>>2>>>0]=h.getUTCDate(),c()[F+16>>>2>>>0]=h.getUTCMonth(),c()[F+20>>>2>>>0]=h.getUTCFullYear()-1900,c()[F+24>>>2>>>0]=h.getUTCDay(),h=(h.getTime()-Date.UTC(h.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,c()[F+28>>>2>>>0]=h}var Vl=h=>h%4==0&&(h%100!=0||h%400==0),Ww=[0,31,60,91,121,152,182,213,244,274,305,335],Gw=[0,31,59,90,120,151,181,212,243,273,304,334];function BM(h,F){h=-9007199254740992>h||9007199254740992<h?NaN:Number(h),F>>>=0,h=new Date(1e3*h),c()[F>>>2>>>0]=h.getSeconds(),c()[F+4>>>2>>>0]=h.getMinutes(),c()[F+8>>>2>>>0]=h.getHours(),c()[F+12>>>2>>>0]=h.getDate(),c()[F+16>>>2>>>0]=h.getMonth(),c()[F+20>>>2>>>0]=h.getFullYear()-1900,c()[F+24>>>2>>>0]=h.getDay();var K=(Vl(h.getFullYear())?Ww:Gw)[h.getMonth()]+h.getDate()-1|0;c()[F+28>>>2>>>0]=K,c()[F+36>>>2>>>0]=-60*h.getTimezoneOffset(),K=new Date(h.getFullYear(),6,1).getTimezoneOffset();var J=new Date(h.getFullYear(),0,1).getTimezoneOffset();h=0|(K!=J&&h.getTimezoneOffset()==Math.min(J,K)),c()[F+32>>>2>>>0]=h}function RM(h){h>>>=0;var F=new Date(c()[h+20>>>2>>>0]+1900,c()[h+16>>>2>>>0],c()[h+12>>>2>>>0],c()[h+8>>>2>>>0],c()[h+4>>>2>>>0],c()[h>>>2>>>0],0),K=c()[h+32>>>2>>>0],J=F.getTimezoneOffset(),pe=new Date(F.getFullYear(),6,1).getTimezoneOffset(),De=new Date(F.getFullYear(),0,1).getTimezoneOffset(),ct=Math.min(De,pe);return 0>K?c()[h+32>>>2>>>0]=+(pe!=De&&ct==J):0<K!=(ct==J)&&(pe=Math.max(De,pe),F.setTime(F.getTime()+6e4*((0<K?ct:pe)-J))),c()[h+24>>>2>>>0]=F.getDay(),K=(Vl(F.getFullYear())?Ww:Gw)[F.getMonth()]+F.getDate()-1|0,c()[h+28>>>2>>>0]=K,c()[h>>>2>>>0]=F.getSeconds(),c()[h+4>>>2>>>0]=F.getMinutes(),c()[h+8>>>2>>>0]=F.getHours(),c()[h+12>>>2>>>0]=F.getDate(),c()[h+16>>>2>>>0]=F.getMonth(),c()[h+20>>>2>>>0]=F.getYear(),h=F.getTime(),BigInt(isNaN(h)?-1:h/1e3)}function Hw(h,F,K,J,pe,De,ct){return _e?an(16,1,h,F,K,J,pe,De,ct):-52}function qw(h,F,K,J,pe,De){if(_e)return an(17,1,h,F,K,J,pe,De)}function NM(h,F,K,J){h>>>=0,F>>>=0,K>>>=0,J>>>=0;var pe=new Date().getFullYear(),De=new Date(pe,0,1),ct=new Date(pe,6,1);pe=De.getTimezoneOffset();var yt=ct.getTimezoneOffset(),Ft=Math.max(pe,yt);b()[h>>>2>>>0]=60*Ft,c()[F>>>2>>>0]=+(pe!=yt),De=(h=Bt=>Bt.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(De),ct=h(ct),yt<pe?(Ul(De,K,17),Ul(ct,J,17)):(Ul(De,J,17),Ul(ct,K,17))}var dg=[],Kw=(h,F)=>{dg.length=0;for(var K;K=u()[h++>>>0];){var J=K!=105;F+=(J&=K!=112)&&F%8?4:0,dg.push(K==112?b()[F>>>2>>>0]:K==106?Cn[F>>>3]:K==105?c()[F>>>2>>>0]:E()[F>>>3>>>0]),F+=J?8:4}return dg};function jM(h,F,K){return h>>>=0,F=Kw(F>>>0,K>>>0),Xm[h](...F)}function UM(h,F,K){return h>>>=0,F=Kw(F>>>0,K>>>0),Xm[h](...F)}var VM=()=>{},WM=()=>Date.now();function GM(h,F){return nr(On(h>>>0,F>>>0))}var Qw,HM=()=>{throw Js+=1,"unwind"};function qM(){return 4294901760}Qw=()=>performance.timeOrigin+performance.now();var KM=()=>navigator.hardwareConcurrency;function QM(){return jl("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function XM(h){h>>>=0;var F=u().length;if(h<=F||4294901760<h)return!1;for(var K=1;4>=K;K*=2){var J=F*(1+.2/K);J=Math.min(J,h+100663296);var pe=Math;J=Math.max(h,J);e:{pe=(pe.min.call(pe,4294901760,J+(65536-J%65536)%65536)-Er.buffer.byteLength+65535)/65536;try{Er.grow(pe),Un();var De=1;break e}catch{}De=void 0}if(De)return!0}return!1}var oh=()=>(jl("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),kf={},Xw=h=>{h.forEach(F=>{oh()})};function YM(){var h=Error().stack.toString().split(`
`);return h[0]=="Error"&&h.shift(),Xw(h),kf.Ob=oh(),kf.ac=h,kf.Ob}function ZM(h,F,K){if(h>>>=0,F>>>=0,kf.Ob==h)var J=kf.ac;else(J=Error().stack.toString().split(`
`))[0]=="Error"&&J.shift(),Xw(J);for(var pe=3;J[pe]&&oh()!=h;)++pe;for(h=0;h<K&&J[h+pe];++h)c()[F+4*h>>>2>>>0]=oh();return h}var fg,pg={},Yw=()=>{if(!fg){var h,F={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:dt};for(h in pg)pg[h]===void 0?delete F[h]:F[h]=pg[h];var K=[];for(h in F)K.push(`${h}=${F[h]}`);fg=K}return fg};function Zw(h,F){if(_e)return an(18,1,h,F);h>>>=0,F>>>=0;var K=0;return Yw().forEach((J,pe)=>{var De=F+K;for(pe=b()[h+4*pe>>>2>>>0]=De,De=0;De<J.length;++De)s()[pe++>>>0]=J.charCodeAt(De);s()[pe>>>0]=0,K+=J.length+1}),0}function Jw(h,F){if(_e)return an(19,1,h,F);h>>>=0,F>>>=0;var K=Yw();b()[h>>>2>>>0]=K.length;var J=0;return K.forEach(pe=>J+=pe.length+1),b()[F>>>2>>>0]=J,0}function e1(h){return _e?an(20,1,h):52}function t1(h,F,K,J){return _e?an(21,1,h,F,K,J):52}function r1(h,F,K,J){return _e?an(22,1,h,F,K,J):70}var JM=[null,[],[]];function n1(h,F,K,J){if(_e)return an(23,1,h,F,K,J);F>>>=0,K>>>=0,J>>>=0;for(var pe=0,De=0;De<K;De++){var ct=b()[F>>>2>>>0],yt=b()[F+4>>>2>>>0];F+=8;for(var Ft=0;Ft<yt;Ft++){var Bt=u()[ct+Ft>>>0],er=JM[h];Bt===0||Bt===10?((h===1?xr:nr)(yw(er,0)),er.length=0):er.push(Bt)}pe+=yt}return b()[J>>>2>>>0]=pe,0}var i1=[31,29,31,30,31,30,31,31,30,31,30,31],o1=[31,28,31,30,31,30,31,31,30,31,30,31],ek=(h,F)=>{s().set(h,F>>>0)};function s1(h,F,K,J){function pe(it,Cr,un){for(it=typeof it=="number"?it.toString():it||"";it.length<Cr;)it=un[0]+it;return it}function De(it,Cr){return pe(it,Cr,"0")}function ct(it,Cr){function un(v1){return 0>v1?-1:0<v1?1:0}var ta;return(ta=un(it.getFullYear()-Cr.getFullYear()))===0&&(ta=un(it.getMonth()-Cr.getMonth()))===0&&(ta=un(it.getDate()-Cr.getDate())),ta}function yt(it){switch(it.getDay()){case 0:return new Date(it.getFullYear()-1,11,29);case 1:return it;case 2:return new Date(it.getFullYear(),0,3);case 3:return new Date(it.getFullYear(),0,2);case 4:return new Date(it.getFullYear(),0,1);case 5:return new Date(it.getFullYear()-1,11,31);case 6:return new Date(it.getFullYear()-1,11,30)}}function Ft(it){var Cr=it.Bb;for(it=new Date(new Date(it.Cb+1900,0,1).getTime());0<Cr;){var un=it.getMonth(),ta=(Vl(it.getFullYear())?i1:o1)[un];if(!(Cr>ta-it.getDate())){it.setDate(it.getDate()+Cr);break}Cr-=ta-it.getDate()+1,it.setDate(1),11>un?it.setMonth(un+1):(it.setMonth(0),it.setFullYear(it.getFullYear()+1))}return un=new Date(it.getFullYear()+1,0,4),Cr=yt(new Date(it.getFullYear(),0,4)),un=yt(un),0>=ct(Cr,it)?0>=ct(un,it)?it.getFullYear()+1:it.getFullYear():it.getFullYear()-1}h>>>=0,F>>>=0,K>>>=0,J>>>=0;var Bt=b()[J+40>>>2>>>0];for(var er in J={fc:c()[J>>>2>>>0],ec:c()[J+4>>>2>>>0],Gb:c()[J+8>>>2>>>0],Kb:c()[J+12>>>2>>>0],Hb:c()[J+16>>>2>>>0],Cb:c()[J+20>>>2>>>0],ub:c()[J+24>>>2>>>0],Bb:c()[J+28>>>2>>>0],nc:c()[J+32>>>2>>>0],dc:c()[J+36>>>2>>>0],hc:Bt?On(Bt):""},K=On(K),Bt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})K=K.replace(new RegExp(er,"g"),Bt[er]);var Ir="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ur="January February March April May June July August September October November December".split(" ");for(er in Bt={"%a":it=>Ir[it.ub].substring(0,3),"%A":it=>Ir[it.ub],"%b":it=>Ur[it.Hb].substring(0,3),"%B":it=>Ur[it.Hb],"%C":it=>De((it.Cb+1900)/100|0,2),"%d":it=>De(it.Kb,2),"%e":it=>pe(it.Kb,2," "),"%g":it=>Ft(it).toString().substring(2),"%G":Ft,"%H":it=>De(it.Gb,2),"%I":it=>((it=it.Gb)==0?it=12:12<it&&(it-=12),De(it,2)),"%j":it=>{for(var Cr=0,un=0;un<=it.Hb-1;Cr+=(Vl(it.Cb+1900)?i1:o1)[un++]);return De(it.Kb+Cr,3)},"%m":it=>De(it.Hb+1,2),"%M":it=>De(it.ec,2),"%n":()=>`
`,"%p":it=>0<=it.Gb&&12>it.Gb?"AM":"PM","%S":it=>De(it.fc,2),"%t":()=>"	","%u":it=>it.ub||7,"%U":it=>De(Math.floor((it.Bb+7-it.ub)/7),2),"%V":it=>{var Cr=Math.floor((it.Bb+7-(it.ub+6)%7)/7);if(2>=(it.ub+371-it.Bb-2)%7&&Cr++,Cr)Cr==53&&((un=(it.ub+371-it.Bb)%7)==4||un==3&&Vl(it.Cb)||(Cr=1));else{Cr=52;var un=(it.ub+7-it.Bb-1)%7;(un==4||un==5&&Vl(it.Cb%400-1))&&Cr++}return De(Cr,2)},"%w":it=>it.ub,"%W":it=>De(Math.floor((it.Bb+7-(it.ub+6)%7)/7),2),"%y":it=>(it.Cb+1900).toString().substring(2),"%Y":it=>it.Cb+1900,"%z":it=>{var Cr=0<=(it=it.dc);return it=Math.abs(it)/60,(Cr?"+":"-")+("0000"+(it/60*100+it%60)).slice(-4)},"%Z":it=>it.hc,"%%":()=>"%"},K=K.replace(/%%/g,"\0\0"),Bt)K.includes(er)&&(K=K.replace(new RegExp(er,"g"),Bt[er](J)));return er=function(it){var Cr=Array(tg(it)+1);return bw(it,Cr,0,Cr.length),Cr}(K=K.replace(/\0\0/g,"%")),er.length>F?0:(ek(er,h),er.length-1)}function tk(h,F,K,J){return s1(h>>>0,F>>>0,K>>>0,J>>>0)}_e||function(){for(var h=w.numThreads-1;h--;)hw();Mf.unshift(()=>{Oi++,function(F){_e?F():Promise.all(ss.map(pw)).then(F)}(()=>Zp())})}();for(var a1=Array(256),sh=0;256>sh;++sh)a1[sh]=String.fromCharCode(sh);Fw=a1,as=w.BindingError=class extends Error{constructor(h){super(h),this.name="BindingError"}},w.InternalError=class extends Error{constructor(h){super(h),this.name="InternalError"}},Po.push(0,1,void 0,1,null,1,!0,1,!1,1),w.count_emval_handles=()=>Po.length/2-5-ig.length;var rk=[Jm,uw,mw,ww,vw,xw,Mw,kw,Tw,Sw,Ew,Cw,Pw,$w,Aw,Iw,Hw,qw,Zw,Jw,e1,t1,r1,n1],Yt=function(){function h(K,J){return Yt=K.exports,Yt=function(){var pe=Yt,De={};for(let[ct,yt]of Object.entries(pe))De[ct]=typeof yt=="function"?(...Ft)=>{rh.push(ct);try{return yt(...Ft)}finally{ki||(rh.pop(),lo&&us===1&&rh.length===0&&(us=0,Js+=1,th(g1),typeof Fibers<"u"&&Fibers.oc()))}}:yt;return De}(),Yt=function(){var pe=Yt,De=yt=>Ft=>yt(Ft)>>>0,ct=yt=>()=>yt()>>>0;return(pe=Object.assign({},pe)).Ca=De(pe.Ca),pe.fb=ct(pe.fb),pe.gb=De(pe.gb),pe.emscripten_main_runtime_thread_id=ct(pe.emscripten_main_runtime_thread_id),pe.sb=De(pe.sb),pe.tb=ct(pe.tb),pe}(),cw.push(Yt.ib),Vn.unshift(Yt.Ba),Hr=J,Zp(),Yt}var F=aw();if(Oi++,w.instantiateWasm)try{return w.instantiateWasm(F,h)}catch(K){nr(`Module.instantiateWasm callback failed with error: ${K}`),H(K)}return Qm||(Qm=w.locateFile?nw("ort-wasm-simd-threaded.jsep.wasm")?"ort-wasm-simd-threaded.jsep.wasm":w.locateFile?w.locateFile("ort-wasm-simd-threaded.jsep.wasm",Mt):Mt+"ort-wasm-simd-threaded.jsep.wasm":new URL(n("./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm"),n.b).href),function(K,J){var pe=Qm;return Dt||typeof WebAssembly.instantiateStreaming!="function"||nw(pe)||iw(pe)||typeof fetch!="function"?sw(pe,K,J):fetch(pe,{credentials:"same-origin"}).then(De=>WebAssembly.instantiateStreaming(De,K).then(J,function(ct){return nr(`wasm streaming compile failed: ${ct}`),nr("falling back to ArrayBuffer instantiation"),sw(pe,K,J)}))}(F,function(K){h(K.instance,K.module)}).catch(H),{}}(),l1=h=>(l1=Yt.Ca)(h),u1=()=>(u1=Yt.Da)();w._OrtInit=(h,F)=>(w._OrtInit=Yt.Ea)(h,F),w._OrtGetLastError=(h,F)=>(w._OrtGetLastError=Yt.Fa)(h,F),w._OrtCreateSessionOptions=(h,F,K,J,pe,De,ct,yt,Ft,Bt)=>(w._OrtCreateSessionOptions=Yt.Ga)(h,F,K,J,pe,De,ct,yt,Ft,Bt),w._OrtAppendExecutionProvider=(h,F)=>(w._OrtAppendExecutionProvider=Yt.Ha)(h,F),w._OrtAddFreeDimensionOverride=(h,F,K)=>(w._OrtAddFreeDimensionOverride=Yt.Ia)(h,F,K),w._OrtAddSessionConfigEntry=(h,F,K)=>(w._OrtAddSessionConfigEntry=Yt.Ja)(h,F,K),w._OrtReleaseSessionOptions=h=>(w._OrtReleaseSessionOptions=Yt.Ka)(h),w._OrtCreateSession=(h,F,K)=>(w._OrtCreateSession=Yt.La)(h,F,K),w._OrtReleaseSession=h=>(w._OrtReleaseSession=Yt.Ma)(h),w._OrtGetInputOutputCount=(h,F,K)=>(w._OrtGetInputOutputCount=Yt.Na)(h,F,K),w._OrtGetInputName=(h,F)=>(w._OrtGetInputName=Yt.Oa)(h,F),w._OrtGetOutputName=(h,F)=>(w._OrtGetOutputName=Yt.Pa)(h,F),w._OrtFree=h=>(w._OrtFree=Yt.Qa)(h),w._OrtCreateTensor=(h,F,K,J,pe,De)=>(w._OrtCreateTensor=Yt.Ra)(h,F,K,J,pe,De),w._OrtGetTensorData=(h,F,K,J,pe)=>(w._OrtGetTensorData=Yt.Sa)(h,F,K,J,pe),w._OrtReleaseTensor=h=>(w._OrtReleaseTensor=Yt.Ta)(h),w._OrtCreateRunOptions=(h,F,K,J)=>(w._OrtCreateRunOptions=Yt.Ua)(h,F,K,J),w._OrtAddRunConfigEntry=(h,F,K)=>(w._OrtAddRunConfigEntry=Yt.Va)(h,F,K),w._OrtReleaseRunOptions=h=>(w._OrtReleaseRunOptions=Yt.Wa)(h),w._OrtCreateBinding=h=>(w._OrtCreateBinding=Yt.Xa)(h),w._OrtBindInput=(h,F,K)=>(w._OrtBindInput=Yt.Ya)(h,F,K),w._OrtBindOutput=(h,F,K,J)=>(w._OrtBindOutput=Yt.Za)(h,F,K,J),w._OrtClearBoundOutputs=h=>(w._OrtClearBoundOutputs=Yt._a)(h),w._OrtReleaseBinding=h=>(w._OrtReleaseBinding=Yt.$a)(h),w._OrtRunWithBinding=(h,F,K,J,pe)=>(w._OrtRunWithBinding=Yt.ab)(h,F,K,J,pe),w._OrtRun=(h,F,K,J,pe,De,ct,yt)=>(w._OrtRun=Yt.bb)(h,F,K,J,pe,De,ct,yt),w._OrtEndProfiling=h=>(w._OrtEndProfiling=Yt.cb)(h),w._JsepOutput=(h,F,K)=>(w._JsepOutput=Yt.db)(h,F,K),w._JsepGetNodeName=h=>(w._JsepGetNodeName=Yt.eb)(h);var ah,Wl=()=>(Wl=Yt.fb)(),lh=w._malloc=h=>(lh=w._malloc=Yt.gb)(h),uo=w._free=h=>(uo=w._free=Yt.hb)(h),hg=(h,F,K,J,pe,De)=>(hg=Yt.kb)(h,F,K,J,pe,De),c1=()=>(c1=Yt.lb)(),d1=(h,F,K,J,pe)=>(d1=Yt.mb)(h,F,K,J,pe),mg=h=>(mg=Yt.nb)(h),uh=h=>(uh=Yt.ob)(h),f1=()=>(f1=Yt.pb)(),p1=(h,F)=>(p1=Yt.qb)(h,F),ch=h=>(ch=Yt.rb)(h),gg=h=>(gg=Yt.sb)(h),_g=()=>(_g=Yt.tb)(),h1=w.dynCall_ii=(h,F)=>(h1=w.dynCall_ii=Yt.vb)(h,F),m1=h=>(m1=Yt.wb)(h),g1=()=>(g1=Yt.xb)(),_1=h=>(_1=Yt.yb)(h),y1=()=>(y1=Yt.zb)();function w1(){0<Oi||(_e?(q(w),_e||Jp(Vn),startWorker(w)):(Jp(Mf),0<Oi||ah||(ah=!0,w.calledRun=!0,ki||(_e||Jp(Vn),q(w),_e||Jp(ii)))))}return w.___start_em_js=872704,w.___stop_em_js=872926,w.stackSave=()=>_g(),w.stackRestore=h=>ch(h),w.stackAlloc=h=>gg(h),w.UTF8ToString=On,w.stringToUTF8=Ul,w.lengthBytesUTF8=tg,os=function h(){ah||w1(),ah||(os=h)},w1(),Z}),$t=vt,((r=globalThis.self)==null?void 0:r.name)==="em-pthread"&&vt()}),rt,Nt,Rt,Qt,Ht,Gt,tr,ir,lr=m(()=>{var r,i;Ke(),rt=import.meta.url??(typeof document<"u"?(r=document.currentScript)==null?void 0:r.src:typeof self<"u"?(i=self.location)==null?void 0:i.href:void 0),Nt=typeof location>"u"?void 0:location.origin,Rt=(s,u)=>{try{let d=u??rt;return(d?new URL(s,d):new URL(s)).origin===Nt}catch{return!1}},Qt=async s=>{let u=await(await fetch(s,{credentials:"same-origin"})).blob();return URL.createObjectURL(u)},Ht=(Qe(),v(de)).default,Gt=async()=>{if(!rt)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Rt(rt))return[void 0,Ht()];let s=await Qt(rt);return[s,Ht(s)]},tr=(kt(),v(ft)).default,ir=async(s,u,d)=>[void 0,tr]}),kr,mt,Tt,Lt,nn,yi,Ai,Qr,kn=m(()=>{lr(),mt=!1,Tt=!1,Lt=!1,nn=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},yi=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ai=async r=>{if(mt)return Promise.resolve();if(Tt)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Lt)throw new Error("previous call to 'initializeWebAssembly()' failed.");Tt=!0;let i=r.initTimeout,s=r.numThreads;if(!yi())throw new Error("WebAssembly SIMD is not supported in the current environment.");let u=nn();s>1&&!u&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+s+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),r.numThreads=s=1);let d=r.wasmPaths,p=typeof d=="string"?d:void 0,c=d==null?void 0:d.mjs,b=(c==null?void 0:c.href)??c,T=d==null?void 0:d.wasm,E=(T==null?void 0:T.href)??T,q=r.wasmBinary,[H,w]=await ir(b,p,s>1),Z=!1,re=[];if(i>0&&re.push(new Promise(le=>{setTimeout(()=>{Z=!0,le()},i)})),re.push(new Promise((le,_e)=>{let be={numThreads:s};q?be.wasmBinary=q:(E||p)&&(be.locateFile=(me,Fe)=>E??(p??Fe)+me),w(be).then(me=>{Tt=!1,mt=!0,kr=me,le(),H&&URL.revokeObjectURL(H)},me=>{Tt=!1,Lt=!0,_e(me)})})),await Promise.race(re),Z)throw new Error(`WebAssembly backend initializing failed due to timeout: ${i}ms`)},Qr=()=>{if(mt&&kr)return kr;throw new Error("WebAssembly is not initialized yet.")}}),Yr,wi,Nr,Wi=m(()=>{kn(),Yr=(r,i)=>{let s=Qr(),u=s.lengthBytesUTF8(r)+1,d=s._malloc(u);return s.stringToUTF8(r,d,u),i.push(d),d},wi=(r,i,s,u)=>{if(typeof r=="object"&&r!==null){if(s.has(r))throw new Error("Circular reference in options");s.add(r)}Object.entries(r).forEach(([d,p])=>{let c=i?i+d:d;if(typeof p=="object")wi(p,c+".",s,u);else if(typeof p=="string"||typeof p=="number")u(c,p.toString());else if(typeof p=="boolean")u(c,p?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof p}`)})},Nr=r=>{let i=Qr(),s=i.stackSave();try{let u=i.stackAlloc(8);i._OrtGetLastError(u,u+4);let d=i.HEAP32[u/4],p=i.HEAPU32[u/4+1],c=p?i.UTF8ToString(p):"";throw new Error(`${r} ERROR_CODE: ${d}, ERROR_MESSAGE: ${c}`)}finally{i.stackRestore(s)}}}),Ii,$s=m(()=>{kn(),Wi(),Ii=r=>{let i=Qr(),s=0,u=[],d=r||{};try{if((r==null?void 0:r.logSeverityLevel)===void 0)d.logSeverityLevel=2;else if(typeof r.logSeverityLevel!="number"||!Number.isInteger(r.logSeverityLevel)||r.logSeverityLevel<0||r.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${r.logSeverityLevel}`);if((r==null?void 0:r.logVerbosityLevel)===void 0)d.logVerbosityLevel=0;else if(typeof r.logVerbosityLevel!="number"||!Number.isInteger(r.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${r.logVerbosityLevel}`);(r==null?void 0:r.terminate)===void 0&&(d.terminate=!1);let p=0;return(r==null?void 0:r.tag)!==void 0&&(p=Yr(r.tag,u)),s=i._OrtCreateRunOptions(d.logSeverityLevel,d.logVerbosityLevel,!!d.terminate,p),s===0&&Nr("Can't create run options."),(r==null?void 0:r.extra)!==void 0&&wi(r.extra,"",new WeakSet,(c,b)=>{let T=Yr(c,u),E=Yr(b,u);i._OrtAddRunConfigEntry(s,T,E)!==0&&Nr(`Can't set a run config entry: ${c} - ${b}.`)}),[s,u]}catch(p){throw s!==0&&i._OrtReleaseRunOptions(s),u.forEach(c=>i._free(c)),p}}}),Uo,Vo,Wo,Go,Gi,As=m(()=>{kn(),Wi(),Uo=r=>{switch(r){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${r}`)}},Vo=r=>{switch(r){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${r}`)}},Wo=r=>{r.extra||(r.extra={}),r.extra.session||(r.extra.session={});let i=r.extra.session;i.use_ort_model_bytes_directly||(i.use_ort_model_bytes_directly="1"),r.executionProviders&&r.executionProviders.some(s=>(typeof s=="string"?s:s.name)==="webgpu")&&(r.enableMemPattern=!1)},Go=(r,i,s)=>{for(let u of i){let d=typeof u=="string"?u:u.name;switch(d){case"webnn":if(d="WEBNN",typeof u!="string"){let c=u==null?void 0:u.deviceType;if(c){let b=Yr("deviceType",s),T=Yr(c,s);Qr()._OrtAddSessionConfigEntry(r,b,T)!==0&&Nr(`Can't set a session config entry: 'deviceType' - ${c}.`)}}break;case"webgpu":if(d="JS",typeof u!="string"){let c=u;if(c!=null&&c.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);let b=Yr("preferredLayout",s),T=Yr(c.preferredLayout,s);Qr()._OrtAddSessionConfigEntry(r,b,T)!==0&&Nr(`Can't set a session config entry: 'preferredLayout' - ${c.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${d}`)}let p=Yr(d,s);Qr()._OrtAppendExecutionProvider(r,p)!==0&&Nr(`Can't append execution provider: ${d}.`)}},Gi=r=>{let i=Qr(),s=0,u=[],d=r||{};Wo(d);try{let p=Uo(d.graphOptimizationLevel??"all"),c=Vo(d.executionMode??"sequential"),b=typeof d.logId=="string"?Yr(d.logId,u):0,T=d.logSeverityLevel??2;if(!Number.isInteger(T)||T<0||T>4)throw new Error(`log serverity level is not valid: ${T}`);let E=d.logVerbosityLevel??0;if(!Number.isInteger(E)||E<0||E>4)throw new Error(`log verbosity level is not valid: ${E}`);let q=typeof d.optimizedModelFilePath=="string"?Yr(d.optimizedModelFilePath,u):0;if(s=i._OrtCreateSessionOptions(p,!!d.enableCpuMemArena,!!d.enableMemPattern,c,!!d.enableProfiling,0,b,T,E,q),s===0&&Nr("Can't create session options."),d.executionProviders&&Go(s,d.executionProviders,u),d.enableGraphCapture!==void 0){if(typeof d.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${d.enableGraphCapture}`);let H=Yr("enableGraphCapture",u),w=Yr(d.enableGraphCapture.toString(),u);i._OrtAddSessionConfigEntry(s,H,w)!==0&&Nr(`Can't set a session config entry: 'enableGraphCapture' - ${d.enableGraphCapture}.`)}if(d.freeDimensionOverrides)for(let[H,w]of Object.entries(d.freeDimensionOverrides)){if(typeof H!="string")throw new Error(`free dimension override name must be a string: ${H}`);if(typeof w!="number"||!Number.isInteger(w)||w<0)throw new Error(`free dimension override value must be a non-negative integer: ${w}`);let Z=Yr(H,u);i._OrtAddFreeDimensionOverride(s,Z,w)!==0&&Nr(`Can't set a free dimension override: ${H} - ${w}.`)}return d.extra!==void 0&&wi(d.extra,"",new WeakSet,(H,w)=>{let Z=Yr(H,u),re=Yr(w,u);i._OrtAddSessionConfigEntry(s,Z,re)!==0&&Nr(`Can't set a session config entry: ${H} - ${w}.`)}),[s,u]}catch(p){throw s!==0&&i._OrtReleaseSessionOptions(s),u.forEach(c=>i._free(c)),p}}}),_o,vi,Hi,Fi,ro,yo,wo,Zt=m(()=>{_o=r=>{switch(r){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${r}`)}},vi=r=>{switch(r){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${r}`)}},Hi=(r,i)=>{let s=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][r],u=typeof i=="number"?i:i.reduce((d,p)=>d*p,1);return s>0?Math.ceil(u*s):void 0},Fi=r=>{switch(r){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${r}`)}},ro=r=>{switch(r){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${r}`)}},yo=r=>r==="float32"||r==="float16"||r==="int32"||r==="int64"||r==="uint32"||r==="uint8"||r==="bool"||r==="uint4"||r==="int4",wo=r=>{switch(r){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${r}`)}}}),no,Ho=m(()=>{Ke(),no=async r=>{if(typeof r=="string"){let i=await fetch(r);if(!i.ok)throw new Error(`failed to load external data file: ${r}`);let s=i.headers.get("Content-Length"),u=s?parseInt(s,10):0;if(u<1073741824)return new Uint8Array(await i.arrayBuffer());{if(!i.body)throw new Error(`failed to load external data file: ${r}, no response body.`);let d=i.body.getReader(),p;try{p=new ArrayBuffer(u)}catch(b){if(b instanceof RangeError){let T=Math.ceil(u/65536);p=new WebAssembly.Memory({initial:T,maximum:T}).buffer}else throw b}let c=0;for(;;){let{done:b,value:T}=await d.read();if(b)break;let E=T.byteLength;new Uint8Array(p,c,E).set(T),c+=E}return new Uint8Array(p,0,u)}}else return r instanceof Blob?new Uint8Array(await r.arrayBuffer()):r instanceof Uint8Array?r:new Uint8Array(r)}}),qo,vo,Ko,Qo,bo,Xo,Kr,qn=m(()=>{Zt(),qo=["V","I","W","E","F"],vo=(r,i)=>{console.log(`[${qo[r]},${new Date().toISOString()}]${i}`)},bo=(r,i)=>{Ko=r,Qo=i},Xo=(r,i)=>{let s=ro(r),u=ro(Ko);s>=u&&vo(s,typeof i=="function"?i():i)},Kr=(...r)=>{Qo&&Xo(...r)}}),Ue,W=m(()=>{Zt(),Ue=(r,i)=>new(Fi(i))(r)}),fe=m(()=>{}),Ee,Oe,Le,nt,Et,Pt,Ct,Ot,sr,Dr=m(()=>{qn(),fe(),Ee=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Oe=[],Le=r=>Math.ceil(r/16)*16,nt=r=>{for(let i=0;i<Oe.length;i++){let s=Oe[i];if(r<=s)return s}return Math.ceil(r/16)*16},Et=1,Pt=()=>Et++,Ct=async(r,i,s,u)=>{let d=Le(s),p=r.device.createBuffer({size:d,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let c=r.getCommandEncoder();r.endComputePass(),c.copyBufferToBuffer(i,0,p,0,d),r.flush(),await p.mapAsync(GPUMapMode.READ);let b=p.getMappedRange();if(u){let T=u();return T.set(new Uint8Array(b,0,s)),T}else return new Uint8Array(b.slice(0,s))}finally{p.destroy()}},Ot=class{constructor(r){this.backend=r,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map;for(let[i]of Ee)Oe.push(i),this.freeBuffers.set(i,[]),this.freeUniformBuffers.set(i,[])}upload(r,i){let s=i.buffer,u=i.byteOffset,d=i.byteLength,p=Le(d),c=this.storageCache.get(r);if(!c)throw new Error("gpu data for uploading does not exist");if(c.originalSize!==d)throw new Error(`inconsistent data size. gpu data size=${c.originalSize}, data size=${d}`);let b=this.backend.device.createBuffer({mappedAtCreation:!0,size:p,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),T=b.getMappedRange();new Uint8Array(T).set(new Uint8Array(s,u,d)),b.unmap();let E=this.backend.getCommandEncoder();this.backend.endComputePass(),E.copyBufferToBuffer(b,0,c.gpuData.buffer,0,p),Kr("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${r})`),this.buffersForUploadingPending.push(b)}memcpy(r,i){let s=this.storageCache.get(r);if(!s)throw new Error("source gpu data for memcpy does not exist");let u=this.storageCache.get(i);if(!u)throw new Error("destination gpu data for memcpy does not exist");if(s.originalSize!==u.originalSize)throw new Error("inconsistent source and destination gpu data size");let d=Le(s.originalSize),p=this.backend.getCommandEncoder();this.backend.endComputePass(),p.copyBufferToBuffer(s.gpuData.buffer,0,u.gpuData.buffer,0,d)}registerExternalBuffer(r,i,s){let u;if(s){if(u=this.externalBuffers.get(s),u===void 0)throw new Error("previous buffer is not registered");if(r===s)return Kr("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${i}) => id=${u}, buffer is the same, skip.`),u;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);this.externalBuffers.delete(s)}else u=Pt();return this.storageCache.set(u,{gpuData:{id:u,type:0,buffer:r},originalSize:i}),this.externalBuffers.set(r,u),Kr("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${i}) => id=${u}, registered.`),u}unregisterExternalBuffer(r){let i=this.externalBuffers.get(r);i!==void 0&&(this.storageCache.delete(i),this.externalBuffers.delete(r),Kr("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${i}`))}create(r,i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let s=nt(r),u,d=(i&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,p=(i&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(d||p){let b=(d?this.freeBuffers:this.freeUniformBuffers).get(s);b?b.length>0?u=b.pop():u=this.backend.device.createBuffer({size:s,usage:i}):u=this.backend.device.createBuffer({size:s,usage:i})}else u=this.backend.device.createBuffer({size:s,usage:i});let c={id:Pt(),type:0,buffer:u};return this.storageCache.set(c.id,{gpuData:c,originalSize:r}),Kr("verbose",()=>`[WebGPU] GpuDataManager.create(size=${r}) => id=${c.id}`),c}get(r){var i;return(i=this.storageCache.get(r))==null?void 0:i.gpuData}release(r){let i=this.storageCache.get(r);if(!i)throw new Error("releasing data does not exist");return Kr("verbose",()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${i.gpuData.id}`),this.storageCache.delete(r),this.buffersPending.push(i.gpuData.buffer),i.originalSize}async download(r,i){let s=this.storageCache.get(r);if(!s)throw new Error("data does not exist");await Ct(this.backend,s.gpuData.buffer,s.originalSize,i)}refreshPendingBuffers(){for(let r of this.buffersForUploadingPending)r.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let r of this.buffersPending){let i=Ee.get(r.size);if((r.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let s=this.freeBuffers.get(r.size)||[];i===void 0||s.length>=i?r.destroy():s.push(r)}else if((r.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let s=this.freeUniformBuffers.get(r.size)||[];i===void 0||s.length>=i?r.destroy():s.push(r)}else r.destroy()}this.buffersPending=[]}else{let r=this.capturedPendingBuffers.get(this.backend.currentSessionId);r||(r=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,r));for(let i of this.buffersPending)r.push(i);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(r=>{r.forEach(i=>{i.destroy()})}),this.freeUniformBuffers.forEach(r=>{r.forEach(i=>{i.destroy()})}),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(r=>{r.forEach(i=>{i.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(r){let i=this.capturedPendingBuffers.get(r);i&&(i.forEach(s=>{s.destroy()}),this.capturedPendingBuffers.delete(r))}},sr=(...r)=>new Ot(...r)}),cr,Xt,vr=m(()=>{cr=class{constructor(r){Object.assign(this,r)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(r=>`${this[r]}`).join(";")),this.key}},Xt=r=>new cr(r)}),An,vn,Ze,ei,Pr,hn,Bn,Jt=m(()=>{An=class{static calcMatMulShape(r,i){return r[1]!==i[0]?void 0:[r[0],i[1]]}},vn=class{static calcShape(r,i,s=!1){let u=r.length,d=i.length;if(u===0)return i;if(d===0)return r;let p=Math.max(r.length,i.length),c=new Array(p);if(s){if(u<2||d<2)return;let b=An.calcMatMulShape([r[u-2],r[u-1]],[i[d-2],i[d-1]]);if(b===void 0)return;[c[p-2],c[p-1]]=b}for(let b=s?3:1;b<=p;b++){let T=u-b<0?1:r[u-b],E=d-b<0?1:i[d-b];if(T!==E&&T>1&&E>1)return;let q=Math.max(T,E);if(T&&E)c[p-b]=Math.max(T,E);else{if(q>1)return;c[p-b]=0}}return c}static isValidBroadcast(r,i){let s=r.length,u=i.length;if(s>u)return!1;for(let d=1;d<=s;d++)if(r[s-d]!==1&&r[s-d]!==i[u-d])return!1;return!0}},Ze=class Uh{static size(i){return Uh.getSizeFromDimensionRange(i,0,i.length)}static convertShape(i,s=4){let u=i.length;if(u===0)return[];let d=new Array(u),p=u-1;for(;p>=0;){if(i[p]%s===0){d[p]=i[p]/s;break}if(s%i[p]!==0)throw new Error("cannot convert shape");d[p]=1,s/=i[p],p--}for(p--;p>=0;p--)d[p]=i[p];return d}static sizeFromDimension(i,s){if(s<0||s>i.length)throw new Error(`invalid dimension of ${s} for sizeFromDimension as Tensor has ${i.length} dimensions.`);return Uh.getSizeFromDimensionRange(i,s,i.length)}static sizeToDimension(i,s){if(s<0||s>i.length)throw new Error(`invalid dimension of ${s} for sizeToDimension as Tensor has ${i.length} dimensions.`);return Uh.getSizeFromDimensionRange(i,0,s)}static getSizeFromDimensionRange(i,s,u){let d=1;for(let p=s;p<u;p++){if(i[p]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");d*=i[p]}return d}static computeStrides(i){let s=i.length;if(s===0)return[];if(s===1)return[1];let u=new Array(s);u[s-1]=1,u[s-2]=i[s-1];for(let d=s-3;d>=0;--d)u[d]=u[d+1]*i[d+1];return u}static normalizeAxis(i,s){if(i<-s&&i>=s)throw new Error("unsupported axis for this operation.");return i<0?i+s:i}static normalizeAxes(i,s){return i.map(u=>this.normalizeAxis(u,s??i.length))}static sortBasedOnPerm(i,s){return s?s.map(u=>i[u]):i.slice().reverse()}static padShape(i,s){let u=i.length;return i.map((d,p)=>d+s[p]+s[p+u])}static areEqual(i,s){return i.length!==s.length?!1:i.every((u,d)=>u===s[d])}},ei=class Bf{static adjustPoolAttributes(i,s,u,d,p,c){if(!i&&u.length!==s.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(i)for(let b=0;b<s.length-2;b++)b>=u.length?u.push(s[b+2]):u[b]=s[b+2];for(let b=0;b<u.length;b++)if(b<d.length){if(d[b]<0)throw new Error("strides should be greater than or equal to 1")}else d.push(1);for(let b=0;b<u.length;b++)if(b<p.length){if(p[b]<0)throw new Error("dilations should be greater than or equal to 1")}else p.push(1);for(let b=0;b<u.length*2;b++)if(b<c.length){if(c[b]<0)throw new Error("pad should be greater than or equal to 1")}else c.push(0);for(let b=0;b<u.length;b++){if(u[b]<=0)throw new Error("kernel shapes need to be greater than 0");if(c[b]>=u[b]||c[b+u.length]>=u[b])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(i,s,u,d,p,c,b){if(b){if(p.length!==2*(i.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(s.length!==i.length-2)throw new Error("length of strides should be the length of data dimensions");if(d.length!==i.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let T=0;T<i.length-2;T++)Bf.adjustPadAndReturnShape(i[T+(c?1:2)],s[T],u[T],d[T],p,T,T+i.length-2,b)}}static computePoolOutputShape(i,s,u,d,p,c,b){if(s.length<=0)throw new Error("input shape must be of size greater than 0");let T=[s[0],s[1]];return Bf.computeShapeHelper(i,s,T,u,d,p,c,b),T}static computeConvOutputShape(i,s,u,d,p,c,b){if(i.length<=0||s.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let T=[i[0],s[0]];return Bf.computeShapeHelper(!1,i,T,u,d,p,c,b),T}static computeShapeHelper(i,s,u,d,p,c,b,T){if(i)for(let E=0;E<s.length-2;E++)u.push(1);else for(let E=0;E<s.length-2;E++)u.push(Bf.adjustPadAndReturnShape(s[E+2],d[E],p[E],c[E],b,E,E+s.length-2,T))}static adjustPadAndReturnShape(i,s,u,d,p,c,b,T){let E=u*(d-1)+1;if(T&&T!=="NOTSET")switch(T){case"VALID":return p[c]=0,p[b]=0,Math.floor((i-E)/s+1);case"SAME_LOWER":case"SAME_UPPER":if(u!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let q=((i+s-1)/s-1)*s+d-i;return p[c]=Math.floor(T==="SAME_LOWER"?(q+1)/2:q/2),p[b]=q-p[c],Math.floor((i+q-d)/s+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((i+p[c]+p[b]-E)/s+1)}},Pr=class{static getShapeOfGemmResult(r,i,s,u,d){if(r.length!==2||s.length!==2)throw new Error("shape need to be of size 2");let p,c,b;i?(p=r[1],c=r[0]):(p=r[0],c=r[1]);let T=-1;if(u?(b=s[0],T=1):(b=s[1],T=0),s[T]!==c)throw new Error("dimension mismatch");if(p<=0||b<=0||c<=0)throw new Error("invalid shape specified");if(d&&!vn.isValidBroadcast(d,[p,b]))throw new Error("gemm: invalid bias shape for broadcast");return[p,b,c]}},hn=-34028234663852886e22,Bn=34028234663852886e22}),Kn,Tn,zr,$r,zt,Ar,jr,Zr,Qn,jt,Is,gt,qt,_a,ya,Mu,xo,dr=m(()=>{Zt(),Jt(),Kn=64,Tn=(r,i)=>{if(i===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(r){case 10:return i>1?`vec${i}<f16>`:"f16";case 1:return i>1?`vec${i}<f32>`:"f32";case 6:return i>1?`vec${i}<i32>`:"i32";case 12:return i>1?`vec${i}<u32>`:"u32";case 7:if(i>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(i>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(i!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${r}`)}},zr=(r,i=1)=>{let s=Tn(r,i);return typeof s=="string"?s:s[0]},$r=(r,i=1)=>{let s=Tn(r,i);return typeof s=="string"?s:s[1]},zt=(...r)=>{let i=[];return r.forEach(s=>{s.length!==0&&i.push({type:12,data:s},{type:12,data:Ze.computeStrides(s)})}),i},Ar=r=>r%4===0?4:r%2===0?2:1,jr=(r="f32",i,s="0")=>!i||i===1?`${r}(${s})`:`vec${i}<${r}>(${s})`,Zr=(r,i,s)=>r==="f32"?s:i===1?`f32(${s})`:`vec${i}<f32>(${s})`,Qn=(r,i)=>i===4?`(${r}.x + ${r}.y + ${r}.z + ${r}.w)`:i===2?`(${r}.x + ${r}.y)`:i===3?`(${r}.x + ${r}.y + ${r}.z)`:r,jt=(r,i,s,u)=>r.startsWith("uniforms.")&&s>4?typeof i=="string"?u==="f16"?`${r}[(${i}) / 8][(${i}) % 8 / 4][(${i}) % 8 % 4]`:`${r}[(${i}) / 4][(${i}) % 4]`:u==="f16"?`${r}[${Math.floor(i/8)}][${Math.floor(i%8/4)}][${i%8%4}]`:`${r}[${Math.floor(i/4)}][${i%4}]`:s>1?`${r}[${i}]`:r,Is=(r,i,s,u,d)=>{let p=typeof s=="number",c=p?s:s.length,b=[...new Array(c).keys()],T=c<2?"u32":c<=4?`vec${c}<u32>`:`array<u32, ${c}>`,E=Tn(i,d),q=typeof E=="string"?E:E[1],H=typeof E=="string"?E:E[0],w={indices:T,value:q,storage:H,tensor:i},Z=ut=>typeof ut=="string"?ut:`${ut}u`,re={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},le=p?"uniforms.":"",_e=`${le}${r}_shape`,be=`${le}${r}_strides`,me="";for(let ut=0;ut<c-1;ut++)me+=`
    let dim${ut} = current / ${jt(be,ut,c)};
    let rest${ut} = current % ${jt(be,ut,c)};
    indices[${ut}] = dim${ut};
    current = rest${ut};
    `;me+=`indices[${c-1}] = current;`;let Fe=c<2?"":`
  fn o2i_${r}(offset: u32) -> ${w.indices} {
    var indices: ${w.indices};
    var current = offset;
    ${me}
    return indices;
  }`,Se=ut=>(re.offsetToIndices=!0,c<2?ut:`o2i_${r}(${ut})`),ze=[];if(c>=2)for(let ut=c-1;ut>=0;ut--)ze.push(`${jt(be,ut,c)} * (indices[${ut}])`);let dt=c<2?"":`
  fn i2o_${r}(indices: ${w.indices}) -> u32 {
    return ${ze.join("+")};
  }`,lt=ut=>(re.indicesToOffset=!0,c<2?ut:`i2o_${r}(${ut})`),Mt=(...ut)=>c===0?"0u":`${w.indices}(${ut.map(Z).join(",")})`,Dt=(ut,At)=>c<2?`${ut}`:`${jt(ut,At,c)}`,Vt=(ut,At,ar)=>c<2?`${ut}=${ar};`:`${jt(ut,At,c)}=${ar};`,hr={},xr=(ut,At)=>{re.broadcastedIndicesToOffset=!0;let ar=`${At.name}broadcastedIndicesTo${r}Offset`;if(ar in hr)return`${ar}(${ut})`;let Gr=[];for(let gn=c-1;gn>=0;gn--){let Cn=At.indicesGet("outputIndices",gn+At.rank-c);Gr.push(`${Dt(be,gn)} * (${Cn} % ${Dt(_e,gn)})`)}return hr[ar]=`fn ${ar}(outputIndices: ${At.type.indices}) -> u32 {
             return ${Gr.length>0?Gr.join("+"):"0u"};
           }`,`${ar}(${ut})`},nr=(ut,At)=>(()=>{if(w.storage===w.value)return`${r}[${ut}]=${At};`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`${r}[${ut}]=vec2<u32>(u32(${At}), select(0u, 0xFFFFFFFFu, ${At} < 0));`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`${r}[${ut}]=vec2<u32>(u32(${At}), 0u);`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`${r}[${ut}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${At}));`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),Wr=ut=>(()=>{if(w.storage===w.value)return`${r}[${ut}]`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`i32(${r}[${ut}].x)`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`u32(${r}[${ut}].x)`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`vec4<bool>(bool(${r}[${ut}] & 0xFFu), bool(${r}[${ut}] & 0xFF00u), bool(${r}[${ut}] & 0xFF0000u), bool(${r}[${ut}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),Jr=c<2?"":`
  fn get_${r}ByIndices(indices: ${w.indices}) -> ${q} {
    return ${Wr(`i2o_${r}(indices)`)};
  }`,Er=c<2?"":(()=>{let ut=b.map(ar=>`d${ar}: u32`).join(", "),At=b.map(ar=>`d${ar}`).join(", ");return`
  fn get_${r}(${ut}) -> ${q} {
    return get_${r}ByIndices(${Mt(At)});
  }`})(),Hr=(...ut)=>{if(ut.length!==c)throw new Error(`indices length must be ${c}`);let At=ut.map(Z).join(",");return c===0?Wr("0u"):c===1?Wr(At[0]):(re.get=!0,re.getByIndices=!0,re.indicesToOffset=!0,`get_${r}(${At})`)},rr=ut=>c<2?Wr(ut):(re.getByIndices=!0,re.indicesToOffset=!0,`get_${r}ByIndices(${ut})`),wr=c<2?"":`
  fn set_${r}ByIndices(indices: ${w.indices}, value: ${q}) {
    ${nr(`i2o_${r}(indices)`,"value")}
  }`,Or=c<2?"":(()=>{let ut=b.map(ar=>`d${ar}: u32`).join(", "),At=b.map(ar=>`d${ar}`).join(", ");return`
  fn set_${r}(${ut}, value: ${q}) {
    set_${r}ByIndices(${Mt(At)}, value);
  }`})();return{impl:()=>{let ut=[],At=!1;return re.offsetToIndices&&(ut.push(Fe),At=!0),re.indicesToOffset&&(ut.push(dt),At=!0),re.broadcastedIndicesToOffset&&(Object.values(hr).forEach(ar=>ut.push(ar)),At=!0),re.set&&(ut.push(Or),At=!0),re.setByIndices&&(ut.push(wr),At=!0),re.get&&(ut.push(Er),At=!0),re.getByIndices&&(ut.push(Jr),At=!0),!p&&At&&ut.unshift(`const ${_e} = ${w.indices}(${s.join(",")});`,`const ${be} = ${w.indices}(${Ze.computeStrides(s).join(",")});`),ut.join(`
`)},type:w,offsetToIndices:Se,indicesToOffset:lt,broadcastedIndicesToOffset:xr,indices:Mt,indicesGet:Dt,indicesSet:Vt,set:(...ut)=>{if(ut.length!==c+1)throw new Error(`indices length must be ${c}`);let At=ut[c];if(typeof At!="string")throw new Error("value must be string");let ar=ut.slice(0,c).map(Z).join(",");return c===0?nr("0u",At):c===1?nr(ar[0],At):(re.set=!0,re.setByIndices=!0,re.indicesToOffset=!0,`set_${r}(${ar}, ${At})`)},setByOffset:nr,setByIndices:(ut,At)=>c<2?nr(ut,At):(re.setByIndices=!0,re.indicesToOffset=!0,`set_${r}ByIndices(${ut}, ${At});`),get:Hr,getByOffset:Wr,getByIndices:rr,usage:u,name:r,strides:be,shape:_e,rank:c}},gt=(r,i,s,u=1)=>Is(r,i,s,"input",u),qt=(r,i,s,u=1)=>Is(r,i,s,"output",u),_a=(r,i,s,u=1)=>Is(r,i,s,"internal",u),ya=class{constructor(r,i){this.normalizedDispatchGroup=r,this.limits=i,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(r){return`if (global_idx >= ${typeof r=="number"?`${r}u`:r}) { return; }`}mainStart(r=Kn){let i=typeof r=="number"?r:r[0],s=typeof r=="number"?1:r[1],u=typeof r=="number"?1:r[2];if(i>this.limits.maxComputeWorkgroupSizeX||s>this.limits.maxComputeWorkgroupSizeY||u>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${i}, ${s}, ${u}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(i*s*u>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${i}, ${s}, ${u}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let d=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,p=d?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,c=d?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${i*s*u}u + local_idx;`;return`@compute @workgroup_size(${i}, ${s}, ${u})
  fn main(${p}) {
    ${c}
  `}appendVariableUniforms(r){r.rank!==0&&(r.shape.startsWith("uniforms.")&&this.uniforms.push({name:r.shape.replace("uniforms.",""),type:"u32",length:r.rank}),r.strides.startsWith("uniforms.")&&this.uniforms.push({name:r.strides.replace("uniforms.",""),type:"u32",length:r.rank}))}declareVariable(r,i){if(r.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(r),this.appendVariableUniforms(r);let s=r.usage==="input"?"read":"read_write",u=r.type.storage;return`@group(0) @binding(${i}) var<storage, ${s}> ${r.name}: array<${u}>;`}declareVariables(...r){return r.map(i=>this.declareVariable(i,this.variableIndex++)).join(`
`)}registerInternalVariable(r){if(r.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(r),this.appendVariableUniforms(r)}registerInternalVariables(...r){return r.forEach(i=>this.registerInternalVariable(i)),this}registerUniform(r,i,s=1){return this.uniforms.push({name:r,type:i,length:s}),this}registerUniforms(r){return this.uniforms=this.uniforms.concat(r),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let r=[];for(let{name:i,type:s,length:u}of this.uniforms)if(u&&u>4)s==="f16"?r.push(`@align(16) ${i}:array<mat2x4<${s}>, ${Math.ceil(u/8)}>`):r.push(`${i}:array<vec4<${s}>, ${Math.ceil(u/4)}>`);else{let d=u==null||u===1?s:`vec${u}<${s}>`;r.push(`${i}:${d}`)}return`
      struct Uniforms { ${r.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(r=>r.impl()).join(`
`)+this.internalVariables.map(r=>r.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let r=i=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(i)];return this.uniforms.map(i=>[r(i.type),i.length??1])}},Mu=(r,i)=>new ya(r,i),xo=(r,i)=>{let s=r.length,u=[];for(let d=0;d<s;d++){let p=s-1-d,c=r[p]||1;(i[i.length-1-d]||1)>1&&c===1&&u.unshift(p)}return u}}),ku,wa,Yo,Tu,bi,Su,va,Mo=m(()=>{Zt(),Jt(),vr(),dr(),ku=r=>{if(!r||r.length!==1)throw new Error("Transpose requires 1 input.")},wa=(r,i)=>i&&i.length!==r?[...new Array(r).keys()].reverse():i,Yo=(r,i)=>Ze.sortBasedOnPerm(r,wa(r.length,i)),Tu=(r,i,s,u)=>{let d=[];d.push(`fn perm(i: ${u.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`);for(let p=0;p<i;++p)d.push(s.indicesSet("a",r[p],`i[${p}]`));return d.push("return a;}"),d.join(`
`)},bi=(r,i)=>{let s=r.dataType,u=r.dims.length,d=wa(u,i),p=Yo(r.dims,d),c=qt("output",s,p.length),b=gt("a",s,u),T;if(d.length===2&&d[0]===1&&d[1]===0){let E=c.type.value,q=[16,16,1];T=H=>`
  ${H.registerUniform("output_size","u32").declareVariables(b,c)}
  var<workgroup> tile : array<array<${E}, ${q[0]+1}>, ${q[0]}>;
  ${H.mainStart(q)}
    var x = workgroup_id.x * ${q[0]}u + local_id.x;
    var y = workgroup_id.y * ${q[0]}u + local_id.y;
    let width = uniforms.output_shape[0];
    let height = uniforms.output_shape[1];
    if (x < width && y < height) {
      tile[local_id.y][local_id.x] = ${b.getByOffset("y * width + x")};
    }
    workgroupBarrier();
    x = workgroup_id.y * ${q[0]}u + local_id.x;
    y = workgroup_id.x * ${q[0]}u + local_id.y;
    if (x < height && y < width) {
      ${c.setByOffset("y * height + x","tile[local_id.x][local_id.y]")}
    }
  }`}else T=E=>`
  ${E.registerUniform("output_size","u32").declareVariables(b,c)}

  ${Tu(d,u,b,c)}

  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${c.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${c.setByOffset("global_idx",b.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${i}`,inputDependencies:["rank"]},getRunData:()=>{let E=Ze.size(p);return{outputs:[{dims:p,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(E/64)},programUniforms:[{type:12,data:E},...zt(r.dims,p)]}},getShaderSource:T}},Su=(r,i)=>{ku(r.inputs),r.compute(bi(r.inputs[0],i.perm))},va=r=>Xt({perm:r.perm})}),Eu,Cu,Pu,$u,ba,Au,Iu,xa,Fu,zu,ti,Ou,Du,Ma,Lu,Bu,ka,Ru,Nu,Ta,ju,yp=m(()=>{Zt(),Jt(),dr(),Ia(),Mo(),Eu={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Cu={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Pu={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},$u={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},ba=(r,i)=>{let s=[];for(let u=i-r;u<i;++u)s.push(u);return s},Au=(r,i)=>{let s=[],u=r.length;for(let p=0;p<u;p++)i.indexOf(p)===-1&&s.push(r[p]);let d=i.map(p=>r[p]);return[s,d]},Iu=(r,i)=>{let s=r.length+i.length,u=[],d=0;for(let p=0;p<s;p++)i.indexOf(p)===-1?u.push(r[d++]):u.push(1);return u},xa=(r,i)=>{for(let s=0;s<r.length;++s)if(r[r.length-s-1]!==i-1-s)return!1;return!0},Fu=(r,i)=>{let s=[];if(!xa(r,i)){for(let u=0;u<i;++u)r.indexOf(u)===-1&&s.push(u);r.forEach(u=>s.push(u))}return s},zu=(r,i,s,u,d,p,c)=>{let b=s[0].dims,T=Ze.size(p),E=Ze.size(c),q=gt("_A",s[0].dataType,b),H=qt("output",d,p),w=32,Z=`
          var<workgroup> aBestValues : array<f32, ${w}>;
       `;return{name:r,shaderCache:i,getShaderSource:re=>`
        ${re.registerUniform("reduceSize","u32").declareVariables(q,H)}
        ${Z}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${re.mainStart(w)}

          let outputIndex = global_idx / ${w};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Pu[u]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${w}) {
           let candidate = f32(${q.getByOffset("offset + k")});
           bestValue = ${Eu[u]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${w}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Cu[u]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${H.setByOffset("outputIndex",`${u==="mean"?`${H.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${H.type.storage}(${$u[u]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:p,dataType:d}],dispatchGroup:{x:T},programUniforms:[{type:12,data:E}]})}},ti=(r,i,s,u)=>{let d=r.inputs.length===1?s:zs(r.inputs,s),p=d.axes;p.length===0&&!d.noopWithEmptyAxes&&(p=r.inputs[0].dims.map((Z,re)=>re));let c=Ze.normalizeAxes(p,r.inputs[0].dims.length),b=c,T=r.inputs[0],E=Fu(b,r.inputs[0].dims.length);E.length>0&&(T=r.compute(bi(r.inputs[0],E),{inputs:[0],outputs:[-1]})[0],b=ba(b.length,T.dims.length));let[q,H]=Au(T.dims,b),w=q;d.keepDims&&(w=Iu(q,c)),r.compute(zu(i,{hint:d.cacheKey,inputDependencies:["type"]},[T],u,r.inputs[0].dataType,w,H),{inputs:[T]})},Ou=(r,i)=>{ti(r,"ReduceMeanShared",i,"mean")},Du=(r,i)=>{ti(r,"ReduceL1Shared",i,"l1")},Ma=(r,i)=>{ti(r,"ReduceL2Shared",i,"l2")},Lu=(r,i)=>{ti(r,"ReduceLogSumExpShared",i,"logSumExp")},Bu=(r,i)=>{ti(r,"ReduceMaxShared",i,"max")},ka=(r,i)=>{ti(r,"ReduceMinShared",i,"min")},Ru=(r,i)=>{ti(r,"ReduceProdShared",i,"prod")},Nu=(r,i)=>{ti(r,"ReduceSumShared",i,"sum")},Ta=(r,i)=>{ti(r,"ReduceSumSquareShared",i,"sumSquare")},ju=(r,i)=>{ti(r,"ReduceLogSumShared",i,"logSum")}}),ri,Uu,Fs,zs,ui,Vu,Sa,Wu,Gu,Ea,Hu,qu,Ca,Ku,Qu,ni,Xu,Yu,Pa,Zu,Ju,$a,ec,tc,Aa,rc,Ia=m(()=>{Zt(),Jt(),vr(),dr(),yp(),ri=r=>{if(!r||r.length===0||r.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(r.length===2&&r[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Uu=r=>["","",`var value = ${r.getByIndices("input_indices")};`,""],Fs=(r,i,s,u,d,p,c=!1,b=!1)=>{let T=[],E=s[0].dims,q=E.length,H=Ze.normalizeAxes(d,q),w=!b&&H.length===0;E.forEach((le,_e)=>{w||H.indexOf(_e)>=0?c&&T.push(1):T.push(le)});let Z=T.length,re=Ze.size(T);return{name:r,shaderCache:i,getShaderSource:le=>{let _e=[],be=gt("_A",s[0].dataType,q),me=qt("output",p,Z),Fe=u(be,me,H),Se=Fe[2];for(let ze=0,dt=0;ze<q;ze++)w||H.indexOf(ze)>=0?(c&&dt++,Se=`for(var j${ze}: u32 = 0; j${ze} < ${E[ze]}; j${ze}++) {
                  ${Fe[2].includes("last_index")?`let last_index = j${ze};`:""}
                  ${be.indicesSet("input_indices",ze,`j${ze}`)}
                  ${Se}
                }`):(_e.push(`${be.indicesSet("input_indices",ze,me.indicesGet("output_indices",dt))};`),dt++);return`

        ${le.registerUniform("output_size","u32").declareVariables(be,me)}

        ${le.mainStart()}
          ${le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${be.type.indices};
          let output_indices = ${me.offsetToIndices("global_idx")};

          ${_e.join(`
`)}
          ${Fe[0]}       // init ops for reduce max/min
          ${Fe[1]}
          ${Se}
          ${Fe[3]}
          ${Fe.length===4?me.setByOffset("global_idx","value"):Fe.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:T,dataType:p}],dispatchGroup:{x:Math.ceil(re/64)},programUniforms:[{type:12,data:re},...zt(E,T)]})}},zs=(r,i)=>{let s=[];return r[1].dims[0]>0&&r[1].getBigInt64Array().forEach(u=>s.push(Number(u))),Xt({axes:s,keepDims:i.keepDims,noopWithEmptyAxes:i.noopWithEmptyAxes})},ui=(r,i,s,u)=>{let d=r.inputs,p=d.length===1?s:zs(d,s);r.compute(Fs(i,{hint:p.cacheKey,inputDependencies:["rank"]},[d[0]],p.noopWithEmptyAxes&&p.axes.length===0?Uu:u,p.axes,d[0].dataType,p.keepDims,p.noopWithEmptyAxes),{inputs:[0]})},Vu=(r,i)=>{ri(r.inputs),ui(r,"ReduceLogSum",i,(s,u)=>[`var value = ${u.type.storage}(0);`,"",`value += ${s.getByIndices("input_indices")};`,"value = log(value);"])},Sa=(r,i)=>{ri(r.inputs),ui(r,"ReduceL1",i,(s,u)=>[`var value = ${u.type.storage}(0);`,"",`value += abs(${s.getByIndices("input_indices")});`,""])},Wu=(r,i)=>{ri(r.inputs),ui(r,"ReduceL2",i,(s,u)=>[`var t = ${u.type.value}(0); var value = ${u.type.value}(0);`,"",`t = ${s.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Gu=(r,i)=>{ri(r.inputs),ui(r,"ReduceLogSumExp",i,(s,u)=>[`var value = ${u.type.storage}(0);`,"",`value += exp(${s.getByIndices("input_indices")});`,"value = log(value);"])},Ea=(r,i)=>{ri(r.inputs),ui(r,"ReduceMax",i,(s,u,d)=>{let p=[];for(let c=0;c<s.rank;c++)(d.indexOf(c)>=0||d.length===0)&&p.push(s.indicesSet("input_indices",c,0));return[`${p.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};`,`value = max(value, ${s.getByIndices("input_indices")});`,""]})},Hu=(r,i)=>{ri(r.inputs),ui(r,"ReduceMean",i,(s,u,d)=>{let p=1;for(let c=0;c<s.rank;c++)(d.indexOf(c)>=0||d.length===0)&&(p*=r.inputs[0].dims[c]);return["var sum = f32(0);","",`sum += f32(${s.getByIndices("input_indices")});`,`let value = ${u.type.value}(sum / ${p});`]})},qu=(r,i)=>{ri(r.inputs),ui(r,"ReduceMin",i,(s,u,d)=>{let p=[];for(let c=0;c<s.rank;c++)(d.indexOf(c)>=0||d.length===0)&&p.push(`input_indices[${c}] = 0;`);return[`${p.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};`,`value = min(value, ${s.getByIndices("input_indices")});`,""]})},Ca=(r,i)=>{ri(r.inputs),ui(r,"ReduceProd",i,(s,u)=>[`var value = ${u.type.storage}(1);`,"",`value *= ${s.getByIndices("input_indices")};`,""])},Ku=(r,i)=>{ri(r.inputs),ui(r,"ReduceSum",i,(s,u)=>[`var value = ${u.type.storage}(0);`,"",`value += ${s.getByIndices("input_indices")};`,""])},Qu=(r,i)=>{ri(r.inputs),ui(r,"ReduceSumSquare",i,(s,u)=>[`var t = ${u.type.value}(0); var value = ${u.type.value}(0);`,"",`t = ${s.getByIndices("input_indices")}; value += t * t;`,""])},ni=(r,i,s)=>{if(i.length===0)return s;let u=1,d=1;for(let p=0;p<i.length;p++)i.indexOf(p)===-1?u*=r[p]:d*=r[p];return d<32&&u>1024},Xu=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Hu(r,i):Ou(r,i)},Yu=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Sa(r,i):Du(r,i)},Pa=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Wu(r,i):Ma(r,i)},Zu=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Gu(r,i):Lu(r,i)},Ju=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Ea(r,i):Bu(r,i)},$a=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?qu(r,i):ka(r,i)},ec=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Ca(r,i):Ru(r,i)},tc=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Ku(r,i):Nu(r,i)},Aa=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Qu(r,i):Ta(r,i)},rc=(r,i)=>{ni(r.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Vu(r,i):ju(r,i)}}),Os,nc,ic,Ds,wp=m(()=>{Zt(),vr(),Ia(),Os=r=>{if(!r||r.length===0||r.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(r[0].dataType!==1)throw new Error("Invalid input type.")},nc=(r,i)=>{Os(r.inputs);let s=(u,d,p)=>{let c=[];for(let b=0;b<u.rank;b++)(p.indexOf(b)>=0||p.length===0)&&c.push(`input_indices[${b}] = 0;`);return[`${c.join(`
`)}`,`var value = ${u.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${u.getByIndices("input_indices")} ${i.selectLastIndex>0?"<=":"<"} value) {
         value = ${u.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};r.compute(Fs("ArgMin",{hint:i.cacheKey,inputDependencies:["rank"]},[r.inputs[0]],s,[i.axis],7,i.keepDims),{inputs:[0]})},ic=(r,i)=>{Os(r.inputs);let s=(u,d,p)=>{let c=[];for(let b=0;b<u.rank;b++)(p.indexOf(b)>=0||p.length===0)&&c.push(`input_indices[${b}] = 0;`);return[`${c.join(`
`)}`,`var value = ${u.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${u.getByIndices("input_indices")} ${i.selectLastIndex>0?">=":">"} value) {
         value = ${u.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};r.compute(Fs("argMax",{hint:i.cacheKey,inputDependencies:["rank"]},[r.inputs[0]],s,[i.axis],7,i.keepDims),{inputs:[0]})},Ds=r=>Xt(r)}),oc,Fa,sc,ac,ko,lc,uc,Ls=m(()=>{Zt(),Jt(),fe(),dr(),oc=(r,i)=>{let s=r[0],u=r[1],d=r[2],p=r[3],c=r[4],b=r[5];if(c&&b)throw new Error("Attention cannot have both past and attention_bias");if(s.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let T=s.dims[0],E=s.dims[1],q=s.dims[2];if(d.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(u.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(u.dims[0]!==q)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(d.dims[0]!==u.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let H=d.dims[0]/3,w=H,Z=w;if(i.qkvHiddenSizes.length>0){if(i.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let Fe of i.qkvHiddenSizes)if(Fe%i.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");H=i.qkvHiddenSizes[0],w=i.qkvHiddenSizes[1],Z=i.qkvHiddenSizes[2]}let re=E;if(H!==w)throw new Error("qkv_hidden_sizes first element should be same as the second");if(d.dims[0]!==H+w+Z)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let le=0;if(c){if(w!==Z)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(c.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(c.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(c.dims[1]!==T)throw new Error('Input "past" second dimension must be batch_size');if(c.dims[2]!==i.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(c.dims[4]!==w/i.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');i.pastPresentShareBuffer||(le=c.dims[3])}let _e=re+le,be=-1,me=0;if(p)throw new Error("Mask not supported");if(c)throw new Error("past is not supported");if(b){if(b.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(b.dims[0]!==T||b.dims[1]!==i.numHeads||b.dims[2]!==E||b.dims[3]!==_e)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:T,sequenceLength:E,pastSequenceLength:le,kvSequenceLength:re,totalSequenceLength:_e,maxSequenceLength:be,inputHiddenSize:q,hiddenSize:H,vHiddenSize:Z,headSize:Math.floor(H/i.numHeads),vHeadSize:Math.floor(Z/i.numHeads),numHeads:i.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:i.maskFilterValue,maskType:me,scale:i.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Fa=(r,i,s)=>{let u=Ar(s),d=64,p=s/u;p<d&&(d=32);let c=Math.ceil(s/u/d),b=[{type:1,data:1/s},{type:12,data:p},{type:12,data:c}],T=zr(r.dataType,u),E=$r(1,u),q=["type"],H=w=>{let Z=qt("x",r.dataType,r.dims,u),re=$r(r.dataType),le=[{name:"d_inv",type:"f32"},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${d}>;
  var<workgroup> thread_sum: array<f32, ${d}>;
  ${w.registerUniforms(le).declareVariables(Z)}
  ${w.mainStart([d,1,1])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${d}) * uniforms.d_comp + local_offset;

    var thread_max_vector = ${E}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${E}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(u){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${u}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${d}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${E}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${E}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(u){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${u}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${d}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${Z.type.value}(${re}(uniforms.d_inv));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${E}(x[offset + i]);
        x[offset + i] = ${Z.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${d};${T};${u}`,inputDependencies:q},getShaderSource:H,getRunData:()=>({outputs:[],dispatchGroup:{x:i},programUniforms:b})}},sc=(r,i,s,u,d,p,c,b)=>{let T=b+p.kvSequenceLength,E=[p.batchSize,p.numHeads,p.sequenceLength,T],q=p.kvNumHeads===void 0&&r>1&&u,H=q?[p.batchSize,p.numHeads,T,p.headSize]:void 0,w=c.scale===0?1/Math.sqrt(p.headSize):c.scale,Z=Ar(p.headSize),re=p.headSize/Z,le=12,_e={x:Math.ceil(T/le),y:Math.ceil(p.sequenceLength/le),z:p.batchSize*p.numHeads},be=[{type:12,data:p.sequenceLength},{type:12,data:re},{type:12,data:T},{type:12,data:p.numHeads},{type:1,data:w},{type:12,data:b},{type:12,data:p.kvSequenceLength}],me=q&&u&&Ze.size(u.dims)>0,Fe=["type","type"];me&&Fe.push("type"),d&&Fe.push("type");let Se=[{dims:E,dataType:i.dataType,gpuDataType:0}];q&&Se.push({dims:H,dataType:i.dataType,gpuDataType:0});let ze=dt=>{let lt=gt("q",i.dataType,i.dims,Z),Mt=gt("key",s.dataType,s.dims,Z),Dt=[lt,Mt];if(me){let Wr=gt("past_key",u.dataType,u.dims,Z);Dt.push(Wr)}d&&Dt.push(gt("attention_bias",d.dataType,d.dims));let Vt=qt("output",i.dataType,E),hr=[Vt];q&&hr.push(qt("present_key",i.dataType,H,Z));let xr=$r(1,Z),nr=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"}];return`
  const TILE_SIZE = ${le}u;

  var<workgroup> tileQ: array<${lt.type.storage}, ${le*le}>;
  var<workgroup> tileK: array<${lt.type.storage}, ${le*le}>;
  ${dt.registerUniforms(nr).declareVariables(...Dt,...hr)}
  ${dt.mainStart([le,le,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    ${me&&q?`
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx;
    let pastKeyOffset = uniforms.past_sequence_length * uniforms.K * headIdx;`:`
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;`}
    ${q?"let presentKeyOffset = headIdx * uniforms.N * uniforms.K;":""}
    var value = ${xr}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${me&&q?`
              if (n + local_id.y < uniforms.past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else {
                tileK[idx] =
                         key[kOffset + (n + local_id.y - uniforms.past_sequence_length) * uniforms.K + w + local_id.x];
              }`:"tileK[idx] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];"}
      ${q?"present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];":""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${xr}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(Z){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${Z}`)}})()};
        output[outputIdx] = ${Vt.type.value} (sum * uniforms.alpha) + ${d?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${Z};${d!==void 0};${u!==void 0};${r}`,inputDependencies:Fe},getRunData:()=>({outputs:Se,dispatchGroup:_e,programUniforms:be}),getShaderSource:ze}},ac=(r,i,s,u,d,p)=>{let c=p+d.kvSequenceLength,b=d.nReps?d.nReps:1,T=d.vHiddenSize*b,E=d.kvNumHeads==null&&r>1&&u,q=E?[d.batchSize,d.numHeads,c,d.headSize]:void 0,H=[d.batchSize,d.sequenceLength,T],w=12,Z={x:Math.ceil(d.vHeadSize/w),y:Math.ceil(d.sequenceLength/w),z:d.batchSize*d.numHeads},re=[{type:12,data:d.sequenceLength},{type:12,data:c},{type:12,data:d.vHeadSize},{type:12,data:d.numHeads},{type:12,data:T},{type:12,data:p},{type:12,data:d.kvSequenceLength}],le=E&&u&&Ze.size(u.dims)>0,_e=["type","type"];le&&_e.push("type");let be=[{dims:H,dataType:i.dataType,gpuDataType:0}];E&&be.push({dims:q,dataType:i.dataType,gpuDataType:0});let me=Fe=>{let Se=gt("probs",i.dataType,i.dims),ze=gt("v",s.dataType,s.dims),dt=[Se,ze];le&&dt.push(gt("past_value",u.dataType,u.dims));let lt=[qt("output",i.dataType,H)];E&&lt.push(qt("present_value",i.dataType,q));let Mt=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"}];return`
  const TILE_SIZE = ${w}u;
  var<workgroup> tileQ: array<${Se.type.value}, ${w*w}>;
  var<workgroup> tileK: array<${Se.type.value}, ${w*w}>;
  ${Fe.registerUniforms(Mt).declareVariables(...dt,...lt)}
  ${Fe.mainStart([w,w,1])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   ${le&&E?`
    let pastValueOffset = headIdx * uniforms.N * uniforms.past_sequence_length + n;
    let vOffset = headIdx * uniforms.N * uniforms.kv_sequence_length + n;
      `:`
   let offsetB = headIdx * uniforms.N * uniforms.K + n;
            `}
    ${E?"let presentValueOffset = headIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${Se.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${le&&E?`
        if (w + local_id.y < uniforms.past_sequence_length) {
          tileK[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else {
          tileK[idx] = v[vOffset + (w + local_id.y - uniforms.past_sequence_length) * uniforms.N];
        }
      `:`
        tileK[idx] = v[offsetB + (w + local_id.y) * uniforms.N];
      `}
        ${E?"present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileK[idx];":""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${u!==void 0};${r}`,inputDependencies:_e},getRunData:()=>({outputs:be,dispatchGroup:Z,programUniforms:re}),getShaderSource:me}},ko=(r,i,s,u,d,p,c,b,T,E,q)=>{let H=Math.min(r.outputCount,1+(c?1:0)+(b?1:0)),w=E.kvNumHeads!==void 0||H>1?E.pastSequenceLength:0,Z=w+E.kvSequenceLength,re=T&&Ze.size(T.dims)>0?T:void 0,le=[i,s];E.kvNumHeads===void 0&&H>1&&c&&Ze.size(c.dims)>0&&le.push(c),re&&le.push(re);let _e=r.compute(sc(H,i,s,c,re,E,q,w),{inputs:le,outputs:E.kvNumHeads===void 0&&H>1?[-1,1]:[-1]})[0];r.compute(Fa(_e,E.batchSize*E.numHeads*E.sequenceLength,Z),{inputs:[_e],outputs:[]});let be=[_e,u];E.kvNumHeads===void 0&&H>1&&b&&Ze.size(b.dims)>0&&be.push(b),r.compute(ac(H,_e,u,b,E,w),{inputs:be,outputs:E.kvNumHeads===void 0&&H>1?[0,2]:[0]})},lc=(r,i)=>{let s=[i.batchSize,i.numHeads,i.sequenceLength,i.headSize],u=i.sequenceLength,d=i.inputHiddenSize,p=i.headSize,c=12,b={x:Math.ceil(i.headSize/c),y:Math.ceil(i.sequenceLength/c),z:i.batchSize*i.numHeads},T=[r.inputs[0],r.inputs[1],r.inputs[2]],E=[{type:12,data:u},{type:12,data:d},{type:12,data:p},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:12,data:i.hiddenSize},{type:12,data:i.hiddenSize+i.hiddenSize+i.vHiddenSize}],q=H=>{let w=qt("output_q",T[0].dataType,s),Z=qt("output_k",T[0].dataType,s),re=qt("output_v",T[0].dataType,s),le=gt("input",T[0].dataType,T[0].dims),_e=gt("weight",T[1].dataType,T[1].dims),be=gt("bias",T[2].dataType,T[2].dims),me=le.type.storage,Fe=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${c}u;
  var<workgroup> tileInput: array<${me}, ${c*c}>;
  var<workgroup> tileWeightQ: array<${me}, ${c*c}>;
  var<workgroup> tileWeightK: array<${me}, ${c*c}>;
  var<workgroup> tileWeightV: array<${me}, ${c*c}>;
  ${H.registerUniforms(Fe).declareVariables(le,_e,be,w,Z,re)}
  ${H.mainStart([c,c,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${me}(0);
    var valueK = ${me}(0);
    var valueV = ${me}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return r.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:r.inputs[0].dataType,gpuDataType:0},{dims:s,dataType:r.inputs[0].dataType,gpuDataType:0},{dims:s,dataType:r.inputs[0].dataType,gpuDataType:0}],dispatchGroup:b,programUniforms:E}),getShaderSource:q},{inputs:T,outputs:[-1,-1,-1]})},uc=(r,i)=>{let s=oc(r.inputs,i),[u,d,p]=lc(r,s);return ko(r,u,d,p,r.inputs[4],void 0,void 0,void 0,r.inputs[5],s,i)}}),cc,dc,za,fc,vp=m(()=>{bt(),Zt(),Jt(),vr(),dr(),cc=(r,i)=>{if(!r||r.length!==5)throw new Error("BatchNormalization requires 5 inputs");let s=(u,d,p)=>{let c=d.length;if(c!==u.length)throw new Error(`${p}: num dimensions != ${c}`);d.forEach((b,T)=>{if(b!==u[T])throw new Error(`${p}: dim[${T}] do not match`)})};if(r[0].dims.length>1){let u=i.format==="NHWC"?i.spatial?r[0].dims.slice(-1):r[0].dims.slice(-1).concat(r[0].dims.slice(1,r[0].dims.length-1)):r[0].dims.slice(1,i.spatial?2:void 0);s(r[1].dims,u,"Invalid input scale"),s(r[2].dims,u,"Invalid input B"),s(r[3].dims,u,"Invalid input mean"),s(r[4].dims,u,"Invalid input var")}else s(r[1].dims,[1],"Invalid input scale"),s(r[2].dims,[1],"Invalid input B"),s(r[3].dims,[1],"Invalid input mean"),s(r[4].dims,[1],"Invalid input var")},dc=(r,i)=>{let{epsilon:s,spatial:u,format:d}=i,p=r[0].dims,c=u?Ar(p[p.length-1]):1,b=d==="NHWC"&&p.length>1?c:1,T=Ze.size(p)/c,E=u,q=E?p.length:p,H=gt("x",r[0].dataType,r[0].dims,c),w=gt("scale",r[1].dataType,r[1].dims,b),Z=gt("bias",r[2].dataType,r[2].dims,b),re=gt("inputMean",r[3].dataType,r[3].dims,b),le=gt("inputVar",r[4].dataType,r[4].dims,b),_e=qt("y",r[0].dataType,q,c),be=()=>{let Fe="";if(u)Fe=`let cOffset = ${p.length===1?"0u":d==="NHWC"?`outputIndices[${p.length-1}] / ${c}`:"outputIndices[1]"};`;else if(d==="NCHW")Fe=`
            ${_e.indicesSet("outputIndices","0","0")}
            let cOffset = ${_e.indicesToOffset("outputIndices")};`;else{Fe=`var cIndices = ${w.type.indices}(0);
                       cIndices[0] = outputIndices[${p.length-1}];`;for(let Se=1;Se<w.rank;Se++)Fe+=`cIndices[${Se}] = outputIndices[${Se}];`;Fe+=`let cOffset = ${w.indicesToOffset("cIndices")};`}return Fe},me=Fe=>`
  const epsilon = ${s};
  ${Fe.registerUniform("outputSize","u32").declareVariables(H,w,Z,re,le,_e)}
  ${Fe.mainStart()}
  ${Fe.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${_e.offsetToIndices(`global_idx * ${c}`)};
    ${be()}
    let scale = ${w.getByOffset("cOffset")};
    let bias = ${Z.getByOffset("cOffset")};
    let inputMean = ${re.getByOffset("cOffset")};
    let inputVar = ${le.getByOffset("cOffset")};
    let x = ${H.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${_e.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${i.epsilon}_${i.format}_${u}_${c}`,inputDependencies:E?["rank","type","type","type","type"]:void 0},getShaderSource:me,getRunData:()=>({outputs:[{dims:r[0].dims,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:E?[{type:12,data:T},...zt(p)]:[{type:12,data:T}]})}},za=r=>Xt(r),fc=(r,i)=>{let{inputs:s,outputCount:u}=r,d=za({...i,outputCount:u});if(N.webgpu.validateInputContent&&cc(s,d),i.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");r.compute(dc(s,d))}}),pc,hc,Oa,bp=m(()=>{Jt(),dr(),pc=r=>{if(r[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(r[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(r[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(r[0].dims[2]!==r[1].dims[0])throw new Error("last dimension of input and bias are not the same")},hc=r=>{let i=r[0].dims,s=r[0].dims[2],u=Ze.size(i)/4,d=r[0].dataType,p=gt("input",d,i,4),c=gt("bias",d,[s],4),b=gt("residual",d,i,4),T=qt("output",d,i,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:i,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:E=>`
  const channels = ${s}u / 4;
  ${E.declareVariables(p,c,b,T)}

  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let value = ${p.getByOffset("global_idx")}
      + ${c.getByOffset("global_idx % channels")} + ${b.getByOffset("global_idx")};
    ${T.setByOffset("global_idx","value")}
  }`}},Oa=r=>{pc(r.inputs),r.compute(hc(r.inputs))}}),mc,Tr,gc,_c,Da,yc,wc,La,vc,bc,Ba,xc,Mc,Bs,kc,Tc,Zo,Ra,Rs,Na,Sc,Ec,Cc,ja,Pc,$c,Ac,Ua,Ic,Fc,Va,zc,Oc,Wa,Dc,Ga,Ha,qa,Ka,Qa,Lc,Bc,Rc,Nc,Ns,Xa=m(()=>{Zt(),Jt(),vr(),dr(),mc=(r,i,s,u,d,p)=>{let c=Math.ceil(i/4),b="";typeof d=="string"?b=`${d}(a)`:b=d("a");let T=gt("inputData",s,[c],4),E=qt("outputData",u,[c],4);return`
      ${r.registerUniform("vec_size","u32").declareVariables(T,E)}

  ${p??""}

  ${r.mainStart()}
    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${T.getByOffset("global_idx")};
    ${E.setByOffset("global_idx",b)}
  }`},Tr=(r,i,s,u,d,p=r.dataType)=>({name:i,shaderCache:{hint:d,inputDependencies:["type"]},getShaderSource:c=>mc(c,Ze.size(r.dims),r.dataType,p,s,u),getRunData:c=>({outputs:[{dims:r.dims,dataType:p}],dispatchGroup:{x:Math.ceil(Ze.size(c[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(Ze.size(r.dims)/4)}]})}),gc=r=>{r.compute(Tr(r.inputs[0],"Abs","abs"))},_c=r=>{r.compute(Tr(r.inputs[0],"Acos","acos"))},Da=r=>{r.compute(Tr(r.inputs[0],"Acosh","acosh"))},yc=r=>{r.compute(Tr(r.inputs[0],"Asin","asin"))},wc=r=>{r.compute(Tr(r.inputs[0],"Asinh","asinh"))},La=r=>{r.compute(Tr(r.inputs[0],"Atan","atan"))},vc=r=>{r.compute(Tr(r.inputs[0],"Atanh","atanh"))},bc=r=>Xt(r),Ba=(r,i)=>{let s;switch(i.to){case 10:s="vec4<f16>";break;case 1:s="vec4<f32>";break;case 12:s="vec4<u32>";break;case 6:s="vec4<i32>";break;case 9:s="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${i.to}`)}r.compute(Tr(r.inputs[0],"Cast",s,void 0,i.cacheKey,i.to))},xc=r=>{let i=r.length>=2&&r[1].data!==0?r[1].getFloat32Array()[0]:hn,s=r.length>=3&&r[2].data!==0?r[2].getFloat32Array()[0]:Bn;return Xt({min:i,max:s})},Mc=(r,i)=>{let s=r.inputs.length===1?i:xc(r.inputs),u=$r(r.inputs[0].dataType);r.compute(Tr(r.inputs[0],"Clip",d=>`clamp(${d}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${u}> = vec4(${u}(${s.min}));
    const clip_max_: vec4<${u}> = vec4(${u}(${s.max}));
`,s.cacheKey),{inputs:[0]})},Bs=r=>{r.compute(Tr(r.inputs[0],"Ceil","ceil"))},kc=r=>{r.compute(Tr(r.inputs[0],"Cos","cos"))},Tc=r=>{r.compute(Tr(r.inputs[0],"Cosh","cosh"))},Zo=r=>Xt(r),Ra=(r,i)=>{let s=$r(r.inputs[0].dataType);r.compute(Tr(r.inputs[0],"Elu",u=>`elu_vf32(${u})`,`
  const elu_alpha_ = ${s}(${i.alpha});

  fn elu_f32(a: ${s}) -> ${s} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${s}>) -> vec4<${s}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,i.cacheKey))},Rs=(r="f32")=>`
const r0: ${r} = 0.3275911;
const r1: ${r} = 0.254829592;
const r2: ${r} = -0.284496736;
const r3: ${r} = 1.421413741;
const r4: ${r} = -1.453152027;
const r5: ${r} = 1.061405429;

fn erf_vf32(v: vec4<${r}>) -> vec4<${r}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Na=r=>{let i=$r(r.inputs[0].dataType);r.compute(Tr(r.inputs[0],"Erf",s=>`erf_vf32(${s})`,Rs(i)))},Sc=r=>{r.compute(Tr(r.inputs[0],"Exp","exp"))},Ec=r=>{r.compute(Tr(r.inputs[0],"Floor","floor"))},Cc=r=>{let i=$r(r.inputs[0].dataType);r.compute(Tr(r.inputs[0],"Gelu",s=>`0.5 * ${s} * (1.0 + erf_vf32(${s} * 0.7071067811865475))`,Rs(i)))},ja=(r,i)=>{let s=$r(r.inputs[0].dataType);r.compute(Tr(r.inputs[0],"LeakyRelu",u=>`select(leaky_relu_alpha_ * ${u}, ${u}, ${u} >= vec4<${s}>(0.0))`,`const leaky_relu_alpha_ = ${s}(${i.alpha});`,i.cacheKey))},Pc=r=>{r.compute(Tr(r.inputs[0],"Not",i=>`!${i}`))},$c=r=>{r.compute(Tr(r.inputs[0],"Neg",i=>`-${i}`))},Ac=r=>{r.compute(Tr(r.inputs[0],"Reciprocal",i=>`1.0/${i}`))},Ua=r=>{let i=$r(r.inputs[0].dataType);r.compute(Tr(r.inputs[0],"Relu",s=>`select(vec4<${i}>(0.0), ${s}, ${s} > vec4<${i}>(0.0))`))},Ic=r=>{r.compute(Tr(r.inputs[0],"Sigmoid",i=>`(1.0 / (1.0 + exp(-${i})))`))},Fc=r=>Xt(r),Va=(r,i)=>{let s=$r(r.inputs[0].dataType);r.compute(Tr(r.inputs[0],"HardSigmoid",u=>`max(vec4<${s}>(0.0), min(vec4<${s}>(1.0), ${i.alpha} * ${u} + vec4<${s}>(${i.beta})))`,void 0,i.cacheKey))},zc=r=>{r.compute(Tr(r.inputs[0],"Sin","sin"))},Oc=r=>{r.compute(Tr(r.inputs[0],"Sinh","sinh"))},Wa=r=>{r.compute(Tr(r.inputs[0],"Sqrt","sqrt"))},Dc=r=>{r.compute(Tr(r.inputs[0],"Tan","tan"))},Ga=r=>`sign(${r}) * (1 - exp(-2 * abs(${r}))) / (1 + exp(-2 * abs(${r})))`,Ha=r=>{r.compute(Tr(r.inputs[0],"Tanh",Ga))},qa=(r="f32")=>`
const fast_gelu_a: ${r} = 0.5;
const fast_gelu_b: ${r} = 0.7978845608028654;
const fast_gelu_c: ${r} = 0.035677408136300125;

fn tanh_v(v: vec4<${r}>) -> vec4<${r}> {
  return ${Ga("v")};
}
`,Ka=r=>`(fast_gelu_a + fast_gelu_a * tanh_v(${r} * (fast_gelu_c * ${r} * ${r} + fast_gelu_b))) * ${r}`,Qa=r=>{let i=$r(r.inputs[0].dataType);r.compute(Tr(r.inputs[0],"FastGelu",Ka,qa(i),void 0,r.inputs[0].dataType))},Lc=(r,i)=>{let s=$r(r.inputs[0].dataType);return r.compute(Tr(r.inputs[0],"ThresholdedRelu",u=>`select(vec4<${s}>(0.0), ${u}, ${u} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${s}>(${i.alpha});`,i.cacheKey)),0},Bc=r=>{r.compute(Tr(r.inputs[0],"Log","log"))},Rc=(r,i)=>`
const alpha = vec4<${r}>(${i});
const one = ${r}(1.0);
const zero = ${r}(0.0);

fn quick_gelu_impl(x: vec4<${r}>) -> vec4<${r}> {
  let v = x *alpha;
  var x1 : vec4<${r}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,Nc=r=>`quick_gelu_impl(${r})`,Ns=(r,i)=>{let s=$r(r.inputs[0].dataType);r.compute(Tr(r.inputs[0],"QuickGelu",Nc,Rc(s,i.alpha),i.cacheKey,r.inputs[0].dataType))}}),jc,Uc,Ya,xp=m(()=>{Jt(),dr(),Xa(),jc=r=>{if(r[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(r[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(r[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(r[0].dims[2]!==r[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Uc=r=>{let i=r[0].dims.slice();i[2]=i[2]/2;let s=gt("input",r[0].dataType,r[0].dims,4),u=gt("bias",r[0].dataType,[r[0].dims[2]],4),d=qt("output",r[0].dataType,i,4),p=Ze.size(i)/4,c=zr(r[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:i,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:b=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${r[0].dims[2]/4/2}u;

  ${b.declareVariables(s,u,d)}

  ${Rs(c)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes(p)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${d.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Ya=r=>{jc(r.inputs),r.compute(Uc(r.inputs))}}),Vc,Wc,ci,Za,Gc,Hc,Ja,qc,Kc,el,Qc,Xc,tl,Mp=m(()=>{Zt(),Jt(),dr(),Vc=(r,i,s,u,d,p,c,b,T,E,q,H)=>{let w,Z;typeof b=="string"?w=Z=(me,Fe)=>`${b}((${me}),(${Fe}))`:typeof b=="function"?w=Z=b:(w=b.scalar,Z=b.vector);let re=qt("outputData",q,u.length,4),le=gt("aData",T,i.length,4),_e=gt("bData",E,s.length,4),be;if(d)if(p){let me=Ze.size(i)===1,Fe=Ze.size(s)===1,Se=i.length>0&&i[i.length-1]%4===0,ze=s.length>0&&s[s.length-1]%4===0;me||Fe?be=re.setByOffset("global_idx",Z(me?`${le.type.value}(${le.getByOffset("0")}.x)`:le.getByOffset("global_idx"),Fe?`${_e.type.value}(${_e.getByOffset("0")}.x)`:_e.getByOffset("global_idx"))):be=`
            let outputIndices = ${re.offsetToIndices("global_idx * 4u")};
            let offsetA = ${le.broadcastedIndicesToOffset("outputIndices",re)};
            let offsetB = ${_e.broadcastedIndicesToOffset("outputIndices",re)};
            ${re.setByOffset("global_idx",Z(c||Se?le.getByOffset("offsetA / 4u"):`${le.type.value}(${le.getByOffset("offsetA / 4u")}[offsetA % 4u])`,c||ze?_e.getByOffset("offsetB / 4u"):`${_e.type.value}(${_e.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else be=re.setByOffset("global_idx",Z(le.getByOffset("global_idx"),_e.getByOffset("global_idx")));else{if(!p)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let me=(Fe,Se,ze="")=>{let dt=`aData[indexA${Se}][componentA${Se}]`,lt=`bData[indexB${Se}][componentB${Se}]`;return`
            let outputIndices${Se} = ${re.offsetToIndices(`global_idx * 4u + ${Se}u`)};
            let offsetA${Se} = ${le.broadcastedIndicesToOffset(`outputIndices${Se}`,re)};
            let offsetB${Se} = ${_e.broadcastedIndicesToOffset(`outputIndices${Se}`,re)};
            let indexA${Se} = offsetA${Se} / 4u;
            let indexB${Se} = offsetB${Se} / 4u;
            let componentA${Se} = offsetA${Se} % 4u;
            let componentB${Se} = offsetB${Se} % 4u;
            ${Fe}[${Se}] = ${ze}(${w(dt,lt)});
          `};q===9?be=`
            var data = vec4<u32>(0);
            ${me("data",0,"u32")}
            ${me("data",1,"u32")}
            ${me("data",2,"u32")}
            ${me("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:be=`
            ${me("outputData[global_idx]",0)}
            ${me("outputData[global_idx]",1)}
            ${me("outputData[global_idx]",2)}
            ${me("outputData[global_idx]",3)}
          `}return`
        ${r.registerUniform("vec_size","u32").declareVariables(le,_e,re)}

        ${H??""}

        ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${be}
      }`},Wc=(r,i,s,u,d,p,c=s.dataType)=>{let b=!Ze.areEqual(s.dims,u.dims),T=s.dims,E=Ze.size(s.dims),q=!1,H=!1,w=[b];if(b){let Z=vn.calcShape(s.dims,u.dims,!1);if(!Z)throw new Error("Can't perform binary op on the given tensors");T=Z,E=Ze.size(T);let re=Ze.size(s.dims)===1,le=Ze.size(u.dims)===1,_e=s.dims.length>0&&s.dims[s.dims.length-1]%4===0,be=u.dims.length>0&&u.dims[u.dims.length-1]%4===0;w.push(re),w.push(le),w.push(_e),w.push(be);let me=1;for(let Fe=1;Fe<T.length;Fe++){let Se=s.dims[s.dims.length-Fe]??1,ze=u.dims[u.dims.length-Fe]??1;if(Se===ze)me*=Se;else break}me%4===0?(H=!0,q=!0):(re||le||_e||be)&&(q=!0)}else q=!0;return w.push(q),{name:r,shaderCache:{hint:i+w.map(Z=>Z.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:Z=>Vc(Z,s.dims,u.dims,T,q,b,H,d,s.dataType,u.dataType,c,p),getRunData:()=>({outputs:[{dims:T,dataType:c}],dispatchGroup:{x:Math.ceil(E/64/4)},programUniforms:[{type:12,data:Math.ceil(Ze.size(T)/4)},...zt(s.dims,u.dims,T)]})}},ci=(r,i,s,u,d,p)=>{r.compute(Wc(i,d??"",r.inputs[0],r.inputs[1],s,u,p))},Za=r=>{ci(r,"Add",(i,s)=>`${i}+${s}`)},Gc=r=>{ci(r,"Div",(i,s)=>`${i}/${s}`)},Hc=r=>{ci(r,"Equal",{scalar:(i,s)=>`u32(${i}==${s})`,vector:(i,s)=>`vec4<u32>(${i}==${s})`},void 0,void 0,9)},Ja=r=>{ci(r,"Mul",(i,s)=>`${i}*${s}`)},qc=r=>{let i=gt("input",r.inputs[0].dataType,r.inputs[0].dims).type.value;ci(r,"Pow",{scalar:(s,u)=>`pow_custom(${s},${u})`,vector:(s,u)=>`pow_vector_custom(${s},${u})`},`
    fn pow_custom(a : ${i}, b : ${i}) -> ${i} {
      if (b == ${i}(0.0)) {
        return ${i}(1.0);
      } else if (a < ${i}(0.0) && f32(b) != floor(f32(b))) {
        return ${i}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${i}(1.0), round(f32(abs(b) % ${i}(2.0))) != 1.0) * ${i}(${i==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${i}>, b : vec4<${i}>) -> vec4<${i}> {
      // TODO: implement vectorized pow
      return vec4<${i}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Kc=r=>{ci(r,"Sub",(i,s)=>`${i}-${s}`)},el=r=>{ci(r,"Greater",{scalar:(i,s)=>`u32(${i}>${s})`,vector:(i,s)=>`vec4<u32>(${i}>${s})`},void 0,void 0,9)},Qc=r=>{ci(r,"Less",{scalar:(i,s)=>`u32(${i}<${s})`,vector:(i,s)=>`vec4<u32>(${i}<${s})`},void 0,void 0,9)},Xc=r=>{ci(r,"GreaterOrEqual",{scalar:(i,s)=>`u32(${i}>=${s})`,vector:(i,s)=>`vec4<u32>(${i}>=${s})`},void 0,void 0,9)},tl=r=>{ci(r,"LessOrEqual",{scalar:(i,s)=>`u32(${i}<=${s})`,vector:(i,s)=>`vec4<u32>(${i}<=${s})`},void 0,void 0,9)}}),Yc,Zc,Jc,ed,td,rl,kp=m(()=>{Zt(),Jt(),vr(),dr(),Yc=(r,i)=>{if(!r||r.length<1)throw new Error("too few inputs");let s=0,u=r[s],d=u.dataType,p=u.dims.length;r.forEach((c,b)=>{if(b!==s){if(c.dataType!==d)throw new Error("input tensors should be one type");if(c.dims.length!==p)throw new Error("input tensors should have the same shape");c.dims.forEach((T,E)=>{if(E!==i&&T!==u.dims[E])throw new Error("non concat dimensions must match")})}})},Zc=(r,i)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${r}u>(${i});
    for (var i: u32 = 0u; i < ${r}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${r}u;
  }`,Jc=(r,i)=>{let s=r.length,u=[];for(let d=0;d<s;++d){let p=i.setByOffset("global_idx",r[d].getByIndices("indices"));s===1?u.push(p):d===0?u.push(`if (inputIndex == ${d}u) { ${p} }`):d===s-1?u.push(`else { ${p} }`):u.push(`else if (inputIndex == ${d}) { ${p} }`)}return u.join(`
`)},ed=(r,i,s,u)=>{let d=Ze.size(s),p=new Array(r.length),c=new Array(r.length),b=0,T=[],E=[],q=[{type:12,data:d}];for(let le=0;le<r.length;++le)b+=r[le].dims[i],p[le]=b,E.push(r[le].dims.length),c[le]=gt(`input${le}`,u,E[le]),T.push("rank"),q.push({type:12,data:p[le]});for(let le=0;le<r.length;++le)q.push(...zt(r[le].dims));q.push(...zt(s));let H=qt("output",u,s.length),w=H.indicesGet("indices",i),Z=Array.from(Array(p.length).keys()).map(le=>`uniforms.sizeInConcatAxis${le}`).join(","),re=le=>`

  ${(()=>{le.registerUniform("outputSize","u32");for(let _e=0;_e<r.length;_e++)le.registerUniform(`sizeInConcatAxis${_e}`,"u32");return le.declareVariables(...c,H)})()}

  ${Zc(p.length,Z)}

  ${le.mainStart()}
    ${le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${H.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${w});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${p.length}u>(${Z});
      ${w} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Jc(c,H)}
  }`;return{name:"Concat",shaderCache:{hint:`${i}`,inputDependencies:T},getRunData:()=>({outputs:[{dims:s,dataType:u}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:q}),getShaderSource:re}},td=(r,i)=>{let s=r.inputs,u=s[0].dims,d=Ze.normalizeAxis(i.axis,u.length);Yc(s,d);let p=u.slice();p[d]=s.reduce((b,T)=>b+(T.dims.length>d?T.dims[d]:0),0);let c=s.filter(b=>Ze.size(b.dims)>0);r.compute(ed(c,d,p,s[0].dataType),{inputs:c})},rl=r=>Xt({axis:r.axis})}),qi,zi,Ki,nl,Rn=m(()=>{Zt(),Jt(),qi=(r,i,s="f32")=>{switch(r.activation){case"Relu":return`value = max(value, ${i}(0.0));`;case"Sigmoid":return`value = (${i}(1.0) / (${i}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${i}(${s}(uniforms.clip_min)), ${i}(${s}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${i}(0.0), min(${i}(1.0), ${s}(uniforms.alpha) * value + ${s}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${s}(uniforms.alpha) * value, value, value >= ${i}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${r.activation}`)}},zi=(r,i)=>{r.activation==="Clip"?i.push({type:1,data:r.clipMax},{type:1,data:r.clipMin}):r.activation==="HardSigmoid"?i.push({type:1,data:r.alpha},{type:1,data:r.beta}):r.activation==="LeakyRelu"&&i.push({type:1,data:r.alpha})},Ki=(r,i)=>{r.activation==="Clip"?i.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):r.activation==="HardSigmoid"?i.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):r.activation==="LeakyRelu"&&i.push({name:"alpha",type:"f32"})},nl=r=>{let i=(r==null?void 0:r.activation)||"";if(i==="HardSigmoid"){let[s,u]=(r==null?void 0:r.activation_params)||[.2,.5];return{activation:i,alpha:s,beta:u}}else if(i==="Clip"){let[s,u]=(r==null?void 0:r.activation_params)||[hn,Bn];return{activation:i,clipMax:u,clipMin:s}}else if(i==="LeakyRelu"){let[s]=(r==null?void 0:r.activation_params)||[.01];return{activation:i,alpha:s}}return{activation:i}}}),Sn,il,js=m(()=>{Sn=(r,i)=>{switch(r){case 1:return i;case 2:return`vec2<${i}>`;case 3:return`vec3<${i}>`;case 4:return`vec4<${i}>`;default:throw new Error(`${r}-component is not supported.`)}},il=r=>`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      `}),ol,sl=m(()=>{ol=r=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${r}.x), i32(${r}.y), i32(${r}.z), 1));
}
`}),rd,nd,Us,al,Vs,Ws,id,ll,io=m(()=>{Zt(),Jt(),dr(),Rn(),js(),rd=(r,i)=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${i?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${i?", batchIndices":""});
        `,nd=(r,i)=>r?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${i===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${i===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${i===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,Us=(r,i,s="f32",u,d=!1,p=32,c=!1,b=32)=>{let T=i[1]*r[1],E=i[0]*r[0],q=d?T:p,H=d?p:T,w=q/i[0],Z=p/i[1];if(!((d&&w===4&&r[1]===4||!d&&(w===3||w===4))&&q%i[0]===0&&p%i[1]===0&&r[0]===4))throw new Error(`If transposeA ${d} is true, innerElementSize ${w} and workPerThread[1] ${r[1]} must be 4.
      Otherwise, innerElementSize ${w} must be 3 or 4.
  tileAWidth ${q} must be divisible by workgroupSize[0]${i[0]}. tileInner ${p} must be divisible by workgroupSize[1] ${i[1]}. colPerThread ${r[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${w}<${s}>, ${q/w}>, ${H}>;
var<workgroup> mm_Bsub: array<array<vec4<${s}>, ${E/r[0]}>, ${p}>;

const rowPerThread = ${r[1]};
const colPerThread = ${r[0]};
const innerElementSize = ${w};
const tileInner = ${p};

@compute @workgroup_size(${i[0]}, ${i[1]}, ${i[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${c?"0":"i32(globalId.z)"};
  ${u?`let batchIndices = ${u.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${T};

  let num_tiles = ${c?`${Math.ceil(b/p)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${c?`i32(globalId.z) * ${b}`:"0"};

  var acc: array<vec4<${s}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${Z};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${rd(d,u)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${Z}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${u?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${w===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${nd(d,w)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},al=(r,i)=>r?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${i?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${i?", batchIndices":""});
            `,Vs=r=>r?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Ws=(r,i,s="f32",u,d=!1,p=32,c=!1,b=32,T=!1)=>{let E=r[1]*i[1],q=r[0]*i[0],H=d?E:p,w=d?p:E;if(!(w%i[1]===0&&H%i[0]===0&&p%i[1]===0))throw new Error(`tileAHight ${w} must be divisible by workgroupSize[1]${i[1]}, tileAWidth ${H} must be divisible by workgroupSize[0]${i[0]}, tileInner ${p} must be divisible by workgroupSize[1]${i[1]}`);let Z=w/i[1],re=H/i[0],le=p/i[1],_e=T?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${E};
    let globalColStart = i32(workgroupId.x) * ${q};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${w}; inputRow = inputRow + ${i[1]}) {
        for (var inputCol = localCol; inputCol < ${H}; inputCol = inputCol + ${i[0]}) {
          ${al(d,u)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${i[1]}) {
            for (var inputCol = localCol; inputCol < ${q}; inputCol = inputCol + ${i[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${u?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${s}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${i[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${d?`mm_Asub[k][localRow + innerRow * ${i[1]}];`:`mm_Asub[localRow + innerRow * ${i[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${i[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${i[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${E};

let tileRowA = i32(localId.y) * ${Z};
let tileColA = i32(localId.x) * ${re};
let tileRowB = i32(localId.y) * ${le};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${Z}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${re}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${al(d,u)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${le}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${u?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${s}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Vs(d)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${s}, ${H}>, ${w}>;
  var<workgroup> mm_Bsub : array<array<${s}, ${q}>, ${p}>;
  const rowPerThread = ${r[1]};
  const colPerThread = ${r[0]};
  const tileInner = ${p};

@compute @workgroup_size(${i[0]}, ${i[1]}, ${i[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${c?"0":"i32(globalId.z)"};
    ${u?`let batchIndices = ${u.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${c?`${Math.ceil(b/p)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${c?`i32(globalId.z) * ${b}`:"0"};

    var acc : array<array<${s}, colPerThread>, rowPerThread>;
    ${_e}
  }
`},id=(r,i,s,u,d,p=!1)=>{let[c,b,T]=d,[E,q,H,w]=u,Z=xo(c,T),re=xo(b,T),le=zr(u[0].type.tensor),_e=()=>{let me=q.rank,Fe=E.rank,Se=`var aIndices: ${q.type.indices};`;for(let ze=me-2-1,dt=Fe-1;ze>=0;ze--,dt--)Se+=`
aIndices[${ze}] = ${Fe>1?`batchIndices[${dt}]`:"batchIndices"};`;return Z.forEach(ze=>{Se+=`
aIndices[${ze}] = 0;`}),Se+=`
aIndices[${me-2}] = u32(row);
                   aIndices[${me-1}] = u32(colIn);`,Se},be=()=>{let me=H.rank,Fe=E.rank,Se=`var bIndices: ${H.type.indices};`;for(let ze=me-2-1,dt=Fe-1;ze>=0;ze--,dt--)Se+=`
bIndices[${ze}] = ${Fe>1?`batchIndices[${dt}]`:"batchIndices"};`;return re.forEach(ze=>{Se+=`
bIndices[${ze}] = 0;`}),Se+=`
bIndices[${me-2}] = u32(row);
                   bIndices[${me-1}] = u32(colIn);`,Se};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${E.type.indices}) -> ${Sn(r,le)} {
      var value = ${Sn(r,le)}(0.0);
      let col = colIn * ${r};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${_e()}
        value = ${q.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${E.type.indices}) -> ${Sn(r,le)} {
      var value = ${Sn(r,le)}(0.0);
      let col = colIn * ${r};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${be()}
        value = ${H.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Sn(r,le)}) {
      let col = colIn * ${r};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${i?`value = value + ${p?"bias[colIn]":`${Sn(r,le)}(bias[row])`};`:""}
        ${s}
        ${w.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},ll=(r,i,s,u,d=!1,p)=>{let c=r[0].dims,b=r[1].dims,T=c.slice(0,-2),E=b.slice(0,-2),q=u?u.slice(0,-2):s.slice(0,-2),H=Ze.size(q),w=c[c.length-2],Z=c[c.length-1],re=b[b.length-1],le=Z%4===0&&re%4===0,_e=w<=8?[4,1,1]:[4,4,1],be=[8,8,1],me=[Math.ceil(re/be[0]/_e[0]),Math.ceil(w/be[1]/_e[1]),Math.ceil(H/be[2]/_e[2])],Fe=le?4:1,Se=[...T,w,Z/Fe],ze=Se.length,dt=[...E,Z,re/Fe],lt=dt.length,Mt=[H,w,re/Fe],Dt=[{type:6,data:w},{type:6,data:re},{type:6,data:Z}];zi(i,Dt),Dt.push(...zt(q,Se,dt));let Vt=["rank","rank"],hr=r.length>2;hr&&(Dt.push(...zt(r[2].dims)),Vt.push("rank")),Dt.push(...zt(Mt));let xr=nr=>{let Wr=q.length,Jr=_a("batchDims",r[0].dataType,Wr,1),Er=zr(r[0].dataType),Hr=gt("a",r[0].dataType,ze,Fe),rr=gt("b",r[1].dataType,lt,Fe),wr=qt("result",r[0].dataType,Mt.length,Fe),Or=[Hr,rr];if(hr){let gn=d?Fe:1;Or.push(gt("bias",r[2].dataType,r[2].dims.length,gn))}let ut=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Ki(i,ut);let At=zr(wr.type.tensor),ar=qi(i,wr.type.value,At),Gr=id(Fe,hr,ar,[Jr,Hr,rr,wr],[T,E,q],d);return`
  ${nr.registerUniforms(ut).registerInternalVariables(Jr).declareVariables(...Or,wr)}
  ${Gr}
  ${le?Us(_e,be,Er,Jr):Ws(_e,be,Er,Jr)}
                   `};return{name:"MatMul",shaderCache:{hint:`${_e};${i.activation};${le};${d}`,inputDependencies:Vt},getRunData:()=>({outputs:[{dims:p?p(s):s,dataType:r[0].dataType}],dispatchGroup:{x:me[0],y:me[1],z:me[2]},programUniforms:Dt}),getShaderSource:xr}}}),od,sd,Tp=m(()=>{Zt(),qn(),dr(),Rn(),js(),sl(),io(),od=(r,i,s,u,d=!1,p,c=4,b=4,T=4,E="f32")=>{let q=Dt=>{switch(Dt){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${E}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Dt} is not supported.`)}},H=Dt=>{switch(Dt){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Dt} is not supported.`)}},w=r?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,Z=r?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,re=r?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",le=r?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",_e=r?"row":"col",be=r?"col":"row",me=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${r?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${_e} / outWidth;
    let outCol = ${_e} % outWidth;

    let WRow = ${be} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${be} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${be} % inChannels;
    var resData = ${Sn(c,E)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${re} && xCol >= 0 && xCol < ${le}) {
      ${w}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${q(c)}
    }
    return resData;`,Fe=r?i&&u?`
    let col = colIn * ${c};
    ${me}`:`
    let col = colIn * ${c};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${me}
    }
    return ${Sn(c,E)}(0.0);`:u&&s?`
    let col = colIn * ${c};
    ${me}`:`
    let col = colIn * ${c};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${me}
    }
    return ${Sn(c,E)}(0.0);`,Se=`${H(b)}`,ze=Sn(T,E),dt=Sn(r?c:b,E),lt=Sn(r?b:c,E),Mt=qi(p,ze,E);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${dt} {
      ${r?Fe:Se}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${lt} {
      ${r?Se:Fe}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${ze}) {
      let col = colIn * ${T};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${r?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${Z}
      ${il(d)}
      ${Mt}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},sd=(r,i,s,u,d,p,c,b,T)=>{let E=i.format==="NHWC",q=E?r[0].dims[3]:r[0].dims[1],H=s[0],w=E?s[2]:s[3],Z=E?s[1]:s[2],re=E?s[3]:s[1],le=E&&(q%4===0||q%3===0)&&re%4===0,_e=E?re:w*Z,be=E?w*Z:re,me=[8,8,1],Fe=u<=8?[4,1,1]:[4,4,1],Se=[Math.ceil(_e/me[0]/Fe[0]),Math.ceil(be/me[1]/Fe[1]),Math.ceil(H/me[2]/Fe[2])];Kr("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${Se}`);let ze=le?E&&q%4!==0?3:4:1,dt=me[1]*Fe[1],lt=me[0]*Fe[0],Mt=Math.max(me[0]*ze,me[1]),Dt=u%dt===0,Vt=d%lt===0,hr=p%Mt===0,xr=le?[ze,4,4]:[1,1,1],nr=[{type:6,data:u},{type:6,data:d},{type:6,data:p},{type:6,data:[i.pads[0],i.pads[1]]},{type:6,data:i.strides},{type:6,data:i.dilations}];zi(i,nr),nr.push(...zt(r[0].dims,r[1].dims));let Wr=["rank","rank"];c&&(nr.push(...zt(r[2].dims)),Wr.push("rank")),nr.push(...zt(s));let Jr=Er=>{let Hr=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Ki(i,Hr);let rr=le?4:1,wr=zr(r[0].dataType),Or=`
      fn setOutputAtIndex(flatIndex : i32, value : ${le?`vec4<${wr}>`:wr}) {
        result[flatIndex] = ${le?`vec4<${wr}>`:wr}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${le?`vec4<${wr}>`:wr}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${le?"/ 4":""}, value);
      }`,ut=gt("x",r[0].dataType,r[0].dims.length,ze===3?1:ze),At=gt("w",r[1].dataType,r[1].dims.length,rr),ar=[ut,At],Gr=qt("result",r[0].dataType,s.length,rr);if(c){let gn=gt("bias",r[2].dataType,r[2].dims.length,rr);ar.push(gn),Or+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${le?`vec4<${wr}>`:wr} {
          return bias[coords.${E?"w":"y"}${le?"/ 4":""}];
        }`}return`
        ${ol("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Er.registerUniforms(Hr).declareVariables(...ar,Gr)}
        ${Or}
        ${od(E,Dt,Vt,hr,c,i,xr[0],xr[1],xr[2],wr)}
        ${le?Us(Fe,me,wr,void 0,!E,Mt):Ws(Fe,me,wr,void 0,!E,Mt,!1,void 0,b)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${i.cacheKey};${ze};${le};${Dt};${Vt};${hr};${dt};${lt};${Mt}`,inputDependencies:Wr},getRunData:()=>({outputs:[{dims:T?T(s):s,dataType:r[0].dataType}],dispatchGroup:{x:Se[0],y:Se[1],z:Se[2]},programUniforms:nr}),getShaderSource:Jr}}}),ad,Jo,es,ld,ul,Sp,ud,cd,Ep=m(()=>{Zt(),qn(),Jt(),dr(),Rn(),js(),ad=r=>{let i=1;for(let s=0;s<r.length;s++)i*=r[s];return i},Jo=r=>typeof r=="number"?[r,r,r]:r,es=(r,i)=>i<=1?r:r+(r-1)*(i-1),ld=(r,i,s,u=1)=>{let d=es(i,u);return Math.floor((r[0]*(s-1)-s+d)/2)},ul=(r,i,s,u,d)=>{d==null&&(d=ld(r,i[0],u[0]));let p=[0,0,0,s];for(let c=0;c<3;c++)r[c]+2*d>=i[c]&&(p[c]=Math.trunc((r[c]-i[c]+2*d)/u[c]+1));return p},Sp=(r,i,s,u,d,p,c,b,T,E)=>{let q,H,w,Z;if(r==="VALID"&&(r=0),typeof r=="number"){q={top:r,bottom:r,left:r,right:r,front:r,back:r};let re=ul([i,s,u,1],[b,T,E],1,[d,p,c],r);H=re[0],w=re[1],Z=re[2]}else if(Array.isArray(r)){if(!r.every((le,_e,be)=>le===be[0]))throw Error(`Unsupported padding parameter: ${r}`);q={top:r[0],bottom:r[1],left:r[2],right:r[3],front:r[4],back:r[5]};let re=ul([i,s,u,1],[b,T,E],1,[d,p,c],r[0]);H=re[0],w=re[1],Z=re[2]}else if(r==="SAME_UPPER"){H=Math.ceil(i/d),w=Math.ceil(s/p),Z=Math.ceil(u/c);let re=(H-1)*d+b-i,le=(w-1)*p+T-s,_e=(Z-1)*c+E-u,be=Math.floor(re/2),me=re-be,Fe=Math.floor(le/2),Se=le-Fe,ze=Math.floor(_e/2),dt=_e-ze;q={top:Fe,bottom:Se,left:ze,right:dt,front:be,back:me}}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:q,outDepth:H,outHeight:w,outWidth:Z}},ud=(r,i,s,u,d,p=!1,c="channelsLast")=>{let b,T,E,q,H;if(c==="channelsLast")[b,T,E,q,H]=r;else if(c==="channelsFirst")[b,H,T,E,q]=r;else throw new Error(`Unknown dataFormat ${c}`);let[w,,Z,re,le]=i,[_e,be,me]=Jo(s),[Fe,Se,ze]=Jo(u),dt=es(Z,Fe),lt=es(re,Se),Mt=es(le,ze),{padInfo:Dt,outDepth:Vt,outHeight:hr,outWidth:xr}=Sp(d,T,E,q,_e,be,me,dt,lt,Mt),nr=p?w*H:w,Wr=[0,0,0,0,0];return c==="channelsFirst"?Wr=[b,nr,Vt,hr,xr]:c==="channelsLast"&&(Wr=[b,Vt,hr,xr,nr]),{batchSize:b,dataFormat:c,inDepth:T,inHeight:E,inWidth:q,inChannels:H,outDepth:Vt,outHeight:hr,outWidth:xr,outChannels:nr,padInfo:Dt,strideDepth:_e,strideHeight:be,strideWidth:me,filterDepth:Z,filterHeight:re,filterWidth:le,effectiveFilterDepth:dt,effectiveFilterHeight:lt,effectiveFilterWidth:Mt,dilationDepth:Fe,dilationHeight:Se,dilationWidth:ze,inShape:r,outShape:Wr,filterShape:i}},cd=(r,i,s,u,d,p)=>{let c=p==="channelsLast";c?r[0].dims[3]:r[0].dims[1];let b=[64,1,1],T={x:s.map((_e,be)=>be)},E=[Math.ceil(ad(T.x.map(_e=>s[_e]))/b[0]),1,1];Kr("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${E}`);let q=1,H=Ze.size(s),w=[{type:12,data:H},{type:12,data:u},{type:12,data:d},{type:12,data:i.strides},{type:12,data:i.dilations}];zi(i,w),w.push(...zt(r[0].dims,r[1].dims));let Z=["rank","rank"],re=r.length===3;re&&(w.push(...zt(r[2].dims)),Z.push("rank")),w.push(...zt(s));let le=_e=>{let be=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:u.length},{name:"pads",type:"u32",length:d.length},{name:"strides",type:"u32",length:i.strides.length},{name:"dilations",type:"u32",length:i.dilations.length}];Ki(i,be);let me=1,Fe=zr(r[0].dataType),Se=gt("x",r[0].dataType,r[0].dims.length,q),ze=gt("W",r[1].dataType,r[1].dims.length,me),dt=[Se,ze],lt=qt("result",r[0].dataType,s.length,me),Mt="";if(re){let hr=gt("bias",r[2].dataType,r[2].dims.length,me);dt.push(hr),Mt+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${Fe} {
          return bias[${c?jt("coords",4,5):jt("coords",1,5)}];
        }`}let Dt=Sn(q,Fe),Vt=qi(i,Dt,Fe);return`
            ${Mt}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${Se.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${ze.getByIndices("aIndices")};
            }
          ${_e.registerUniforms(be).declareVariables(...dt,lt)}
          ${_e.mainStart()}
          ${_e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${lt.offsetToIndices("global_idx")};
              let batch = ${jt("coords",0,Se.rank)};
              let d2 = ${c?jt("coords",Se.rank-1,Se.rank):jt("coords",1,Se.rank)};
              let xFRCCorner = vec3<u32>(${c?jt("coords",1,Se.rank):jt("coords",2,Se.rank)},
              ${c?jt("coords",2,Se.rank):jt("coords",3,Se.rank)},
              ${c?jt("coords",3,Se.rank):jt("coords",4,Se.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${c?jt("uniforms.x_shape",1,Se.rank):jt("uniforms.x_shape",2,Se.rank)};
              let xShapeZ = ${c?jt("uniforms.x_shape",2,Se.rank):jt("uniforms.x_shape",3,Se.rank)};
              let xShapeW = ${c?jt("uniforms.x_shape",3,Se.rank):jt("uniforms.x_shape",4,Se.rank)};
              let xShapeU = ${c?jt("uniforms.x_shape",4,Se.rank):jt("uniforms.x_shape",1,Se.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${c?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${c?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${c?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${c?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${re?"value = value + getBiasByOutputCoords(coords)":""};
              ${Vt}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${i.cacheKey};${c};${q};${re}`,inputDependencies:Z},getRunData:()=>({outputs:[{dims:s,dataType:r[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:w}),getShaderSource:le}}}),To,dd,Cp=m(()=>{Zt(),Jt(),dr(),gl(),Rn(),To=(r,i,s)=>{let u=r.length>2,d=u?"value += b[output_channel];":"",p=r[0].dims,c=r[1].dims,b=c[0]/i.group,T=i.format==="NHWC",E=dl(p,c,i.dilations,i.pads,i.strides,T),q=Ze.size(E),H=[{type:12,data:q},{type:12,data:i.dilations},{type:12,data:[i.strides[0],i.strides[1]]},{type:12,data:[i.pads[0],i.pads[1]]},{type:12,data:b}];zi(i,H),H.push(...zt(p,c));let w=["rank","rank"];u&&(H.push(...zt(r[2].dims)),w.push("rank")),H.push(...zt(E));let Z=re=>{let le=qt("output",r[0].dataType,E.length),_e=zr(le.type.tensor),be=qi(i,le.type.value,_e),me=gt("x",r[0].dataType,p.length),Fe=gt("w",r[1].dataType,c.length),Se=[me,Fe];u&&Se.push(gt("b",r[2].dataType,r[2].dims.length));let ze=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:i.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return Ki(i,ze),`
  ${re.registerUniforms(ze).declareVariables(...Se,le)}

  ${re.mainStart()}
    ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${le.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${T?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${T?1:2}], outputIndices[${T?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel / uniforms.output_channels_per_group;

    var value: ${le.type.value} = ${le.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[${T?1:2}]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[${T?2:3}]) {
            continue;
          }

          let xVal = ${T?me.get("batch","xHeight","xWidth","input_channel"):me.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${Fe.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${d}
    ${be}
    ${le.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:i.cacheKey,inputDependencies:w},getRunData:()=>({outputs:[{dims:s?s(E):E,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(q/64)},programUniforms:H}),getShaderSource:Z}},dd=(r,i,s,u)=>{let d=r.length>2,p=Ar(s[3]),c=Ar(s[2]),b=Ze.size(s)/p/c,T=[r[0].dims[0],r[0].dims[1],r[0].dims[2],r[0].dims[3]/p],E=[r[1].dims[0],r[1].dims[1],r[1].dims[2],r[1].dims[3]/p],q=[s[0],s[1],s[2],s[3]/p],H=[{type:12,data:b},{type:6,data:[i.strides[0],i.strides[1]]},{type:6,data:[i.pads[0],i.pads[1]]}];zi(i,H),H.push(...zt(T,E,q));let w=(c-1)*i.strides[1]+E[1],Z=re=>{let le=qt("output",r[0].dataType,q.length,p),_e=zr(le.type.tensor),be=qi(i,le.type.value,_e),me=gt("x",r[0].dataType,T.length,p),Fe=gt("w",r[1].dataType,E.length,p),Se=[me,Fe];d&&Se.push(gt("b",r[2].dataType,r[2].dims,p));let ze=d?"value += b[output_channel];":"",dt=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Ki(i,dt),`
  ${re.registerUniforms(dt).declareVariables(...Se,le)}
  ${re.mainStart()}
    ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${c}u;
    let col = (index1 % width1) * ${c}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${me.type.value}, ${w}>;
    var values: array<${le.type.value}, ${c}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${E[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${w}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${me.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${me.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${E[1]}; w_width++) {
          let w_val = ${Fe.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${c}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${c}u; i++) {
      var value = values[i];
      ${ze}
      ${be}
      ${le.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${i.cacheKey};${p};${c};${w};${E[0]};${E[1]}`,inputDependencies:d?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:u?u(s):s,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:H}),getShaderSource:Z}}}),cl,fd,pd,Gs=m(()=>{Zt(),Jt(),io(),dr(),Rn(),cl=(r,i,s,u,d=!1,p)=>{let c=r[0].dims,b=r[1].dims,T=c[c.length-2],E=b[b.length-1],q=c[c.length-1],H=Ar(E),w=Ar(q),Z=Ar(T),re=Ze.size(s)/H/Z,le=r.length>2,_e=u?u.slice(0,-2):s.slice(0,-2),be=[Ze.size(_e),T,E],me=[{type:12,data:re},{type:12,data:T},{type:12,data:E},{type:12,data:q}];zi(i,me),me.push(...zt(_e,c,b)),le&&me.push(...zt(r[2].dims)),me.push(...zt(be));let Fe=Se=>{let ze=_a("batch_dims",r[0].dataType,_e.length),dt=gt("a",r[0].dataType,c.length,w),lt=gt("b",r[1].dataType,b.length,H),Mt=qt("output",r[0].dataType,be.length,H),Dt=zr(Mt.type.tensor),Vt=qi(i,Mt.type.value,Dt),hr=[dt,lt],xr="";if(le){let Or=d?H:1;hr.push(gt("bias",r[2].dataType,r[2].dims.length,Or)),xr=`${d?`value += bias[col / ${Or}];`:`value += ${Mt.type.value}(bias[row + i]);`}`}let nr=c.slice(0,-2),Wr=b.slice(0,-2),Jr=xo(nr,_e),Er=xo(Wr,_e),Hr=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Ki(i,Hr);let rr=(Or,ut)=>{let At=Or.rank,ar=Or.name;if(At===2)return`var ${ar}_indices = ${Or.type.indices}(0u, 0u);`;let Gr=ze.rank,gn=`var ${ar}_indices: ${Or.type.indices};`;for(let Cn=At-2-1,is=Gr-1;Cn>=0;Cn--,is--)gn+=`
${ar}_indices[${Cn}] = ${Gr>1?`batch_indices[${is}]`:"batch_indices"};`;return ut.forEach(Cn=>{gn+=`
${ar}_indices[${Cn}] = 0;`}),gn+=`${ar}_indices[${At-2}] = 0u;
                     ${ar}_indices[${At-1}] = 0u;`,gn},wr=()=>{let Or=`var a_data: ${dt.type.value};`;for(let ut=0;ut<w;ut++)Or+=`
              let b_data${ut} = b[(b_offset + (k + ${ut}) * uniforms.N + col) / ${H}];`;for(let ut=0;ut<Z;ut++){Or+=`a_data = a[(a_offset + (row + ${ut}) * uniforms.K + k) / ${w}];`;for(let At=0;At<w;At++)Or+=`
            values[${ut}] = fma(${lt.type.value}(a_data${w===1?"":`[${At}]`}), b_data${At}, values[${ut}]);
`}return Or};return`
  ${Se.registerUniforms(Hr).registerInternalVariables(ze).declareVariables(...hr,Mt)}
  ${Se.mainStart()}
    ${Se.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${H})) * ${H};
    var index1 = global_idx / (uniforms.N / ${H});
    let stride1 = uniforms.M / ${Z};
    let row = (index1 % stride1) * ${Z};
    let batch = index1 / stride1;

    ${s.length===2?"":`let batch_indices = ${ze.offsetToIndices("batch")};`}
    ${rr(dt,Jr)}
    let a_offset = ${dt.indicesToOffset("a_indices")};
    ${rr(lt,Er)}
    let b_offset = ${lt.indicesToOffset("b_indices")};
    var values: array<${Mt.type.value}, ${Z}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${w}) {
      ${wr()}
    }
    for (var i = 0u; i < ${Z}u; i++) {
      var value = values[i];
      ${xr}
      ${Vt}
      let cur_indices = ${Mt.type.indices}(batch, row + i, col);
      let offset = ${Mt.indicesToOffset("cur_indices")};
      ${Mt.setByOffset(`offset / ${H}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${i.activation};${H};${w};${Z};${d}`,inputDependencies:le?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:p?p(s):s,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(re/64)},programUniforms:me}),getShaderSource:Fe}},fd=r=>{if(!r||r.length!==2)throw new Error("MatMul requires 2 inputs.");if(r[0].dims[r[0].dims.length-1]!==r[1].dims[r[1].dims.length-2])throw new Error("shared dimension does not match.")},pd=r=>{fd(r.inputs);let i=vn.calcShape(r.inputs[0].dims,r.inputs[1].dims,!0);if(!i)throw new Error("Can't use matmul on the given tensors");let s=i[i.length-1],u=r.inputs[0].dims[r.inputs[0].dims.length-1];s<8&&u<8?r.compute(cl(r.inputs,{activation:""},i)):r.compute(ll(r.inputs,{activation:""},i))}}),dl,Hs,hd,qs,fl,pl,hl,md,ml,gl=m(()=>{Jt(),Tp(),Ep(),io(),Cp(),Rn(),Gs(),Mo(),dl=(r,i,s,u,d,p)=>{let c=r[0],b=r.slice(p?1:2,p?3:4),T=b.length,E=i[0],q=i.slice(2).map((w,Z)=>w+(w-1)*(s[Z]-1)),H=b.map((w,Z)=>w+u[Z]+u[Z+T]).map((w,Z)=>Math.floor((w-q[Z]+d[Z])/d[Z]));return H.splice(0,0,c),H.splice(p?3:1,0,E),H},Hs=[2,3,1,0],hd=(r,i)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length>5)throw new Error("greater than 5D is not supported");if(r[0].dims.length!==r[1].dims.length)throw new Error("filter does not have same dimension as input");let s=r[0].dims[i.format==="NHWC"?r[0].dims.length-1:1],u=r[1].dims[1]*i.group;if(s!==u)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(r.length===3&&(r[2].dims.length!==1||r[1].dims[0]!==r[2].dims[0]))throw new Error("invalid bias");let d=r[0].dims.length-2;if(i.dilations.length!==d)throw new Error(`dilations should be ${d}D`);if(i.strides.length!==d)throw new Error(`strides should be ${d}D`);if(i.pads.length!==d*2)throw new Error(`pads should be ${d*2}D`);if(i.kernelShape.length!==0&&i.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape")},qs=(r,i)=>{let s=r.kernelShape.slice();for(let p=2;p<i[1].dims.length;++p)s[p-2]===0&&(s[p-2]=i[1].dims[p]);let u=r.pads.slice();ei.adjustPadsBasedOnAutoPad(i[0].dims,r.strides,r.dilations,s,u,r.format==="NHWC",r.autoPad);let d=Object.assign({},r);return Object.assign(d,{kernelShape:s,pads:u}),d},fl=r=>{let i=nl(r),s=r.format,u=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][r.auto_pad],d=r.dilations,p=r.group,c=r.kernel_shape,b=r.pads,T=r.strides,E=r.w_is_const();return{autoPad:u,format:s,dilations:d,group:p,kernelShape:c,pads:b,strides:T,wIsConst:E,...i,cacheKey:`${r.format};${i.activation};`}},pl=(r,i,s,u)=>{let d=s.format==="NHWC";if(s.group!==1){if(!r.adapterInfo.isArchitecture("ampere")&&d&&i[1].dims[0]===s.group&&i[1].dims[1]===1&&s.dilations[0]===1&&s.dilations[1]===1){let dt=dl(i[0].dims,i[1].dims,s.dilations,s.pads,s.strides,d),lt=r.kernelCustomData.wT??r.compute(bi(i[1],Hs),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=lt);let Mt=[i[0],lt];i.length===3&&Mt.push(i[2]),r.compute(dd(Mt,s,dt,u),{inputs:Mt})}else r.compute(To(i,s,u));return}let p=i.length===3,c=i[0].dims[d?1:2],b=i[0].dims[d?2:3],T=i[0].dims[d?3:1],E=i[1].dims[2],q=i[1].dims[3],H=dl(i[0].dims,i[1].dims,s.dilations,s.pads,s.strides,d),w=H[d?1:2],Z=H[d?2:3],re=H[d?3:1],le=d&&E===c&&q===b&&s.pads[0]===0&&s.pads[1]===0;if(le||E===1&&q===1&&s.dilations[0]===1&&s.dilations[1]===1&&s.strides[0]===1&&s.strides[1]===1&&s.pads[0]===0&&s.pads[1]===0){let dt=H[0],lt,Mt,Dt,Vt=[];if(d){let nr=r.kernelCustomData.wT??r.compute(bi(i[1],Hs),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];if(s.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=nr),le){let Wr=c*b*T;lt=i[0].reshape([1,dt,Wr]),Mt=nr.reshape([1,Wr,re]),Dt=[1,dt,re]}else lt=i[0].reshape([dt,c*b,T]),Mt=nr.reshape([1,T,re]),Dt=[dt,w*Z,re];Vt.push(lt),Vt.push(Mt)}else lt=i[0].reshape([dt,T,c*b]),Mt=i[1].reshape([1,re,T]),Dt=[dt,re,w*Z],Vt.push(Mt),Vt.push(lt);p&&Vt.push(i[2]);let hr=Dt[2],xr=Vt[0].dims[Vt[0].dims.length-1];hr<8&&xr<8?r.compute(cl(Vt,s,H,Dt,d,u),{inputs:Vt}):r.compute(ll(Vt,s,H,Dt,d,u),{inputs:Vt});return}let _e=!0,be=r.kernelCustomData.wT??r.compute(bi(i[1],Hs),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=be);let me=[i[0],be];p&&me.push(i[2]);let Fe=d?w*Z:re,Se=d?re:w*Z,ze=E*q*T;r.compute(sd(me,s,H,Fe,Se,ze,p,_e,u),{inputs:me})},hl=(r,i)=>{let s=i.format==="NHWC",u=[r.inputs[0].reshape(s?[r.inputs[0].dims[0],1,r.inputs[0].dims[1],r.inputs[0].dims[2]]:[r.inputs[0].dims[0],r.inputs[0].dims[1],1,r.inputs[0].dims[2]]),r.inputs[1].reshape([r.inputs[1].dims[0],r.inputs[1].dims[1],1,r.inputs[1].dims[2]])];r.inputs.length===3&&u.push(r.inputs[2]);let d=[0,i.pads[0],0,i.pads[1]],p=[1].concat(i.strides),c=[1].concat(i.dilations),b=[1].concat(i.kernelShape),T=qs({...i,pads:d,strides:p,dilations:c,kernelShape:b},u);pl(r,u,T,E=>s?[E[0],E[2],E[3]]:[E[0],E[1],E[3]])},md=(r,i,s)=>{let u=s.format==="NHWC"?"channelsLast":"channelsFirst",d=qs(s,i),p=s.autoPad==="NOTSET"?s.pads:s.autoPad,c=ud(i[0].dims,i[1].dims,s.strides,s.dilations,p,!1,u);r.compute(cd(i,d,c.outShape,[c.filterDepth,c.filterHeight,c.filterWidth],[c.padInfo.front,c.padInfo.top,c.padInfo.left],u))},ml=(r,i)=>{if(hd(r.inputs,i),r.inputs[0].dims.length===3)hl(r,i);else if(r.inputs[0].dims.length===5)md(r,r.inputs,i);else{let s=qs(i,r.inputs);pl(r,r.inputs,s)}}}),gd,_d,yd=m(()=>{Zt(),qn(),dr(),Rn(),js(),sl(),io(),gd=(r,i=!1,s,u,d=4)=>{let p=_e=>{switch(_e){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${u}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${_e} is not supported.`)}},c=r?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,b=r?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,T=r?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",E=r?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",q=r?"row":"col",H=r?"col":"row",w=`
      let inChannels = ${r?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${r?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${q} / outWidth;
      let outCol = ${q} % outWidth;

      let WRow = ${H} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${H} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${T}) || fract(xR) > 0.0) {
        return ${u}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${E}) || fract(xC) > 0.0) {
        return ${u}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${H} % inChannels;
      ${c}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${d}];`,Z=r?`
      let col = colIn * ${d};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${w}
      }
      return ${u}(0.0);`:`
      let col = colIn * ${d};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${w}
      }
      return ${u}(0.0);`,re=`
      let col = colIn * ${d};
      let inChannels = ${r?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${r?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${p(d)}
      }
      return ${u}(0.0);
      `,le=qi(s,u);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${u} {
    ${r?Z:re}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${u} {
    ${r?re:Z}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${u}) {
    let col = colIn * ${d};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${r?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${b}
      ${il(i)}
      ${le}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${d}] = value;
    }
  }`},_d=(r,i,s,u,d,p,c,b)=>{let T=i.format==="NHWC",E=T?r[0].dims[3]:r[0].dims[1],q=s[0],H=T?s[2]:s[3],w=T?s[1]:s[2],Z=T?s[3]:s[1],re=T&&E%4===0&&E%3&&Z%4===0,le=T?Z:H*w,_e=T?H*w:Z,be=[8,8,1],me=u<=8?[4,1,1]:[4,4,1],Fe=[Math.ceil(le/be[0]/me[0]),Math.ceil(_e/be[1]/me[1]),Math.ceil(q/be[2]/me[2])];Kr("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${Fe}`);let Se=re?4:1,ze=Math.max(be[0]*Se,be[1]),dt=re?4:1,lt=[i.kernelShape[T?1:2],i.kernelShape[T?2:3]],Mt=[lt[0]+(i.dilations[0]<=1?0:(lt[0]-1)*(i.dilations[0]-1)),lt[1]+(i.dilations[1]<=1?0:(lt[1]-1)*(i.dilations[1]-1))],Dt=[Mt[0]-1-Math.floor((i.pads[0]+i.pads[2])/2),Mt[1]-1-Math.floor((i.pads[1]+i.pads[3])/2)],Vt=[{type:6,data:u},{type:6,data:d},{type:6,data:p},{type:6,data:i.strides},{type:6,data:i.dilations},{type:6,data:lt},{type:6,data:Dt}];zi(i,Vt),Vt.push(...zt(r[0].dims,r[1].dims));let hr=["rank","rank"];c&&(Vt.push(...zt(r[2].dims)),hr.push("rank")),Vt.push(...zt(s));let xr=nr=>{let Wr=gt("x",r[0].dataType,r[0].dims.length,dt),Jr=gt("w",r[1].dataType,r[1].dims.length,1),Er=qt("result",r[0].dataType,s.length,dt),Hr=[Wr,Jr],rr="";if(c){let ut=gt("bias",r[2].dataType,r[2].dims.length,dt);Hr.push(ut),rr+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${ut.type.value} {
            return bias[coords.${T?"w":"y"}${re?"/ 4":""}];
          }`}let wr=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:lt.length},{name:"pads",type:"i32",length:Dt.length}];Ki(i,wr);let Or=zr(r[0].dataType,1);if(Or!=="f16"&&Or!=="f32")throw new Error(`elemType ${Or} is not supported.`);return`
        ${ol("uniforms.result_strides")}
        ${nr.registerUniforms(wr).declareVariables(...Hr,Er)};
        ${rr}
        ${gd(T,c,i,Wr.type.value,Se)}
        ${re?Us(me,be,Or,void 0,!T,ze):Ws(me,be,Or,void 0,!T,ze,!1,void 0,b)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${i.cacheKey};${me};${be};${re}`,inputDependencies:hr},getRunData:()=>({outputs:[{dims:s,dataType:r[0].dataType}],dispatchGroup:{x:Fe[0],y:Fe[1],z:Fe[2]},programUniforms:Vt}),getShaderSource:xr}}}),wd,_l,yl=m(()=>{Zt(),qn(),Jt(),dr(),wd=(r,i,s,u,d,p=!1,c,b,T=!1)=>{let E=T?1:2,q=T?2:3,H=T?3:1,w=p?2:1,Z=`
  fn setOutputAtIndex(flatIndex : u32, value : ${p?`vec4<${c}>`:c}) {
    result[flatIndex] = ${p?`vec4<${c}>`:c}(value);
  }`;u&&(Z+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${p?`vec4<${c}>`:c} {
      return bias[coords.${T?"w":"y"}${p?"/ 4":""}];
    }`);let re=p?4:1,le=gt("W",i[1].dataType,i[1].dims.length,re),_e=gt("Dy",i[0].dataType,i[0].dims.length,re),be=[_e,le];u&&be.push(gt("bias",i[2].dataType,[s[H]].length,re));let me=qt("result",i[0].dataType,s.length,re),Fe=`{
        let batch: u32 = ${d?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${d?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${d?"global_id.y":"workgroup_id.y"} * ${w};
        let d1: u32 = ${d?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${c}>, ${w}>;
        for (var i = 0; i < ${w}; i++) {
          dotProd[i] = vec4<${c}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${c}(dyCorner.x) + ${c}(wR)) / ${c}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${c}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${c}(dyCorner.y) + ${c}(wC)) / ${c}(uniforms.strides.y);
            let dyC2 = (${c}(dyCorner.y) + 1.0 + ${c}(wC)) / ${c}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${c}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${c}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${_e.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${c}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${_e.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${c}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${H}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${_e.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${c}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${le.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${_e.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${c}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${w}; i = i + 1) {
          let value = dotProd[i] + ${u?"bias[c+i]":`vec4<${c}>(0.0)`};
          ${me.set("batch","r","c + i","d1","value")};
        }
      }`,Se=`
          let outputIndices = ${me.offsetToIndices("global_idx")};
          let batch = ${me.indicesGet("outputIndices",0)};
          let d1 = ${me.indicesGet("outputIndices",H)};
          let r = ${me.indicesGet("outputIndices",E)};
          let c = ${me.indicesGet("outputIndices",q)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${c}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${c}(dyRCorner) + ${c}(wR)) / ${c}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${c}(uniforms.Dy_shape[${E}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${c}(dyCCorner) + ${c}(wC)) / ${c}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${c}(uniforms.Dy_shape[${q}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${T?_e.get("batch","idyR","idyC","inputChannel"):_e.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${le.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${u?"bias[d1]":`${c}(0.0)`};
          ${me.setByOffset("global_idx","value")};
        `;return`
  ${r.registerUniforms(b).declareVariables(...be,me)}
  ${Z}

    ${r.mainStart()}
    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${p?Fe:Se}}`},_l=(r,i,s)=>{let u=r.length>2,d=i.outputShape,p=Ze.size(d),c=[Math.ceil(p/64),1,1];Kr("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${c}`);let b=i.format==="NHWC",T=["rank","rank"],E=[i.strides[0],i.strides[1]],q=[i.kernelShape[b?1:2],i.kernelShape[b?2:3]],H=[i.dilations[0],i.dilations[1]],w=[q[0]+(i.dilations[0]<=1?0:(i.kernelShape[b?1:2]-1)*(i.dilations[0]-1)),q[1]+(i.dilations[1]<=1?0:(i.kernelShape[b?2:3]-1)*(i.dilations[1]-1))],Z=[w[0]-1-Math.floor((i.pads[0]+i.pads[2])/2),w[1]-1-Math.floor(i.pads[1]+i.pads[3])/2],re=!1,le=i.group,_e=r[1].dims,be=_e[0]/le,me=_e[1],Fe=[{type:12,data:p},{type:12,data:E},{type:12,data:q},{type:12,data:H},{type:12,data:w},{type:6,data:Z},{type:12,data:be},{type:12,data:me},...zt(r[0].dims,r[1].dims)];u&&(Fe.push(...zt(r[2].dims)),T.push("rank")),Fe.push(...zt(d));let Se=c[1]===1&&c[2]===1,ze=dt=>{let lt=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:E.length},{name:"filter_dims",type:"u32",length:q.length},{name:"dilations",type:"u32",length:q.length},{name:"effective_filter_dims",type:"u32",length:w.length},{name:"pads",type:"i32",length:Z.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],Mt=zr(r[0].dataType);return`${wd(dt,r,d,u,Se,re,Mt,lt,b)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${i.cacheKey};`,inputDependencies:T},getRunData:()=>({dispatchGroup:{x:c[0],y:c[1],z:c[2]},outputs:[{dims:s?s(d):d,dataType:r[0].dataType}],programUniforms:Fe}),getShaderSource:ze}}}),vd,bd,xd,wl,vl,Ks,Pp,Md,kd,bl,$p=m(()=>{yd(),yl(),Rn(),Mo(),vd=(r,i,s,u,d,p)=>(r-1)*i+s+(u-1)*d+1-p,bd=(r,i,s,u,d)=>{let p=Math.floor(r/2);i==="SAME_UPPER"?(s[u]=p,s[d]=r-p):i==="SAME_LOWER"&&(s[u]=r-p,s[d]=p)},xd=(r,i,s,u,d,p,c,b,T,E)=>{let q=r.length-2,H=E.length===0;if(T.length===0)for(let re=0;re<q;++re)T.push(0);let w=r[0],Z=i[b?3:1]*d;for(let re=0,le=r.length-q-(b?1:0);re<q;++re,++le){let _e=r[le],be=H?_e*c[re]:E[re],me=vd(_e,c[re],p[re],i[le],s[re],be);bd(me,u,p,re,re+q),H&&E.push(c[re]*(_e-1)+T[re]+(i[le]-1)*s[re]+1-p[re]-p[re+q])}E.splice(0,0,w),E.splice(b?3:1,0,Z)},wl=(r,i)=>{let s=r.kernelShape.slice();if(r.kernelShape.length===0||r.kernelShape.reduce((H,w)=>H*w,1)===0){s.length=0;for(let H=2;H<i[1].dims.length;++H)s.push(i[1].dims[H])}let u=r.format==="NHWC";s.splice(0,0,i[1].dims[0]),s.splice(u?3:1,0,i[1].dims[1]);let d=r.pads.slice(),p=r.outputShape.slice(),c=r.outputPadding.slice(),b=i[0].dims,T=r.dilations.slice();if(T.reduce((H,w)=>H+w,0)===0){let H=i[0].dims.length-2;T=new Array(H).fill(1)}let E=r.strides.slice();if(E.reduce((H,w)=>H+w,0)===0){let H=i[0].dims.length-2;E=new Array(H).fill(1)}xd(b,s,T,r.autoPad,r.group,d,E,u,c,p);let q=Object.assign({},r);return Object.assign(q,{kernelShape:s,pads:d,outputPadding:c,outputShape:p,dilations:T,strides:E}),q},vl=r=>{let i=nl(r),s=r.format,u=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof r.autoPad>"u"?0:r.autoPad],d=r.dilations,p=r.group,c=r.kernelShape,b=r.pads,T=r.strides,E=r.wIsConst(),q=r.outputPadding,H=r.outputShape;return{autoPad:u,format:s,dilations:d,group:p,kernelShape:c,outputPadding:q,outputShape:H,pads:b,strides:T,wIsConst:E,...i,cacheKey:`${r.format};${i.activation};`}},Ks=(r,i)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length!==4&&r[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(r[0].dims.length!==r[1].dims.length)throw new Error("filter does not have same dimension as input");let s=r[0].dims[i.format==="NHWC"?r[0].dims.length-1:1],u=r[1].dims[0];if(s!==u)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let d=r[1].dims[1]*i.group;if(r.length===3&&(r[2].dims.length!==1||r[2].dims[0]!==d))throw new Error("invalid bias");let p=r[0].dims.length-2;if(i.dilations.reduce((c,b)=>c+b,0)>0&&i.dilations.length!==p)throw new Error(`dilations should be ${p}D`);if(i.strides.reduce((c,b)=>c+b,0)>0&&i.strides.length!==p)throw new Error(`strides should be ${p}D`);if(i.pads.reduce((c,b)=>c+b,0)>0&&i.pads.length!==p*2)throw new Error(`pads should be ${p*2}D`);if(i.outputPadding.length!==p&&i.outputPadding.length!==0)throw new Error(`output_padding should be ${p}D`);if(i.kernelShape.reduce((c,b)=>c+b,0)>0&&i.kernelShape.length!==0&&i.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape");if(i.outputShape.length!==0&&i.outputShape.length!==r[0].dims.length-2)throw new Error("invalid output shape")},Pp=[2,3,1,0],Md=(r,i,s)=>{let u=wl(s,i),d=s.format==="NHWC",p=u.outputShape,c=p[d?3:1],b=i[0].dims[d?3:1];if(u.group!==1||c===1&&b===1){r.compute(_l(i,u));return}let T=p[d?1:2],E=p[d?2:3],q=i[1].dims[2],H=i[1].dims[3],w=d?T*E:c,Z=d?c:T*E,re=q*H*b,le=!0,_e=r.kernelCustomData.wT??r.compute(bi(i[1],Pp),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=_e);let be=[i[0],_e],me=i.length===3;me&&(!d&&i[2].dims.length===1?be.push(i[2].reshape([i[2].dims[0],1,1])):be.push(i[2])),r.compute(_d(be,u,p,w,Z,re,me,le),{inputs:be})},kd=(r,i)=>{let s=i.format==="NHWC",u=[r.inputs[0].reshape(s?[r.inputs[0].dims[0],1,r.inputs[0].dims[1],r.inputs[0].dims[2]]:[r.inputs[0].dims[0],r.inputs[0].dims[1],1,r.inputs[0].dims[2]]),r.inputs[1].reshape([r.inputs[1].dims[0],r.inputs[1].dims[1],1,r.inputs[1].dims[2]])];r.inputs.length===3&&u.push(r.inputs[2]);let d=i.kernelShape;(d.length===0||d[0]===0)&&(d=[r.inputs[1].dims[2]]);let p=i.dilations;(p.length===0||p[0]===0)&&(p=[1]);let c=i.strides;(c.length===0||c[0]===0)&&(c=[1]);let b=i.pads;b.length===0&&(b=[0,0]),b=[0,b[0],0,b[1]],c=[1].concat(c),p=[1].concat(p),d=[1].concat(d);let T=wl({...i,pads:b,strides:c,dilations:p,kernelShape:d},u);r.compute(_l(u,T,E=>s?[E[0],E[2],E[3]]:[E[0],E[1],E[3]]))},bl=(r,i)=>{Ks(r.inputs,i),r.inputs[0].dims.length===3?kd(r,i):Md(r,r.inputs,i)}}),Td,xl,Sd,Ap=m(()=>{Zt(),Jt(),vr(),dr(),Td=(r,i,s,u)=>{let d=Ze.size(i),p=i.length,c=gt("input",r,p),b=qt("output",r,p),T=s.dataType===6?s.getInt32Array()[0]:Number(s.getBigInt64Array()[0]),E=Ze.normalizeAxis(T,p),q=H=>{let w=` i32(${c.indicesGet("inputIndices","uniforms.axis")}) `,Z=jt("uniforms.input_shape","uniforms.axis",p),re=u.reverse?w+(u.exclusive?" + 1":""):"0",le=u.reverse?Z:w+(u.exclusive?"":" + 1");return`
                ${H.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(c,b)}
                ${H.mainStart()}
                  ${H.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${b.offsetToIndices("global_idx")};
                  var sum = ${b.type.value}(0);
                  let first : i32 = ${re};
                  let last : i32 = ${le};
                  for (var i : i32 = first; i < last; i++) {
                    ${c.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${c.getByIndices("inputIndices")};
                  }
                  ${b.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:u.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:12,data:E},...zt(i,i)]}),getShaderSource:q}},xl=(r,i)=>{let s=r.inputs[0].dims,u=r.inputs[0].dataType,d=r.inputs[1];r.compute(Td(u,s,d,i),{inputs:[0]})},Sd=r=>{let i=r.exclusive===1,s=r.reverse===1;return Xt({exclusive:i,reverse:s})}}),Ml,Ip,Fp,kl,Tl,zp=m(()=>{Zt(),Jt(),vr(),dr(),Ml=r=>{if(!r||r.length!==1)throw new Error("DepthToSpace requires 1 input.");if(r[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Ip=(r,i,s,u)=>{let d=[];d.push(`fn perm(i: ${u.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`);for(let p=0;p<i;++p)d.push(s.indicesSet("a",r[p],`i[${p}]`));return d.push("return a;}"),d.join(`
`)},Fp=(r,i)=>{let s,u,d,p,c,b,T=i.format==="NHWC",E=i.blocksize,q=i.mode==="DCR";T?([s,u,d,p]=r.dims,c=q?[s,u,d,E,E,p/E**2]:[s,u,d,p/E**2,E,E],b=q?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([s,u,d,p]=[r.dims[0],r.dims[2],r.dims[3],r.dims[1]],c=q?[s,E,E,p/E**2,u,d]:[s,p/E**2,E,E,u,d],b=q?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let H=r.reshape(c),w=H.dims.length,Z=r.dataType,re=gt("a",Z,w),le=qt("output",Z,w),_e=be=>`
  ${be.registerUniform("output_size","u32").declareVariables(re,le)}

  ${Ip(b,w,re,le)}

  ${be.mainStart()}
    ${be.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${le.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${le.setByOffset("global_idx",re.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${r.dims};${i.blocksize};${i.mode}`,inputDependencies:["rank"]},getRunData:be=>{let me=T?[s,u*E,d*E,p/E**2]:[s,p/E**2,u*E,d*E],Fe=Ze.size(me),Se=H.dims,ze=Ze.sortBasedOnPerm(Se,b);return{outputs:[{dims:me,dataType:be[0].dataType}],dispatchGroup:{x:Math.ceil(Fe/64)},programUniforms:[{type:12,data:Fe},...zt(Se,ze)]}},getShaderSource:_e}},kl=(r,i)=>{Ml(r.inputs),r.compute(Fp(r.inputs[0],i))},Tl=r=>Xt({blocksize:r.blocksize,mode:r.mode,format:r.format})}),Qs,So,Sl,Ed,El,Cd,Pd,Xs,$d,Ad,Lr,Im=m(()=>{Zt(),Jt(),vr(),dr(),Qs="[a-zA-Z]|\\.\\.\\.",So="("+Qs+")+",Sl="^"+So+"$",Ed="("+So+",)*"+So,El="^"+Ed+"$",Cd=class{constructor(r=-1){this.symbolToIndices=new Map,this.inputIndex=r}addSymbol(r,i){let s=this.symbolToIndices.get(r);s===void 0?s=[i]:s.push(i),this.symbolToIndices.set(r,s)}},Pd=class{constructor(r,i){var d;this.equation=i,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[s,u]=i.includes("->")?i.split("->",2):[i,""];if(!s.match(RegExp(El)))throw new Error("Invalid LHS term");if(s.split(",").forEach((p,c)=>{let b=r[c].dims.slice();if(!p.match(RegExp(Sl)))throw new Error("Invalid LHS term");let T=this.processTerm(p,!0,b,c);this.lhs.push(T)}),u==="")u+=[...this.symbolToInfo.entries()].filter(([p,c])=>c.count===1||p==="...").map(([p])=>p).join("");else if(!u.match(RegExp(So)))throw new Error("Invalid RHS");(d=u.match(RegExp(Qs,"g")))==null||d.forEach(p=>{if(p==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let c=this.symbolToInfo.get(p);if(c===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(c.dimValue)}}),this.rhs=this.processTerm(u,!1,this.outputDims)}addSymbol(r,i,s){let u=this.symbolToInfo.get(r);if(u!==void 0){if(u.dimValue!==i&&u.count!==1)throw new Error("Dimension mismatch");u.count++,u.inputIndices.push(s)}else u={count:1,dimValue:i,inputIndices:[s]};this.symbolToInfo.set(r,u)}processTerm(r,i,s,u=-1){let d=s.length,p=!1,c=[],b=0;if(!r.match(RegExp(Sl))&&!i&&r!=="")throw new Error("Invalid LHS term");let T=r.match(RegExp(Qs,"g")),E=new Cd(u);return T==null||T.forEach((q,H)=>{if(q==="..."){if(p)throw new Error("Only one ellipsis is allowed per input term");p=!0;let w=d-T.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(c=s.slice(b,b+w),this.hasEllipsis){if(this.ellipsisDims.length!==c.length||this.ellipsisDims.toString()!==c.toString())throw new Error("Ellipsis dimensions mismatch")}else if(i)this.hasEllipsis=!0,this.ellipsisDims=c;else throw new Error("Ellipsis must be specified in the LHS");for(let Z=0;Z<c.length;Z++){let re=String.fromCharCode(48+Z);E.addSymbol(re,H+Z),this.addSymbol(re,s[b++],u)}}else E.addSymbol(q,H+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(q,s[b++],u)}),E}},Xs=r=>r+"_max",$d=(r,i,s,u)=>{let d=r.map(E=>E.length).map((E,q)=>gt(`input${q}`,i,E)),p=Ze.size(u),c=qt("output",i,u.length),b=[...s.symbolToInfo.keys()].filter(E=>!s.rhs.symbolToIndices.has(E)),T=E=>{let q=[],H="var prod = 1.0;",w="var sum = 0.0;",Z="sum += prod;",re=[],le=[],_e=[],be=[],me=s.symbolToInfo.size===s.rhs.symbolToIndices.size;s.symbolToInfo.forEach((Se,ze)=>{var dt;if(s.rhs.symbolToIndices.has(ze)){let lt=(dt=s.rhs.symbolToIndices.get(ze))==null?void 0:dt[0];lt!==void 0&&s.lhs.forEach((Mt,Dt)=>{if(Se.inputIndices.includes(Dt)){let Vt=Mt.symbolToIndices.get(ze);if(Vt===void 0)throw new Error("Invalid symbol error");Vt.forEach(hr=>{q.push(`${d[Dt].indicesSet(`input${Dt}Indices`,hr,c.indicesGet("outputIndices",lt))}`)})}})}else s.lhs.forEach((lt,Mt)=>{if(Se.inputIndices.includes(Mt)){let Dt=lt.symbolToIndices.get(ze);if(Dt===void 0)throw new Error("Invalid symbol error");Dt.forEach(Vt=>{re.push(`${d[Mt].indicesSet(`input${Mt}Indices`,Vt,`${ze}`)}`)}),be.push(`prod *= ${d[Mt].getByIndices(`input${Mt}Indices`)};`)}}),le.push(`for(var ${ze}: u32 = 0; ${ze} < uniforms.${Xs(ze)}; ${ze}++) {`),_e.push("}")});let Fe=me?[...q,`let sum = ${d.map((Se,ze)=>Se.getByIndices(`input${ze}Indices`)).join(" * ")};`]:[...q,w,...le,...re,H,...be,Z,..._e];return`
            ${E.registerUniforms(b.map(Se=>({name:`${Xs(Se)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...d,c)}

            ${E.mainStart()}
            ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${c.offsetToIndices("global_idx")};
            ${d.map((Se,ze)=>`var input${ze}Indices: ${d[ze].type.indices};`).join(`
`)}
            ${Fe.join(`
`)};
            ${c.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:s.equation,inputDependencies:r.map(()=>"rank")},getRunData:()=>{let E=b.filter(H=>s.symbolToInfo.has(H)).map(H=>{var w;return{type:12,data:((w=s.symbolToInfo.get(H))==null?void 0:w.dimValue)||0}});E.push({type:12,data:p});let q=r.map((H,w)=>[...zt(H)]).reduce((H,w)=>H.concat(w),E);return q.push(...zt(u)),{outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:q}},getShaderSource:T}},Ad=(r,i)=>{let s=new Pd(r.inputs,i.equation),u=s.outputDims,d=r.inputs.map((p,c)=>p.dims);r.compute($d(d,r.inputs[0].dataType,s,u))},Lr=r=>{let i=r.equation.replace(/\s+/g,"");return Xt({equation:i})}}),Op,Id,Cl,Fd,zd,Dp=m(()=>{Zt(),Jt(),dr(),Op=r=>{if(!r||r.length!==2)throw new Error("Expand requires 2 input.");let i=r[0].dims,s=Array.from(r[1].getBigInt64Array(),Number),u=s.length<i.length?0:s.length-i.length,d=i.length<s.length?0:i.length-s.length;for(;u<s.length&&d<i.length;++u,++d)if(s[u]!==i[d]&&s[u]!==1&&i[d]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Id=(r,i)=>{let s=r.length-i.length,u=[];for(let d=0;d<s;++d)u.push(r[d]);for(let d=0;d<i.length;++d)u.push(i[d]===1?r[d+s]:i[d]);return u},Cl=(r,i)=>r.length>i.length?Id(r,i):Id(i,r),Fd=r=>{let i=r[0].dims,s=Array.from(r[1].getBigInt64Array(),Number),u=Cl(i,s),d=r[0].dataType,p=d===9?4:1,c=Math.ceil(Ze.size(u)/p),b=E=>{let q=gt("input",d,i.length,p),H=qt("output",d,u.length,p),w;if(d===9){let Z=(re,le,_e="")=>`
          let outputIndices${le} = ${H.offsetToIndices(`outputOffset + ${le}u`)};
          let offset${le} = ${q.broadcastedIndicesToOffset(`outputIndices${le}`,H)};
          let index${le} = offset${le} / 4u;
          let component${le} = offset${le} % 4u;
          ${re}[${le}] = ${_e}(${q.getByOffset(`index${le}`)}[component${le}]);
        `;w=`
        let outputOffset = global_idx * ${p};
        var data = vec4<u32>(0);
        ${Z("data",0,"u32")}
        ${Z("data",1,"u32")}
        ${Z("data",2,"u32")}
        ${Z("data",3,"u32")}
        ${H.setByOffset("global_idx","data")}
      }`}else w=`
        let outputIndices = ${H.offsetToIndices("global_idx")};
        let inputOffset = ${q.broadcastedIndicesToOffset("outputIndices",H)};
        ${H.setByOffset("global_idx",q.getByOffset("inputOffset"))}
      }`;return`
    ${E.registerUniform("vec_size","u32").declareVariables(q,H)}
    ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${w}`},T=[{type:12,data:c},...zt(i,u)];return{name:"Expand",shaderCache:{hint:`${u.length}`,inputDependencies:["rank"]},getShaderSource:b,getRunData:()=>({outputs:[{dims:u,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:T})}},zd=r=>{Op(r.inputs),r.compute(Fd(r.inputs),{inputs:[0]})}}),Od,Pl,Dd=m(()=>{Zt(),Jt(),dr(),Xa(),Od=r=>{let i=r[0].dataType,s=Ze.size(r[0].dims),u=Ze.size(r[1].dims),d=u%4===0,p=c=>{let b=gt("x",i,[1],4),T=gt("bias",i,[1],4),E=qt("y",i,[1],4),q=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],H=Z=>`
      let bias${Z}_offset: u32 = (global_idx * 4 + ${Z}) % uniforms.bias_size;
      let bias${Z} = ${T.getByOffset(`bias${Z}_offset / 4`)}[bias${Z}_offset % 4];`,w=d?`
      let bias = ${T.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${H(0)}${H(1)}${H(2)}${H(3)}
      let bias = ${b.type.value}(bias0, bias1, bias2, bias3);`;return`${c.registerUniforms(q).declareVariables(b,T,E)}

    ${qa($r(i))}

    ${c.mainStart(Kn)}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${b.getByOffset("global_idx")};
      ${w}
      let x_in = x + bias;
      ${E.setByOffset("global_idx",Ka("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${d}`,inputDependencies:["type","type"]},getShaderSource:p,getRunData:c=>({outputs:[{dims:c[0].dims,dataType:c[0].dataType}],programUniforms:[{type:12,data:Math.ceil(s/4)},{type:12,data:u}],dispatchGroup:{x:Math.ceil(s/Kn/4)}})}},Pl=r=>{r.inputs.length<2||Ze.size(r.inputs[1].dims)===0?Qa(r):r.compute(Od(r.inputs))}}),Ld,Bd,$l,Lp,Fm=m(()=>{Zt(),Jt(),vr(),dr(),Ld=r=>{if(!r||r.length!==2)throw new Error("Gather requires 2 inputs.")},Bd=(r,i)=>{let s=r[0].dims,u=r[1].dims,d=s.length,p=Ze.normalizeAxis(i.axis,d),c=s.slice(0);c.splice(p,1,...u);let b=s[p],T=r[0].dataType===9?4:1,E=Math.ceil(Ze.size(c)/T),q=[{type:12,data:E},{type:6,data:b},{type:12,data:p},...zt(r[0].dims,r[1].dims,c)],H=w=>{let Z=gt("data",r[0].dataType,r[0].dims.length,T),re=gt("inputIndices",r[1].dataType,r[1].dims.length),le=qt("output",r[0].dataType,c.length,T),_e=me=>{let Fe=u.length,Se=`var indicesIndices${me}  = ${re.type.indices}(0);`;for(let ze=0;ze<Fe;ze++)Se+=`${Fe>1?`indicesIndices${me}[${ze}]`:`indicesIndices${me}`} = ${c.length>1?`outputIndices${me}[uniforms.axis + ${ze}]`:`outputIndices${me}`};`;Se+=`
          var idx${me} = ${re.getByIndices(`indicesIndices${me}`)};
          if (idx${me} < 0) {
            idx${me} = idx${me} + uniforms.axisDimLimit;
          }
          var dataIndices${me} : ${Z.type.indices};
        `;for(let ze=0,dt=0;ze<d;ze++)ze===p?(Se+=`${d>1?`dataIndices${me}[${ze}]`:`dataIndices${me}`} = u32(idx${me});`,dt+=Fe):(Se+=`${d>1?`dataIndices${me}[${ze}]`:`dataIndices${me}`} = ${c.length>1?`outputIndices${me}[${dt}]`:`outputIndices${me}`};`,dt++);return Se},be;if(r[0].dataType===9){let me=(Fe,Se,ze="")=>`
          let outputIndices${Se} = ${le.offsetToIndices(`outputOffset + ${Se}u`)};
          ${_e(Se)};
          let offset${Se} = ${Z.indicesToOffset(`dataIndices${Se}`)};
          let index${Se} = offset${Se} / 4u;
          let component${Se} = offset${Se} % 4u;
          ${Fe}[${Se}] = ${ze}(${Z.getByOffset(`index${Se}`)}[component${Se}]);
        `;be=`
        let outputOffset = global_idx * ${T};
        var value = vec4<u32>(0);
        ${me("value",0,"u32")}
        ${me("value",1,"u32")}
        ${me("value",2,"u32")}
        ${me("value",3,"u32")}
        ${le.setByOffset("global_idx","value")}
      `}else be=`
      let outputIndices = ${le.offsetToIndices("global_idx")};
      ${_e("")};
      let value = ${Z.getByIndices("dataIndices")};
      ${le.setByOffset("global_idx","value")};
      `;return`
      ${w.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(Z,re,le)}
      ${w.mainStart()}
        ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${be}
      }`};return{name:"Gather",shaderCache:{hint:i.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:c,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(E/64)},programUniforms:q}),getShaderSource:H}},$l=r=>Xt({axis:r.axis}),Lp=(r,i)=>{let s=r.inputs;Ld(s),r.compute(Bd(r.inputs,i))}}),Rd,Nd,jd,Ud,Bp=m(()=>{Zt(),Jt(),vr(),dr(),Rd=(r,i)=>{if(r.length<3||r.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let s=Ze.normalizeAxis(i.quantizeAxis,r[0].dims.length),u=i.blockSize,d=r[0],p=r[2],c=r.length===4?r[3]:void 0;if(p.dims.length!==d.dims.length||!d.dims.map((b,T)=>T===s?Math.ceil(b/u)===p.dims[T]:b===p.dims[T]).reduce((b,T)=>b&&T,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(c){if(c.dataType!==d.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(c.dims.length!==p.dims.length||!c.dims.map((b,T)=>b===p.dims[T]).reduce((b,T)=>b&&T,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},Nd=(r,i)=>{let s=r[0].dims,u=r[1].dims,d=s.length,p=Ze.normalizeAxis(i.gatherAxis,d),c=Ze.normalizeAxis(i.quantizeAxis,d),b=s.slice(0);b.splice(p,1,...u);let T=Ze.size(b),E=r[2].dataType,q=r[0].dataType===22,H=[{type:12,data:T},{type:12,data:c},{type:12,data:p},{type:12,data:i.blockSize},...zt(...r.map((Z,re)=>Z.dims),b)],w=Z=>{let re=gt("data",r[0].dataType,r[0].dims.length),le=gt("inputIndices",r[1].dataType,r[1].dims.length),_e=gt("scales",r[2].dataType,r[2].dims.length),be=r.length>3?gt("zeroPoint",r[3].dataType,r[3].dims.length):void 0,me=qt("output",E,b.length),Fe=[re,le,_e];be&&Fe.push(be);let Se=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${Z.registerUniforms(Se).declareVariables(...Fe,me)}
        ${Z.mainStart()}
        let output_indices = ${me.offsetToIndices("global_idx")};
        var indices_indices = ${le.type.indices}(0);
        ${u.length>1?`
          for (var i: u32 = 0; i < ${u.length}; i++) {
            let index = ${me.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${le.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${me.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${re.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${me.indicesGet("output_indices","i")};
          ${re.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${le.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${s[p]};
        }
        ${re.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${b.length}; i++) {
          let index = ${me.indicesGet("output_indices",`i + ${u.length} - 1`)};
          ${re.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${re.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${re.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${q?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${_e.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${_e.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${_e.getByIndices("scale_indices")};
        ${be?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${be.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${be.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${q?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${$r(E)}(quantized_data - zero_point) * scale;
        ${me.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${i.cacheKey};${r.filter((Z,re)=>re!==1).map(Z=>Z.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:r.length},(Z,re)=>"rank")},getRunData:()=>({outputs:[{dims:b,dataType:E}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:H}),getShaderSource:w}},jd=(r,i)=>{let s=r.inputs;Rd(s,i),r.compute(Nd(r.inputs,i))},Ud=r=>Xt({blockSize:r.blockSize,gatherAxis:r.gatherAxis,quantizeAxis:r.quantizeAxis})}),Vd,Wd,Gd,Hd,Rp=m(()=>{Zt(),Jt(),vr(),dr(),Vd=r=>{if(!r||r.length!==2)throw new Error("GatherElements requires 2 inputs.");if(r[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(r[0].dims.length!==r[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Wd=(r,i)=>{let s=r[0].dims,u=r[0].dataType,d=s.length,p=r[1].dims,c=r[1].dataType,b=Ze.normalizeAxis(i.axis,d),T=s[b],E=p.slice(0),q=Ze.size(E),H=gt("input",u,d),w=gt("indicesInput",c,p.length),Z=qt("output",u,E.length),re=[{type:12,data:q},{type:6,data:T},{type:12,data:b}];return re.push(...zt(s,p,E)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:E,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(q/64)},programUniforms:re}),getShaderSource:le=>`
      ${le.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(H,w,Z)}
      ${le.mainStart()}
      ${le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${Z.offsetToIndices("global_idx")};

      var idx = ${w.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${H.type.indices}(outputIndices);
      ${H.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${H.getByIndices("inputIndices")};

      ${Z.setByOffset("global_idx","value")};
  }`}},Gd=r=>Xt({axis:r.axis}),Hd=(r,i)=>{let s=r.inputs;Vd(s),r.compute(Wd(r.inputs,i))}}),qd,Kd,Qd,Xd,Np=m(()=>{Zt(),Jt(),dr(),qd=r=>{if(!r)throw new Error("Input is missing");if(r.length<2||r.length>3)throw new Error("Invaid input number.");if(r.length===3&&r[2].dims.length>2)throw new Error("Invalid input shape of C");if(r[0].dataType!==r[1].dataType||r.length===3&&r[0].dataType!==r[2].dataType)throw new Error("Input types are mismatched")},Kd=(r,i)=>{let s=r[0].dims.slice(),u=r[1].dims.slice(),[d,p,c]=Pr.getShapeOfGemmResult(s,i.transA,u,i.transB,r.length===3?r[2].dims:void 0),b=[d,p];if(!b)throw new Error("Can't use gemm on the given tensors");let T=Ze.size(b),E=[{type:12,data:T},{type:12,data:d},{type:12,data:p},{type:12,data:c},{type:1,data:i.alpha},{type:1,data:i.beta}],q=["type","type"];r.length===3&&(E.push(...zt(r[2].dims)),q.push("rank")),E.push(...zt(b));let H=w=>{let Z="";i.transA&&i.transB?Z="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":i.transA&&!i.transB?Z="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!i.transA&&i.transB?Z="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!i.transA&&!i.transB&&(Z="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let re=i.alpha===1?"":"value *= uniforms.alpha;",le=gt("a",r[0].dataType,r[0].dims),_e=gt("b",r[1].dataType,r[1].dims),be=le.type.value,me=null,Fe=[le,_e];r.length===3&&(me=gt("c",r[2].dataType,r[2].dims.length),Fe.push(me));let Se=qt("output",r[0].dataType,b.length);Fe.push(Se);let ze=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${w.registerUniforms(ze).declareVariables(...Fe)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${be}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${Z}
    }

    ${re}
    ${me!=null?`let cOffset = ${me.broadcastedIndicesToOffset("vec2(m, n)",Se)}; value += ${be}(uniforms.beta) * ${me.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${i.cacheKey}`,inputDependencies:q},getRunData:()=>({outputs:[{dims:b,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:E}),getShaderSource:H}},Qd=r=>{let i=r.transA,s=r.transB,u=r.alpha,d=r.beta;return{transA:i,transB:s,alpha:u,beta:d,cacheKey:`${r.transA};${r.transB};${r.alpha===1}`}},Xd=(r,i)=>{qd(r.inputs),r.compute(Kd(r.inputs,i))}}),In,jp,Al,Il,Yd,ts,Zd,Jd=m(()=>{Zt(),Jt(),vr(),fe(),Ls(),dr(),Mo(),In=(r,i)=>r.length>i&&r[i].dims.length>0?r[i]:void 0,jp=(r,i)=>{let s=r[0],u=In(r,1),d=In(r,2),p=In(r,3),c=In(r,4),b=In(r,5),T=In(r,6),E=In(r,7);if(s.dims.length!==3&&s.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let q=s.dims[0],H=s.dims[1],w=s.dims.length===3?s.dims[2]:i.numHeads*s.dims[4],Z=H,re=0,le=0,_e=Math.floor(w/i.numHeads);if(T&&E&&Ze.size(T.dims)&&Ze.size(E.dims)){if(T.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(T.dims[0]!==q||T.dims[1]!==i.numHeads||T.dims[3]!==_e)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(E.dims[0]!==q||E.dims[1]!==i.numHeads||E.dims[3]!==_e)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(T.dims[2]!==E.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(E.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');re=T.dims[2],le=T.dims[2]}else if(T&&Ze.size(T.dims)||E&&Ze.size(E.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let be;if(u&&Ze.size(u.dims)>0){if(s.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(u.dims.length<3||u.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(s.dims[0]!==u.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(u.dims.length===3){if(u.dims[2]!==s.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');be=2,Z=u.dims[1]}else if(u.dims.length===5){if(u.dims[2]!==i.numHeads||u.dims[3]!==2||u.dims[4]!==_e)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(d)throw new Error('Expect "value" be none when "key" has packed kv format.');be=5,Z=u.dims[1]}else{if(u.dims[1]!==i.numHeads||u.dims[3]!==_e)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');be=0,Z=u.dims[2]}}else{if(s.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(s.dims[2]!==i.numHeads||s.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');be=3}if(p&&Ze.size(p.dims)>0){if(p.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(u&&u.dims.length===5&&u.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let me=re+Z,Fe=0;if(c&&Ze.size(c.dims)>0){Fe=8;let lt=c.dims;throw lt.length===1?lt[0]===q?Fe=1:lt[0]===3*q+2&&(Fe=3):lt.length===2&&lt[0]===q&&lt[1]===me&&(Fe=5),Fe===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let Se=!1,ze=w;if(d&&Ze.size(d.dims)>0){if(d.dims.length!==3&&d.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(s.dims[0]!==d.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(d.dims.length===3){if(Z!==d.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');ze=d.dims[2]}else{if(Z!==d.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');ze=d.dims[1]*d.dims[3],Se=!0}}let dt=!1;if(c&&Ze.size(c.dims)>0)throw new Error("Key padding mask is not supported");if(b&&Ze.size(b.dims)>0){if(b.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(b.dims[0]!==q||b.dims[1]!==i.numHeads||b.dims[2]!==H||b.dims[3]!==me)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:q,sequenceLength:H,pastSequenceLength:re,kvSequenceLength:Z,totalSequenceLength:me,maxSequenceLength:le,inputHiddenSize:0,hiddenSize:w,vHiddenSize:ze,headSize:_e,vHeadSize:Math.floor(ze/i.numHeads),numHeads:i.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:i.maskFilterValue,maskType:Fe,scale:i.scale,broadcastResPosBias:dt,passPastInKv:Se,qkvFormat:be}},Al=r=>Xt({...r}),Il=Xt({perm:[0,2,1,3]}),Yd=(r,i,s,u,d,p,c)=>{let b=[u,d,p],T=Ze.size(b),E=[{type:12,data:T},{type:12,data:c},{type:12,data:p}],q=H=>{let w=qt("qkv_with_bias",i.dataType,b),Z=gt("qkv",i.dataType,b),re=gt("bias",s.dataType,b),le=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${H.registerUniforms(le).declareVariables(Z,re,w)}
  ${H.mainStart()}
    ${H.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return r.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:b,dataType:i.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:E}),getShaderSource:q},{inputs:[i,s],outputs:[-1]})[0]},ts=(r,i,s,u,d,p,c,b)=>{let T=p;if(c&&Ze.size(c.dims)>0){if(u===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return T=Yd(r,p,c,i,u,s*d,b),T=T.reshape([i,u,s,d]),r.compute(bi(T,Il.perm),{inputs:[T],outputs:[-1]})[0]}else return p.dims.length===3&&(T=p.reshape([i,u,s,d])),r.compute(bi(T,Il.perm),{inputs:[T],outputs:[-1]})[0]},Zd=(r,i)=>{let s=jp(r.inputs,i),u=r.inputs[0],d=In(r.inputs,1),p=In(r.inputs,2),c=In(r.inputs,3),b=In(r.inputs,4),T=In(r.inputs,5),E=In(r.inputs,6),q=In(r.inputs,7);if(u.dims.length===5)throw new Error("Packed QKV is not implemented");if((d==null?void 0:d.dims.length)===5)throw new Error("Packed KV is not implemented");let H=d&&p&&d.dims.length===4&&p.dims.length===4,w=ts(r,s.batchSize,s.numHeads,s.sequenceLength,s.headSize,u,c,0);if(H)return ko(r,w,d,p,b,void 0,E,q,T,s,i);if(!d||!p)throw new Error("key and value must be provided");let Z=ts(r,s.batchSize,s.numHeads,s.kvSequenceLength,s.headSize,d,c,s.hiddenSize),re=ts(r,s.batchSize,s.numHeads,s.kvSequenceLength,s.vHeadSize,p,c,2*s.hiddenSize);ko(r,w,Z,re,b,void 0,E,q,T,s,i)}}),Fl,ef,tf,zl,rf,nf=m(()=>{Zt(),Jt(),dr(),Fl=r=>Array.from(r.getBigInt64Array(),Number),ef=r=>{if(!r||r.length!==2)throw new Error("Tile requires 2 inputs.");if(r[0].dataType!==1&&r[0].dataType!==10&&r[0].dataType!==6&&r[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(r[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(r[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Fl(r[1]).length!==r[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},tf=(r,i)=>{let s=[];for(let u=0;u<r.length;++u)s.push(r[u]*i[u]);return s},zl=(r,i)=>{let s=r[0].dims,u=i??Fl(r[1]),d=tf(s,u),p=Ze.size(d),c=r[0].dataType,b=gt("input",c,s.length),T=qt("output",c,d.length),E=q=>`
      const inputShape = ${b.indices(...s)};
      ${q.registerUniform("output_size","u32").declareVariables(b,T)}
      ${q.mainStart()}
      ${q.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${T.offsetToIndices("global_idx")};
      var input_indices: ${b.type.indices};
      for (var i = 0; i < ${s.length}; i++) {
        let input_dim_i = ${b.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${T.indicesGet("output_indices","i")}  % input_dim_i;

        ${b.indicesSet("input_indices","i","input_dim_value")}
      }
      ${T.setByOffset("global_idx",b.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${u}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:d,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:12,data:p},...zt(r[0].dims,d)]}),getShaderSource:E}},rf=r=>{ef(r.inputs),r.compute(zl(r.inputs),{inputs:[0]})}}),of,Ol,sf,af,Dl,lf,Up=m(()=>{Zt(),Jt(),vr(),Ls(),dr(),Jd(),nf(),Mo(),of=(r,i)=>{let s=r[0],u=r[1],d=r[2],p=r[3],c=r[4];if(s.dims.length!==3&&s.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let b=!1,T=s.dims[0],E=s.dims[1],q=s.dims.length===3?b?s.dims[2]/3:s.dims[2]:i.numHeads*s.dims[4],H=E,w=0,Z=0,re=Math.floor(q/i.numHeads),le=p&&p.dims.length!==0,_e=c&&c.dims.length!==0,be=!0;if(le&&_e){if(p.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(c.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');w=p.dims[1],Z=p.dims[1]}else if(le||_e)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let me;if(u){if(s.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(u.dims.length<3||u.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(s.dims[0]!==u.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(u.dims.length===3){if(s.dims[2]%u.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');me=2,H=u.dims[1]}else if(u.dims.length===5){if(u.dims[2]!==i.numHeads||u.dims[3]!==2||u.dims[4]!==re)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(d)throw new Error('Expect "value" be none when "key" has packed kv format.');me=5,H=u.dims[1]}else{if(u.dims[1]!==i.numHeads||u.dims[3]!==re)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');me=0,H=u.dims[2]}}else{if(s.dims.length!==3&&s.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(s.dims.length===5&&(s.dims[2]!==i.numHeads||s.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');me=3}let Fe=0,Se=!1,ze=q;if(d){if(d.dims.length!==3&&d.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(s.dims[0]!==d.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(d.dims.length===3){if(H!==d.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');ze=d.dims[2]}else{if(H!==d.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');ze=d.dims[1]*d.dims[3],Se=!0}}let dt=w+H;return{batchSize:T,sequenceLength:E,pastSequenceLength:w,kvSequenceLength:H,totalSequenceLength:dt,maxSequenceLength:Z,inputHiddenSize:0,hiddenSize:q,vHiddenSize:ze,headSize:re,vHeadSize:Math.floor(ze/i.kvNumHeads),numHeads:i.numHeads,kvNumHeads:i.kvNumHeads,nReps:i.numHeads/i.kvNumHeads,pastPresentShareBuffer:!1,maskType:Fe,scale:i.scale,broadcastResPosBias:!1,passPastInKv:Se,qkvFormat:me,isPastkvBSNH:be}},Ol=(r,i,s,u)=>{let d=[u.batchSize,u.totalSequenceLength,u.kvNumHeads,u.headSize],p=4,c=Ze.size(d)/p,b=u.totalSequenceLength,T=qt("present_kv",s,d.length,p),E=gt("new_kv",r.dataType,r.dims.length,p),q=i?gt("past_kv",i.dataType,i.dims.length,p):void 0,H=Math.ceil(u.headSize/p),w={x:b,y:r.dims[0],z:1},Z=i?["rank","rank"]:["rank"],re=[{type:12,data:c},{type:12,data:u.pastSequenceLength},{type:12,data:u.kvSequenceLength},{type:12,data:u.totalSequenceLength}],le=[E];q?(re.push(...zt(r.dims),...zt(i.dims),...zt(d)),le.push(q)):re.push(...zt(r.dims),...zt(d));let _e=[{name:"output_size",type:"u32"},{name:"past_seqlen",type:"u32"},{name:"new_seqlen",type:"u32"},{name:"present_seqlen",type:"u32"}],be=`      let past_batch_stride = uniforms.past_seqlen * num_heads * H;
        var past_head_stride = uniforms.past_seqlen * H;
        if (is_bsnh) {
          past_head_stride = H;
        }
        let in_offset = b * past_batch_stride + s * row_stride + n * past_head_stride + h;
        present_kv[out_offset] = past_kv[in_offset];`,me=`      let new_batch_stride = uniforms.new_seqlen * num_heads * H;
        let new_row_stride = num_heads * H;
        let new_head_stride = H;
        let in_offset = b * new_batch_stride + (s - past_seqlen) * new_row_stride + n * new_head_stride + h;
        present_kv[out_offset] = new_kv[in_offset];`,Fe=i?`if (s < past_seqlen) {
        ${be}
        } else if (s < past_seqlen + uniforms.new_seqlen) {
        ${me}
        }`:`if (s < past_seqlen + uniforms.new_seqlen) {
          ${me}
        }`,Se=ze=>`

  ${ze.registerUniforms(_e).declareVariables(...le,T)}
  ${ze.mainStart([H,u.kvNumHeads,1])}
    ${ze.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    var indices = ${T.offsetToIndices("global_idx")};
    let h = local_id.x;
    let n = local_id.y;
    let s = workgroup_id.x;
    let b = workgroup_id.y;
    let num_heads = ${u.kvNumHeads}u;
    let H = ${H}u;

    let present_seqlen = uniforms.present_seqlen;
    let present_batch_stride = present_seqlen * num_heads * H;
    var row_stride = H;
    let is_bsnh = ${u.isPastkvBSNH};

    if (is_bsnh) {
      row_stride = num_heads * H;
    }
    var present_head_stride = present_seqlen * H;
    if (is_bsnh) {
      present_head_stride = H;
    }

    let past_seqlen = uniforms.past_seqlen;

    let out_offset = b * present_batch_stride + s * row_stride + n * present_head_stride + h;
    ${Fe}
  }`;return{name:"ConcatPastNew",shaderCache:{hint:`${u.kvNumHeads}${H}${!!i}`,inputDependencies:Z},getRunData:()=>({outputs:[{dims:d,dataType:s}],dispatchGroup:w,programUniforms:re}),getShaderSource:Se}},sf=r=>Xt({...r}),af=Xt({perm:[0,2,1,3]}),Dl=(r,i,s,u,d)=>{let p=i,c=u.kvNumHeads,b=u.nReps;return i.dims.length===3&&u.kvSequenceLength!==0&&(p=i.reshape([u.batchSize,u.kvSequenceLength,c,u.headSize])),s?p=r.compute(Ol(p,s,p.dataType,u),{inputs:[p,s],outputs:[u.isPastkvBSNH?d:-1]})[0]:p=r.compute(Ol(p,void 0,p.dataType,u),{inputs:[p],outputs:[u.isPastkvBSNH?d:-1]})[0],b!==1&&(p=r.compute(zl([p],[1,1,1,b]),{inputs:[p],outputs:[-1]})[0],p=p.reshape([u.batchSize,u.totalSequenceLength,c*b,u.headSize])),r.compute(bi(p,af.perm),{inputs:[p],outputs:[-1]})[0]},lf=(r,i)=>{var T;let s=of(r.inputs,i);if(r.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((T=r.inputs[1])==null?void 0:T.dims.length)===5)throw new Error("Packed KV is not implemented");let u=ts(r,s.batchSize,s.numHeads,s.sequenceLength,s.headSize,r.inputs[0],void 0,0),d=r.inputs[3]&&r.inputs[3].dims.length!==0?r.inputs[3]:void 0,p=r.inputs[4]&&r.inputs[4].dims.length!==0?r.inputs[4]:void 0,c=Dl(r,r.inputs[1],d,s,1),b=Dl(r,r.inputs[2],p,s,2);ko(r,u,c,b,void 0,void 0,void 0,void 0,void 0,s,i)}}),uf,cf,df,ff,Vp=m(()=>{Zt(),Jt(),dr(),uf=(r,i)=>{let s=r[0].dims,u=s,d=2,p=Ze.sizeToDimension(s,d),c=Ze.sizeFromDimension(s,d),b=Ar(c),T=c/b,E=[s[0],s[1],T],q=["rank","type","type"],H=[{type:12,data:c},{type:12,data:T}];H.push(...zt(E,E));let w=Z=>{let re=gt("x",r[0].dataType,E.length,b),le=gt("scale",r[1].dataType,r[1].dims),_e=gt("bias",r[2].dataType,r[2].dims),be=qt("output",r[0].dataType,E.length,b),me=[re,le,_e,be],Fe=re.type.value,Se=b===1?"f32":`vec${b}<f32>`,ze=64,dt=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${Se}, ${ze}>;
  const workgroupSize = ${ze}u;
  ${Z.registerUniforms(dt).declareVariables(...me)}
  ${Z.mainStart(ze)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${Se}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${Se}(${re.get("batch","channel","h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${Qn("workgroupShared[0]",b)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${Se}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${Se}(${re.get("batch","channel","h")}) - ${Se}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${Qn("workgroupShared[0]",b)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${i.epsilon}));
    let channelScale = invStdDev * f32(${le.getByOffset("channel")});
    let channelShift = f32(${_e.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${re.get("batch","channel","h")} * ${Fe}(${Se}(channelScale)) + ${Fe}(${Se}(channelShift));
      ${be.set("batch","channel","h","value")};
    }
  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${i.epsilon};${b}`,inputDependencies:q},getRunData:()=>({outputs:[{dims:u,dataType:r[0].dataType}],dispatchGroup:{x:p},programUniforms:H}),getShaderSource:w}},cf=(r,i,s,u,d,p,c,b)=>{let T=Ar(c),E=64,q=T===1?"vec2f":`mat2x${T}f`,H=T===1?"f32":`vec${T}f`,w=(dt,lt)=>`${q}(${dt}, ${lt})`,Z=d*c/T,re=Math.ceil(p/E),le=["type"],_e=[{type:12,data:re},{type:12,data:p},{type:12,data:Math.floor(c/T)},{type:12,data:Math.floor(p*c/T)}],be=dt=>{let lt=gt("input",i.dataType,i.dims,T);return`
  ${dt.declareVariables(lt)}
  @group(0) @binding(1) var<storage, read_write> output : array<${q}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${dt.mainStart(E)}
    let currentImageNumber = global_idx / ${E} / uniforms.C;
    let currentChannelNumber = (global_idx / ${E}) % uniforms.C;
    let wgOffset = local_id.x * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${jr("f32",T)};
    var squaredSum = ${jr("f32",T)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${H}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${w("sum","squaredSum")};
  }`},me=r.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${T}`,inputDependencies:le},getRunData:()=>({outputs:[{dims:[d,c,E,2],dataType:1}],dispatchGroup:{x:d*c/T},programUniforms:_e}),getShaderSource:be},{inputs:[i],outputs:[-1]})[0],Fe=[{type:12,data:Z},{type:12,data:p},{type:12,data:Math.floor(c/T)},{type:12,data:Math.floor(E*c/T)}],Se=["type","type","type"],ze=dt=>{let lt=gt("scale",s.dataType,s.dims,T),Mt=gt("bias",u.dataType,u.dims,T);return`
  @group(0) @binding(0) var<storage, read> input : array<${q}>;
  @group(0) @binding(1) var<storage, read> scale : array<${lt.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${Mt.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${q}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${dt.mainStart()}
    ${dt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${jr("f32",T)};
    var squaredSum = ${jr("f32",T)};
    for (var i: u32 = 0; i < min(${E}, uniforms.H); i++) {
        let value = input[offset + i + currentChannelNumber * ${E}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${b}));
    let channelScale = invStdDev * ${H}(scale[currentChannelNumber]);
    let channelShift = ${H}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${w("channelScale","channelShift")};
  }`};return r.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${T};${b}`,inputDependencies:Se},getRunData:()=>({outputs:[{dims:[d,c,2],dataType:1}],dispatchGroup:{x:Math.ceil(Z/64)},programUniforms:Fe}),getShaderSource:ze},{inputs:[me,s,u],outputs:[-1]})[0]},df=(r,i,s)=>{let u=i[0].dims,d=u,p=u[0],c=u[u.length-1],b=Ze.sizeFromDimension(u,1)/c,T=Ar(c),E=Ze.size(d)/T,q=[{type:12,data:b},{type:12,data:Math.floor(c/T)}],H=["type","type"],w=cf(r,i[0],i[1],i[2],p,b,c,s.epsilon),Z=re=>{let le=zr(i[0].dataType),_e=T===1?"vec2f":`mat2x${T}f`,be=T===1?le:`vec${T}<${le}>`,me=gt("input",i[0].dataType,i[0].dims,T),Fe=qt("output",i[0].dataType,d,T);return`
  @group(0) @binding(0) var<storage, read> input : array<${me.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${_e}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${Fe.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${re.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${be}(scale[0]), ${be}(scale[1]));
  }`};r.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${T}`,inputDependencies:H},getRunData:()=>({outputs:[{dims:d,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(E/64)},programUniforms:q}),getShaderSource:Z},{inputs:[i[0],w]})},ff=(r,i)=>{i.format==="NHWC"?df(r,r.inputs,i):r.compute(uf(r.inputs,i))}}),pf,hf,mf,zm=m(()=>{Zt(),Jt(),dr(),pf=r=>{if(!r||r.length<2)throw new Error("layerNorm requires at least 2 inputs.")},hf=(r,i,s)=>{let u=i.simplified,d=r[0].dims,p=r[1],c=!u&&r[2],b=d,T=Ze.normalizeAxis(i.axis,d.length),E=Ze.sizeToDimension(d,T),q=Ze.sizeFromDimension(d,T),H=Ze.size(p.dims),w=c?Ze.size(c.dims):0;if(H!==q||c&&w!==q)throw new Error(`Size of X.shape()[axis:] == ${q}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${H} and bias size of ${w}`);let Z=[];for(let ze=0;ze<d.length;++ze)ze<T?Z.push(d[ze]):Z.push(1);let re=Ar(q),le=["type","type"],_e=[{type:12,data:E},{type:1,data:q},{type:12,data:Math.floor(q/re)},{type:1,data:i.epsilon}];c&&le.push("type");let be=s>1,me=s>2,Fe=ze=>{let dt=zr(r[0].dataType),lt=[gt("x",r[0].dataType,r[0].dims,re),gt("scale",p.dataType,p.dims,re)];c&&lt.push(gt("bias",c.dataType,c.dims,re)),lt.push(qt("output",r[0].dataType,b,re)),be&&lt.push(qt("mean_data_output",1,Z)),me&&lt.push(qt("inv_std_output",1,Z));let Mt=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${ze.registerUniforms(Mt).declareVariables(...lt)}
  ${ze.mainStart()}
    ${ze.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${jr("f32",re)};
    var mean_square_vector = ${jr("f32",re)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Zr(dt,re,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Qn("mean_vector",re)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Qn("mean_square_vector",re)} / uniforms.norm_size ${u?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Zr(dt,re,"x[j + offset]")};
      let f32scale = ${Zr(dt,re,"scale[j]")};
      output[j + offset] = ${lt[0].type.value}((f32input ${u?"":"- mean"}) * inv_std_dev * f32scale
        ${c?`+ ${Zr(dt,re,"bias[j]")}`:""}
      );
    }

    ${be?"mean_data_output[global_idx] = mean":""};
    ${me?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},Se=[{dims:b,dataType:r[0].dataType}];return be&&Se.push({dims:Z,dataType:1}),me&&Se.push({dims:Z,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${re};${s};${u}`,inputDependencies:le},getRunData:()=>({outputs:Se,dispatchGroup:{x:Math.ceil(E/64)},programUniforms:_e}),getShaderSource:Fe}},mf=(r,i)=>{pf(r.inputs),r.compute(hf(r.inputs,i,r.outputCount))}}),mr,gf,yn,bn,Fn=m(()=>{Zt(),Jt(),vr(),dr(),mr=(r,i)=>{if(r.length<3||r.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let s=r[0],u=s.dims.length;if(s.dims[u-1]!==i.k)throw new Error("The last dim of input shape does not match the k value");let d=Math.floor((i.k+i.blockSize-1)/i.blockSize),p=i.blockSize/8*i.bits,c=r[1];if(!Ze.areEqual(c.dims,[i.n,d,p]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let b=r[2].dims;if(Ze.size(b)!==i.n*d)throw new Error("scales input size error.");if(r.length===4){let T=r[3].dims,E=i.bits>4?i.n*d:i.n*Math.floor((d+1)/2);if(Ze.size(T)!==E)throw new Error("zeroPoints input size error.")}},gf=(r,i)=>{let s=r[0].dims,u=s.length,d=s[u-2],p=i.k,c=i.n,b=s.slice(0,u-2),T=Ze.size(b),E=r[1].dims[2]/4,q=r[0].dataType,H=Ar(i.k),w=Ar(E),Z=Ar(c),re=b.concat([d,c]),le=d>1&&c/Z%2===0?2:1,_e=Ze.size(re)/Z/le,be=64,me=[],Fe=[T,d,p/H],Se=Ze.convertShape(r[1].dims).slice();Se.splice(-1,1,E/w),me.push(...zt(Fe)),me.push(...zt(Se)),me.push(...zt(r[2].dims)),r.length===4&&me.push(...zt(Ze.convertShape(r[3].dims)));let ze=[T,d,c/Z];me.push(...zt(ze));let dt=lt=>{let Mt=Fe.length,Dt=gt("a",r[0].dataType,Mt,H),Vt=gt("b",12,Se.length,w),hr=gt("scales",r[2].dataType,r[2].dims.length),xr=[Dt,Vt,hr],nr=r.length===4?gt("zero_points",12,r[3].dims.length):void 0;nr&&xr.push(nr);let Wr=ze.length,Jr=qt("output",r[0].dataType,Wr,Z),Er=zr(r[0].dataType),Hr=(()=>{switch(H){case 1:return`array<${Er}, 8>`;case 2:return`mat4x2<${Er}>`;case 4:return`mat2x4<${Er}>`;default:throw new Error(`${H}-component is not supported.`)}})(),rr=()=>{let ut=`
          // reuse a data
            var input_offset = ${Dt.indicesToOffset(`${Dt.type.indices}(batch, row, word_offset)`)};
            var a_data: ${Hr};
            for (var j: u32 = 0; j < ${8/H}; j++) {
              a_data[j] = ${Dt.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let At=0;At<Z*le;At++)ut+=`
            b_value = ${w===1?`b${At}_data`:`b${At}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${Hr}(${Array.from({length:4},(ar,Gr)=>`${Er}(b_value_lower[${Gr}]), ${Er}(b_value_upper[${Gr}])`).join(", ")});
            b_dequantized_values = ${H===1?`${Hr}(${Array.from({length:8},(ar,Gr)=>`(b_quantized_values[${Gr}] - ${nr?`zero_point${At}`:"zero_point"}) * scale${At}`).join(", ")});`:`(b_quantized_values - ${Hr}(${Array(8).fill(`${nr?`zero_point${At}`:"zero_point"}`).join(",")})) * scale${At};`};
            workgroup_shared[local_id.x * ${le} + ${Math.floor(At/Z)}]${Z>1?`[${At%Z}]`:""} += ${Array.from({length:8/H},(ar,Gr)=>`${H===1?`a_data[${Gr}] * b_dequantized_values[${Gr}]`:`dot(a_data[${Gr}], b_dequantized_values[${Gr}])`}`).join(" + ")};
          `;return ut},wr=()=>{let ut=`
            var col_index = col * ${Z};
            ${nr?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Er}(8);`}
            `;for(let At=0;At<Z*le;At++)ut+=`
            let scale${At} = ${hr.getByOffset("col_index * nBlocksPerCol + block")};
            ${nr?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${nr.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${At} = ${Er}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return ut},Or=()=>{let ut=`col_index = col * ${Z};`;for(let At=0;At<Z*le;At++)ut+=`
            let b${At}_data = ${Vt.getByIndices(`${Vt.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return ut+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${Hr};
            var b_dequantized_values: ${Hr};`,ut};return`
        var<workgroup> workgroup_shared: array<${Jr.type.value}, ${le*be}>;
        ${lt.declareVariables(...xr,Jr)}
        ${lt.mainStart([be,1,1])}
          let output_indices = ${Jr.offsetToIndices(`(global_idx / ${be}) * ${le}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${be}) {
            //process one block
            var word_offset: u32 = block * ${i.blockSize/H};
            ${wr()}
            for (var word: u32 = 0; word < ${E}; word += ${w}) {
              ${Or()}
              for (var i: u32 = 0; i < ${w}; i++) {
                ${rr()}
                word_offset += ${8/H};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${le}) {
            var output_value: ${Jr.type.value} = ${Jr.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${be}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${le};
            }
            ${Jr.setByIndices(`${Jr.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${i.blockSize};${i.bits};${H};${w};${Z};${le};${be}`,inputDependencies:Array(r.length).fill("rank")},getRunData:()=>({outputs:[{dims:re,dataType:q}],dispatchGroup:{x:_e},programUniforms:me}),getShaderSource:dt}},yn=(r,i)=>{mr(r.inputs,i),r.compute(gf(r.inputs,i))},bn=r=>Xt(r)}),oo,Wp,_f,yf,U,G,ie,Te,Je,at=m(()=>{Zt(),Jt(),dr(),oo=r=>{if(!r||r.length<1)throw new Error("Too few inputs");if(r[0].dataType!==1&&r[0].dataType!==10)throw new Error("Input type must be float or float16.");if(r.length>=2){let i=r[0].dims.length*2===r[1].dims[0];if(r.length===4&&(i=r[3].dims[0]*2===r[1].dims[0]),!i)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Wp=(r,i,s)=>{let u="";for(let d=i-1;d>=0;--d)u+=`
            k = i32(${r.indicesGet("indices",d)}) - ${jt("uniforms.pads",d,s)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${jt("uniforms.x_shape",d,i)})) {
              break;
            }
            offset += k * i32(${jt("uniforms.x_strides",d,i)});
        `;return`
          value = ${r.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${u}
            value = x[offset];
          }
      `},_f=(r,i,s)=>{let u="";for(let d=i-1;d>=0;--d)u+=`
                k = i32(${r.indicesGet("indices",d)}) - ${jt("uniforms.pads",d,s)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${jt("uniforms.x_shape",d,i)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${jt("uniforms.x_shape",d,i)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${jt("uniforms.x_strides",d,i)});
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},yf=(r,i,s)=>{let u="";for(let d=i-1;d>=0;--d)u+=`
                k = i32(${r.indicesGet("indices",d)}) - ${jt("uniforms.pads",d,s)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${jt("uniforms.x_shape",d,i)})) {
                  k = i32(${jt("uniforms.x_shape",d,i)}) - 1;
                }
                offset += k * i32(${jt("uniforms.x_strides",d,i)});
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},U=(r,i,s)=>{let u="";for(let d=i-1;d>=0;--d)u+=`
                k = i32(${r.indicesGet("indices",d)}) - ${jt("uniforms.pads",d,s)};
                if (k < 0)  {
                  k += i32(${jt("uniforms.x_shape",d,i)}]);
                }
                if (k >= i32(${jt("uniforms.x_shape",d,i)})) {
                  k -= i32(${jt("uniforms.x_shape",d,i)});
                }
                offset += k * i32(${jt("uniforms.x_strides",d,i)});
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},G=(r,i,s)=>{switch(s.mode){case 0:return Wp(r,i,s.pads.length);case 1:return _f(r,i,s.pads.length);case 2:return yf(r,i,s.pads.length);case 3:return U(r,i,s.pads.length);default:throw new Error("Invalid mode")}},ie=(r,i)=>{let s=Ze.padShape(r[0].dims.slice(),i.pads),u=r[0].dims,d=Ze.size(s),p=[{type:12,data:d},{type:6,data:i.pads}],c=r.length>=3&&r[2].data;i.mode===0&&p.push({type:c?r[2].dataType:1,data:i.value}),p.push(...zt(r[0].dims,s));let b=["rank"],T=E=>{let q=qt("output",r[0].dataType,s.length),H=gt("x",r[0].dataType,u.length),w=H.type.value,Z=G(q,u.length,i),re=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:i.pads.length}];return i.mode===0&&re.push({name:"constant_value",type:c?w:"f32"}),`
            ${E.registerUniforms(re).declareVariables(H,q)}
            ${E.mainStart()}
            ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${q.offsetToIndices("global_idx")};

            var value = ${w}(0);
            ${Z}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${i.mode}${c}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:s,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(Ze.size(s)/64)},programUniforms:p}),getShaderSource:T}},Te=(r,i)=>{if(r.length>1){let s=r[1].getBigInt64Array(),u=r.length>=3&&r[2].data?r[2].dataType===10?r[2].getUint16Array()[0]:r[2].getFloat32Array()[0]:0,d=r[0].dims.length,p=new Int32Array(2*d).fill(0);if(r.length>=4){let b=r[3].getBigInt64Array();for(let T=0;T<b.length;T++)p[Number(b[T])]=Number(s[T]),p[Number(b[T])+d]=Number(s[T+b.length])}else s.forEach((b,T)=>p[Number(T)]=Number(b));let c=[];return p.forEach(b=>c.push(b)),{mode:i.mode,value:u,pads:c}}else return i},Je=(r,i)=>{oo(r.inputs);let s=Te(r.inputs,i);r.compute(ie(r.inputs,s),{inputs:[0]})}}),_t,It,Kt,pr,_r,Br,yr,Mr,gr,br,Sr,Vr,Nn,jn,xi,zn,mn,En,Ll,Bl=m(()=>{bt(),Zt(),Jt(),dr(),_t=r=>{if(N.webgpu.validateInputContent&&(!r||r.length!==1))throw new Error("Pool ops requires 1 input.")},It=(r,i,s)=>{let u=i.format==="NHWC",d=r.dims.slice();u&&d.splice(1,0,d.pop());let p=Object.hasOwnProperty.call(i,"dilations"),c=i.kernelShape.slice(),b=i.strides.slice(),T=p?i.dilations.slice():[],E=i.pads.slice();ei.adjustPoolAttributes(s,d,c,b,T,E);let q=ei.computePoolOutputShape(s,d,b,T,c,E,i.autoPad),H=Object.assign({},i);p?Object.assign(H,{kernelShape:c,strides:b,pads:E,dilations:T,cacheKey:i.cacheKey}):Object.assign(H,{kernelShape:c,strides:b,pads:E,cacheKey:i.cacheKey});let w=q.slice();return w.push(w.splice(1,1)[0]),[H,u?w:q]},Kt=(r,i)=>{let s=i.format==="NHWC",u=Ze.size(r),d=Ze.size(i.kernelShape),p=[{type:12,data:u},{type:12,data:d}],c=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(i.kernelShape.length<=2){let b=i.kernelShape[i.kernelShape.length-1],T=i.strides[i.strides.length-1],E=i.pads[i.pads.length/2-1],q=i.pads[i.pads.length-1],H=!!(E+q);p.push({type:12,data:b},{type:12,data:T},{type:12,data:E},{type:12,data:q}),c.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let w=!1;if(i.kernelShape.length===2){let Z=i.kernelShape[i.kernelShape.length-2],re=i.strides[i.strides.length-2],le=i.pads[i.pads.length/2-2],_e=i.pads[i.pads.length-2];w=!!(le+_e),p.push({type:12,data:Z},{type:12,data:re},{type:12,data:le},{type:12,data:_e}),c.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[p,c,!0,H,w]}else{if(s)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let b=Ze.computeStrides(i.kernelShape);p.push({type:12,data:b},{type:12,data:i.pads},{type:12,data:i.strides}),c.push({name:"kernelStrides",type:"u32",length:b.length},{name:"pads",type:"u32",length:i.pads.length},{name:"strides",type:"u32",length:i.strides.length});let T=i.pads.reduce((E,q)=>E+q);return[p,c,!!T,!1,!1]}},pr=(r,i,s,u,d,p,c,b,T,E,q,H)=>{let w=d.format==="NHWC",Z=i.type.value,re=qt("output",i.type.tensor,u);if(d.kernelShape.length<=2){let le="",_e="",be="",me=s-(w?2:1);if(q?le=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${me}] = indices[${me}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${me}] < 0 || xIndices[${me}]
                      >= uniforms.x_shape[${me}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${i.indicesToOffset("xIndices")}];
                  ${p}
                }`:le=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${me}] = indices[${me}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${i.indicesToOffset("xIndices")}];
                  ${p}
                }`,d.kernelShape.length===2){let Fe=s-(w?3:2);H?_e=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${Fe}] = indices[${Fe}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${Fe}] < 0 || xIndices[${Fe}] >= uniforms.x_shape[${Fe}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:_e=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${Fe}] = indices[${Fe}] * uniforms.sh - uniforms.phStart + j;
                `,be=`
              }
            `}return`
            ${r.registerUniforms(T).declareVariables(i,re)}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${re.offsetToIndices("global_idx")};
              var xIndices = ${re.offsetToIndices("global_idx")};

              var value = ${Z}(${b});
              var pad = 0;
              ${_e}
              ${le}
              ${be}
              ${c}

              output[global_idx] = value;
            }`}else{if(w)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let le=d.kernelShape.length,_e=d.pads.length,be="";return E?be=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${i.indicesToOffset("xIndices")}];
                ${p}
              }`:be=`
              }
              let x_val = x[${i.indicesToOffset("xIndices")}];
              ${p}
            `,`
            ${r.registerUniforms(T).declareVariables(i,re)}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${re.offsetToIndices("global_idx")};
              var xIndices = ${re.offsetToIndices("global_idx")};

              var offsets: array<u32, ${le}>;

              var value = ${Z}(${b});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${le-1}u; j++) {
                  offsets[j] = offset / ${jt("uniforms.kernelStrides","j",le)};
                  offset -= offsets[j] * ${jt("uniforms.kernelStrides","j",le)};
                }
                offsets[${le-1}] = offset;

                isPad = false;
                for (var j = ${s-le}u; j < ${s}u; j++) {
                  xIndices[j] = indices[j] * ${jt("uniforms.strides",`j - ${s-le}u`,le)}
                    + offsets[j - ${s-le}u] - ${jt("uniforms.pads","j - 2u",_e)};
                  ${be}
              }
              ${c}

              output[global_idx] = value;
            }`}},_r=r=>`${r.format};${r.ceilMode};${r.autoPad};${r.kernelShape.length}`,Br=r=>`${_r(r)};${r.countIncludePad}`,yr=r=>`${_r(r)};${r.storageOrder};${r.dilations}`,Mr=r=>({format:r.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][r.auto_pad],ceilMode:r.ceil_mode,kernelShape:r.kernel_shape,strides:r.strides,pads:r.pads}),gr=(r,i,s,u)=>{let[d,p]=It(i,u,s),c=gt("x",i.dataType,i.dims.length),b=c.type.value,T="value += x_val;",E="";d.countIncludePad?E+=`value /= ${b}(uniforms.kernelSize);`:E+=`value /= ${b}(i32(uniforms.kernelSize) - pad);`;let[q,H,w,Z,re]=Kt(p,d);q.push(...zt(i.dims,p));let le=["rank"];return{name:r,shaderCache:{hint:`${u.cacheKey};${w};${Z};${re}`,inputDependencies:le},getRunData:()=>({outputs:[{dims:p,dataType:i.dataType}],dispatchGroup:{x:Math.ceil(Ze.size(p)/64)},programUniforms:q}),getShaderSource:_e=>pr(_e,c,i.dims.length,p.length,d,T,E,0,H,w,Z,re)}},br=r=>{let i=r.count_include_pad!==0,s=Mr(r);if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let u={countIncludePad:i,...s,cacheKey:""};return{...u,cacheKey:Br(u)}},Sr=(r,i)=>{_t(r.inputs),r.compute(gr("AveragePool",r.inputs[0],!1,i))},Vr={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Nn=r=>{let i=r.format;return{format:i,...Vr,cacheKey:i}},jn=(r,i)=>{_t(r.inputs),r.compute(gr("GlobalAveragePool",r.inputs[0],!0,i))},xi=(r,i,s,u)=>{let[d,p]=It(i,u,s),c=`
      value = max(x_val, value);
    `,b="",T=gt("x",i.dataType,i.dims.length),E=["rank"],[q,H,w,Z,re]=Kt(p,d);return q.push(...zt(i.dims,p)),{name:r,shaderCache:{hint:`${u.cacheKey};${w};${Z};${re}`,inputDependencies:E},getRunData:()=>({outputs:[{dims:p,dataType:i.dataType}],dispatchGroup:{x:Math.ceil(Ze.size(p)/64)},programUniforms:q}),getShaderSource:le=>pr(le,T,i.dims.length,p.length,d,c,b,i.dataType===10?-65504:-1e5,H,w,Z,re)}},zn=(r,i)=>{_t(r.inputs),r.compute(xi("MaxPool",r.inputs[0],!1,i))},mn=r=>{let i=r.storage_order,s=r.dilations,u=Mr(r);if(i!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(u.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let d={storageOrder:i,dilations:s,...u,cacheKey:""};return{...d,cacheKey:yr(d)}},En=r=>{let i=r.format;return{format:i,...Vr,cacheKey:i}},Ll=(r,i)=>{_t(r.inputs),r.compute(xi("GlobalMaxPool",r.inputs[0],!0,i))}}),Rl,Om,Mi,Eo,Dm=m(()=>{Zt(),Jt(),vr(),dr(),Rl=(r,i)=>{if(r.length<2||r.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(r.length===3&&r[1].dims===r[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(r.length===3&&r[0].dataType!==r[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(r[0].dataType===6&&r.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(r[1].dims.length!==0&&r[1].dims.length!==1&&r[1].dims.length!==r[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(r.length>2){if(r[0].dataType!==r[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(r[1].dims.length!==r[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!r[1].dims.map((s,u)=>s===r[2].dims[u]).reduce((s,u)=>s&&u,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(i.blockSize>0){if(r[1].dims.length===0||r[1].dims.length===1&&r[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!r[1].dims.map((d,p)=>p===i.axis||d===r[0].dims[p]).reduce((d,p)=>d&&p,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(r[1].dims.length!==r[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let s=r[0].dims[i.axis],u=r[1].dims[i.axis];if(i.blockSize<Math.ceil(s/u)||i.blockSize>Math.ceil(s/(u-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},Om=(r,i)=>{let s=Ze.normalizeAxis(i.axis,r[0].dims.length),u=r[0].dataType,d=u===3,p=r[0].dims,c=r[1].dataType,b=Ze.size(p),T=u===3||u===2,E=T?[Math.ceil(Ze.size(r[0].dims)/4)]:r[0].dims,q=r[1].dims,H=r.length>2?r[2]:void 0,w=H?T?[Math.ceil(Ze.size(H.dims)/4)]:H.dims:void 0,Z=q.length===0||q.length===1&&q[0]===1,re=Z===!1&&q.length===1,le=Ar(b),_e=Z&&(!T||le===4),be=_e?le:1,me=_e&&!T?le:1,Fe=gt("input",T?12:u,E.length,me),Se=gt("scale",c,q.length),ze=H?gt("zero_point",T?12:u,w.length):void 0,dt=qt("output",c,p.length,be),lt=[Fe,Se];ze&&lt.push(ze);let Mt=[E,q];H&&Mt.push(w);let Dt=[{type:12,data:b/be},{type:12,data:s},{type:12,data:i.blockSize},...zt(...Mt,p)],Vt=hr=>{let xr=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${hr.registerUniforms(xr).declareVariables(...lt,dt)}
      ${hr.mainStart()}
          ${hr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${dt.offsetToIndices("global_idx")};

          // Set input x
          ${T?`
            let input = ${Fe.getByOffset("global_idx / 4")};
            let x_vec = ${d?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${be===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${Fe.getByOffset("global_idx")};`};

          // Set scale input
          ${Z?`let scale_value= ${Se.getByOffset("0")}`:re?`
            let scale_index = ${dt.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${Se.getByOffset("scale_index")};`:`
            var scale_indices: ${Se.type.indices} = output_indices;
            let index = ${Se.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${Se.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${Se.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${ze?Z?T?`
                let zero_point_input = ${ze.getByOffset("0")};
                let zero_point_vec =  ${d?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${ze.getByOffset("0")}`:re?T?`
                let zero_point_index = ${dt.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${ze.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${d?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${dt.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${ze.getByOffset("zero_point_index")};`:T?`
                let zero_point_offset = ${Se.indicesToOffset("scale_indices")};
                let zero_point_input = ${ze.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${d?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${ze.getByIndices("scale_indices")};`:`let zero_point_value = ${T?d?"i32":"u32":Fe.type.value}(0);`};
      // Compute and write output
      ${dt.setByOffset("global_idx",`${dt.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:i.cacheKey,inputDependencies:ze?["rank","rank","rank"]:["rank","rank"]},getShaderSource:Vt,getRunData:()=>({outputs:[{dims:p,dataType:c}],dispatchGroup:{x:Math.ceil(b/be/64),y:1,z:1},programUniforms:Dt})}},Mi=(r,i)=>{Rl(r.inputs,i),r.compute(Om(r.inputs,i))},Eo=r=>Xt({axis:r.axis,blockSize:r.blockSize})}),Gp,Hp,wf,Mx=m(()=>{bt(),Zt(),dr(),Gp=(r,i,s)=>{let u=r===i,d=r<i&&s<0,p=r>i&&s>0;if(u||d||p)throw new Error("Range these inputs' contents are invalid.")},Hp=(r,i,s,u)=>{let d=Math.abs(Math.ceil((i-r)/s)),p=[d],c=d,b=[{type:12,data:c},{type:u,data:r},{type:u,data:s},...zt(p)],T=E=>{let q=qt("output",u,p.length),H=q.type.value,w=[{name:"outputSize",type:"u32"},{name:"start",type:H},{name:"delta",type:H}];return`
        ${E.registerUniforms(w).declareVariables(q)}
        ${E.mainStart()}
        ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${H}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${u}`},getShaderSource:T,getRunData:()=>({outputs:[{dims:p,dataType:u}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:b})}},wf=r=>{let i=0,s=0,u=0;r.inputs[0].dataType===6?(i=r.inputs[0].getInt32Array()[0],s=r.inputs[1].getInt32Array()[0],u=r.inputs[2].getInt32Array()[0]):r.inputs[0].dataType===1&&(i=r.inputs[0].getFloat32Array()[0],s=r.inputs[1].getFloat32Array()[0],u=r.inputs[2].getFloat32Array()[0]),N.webgpu.validateInputContent&&Gp(i,s,u),r.compute(Hp(i,s,u,r.inputs[0].dataType),{inputs:[]})}}),N0,j0,U0,V0,W0,G0,H0,q0,K0,Q0,X0,Lm,Y0,Z0,J0,ey,ty,ry,ny,kx=m(()=>{Zt(),Jt(),vr(),dr(),N0=(r,i)=>{if(r.every(s=>s>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),r.length>0){if(i.mode==="linear"){if(!(r.length===2||r.length===3||r.length===4&&r[0]===1&&r[1]===1||r.length===4&&r[0]===1&&r[3]===1||r.length===5&&r[0]===1&&r[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(i.mode==="cubic"&&!(r.length===2||r.length===4&&r[0]===1&&r[1]===1||r.length===4&&r[0]===1&&r[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},j0=(r,i,s)=>{i.every(d=>d>=0&&d<s||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let u=new Array(s).fill(1);return i.forEach((d,p)=>u[d]=r[p]),u},U0=(r,i,s,u,d,p)=>{let[c,b,T]=s>10?[1,2,3]:[-1,r.length>1?1:-1,-1],E=r[0].dims.length;if(c>0&&r.length>c&&r[c].dims.length>0)r[c].getFloat32Array().forEach(q=>p.push(q));else if(i.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(b>0&&r.length>b&&r[b].dims.length>0){if(r[b].getFloat32Array().forEach(q=>u.push(q)),u.length!==0&&u.length!==E&&s>=18&&u.length!==i.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");N0(u,i),i.axes.length>0&&j0(u,i.axes,E).forEach((q,H)=>u[H]=q)}if(T>0&&r.length>T&&(r[T].getBigInt64Array().forEach(q=>d.push(Number(q))),d.length!==E||s>=18&&d.length===i.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(i.axes.length>0){if(u.length!==i.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(d.length!==i.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof u<"u"&&typeof d<"u"&&u.length>0&&d.length>E)throw new Error("Resize requires only of scales or sizes to be specified")},V0=(r,i)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${i} { `+(()=>{switch(r){case"asymmetric":return`return ${i}(xResized) / ${i}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${i}(xResized) + 0.5) / ${i}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${i}(xResized) + 0.5) / ${i}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${i}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${i}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${i}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${i}(roiStart) * ${i}(lengthOriginal - 1) +
                        (${i}(xResized) * ${i}(roiEnd - roiStart) * ${i}(lengthOriginal - 1)) /
                        ${i}(lengthResized - 1);
                  } else {
                    return 0.5 * ${i}(roiStart + roiEnd) * ${i}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${i}xScale * ${i}(lengthResized);
                  const adjustment = ${i}(lengthResized) / outputWidth;
                  const center = ${i}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${i}(xResized) + 0.5) / ${i}(xScale)) - 0.5;`;case"half_pixel":return`return ((${i}(xResized) + 0.5) / ${i}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${r} is not supported`)}})()+"}",W0=(r,i,s)=>`fn getNearestPixelFromOriginal(xOriginal: ${s}, isDownSample: bool) -> ${s} {`+(()=>{switch(r){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(i<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${r} is not supported`)}})()+"}",G0=(r,i,s)=>{let u=new Array(s).fill(0).concat(new Array(s).fill(1)),d=r.length===0?u:r.slice();return i.length>0?(i.forEach((p,c)=>{u[p]=d[c],u[c+s]=d[i.length+c]}),u):d},H0=(r,i,s,u)=>{let d=[];if(s.length>0)if(u.length>0){if(r.forEach(p=>d.push(p)),Math.max(...u)>r.length)throw new Error("axes is out of bound");u.forEach((p,c)=>d[p]=s[c])}else s.forEach(p=>d.push(p));else{if(i.length===0)throw new Error("Resize requires either scales or sizes.");d=r.map((p,c)=>Math.round(p*i[c]))}return d},q0=(r,i,s)=>{let u=(()=>{switch(s.keepAspectRatioPolicy){case"not_larger":return s.axes.length>0?Math.min(...s.axes.map(p=>i[p]),Number.MAX_VALUE):Math.min(...i,Number.MAX_VALUE);case"not_smaller":return s.axes.length>0?Math.max(...s.axes.map(p=>i[p]),Number.MIN_VALUE):Math.max(...i,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${s.keepAspectRatioPolicy} is not supported`)}})();i.fill(1,0,i.length);let d=r.slice();return s.axes.length>0?(s.axes.forEach(p=>i[p]=u),s.axes.forEach(p=>d[p]=Math.round(r[p]*i[p]))):(i.fill(u,0,i.length),d.forEach((p,c)=>d[c]=Math.round(p*i[c]))),d},K0=(r,i,s,u,d)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${r.type.indices}) -> array<${r.type.value}, ${s.length}> {
      var original_indices: array<${r.type.value}, ${s.length}>;
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${r.indicesGet("output_indices","i")};
        var scale = ${jt("uniforms.scales","i",u)};
        var roi_low = ${jt("uniforms.roi","i",d)};
        var roi_hi = ${jt("uniforms.roi",`i + ${i.length}`,d)};
        if (scale == 1.0) {
          original_indices[i] = ${r.type.value}(output_index);
        } else {
          var input_shape_i = ${jt("uniforms.input_shape","i",i.length)};
          var output_shape_i = ${jt("uniforms.output_shape","i",s.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,Q0=(r,i,s,u,d,p,c)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${i.type.indices}) -> ${r.type.indices} {
      var input_indices: ${r.type.indices};
      for (var i:u32 = 0; i < ${u.length}; i++) {
        var output_index = ${i.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${jt("uniforms.scales","i",d)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${jt("uniforms.roi","i",p)};
          var roi_hi = ${jt("uniforms.roi",`i + ${s.length}`,p)};
          var input_shape_i = ${jt("uniforms.input_shape","i",s.length)};
          var output_shape_i = ${jt("uniforms.output_shape","i",u.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${c} || (original_idx >= 0 && original_idx < ${i.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${i.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${r.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,X0=(r,i)=>`
    fn checkInputIndices(input_indices: ${r.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${i.length}; i++) {
        var input_index = ${r.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${jt("uniforms.input_shape","i",i.length)}) {
          return false;
        }
      }
      return true;
    }`,Lm=(r,i,s,u)=>r.rank>u?`
    ${r.indicesSet("input_indices",i,"channel")};
    ${r.indicesSet("input_indices",s,"batch")};
`:"",Y0=(r,i,s,u,d)=>{let[p,c,b,T]=s.length===2?[-1,0,1,-1]:[0,2,3,1],E=r.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${E} {
      var input_indices: ${r.type.indices};
      ${r.indicesSet("input_indices",c,`max(0, min(row, ${s[c]} - 1))`)};
      ${r.indicesSet("input_indices",b,`max(0, min(col, ${s[b]} - 1))`)};
      ${Lm(r,T,p,2)}
      return ${r.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${i.type.indices}) -> ${E} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${E} = originalIndices[${c}];
      var col:${E} = originalIndices[${b}];
      ${u?`if (row < 0 || row > (${s[c]} - 1) || col < 0 || col > (${s[b]} - 1)) {
        return ${d};
      }`:""};
      row = max(0, min(row, ${s[c]} - 1));
      col = max(0, min(col, ${s[b]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${s.length>2?`u32(originalIndices[${T}])`:"0"};
      var batch: u32 =  ${s.length>2?`u32(originalIndices[${p}])`:"0"};
      var x11: ${E} = getInputValue(batch, channel, row1, col1);
      var x12: ${E} = getInputValue(batch, channel, row1, col2);
      var x21: ${E} = getInputValue(batch, channel, row2, col1);
      var x22: ${E} = getInputValue(batch, channel, row2, col2);
      var dx1: ${E} = abs(row - ${E}(row1));
      var dx2: ${E} = abs(${E}(row2) - row);
      var dy1: ${E} = abs(col - ${E}(col1));
      var dy2: ${E} = abs(${E}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Z0=(r,i,s,u,d,p,c,b,T,E)=>{let q=s.length===2,[H,w]=q?[0,1]:[2,3],Z=r.type.value,re=le=>{let _e=le===H?"row":"col";return`
      fn ${_e}CubicInterpolation(input_indices: ${r.type.indices}, output_indices: ${i.type.indices}) -> ${Z} {
        var output_index = ${i.indicesGet("output_indices",le)};
        var originalIdx: ${Z} = getOriginalCoordinateFromResizedCoordinate(output_index, ${d[le]},
        ${u[le]}, ${s[le]}, ${p[le]}, ${p[le]} + ${s.length});
        var fractOriginalIdx: ${Z} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${b} && (originalIdx < 0 || originalIdx > (${s[le]} - 1))) {
          return ${T};
        }
        var data: array<${Z}, 4> = array<${Z}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${_e}: ${Z} = originalIdx + ${Z}(i);
          if (${_e} < 0 || ${_e} >= ${s[le]}) {
            ${E?`coefs[i + 1] = 0.0;
                        continue;`:b?`return ${T};`:`${_e} = max(0, min(${_e}, ${s[le]} - 1));`};
          }
        var input_indices_copy: ${r.type.indices} = input_indices;
          ${r.indicesSet("input_indices_copy",le,`u32(${_e})`)};
          data[i + 1] = ${le===H?r.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${re(H)};
    ${re(w)};
  fn getCubicInterpolationCoefs(s: ${Z}) -> array<${Z}, 4> {
    var absS = abs(s);
    var coeffs: array<${Z}, 4> = array<${Z}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${Z} = 1.0 - absS;
    var twoMinusAbsS: ${Z} = 2.0 - absS;
    var onePlusAbsS: ${Z} = 1.0 + absS;
    coeffs[0] = ((${c} * onePlusAbsS - 5 * ${c}) * onePlusAbsS + 8 * ${c}) * onePlusAbsS - 4 * ${c};
    coeffs[1] = ((${c} + 2) * absS - (${c} + 3)) * absS * absS + 1;
    coeffs[2] = ((${c} + 2) * oneMinusAbsS - (${c} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${c} * twoMinusAbsS - 5 * ${c}) * twoMinusAbsS + 8 * ${c}) * twoMinusAbsS - 4 * ${c};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${Z}, 4>, coefs: array<${Z}, 4>) -> ${Z} {
    var coefsSum: ${Z} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${i.type.indices}) -> ${Z} {
    var input_indices: ${r.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},J0=(r,i,s,u,d)=>{let[p,c,b,T,E]=s.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],q=r.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${q} {
      var input_indices: ${r.type.indices};
      ${r.indicesSet("input_indices",c,`max(0, min(depth, ${s[c]} - 1))`)};
      ${r.indicesSet("input_indices",b,`max(0, min(height, ${s[b]} - 1))`)};
      ${r.indicesSet("input_indices",T,`max(0, min(width, ${s[T]} - 1))`)};
      ${Lm(r,E,p,3)}
      return ${r.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${i.type.indices}) -> ${q} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${q} = originalIndices[${c}];
      var height:${q} = originalIndices[${b}];
      var width:${q} = originalIndices[${T}];
      ${u?`if (depth < 0 || depth > (${s[c]} - 1) || height < 0 || height > (${s[b]} - 1) || width < 0 || (width > ${s[T]} - 1)) {
      return ${d};
        }`:""};

    depth = max(0, min(depth, ${s[c]} - 1));
      height = max(0, min(height, ${s[b]} - 1));
      width = max(0, min(width, ${s[T]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${s.length>3?`u32(originalIndices[${E}])`:"0"};
      var batch: u32 =  ${s.length>3?`u32(originalIndices[${p}])`:"0"};

      var x111: ${q} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${q} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${q} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${q} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${q} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${q} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${q} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${q} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${q} = abs(depth - ${q}(depth1));
      var dx2: ${q} = abs(${q}(depth2) - depth);
      var dy1: ${q} = abs(height - ${q}(height1));
      var dy2: ${q} = abs(${q}(height2) - height);
      var dz1: ${q} = abs(width - ${q}(width1));
      var dz2: ${q} = abs(${q}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},ey=(r,i,s,u,d,p)=>{let c=r.dims,b=G0(p,i.axes,c.length),T=H0(c,u,d,i.axes),E=u.slice();u.length===0&&(E=c.map((me,Fe)=>me===0?1:T[Fe]/me),i.keepAspectRatioPolicy!=="stretch"&&(T=q0(c,E,i)));let q=qt("output",r.dataType,T.length),H=gt("input",r.dataType,c.length),w=Ze.size(T),Z=c.length===T.length&&c.every((me,Fe)=>me===T[Fe]),re=i.coordinateTransformMode==="tf_crop_and_resize",le=i.extrapolationValue,_e=H.type.value,be=me=>`
      ${Z?"":`
      ${V0(i.coordinateTransformMode,_e)};
      ${(()=>{switch(i.mode){case"nearest":return`
              ${X0(H,c)};
              ${W0(i.nearestMode,s,_e)};
              ${Q0(H,q,c,T,E.length,b.length,re)};
              `;case"linear":return`
              ${K0(q,c,T,E.length,b.length)};
              ${(()=>{if(c.length===2||c.length===4)return`${Y0(H,q,c,re,le)}`;if(c.length===3||c.length===5)return`${J0(H,q,c,re,le)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(c.length===2||c.length===4)return`${Z0(H,q,c,T,E,b,i.cubicCoeffA,re,i.extrapolationValue,i.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${me.registerUniform("output_size","u32").registerUniform("scales","f32",E.length).registerUniform("roi","f32",b.length).declareVariables(H,q)}
      ${me.mainStart()}
        ${me.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${Z?"output[global_idx] = input[global_idx];":`
        let output_indices = ${q.offsetToIndices("global_idx")};
        var input_indices: ${H.type.indices};
        ${(()=>{switch(i.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${H.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${i.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${c.length===2||c.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${i.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${i.cacheKey}|${s}|${E.length>0?E:""}|${d.length>0?d:""}|${b.length>0?b:""}|${Z}|${c}`,inputDependencies:["rank"]},getShaderSource:be,getRunData:()=>({outputs:[{dims:T,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:12,data:w},{type:1,data:E},{type:1,data:b},...zt(c,T)]})}},ty=r=>{let i=r.customDataBuffer;return new Uint32Array(i,i.byteOffset,1)[0]},ry=(r,i)=>{let s=[],u=[],d=[],p=ty(r);if(i.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");U0(r.inputs,i,p,s,u,d),r.compute(ey(r.inputs[0],i,p,s,u,d),{inputs:[0]})},ny=r=>{let i=r.antialias,s=r.axes,u=r.coordinateTransformMode,d=r.cubicCoeffA,p=r.excludeOutside!==0,c=r.extrapolationValue,b=r.keepAspectRatioPolicy,T=r.mode,E=r.nearestMode===""?"simple":r.nearestMode;return Xt({antialias:i,axes:s,coordinateTransformMode:u,cubicCoeffA:d,excludeOutside:p,extrapolationValue:c,keepAspectRatioPolicy:b,mode:T,nearestMode:E})}}),iy,oy,sy,Tx=m(()=>{Zt(),Jt(),vr(),dr(),iy=(r,i)=>{let[s,u,d,p]=r,{numHeads:c,rotaryEmbeddingDim:b}=i;if(s.dims.length!==3&&s.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${s.dims.length}`);if(!Ze.areEqual(u.dims,[])&&!Ze.areEqual(u.dims,[1])&&u.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${u.dims.length}`);if(d.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${d.dims.length}`);if(p.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${p.dims.length}`);if(!Ze.areEqual(d.dims,p.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(b>0&&c===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let T=s.dims[0],E=s.dims[s.dims.length-2],q=d.dims[0],H=Ze.sizeFromDimension(s.dims,1)/E,w=b===0?d.dims[1]*2:H/c;if(b>w)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(u.dims.length===2){if(T!==u.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${u.dims[0]}`);if(E!==u.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${u.dims[1]}`)}if(w/2!==d.dims[1]&&b/2!==d.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${d.dims[1]}`);if(E>q)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},oy=(r,i)=>{let{interleaved:s,numHeads:u,rotaryEmbeddingDim:d,scale:p}=i,c=r[0].dims[0],b=Ze.sizeFromDimension(r[0].dims,1),T=r[0].dims[r[0].dims.length-2],E=b/T,q=r[2].dims[1],H=d===0?q*2:E/u,w=new Array(c,T,E/H,H-q),Z=Ze.computeStrides(w),re=[{type:1,data:p},{type:12,data:w},{type:12,data:Z},...r[0].dims.length===3?new Array({type:12,data:[b,E,H,1]}):[],...r[0].dims.length===4?new Array({type:12,data:[b,H,T*H,1]}):[],...zt(r[0].dims,r[1].dims,r[2].dims,r[3].dims,r[0].dims)],le=_e=>{let be=gt("input",r[0].dataType,r[0].dims.length),me=gt("position_ids",r[1].dataType,r[1].dims.length),Fe=gt("cos_cache",r[2].dataType,r[2].dims.length),Se=gt("sin_cache",r[3].dataType,r[3].dims.length),ze=qt("output",r[0].dataType,r[0].dims.length);return _e.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:w.length},{name:"global_strides",type:"u32",length:Z.length},{name:"input_output_strides",type:"u32",length:Z.length}]),`
        ${_e.declareVariables(be,me,Fe,Se,ze)}

        ${_e.mainStart(Kn)}
          let half_rotary_emb_dim = uniforms.${Fe.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${_e.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${me.broadcastedIndicesToOffset("bsnh.xy",qt("",me.type.tensor,2))};
            let position_id =
                u32(${me.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${s});
            let j = i + select(half_rotary_emb_dim, 1, ${s});
            let re = ${be.getByOffset("i")} * ${Fe.get("position_id","bsnh[3]")} -
                ${be.getByOffset("j")} * ${Se.get("position_id","bsnh[3]")};
            ${ze.setByOffset("i","re")}
            let im = ${be.getByOffset("i")} * ${Se.get("position_id","bsnh[3]")} +
                ${be.getByOffset("j")} * ${Fe.get("position_id","bsnh[3]")};
            ${ze.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${ze.setByOffset("k",be.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:Xt({interleaved:s}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:le,getRunData:()=>({outputs:[{dims:r[0].dims,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(Ze.size(w)/Kn)},programUniforms:re})}},sy=(r,i)=>{iy(r.inputs,i),r.compute(oy(r.inputs,i))}}),ay,ly,uy,Sx=m(()=>{Zt(),Jt(),dr(),ay=r=>{if(!r||r.length<3)throw new Error("layerNorm requires at least 3 inputs.");let i=r[0],s=r[1],u=r[2];if(i.dataType!==s.dataType||i.dataType!==u.dataType)throw new Error("All inputs must have the same data type");if(i.dims.length!==3&&i.dims.length!==2)throw new Error("Input must be 2D or 3D");if(s.dims.length!==3&&s.dims.length!==2)throw new Error("Skip must be 2D or 3D");let d=i.dims[i.dims.length-1],p=i.dims[i.dims.length-2];if(s.dims[s.dims.length-1]!==d)throw new Error("Skip must have the same hidden size as input");if(s.dims[s.dims.length-2]!==p)throw new Error("Skip must have the same sequence length as input");if(u.dims.length!==1)throw new Error("Gamma must be 1D");if(u.dims[u.dims.length-1]!==d)throw new Error("Gamma must have the same hidden size as input");if(r.length>3){let c=r[3];if(c.dims.length!==1)throw new Error("Beta must be 1D");if(c.dims[c.dims.length-1]!==d)throw new Error("Beta must have the same hidden size as input")}if(r.length>4){let c=r[4];if(c.dims.length!==1)throw new Error("Bias must be 1D");if(c.dims[c.dims.length-1]!==d)throw new Error("Bias must have the same hidden size as input")}},ly=(r,i,s,u)=>{let d=i.simplified,p=r[0].dims,c=Ze.size(p),b=p,T=c,E=p.slice(-1)[0],q=u?p.slice(0,-1).concat(1):[],H=!d&&r.length>3,w=r.length>4,Z=u&&s>1,re=u&&s>2,le=s>3,_e=64,be=Ar(E),me=[{type:12,data:T},{type:12,data:be},{type:12,data:E},{type:1,data:i.epsilon}],Fe=ze=>{let dt=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],lt=[gt("x",r[0].dataType,r[0].dims,be),gt("skip",r[1].dataType,r[1].dims,be),gt("gamma",r[2].dataType,r[2].dims,be)];H&&lt.push(gt("beta",r[3].dataType,r[3].dims,be)),w&&lt.push(gt("bias",r[4].dataType,r[4].dims,be)),lt.push(qt("output",r[0].dataType,b,be)),Z&&lt.push(qt("mean_output",1,q)),re&&lt.push(qt("inv_std_output",1,q)),le&&lt.push(qt("input_skip_bias_sum",r[0].dataType,b,be));let Mt=zr(r[0].dataType),Dt=zr(1,be);return`

      ${ze.registerUniforms(dt).declareVariables(...lt)}
      var<workgroup> sum_shared : array<${Dt}, ${_e}>;
      var<workgroup> sum_squared_shared : array<${Dt}, ${_e}>;

      ${ze.mainStart([_e,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${_e};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${_e};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${_e-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${w?"bias[offset1d + i]":Mt+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${le?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Zr(Mt,be,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${_e};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Qn("sum",be)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Qn("square_sum",be)} / f32(uniforms.hidden_size) ${d?"":"- mean * mean"} + uniforms.epsilon);
        ${Z?"mean_output[global_idx] = mean;":""}
        ${re?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${d?"":`- ${Mt}(mean)`}) *
            ${Mt}(inv_std_dev) * gamma[offset1d + i]
            ${H?"+ beta[offset1d + i]":""};
        }
      }`},Se=[{dims:b,dataType:r[0].dataType}];return s>1&&Se.push({dims:q,dataType:1}),s>2&&Se.push({dims:q,dataType:1}),s>3&&Se.push({dims:p,dataType:r[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${be};${Z};${re};${le}`,inputDependencies:r.map((ze,dt)=>"type")},getShaderSource:Fe,getRunData:()=>({outputs:Se,dispatchGroup:{x:Math.ceil(T/E)},programUniforms:me})}},uy=(r,i)=>{ay(r.inputs);let s=[0];r.outputCount>1&&s.push(-3),r.outputCount>2&&s.push(-3),r.outputCount>3&&s.push(3),r.compute(ly(r.inputs,i,r.outputCount,!1),{outputs:s})}}),cy,vf,dy,Bm,fy,py,hy,my,Ex=m(()=>{Zt(),Jt(),vr(),dr(),cy=(r,i)=>{if(!r||r.length<1)throw new Error("too few inputs");if(i.axes.length!==0){if(i.axes.length!==i.starts.length||i.axes.length!==i.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(i.starts.length!==i.ends.length)throw new Error("starts and ends must have the same length");r.slice(1).forEach((s,u)=>{if(r[u+1].dataType!==6&&r[u+1].dataType!==7)throw new Error(`Input ${u} must be an array of int32 or int64`)})},vf=(r,i)=>{let s=[];if(r.length>i)if(r[i].dataType===7)r[i].getBigInt64Array().forEach(u=>s.push(Number(u)));else if(r[i].dataType===6)r[i].getInt32Array().forEach(u=>s.push(Number(u)));else throw new Error(`Input ${i} must be an array of int32 or int64`);return s},dy=(r,i)=>{if(r.length>1){let s=vf(r,1),u=vf(r,2),d=vf(r,3);return d.length===0&&(d=[...Array(r[0].dims.length).keys()]),Xt({starts:s,ends:u,axes:d})}else return i},Bm=(r,i,s,u,d)=>{let p=r;return r<0&&(p+=s[u[i]]),d[i]<0?Math.max(0,Math.min(p,s[u[i]]-1)):Math.max(0,Math.min(p,s[u[i]]))},fy=(r,i,s)=>`fn calculateInputIndices(output_indices: ${i.type.indices}) -> ${r.type.indices} {
          var input_indices: ${r.type.indices};
          var carry = 0u;
          for (var i = ${s.length}; i >= 0; i--) {
            let input_shape_i = ${jt("uniforms.input_shape","i",s.length)};
            let steps_i = ${jt("uniforms.steps","i",s.length)};
            let signs_i = ${jt("uniforms.signs","i",s.length)};
            let starts_i = ${jt("uniforms.starts","i",s.length)};
            var output_index = ${i.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${r.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,py=(r,i)=>{let s=r[0].dims,u=Ze.size(s),d=i.axes.length>0?Ze.normalizeAxes(i.axes,s.length):[...Array(s.length).keys()],p=vf(r,4);p.forEach(be=>be!==0||(()=>{throw new Error("step cannot be 0")})),p.length===0&&(p=Array(d.length).fill(1));let c=i.starts.map((be,me)=>Bm(be,me,s,d,p)),b=i.ends.map((be,me)=>Bm(be,me,s,d,p));if(d.length!==c.length||d.length!==b.length)throw new Error("start, ends and axes should have the same number of elements");if(d.length!==s.length)for(let be=0;be<s.length;++be)d.includes(be)||(c.splice(be,0,0),b.splice(be,0,s[be]),p.splice(be,0,1));let T=p.map(be=>Math.sign(be));p.forEach((be,me,Fe)=>{if(be<0){let Se=(b[me]-c[me])/be,ze=c[me],dt=ze+Se*p[me];c[me]=dt,b[me]=ze,Fe[me]=-be}});let E=s.slice(0);d.forEach((be,me)=>{E[be]=Math.ceil((b[be]-c[be])/p[be])});let q={dims:E,dataType:r[0].dataType},H=qt("output",r[0].dataType,E.length),w=gt("input",r[0].dataType,r[0].dims.length),Z=Ze.size(E),re=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:c.length},{name:"signs",type:"i32",length:T.length},{name:"steps",type:"u32",length:p.length}],le=[{type:12,data:Z},{type:12,data:c},{type:6,data:T},{type:12,data:p},...zt(r[0].dims,E)],_e=be=>`
      ${be.registerUniforms(re).declareVariables(w,H)}
        ${fy(w,H,s)}
        ${be.mainStart()}
          ${be.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${H.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${H.setByOffset("global_idx",w.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${T.length}_${c.length}_${p.length}`,inputDependencies:["rank"]},getShaderSource:_e,getRunData:()=>({outputs:[q],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:le})}},hy=(r,i)=>{cy(r.inputs,i);let s=dy(r.inputs,i);r.compute(py(r.inputs,s),{inputs:[0]})},my=r=>{let i=r.starts,s=r.ends,u=r.axes;return Xt({starts:i,ends:s,axes:u})}}),gy,_y,yy,wy,Cx=m(()=>{Zt(),Jt(),vr(),dr(),gy=r=>{if(!r||r.length!==1)throw new Error("Softmax op requires 1 input.")},_y=(r,i)=>{let s=r.dims,u=Ze.size(s),d=64,p=i.axis;if(p<0&&(p=s.length+p),p<s.length-1)throw new Error("softmax only supports last axis for now.");let c=s[p],b=u/c,T=Ar(c),E=c/T,q=(_e,be)=>be===4?`max(max(${_e}.x, ${_e}.y), max(${_e}.z, ${_e}.w))`:be===2?`max(${_e}.x, ${_e}.y)`:be===3?`max(max(${_e}.x, ${_e}.y), ${_e}.z)`:_e,H=gt("x",r.dataType,r.dims,T),w=qt("result",r.dataType,r.dims,T),Z=H.type.value,re=zr(r.dataType)==="f32"?`var threadMax = ${Z}(-3.402823e+38f);`:`var threadMax = ${Z}(-65504.0h);`,le=_e=>`
      var<workgroup> rowMaxShared : ${Z};
      var<workgroup> rowSumShared : ${Z};
      var<workgroup> threadShared : array<${Z}, ${d}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${Z} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${Z}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${_e.registerUniform("packedCols","i32").declareVariables(H,w)}
      ${_e.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${d};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${re}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${Z}(${q("threadShared[0]",T)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${Z}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${Z}(${Qn("threadShared[0]",T)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${T}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:s,dataType:r.dataType}],dispatchGroup:{x:b},programUniforms:[{type:6,data:E}]}),getShaderSource:le}},yy=(r,i)=>{gy(r.inputs),r.compute(_y(r.inputs[0],i))},wy=r=>Xt({axis:r.axis})}),vy,by,xy,My,ky,Ty,Sy,Px=m(()=>{Zt(),Jt(),vr(),dr(),vy=r=>{if(!r||r.length<1)throw new Error("too few inputs")},by=(r,i)=>{let s=[],u=i.numOutputs;return r[1].dims[0]>0&&(r[1].getBigInt64Array().forEach(d=>s.push(Number(d))),u=s.length),Xt({numOutputs:u,axis:i.axis,splitSizes:s})},xy=r=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${r}u; i += 1u ) {
    if (index < ${jt("uniforms.size_in_split_axis","i",r)}) {
        return i;
    }
    }
    return ${r}u;
}`,My=r=>{let i=r.length,s=[];for(let u=0;u<i;++u){let d=r[u].setByIndices("indices","input[global_idx]");i===1?s.push(d):u===0?s.push(`if (output_number == ${u}u) { ${d} }`):u===i-1?s.push(`else { ${d} }`):s.push(`else if (output_number == ${u}) { ${d} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${r[0].type.indices}, global_idx: u32) {
        ${s.join(`
`)}
      }`},ky=(r,i)=>{let s=r[0].dims,u=Ze.size(s),d=r[0].dataType,p=Ze.normalizeAxis(i.axis,s.length),c=new Array(i.numOutputs),b=gt("input",d,s.length),T=new Array(i.numOutputs),E=[],q=[],H=0,w=[{type:12,data:u}];for(let re=0;re<i.numOutputs;re++){H+=i.splitSizes[re],T[re]=H;let le=s.slice();le[p]=i.splitSizes[re],q.push(le),c[re]=qt(`output${re}`,d,le.length),E.push({dims:q[re],dataType:r[0].dataType})}w.push({type:12,data:T},...zt(s,...q));let Z=re=>`
  ${re.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",T.length).declareVariables(b,...c)}
  ${xy(T.length)}
  ${My(c)}

  ${re.mainStart()}
    ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${b.offsetToIndices("global_idx")};
    var index = ${b.indicesGet("indices",p)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${jt("uniforms.size_in_split_axis","output_number - 1u",T.length)};
      ${b.indicesSet("indices",p,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:i.cacheKey,inputDependencies:["rank"]},getShaderSource:Z,getRunData:()=>({outputs:E,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:w})}},Ty=(r,i)=>{vy(r.inputs);let s=r.inputs.length===1?i:by(r.inputs,i);r.compute(ky(r.inputs,s),{inputs:[0]})},Sy=r=>{let i=r.axis,s=r.splitSizes,u=r.numOutputs<0?s.length:r.numOutputs;if(u!==s.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Xt({axis:i,numOutputs:u,splitSizes:s})}}),Ey,Cy,Py,$x=m(()=>{Zt(),Jt(),dr(),Ey=(r,i,s,u,d)=>{let p=qt("output_data",d,s.length,4),c=gt("a_data",i[1].dataType,i[1].dims.length,4),b=gt("b_data",i[2].dataType,i[2].dims.length,4),T=gt("c_data",i[0].dataType,i[0].dims.length,4),E,q=(H,w,Z)=>`select(${w}, ${H}, ${Z})`;if(!u)E=p.setByOffset("global_idx",q(c.getByOffset("global_idx"),b.getByOffset("global_idx"),T.getByOffset("global_idx")));else{let H=(w,Z,re="")=>{let le=`a_data[index_a${Z}][component_a${Z}]`,_e=`b_data[index_b${Z}][component_b${Z}]`,be=`bool(c_data[index_c${Z}] & (0xffu << (component_c${Z} * 8)))`;return`
            let output_indices${Z} = ${p.offsetToIndices(`global_idx * 4u + ${Z}u`)};
            let offset_a${Z} = ${c.broadcastedIndicesToOffset(`output_indices${Z}`,p)};
            let offset_b${Z} = ${b.broadcastedIndicesToOffset(`output_indices${Z}`,p)};
            let offset_c${Z} = ${T.broadcastedIndicesToOffset(`output_indices${Z}`,p)};
            let index_a${Z} = offset_a${Z} / 4u;
            let index_b${Z} = offset_b${Z} / 4u;
            let index_c${Z} = offset_c${Z} / 4u;
            let component_a${Z} = offset_a${Z} % 4u;
            let component_b${Z} = offset_b${Z} % 4u;
            let component_c${Z} = offset_c${Z} % 4u;
            ${w}[${Z}] = ${re}(${q(le,_e,be)});
          `};d===9?E=`
            var data = vec4<u32>(0);
            ${H("data",0,"u32")}
            ${H("data",1,"u32")}
            ${H("data",2,"u32")}
            ${H("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:E=`
            ${H("output_data[global_idx]",0)}
            ${H("output_data[global_idx]",1)}
            ${H("output_data[global_idx]",2)}
            ${H("output_data[global_idx]",3)}
          `}return`
        ${r.registerUniform("vec_size","u32").declareVariables(T,c,b,p)}
        ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${E}
      }`},Cy=r=>{let i=r[1].dims,s=r[2].dims,u=r[0].dims,d=r[1].dataType,p=!(Ze.areEqual(i,s)&&Ze.areEqual(s,u)),c=i,b=Ze.size(i);if(p){let E=vn.calcShape(vn.calcShape(i,s,!1),u,!1);if(!E)throw new Error("Can't perform where op on the given tensors");c=E,b=Ze.size(c)}let T=Math.ceil(b/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:E=>Ey(E,r,c,p,d),getRunData:()=>({outputs:[{dims:c,dataType:d}],dispatchGroup:{x:Math.ceil(b/64/4)},programUniforms:[{type:12,data:T},...zt(u,i,s,c)]})}},Py=r=>{r.compute(Cy(r.inputs))}}),$y,Ax=m(()=>{wp(),Ls(),vp(),bp(),xp(),Mp(),kp(),gl(),$p(),Ap(),zp(),Im(),Dp(),Dd(),Fm(),Bp(),Rp(),Np(),Up(),Vp(),zm(),Gs(),Fn(),Jd(),at(),Bl(),Dm(),Mx(),Ia(),kx(),Tx(),Sx(),Ex(),Cx(),Px(),nf(),Mo(),Xa(),$x(),$y=new Map([["Abs",[gc]],["Acos",[_c]],["Acosh",[Da]],["Add",[Za]],["ArgMax",[ic,Ds]],["ArgMin",[nc,Ds]],["Asin",[yc]],["Asinh",[wc]],["Atan",[La]],["Atanh",[vc]],["Attention",[uc]],["AveragePool",[Sr,br]],["BatchNormalization",[fc]],["BiasAdd",[Oa]],["BiasSplitGelu",[Ya]],["Cast",[Ba,bc]],["Ceil",[Bs]],["Clip",[Mc]],["Concat",[td,rl]],["Conv",[ml,fl]],["ConvTranspose",[bl,vl]],["Cos",[kc]],["Cosh",[Tc]],["CumSum",[xl,Sd]],["DepthToSpace",[kl,Tl]],["DequantizeLinear",[Mi,Eo]],["Div",[Gc]],["Einsum",[Ad,Lr]],["Elu",[Ra,Zo]],["Equal",[Hc]],["Erf",[Na]],["Exp",[Sc]],["Expand",[zd]],["FastGelu",[Pl]],["Floor",[Ec]],["FusedConv",[ml,fl]],["Gather",[Lp,$l]],["GatherElements",[Hd,Gd]],["GatherBlockQuantized",[jd,Ud]],["Gelu",[Cc]],["Gemm",[Xd,Qd]],["GlobalAveragePool",[jn,Nn]],["GlobalMaxPool",[Ll,En]],["Greater",[el]],["GreaterOrEqual",[Xc]],["GroupQueryAttention",[lf,sf]],["HardSigmoid",[Va,Fc]],["InstanceNormalization",[ff]],["LayerNormalization",[mf]],["LeakyRelu",[ja,Zo]],["Less",[Qc]],["LessOrEqual",[tl]],["Log",[Bc]],["MatMul",[pd]],["MatMulNBits",[yn,bn]],["MaxPool",[zn,mn]],["Mul",[Ja]],["MultiHeadAttention",[Zd,Al]],["Neg",[$c]],["Not",[Pc]],["Pad",[Je]],["Pow",[qc]],["QuickGelu",[Ns,Zo]],["Range",[wf]],["Reciprocal",[Ac]],["ReduceMin",[$a]],["ReduceMean",[Xu]],["ReduceMax",[Ju]],["ReduceSum",[tc]],["ReduceProd",[ec]],["ReduceL1",[Yu]],["ReduceL2",[Pa]],["ReduceLogSum",[rc]],["ReduceLogSumExp",[Zu]],["ReduceSumSquare",[Aa]],["Relu",[Ua]],["Resize",[ry,ny]],["RotaryEmbedding",[sy]],["Sigmoid",[Ic]],["Sin",[zc]],["Sinh",[Oc]],["Slice",[hy,my]],["SkipLayerNormalization",[uy]],["Split",[Ty,Sy]],["Sqrt",[Wa]],["Softmax",[yy,wy]],["Sub",[Kc]],["Tan",[Dc]],["Tanh",[Ha]],["ThresholdedRelu",[Lc,Zo]],["Tile",[rf]],["Transpose",[Su,va]],["Where",[Py]]])}),Ay,Ix=m(()=>{bt(),qn(),dr(),Ay=class{constructor(r){this.backend=r,this.repo=new Map,this.attributesBound=!1}getArtifact(r){return this.repo.get(r)}setArtifact(r,i){this.repo.set(r,i)}run(r,i,s,u,d){et(r.programInfo.name);let p=this.backend.device,c=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let b=[];for(let E of i)b.push({binding:b.length,resource:{buffer:E.buffer}});for(let E of s)b.push({binding:b.length,resource:{buffer:E.buffer}});d&&b.push({binding:b.length,resource:d});let T=p.createBindGroup({layout:r.computePipeline.getBindGroupLayout(0),entries:b,label:r.programInfo.name});if(this.backend.sessionStatus==="capturing"){let E={kernelId:this.backend.currentKernelId,computePipeline:r.computePipeline,bindGroup:T,dispatchGroup:u};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(E)}c.setPipeline(r.computePipeline),c.setBindGroup(0,T),c.dispatchWorkgroups(...u),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),A(r.programInfo.name)}dispose(){}build(r,i){et(r.name);let s=this.backend.device,u=[];s.features.has("shader-f16")&&u.push("enable f16;");let d=Mu(i,this.backend.device.limits),p=r.getShaderSource(d),c=`${u.join(`
`)}
${d.additionalImplementations}
${p}`,b=s.createShaderModule({code:c,label:r.name});Kr("verbose",()=>`[WebGPU] ${r.name} shader code: ${c}`);let T=s.createComputePipeline({compute:{module:b,entryPoint:"main"},layout:"auto",label:r.name});return A(r.name),{programInfo:r,computePipeline:T,uniformVariablesInfo:d.variablesInfo}}normalizeDispatchGroupSize(r){let i=typeof r=="number"?r:r.x,s=typeof r=="number"?1:r.y||1,u=typeof r=="number"?1:r.z||1,d=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(i<=d&&s<=d&&u<=d)return[i,s,u];let p=i*s*u,c=Math.ceil(Math.sqrt(p));if(c>d){if(c=Math.ceil(Math.cbrt(p)),c>d)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[c,c,c]}else return[c,c,1]}}}),Iy,Fy,zy,Oy,Fx=m(()=>{bt(),Zt(),qn(),W(),Dr(),Ax(),Ix(),Iy=(r,i)=>{if(i.length!==r.length)throw new Error(`inputDependencies length ${i.length} is not equal to inputTensors length ${r.length}.`);let s=[];for(let u=0;u<r.length;++u){let d=r[u].dataType;switch(i[u]){case"none":{s.push("");break}case"type":{s.push(`${d}`);break}case"rank":{let p=r[u].dims.length;s.push(`${d};${p}`);break}case"dims":{let p=r[u].dims.join(",");s.push(`${d};${p}`);break}default:throw new Error(`unsupported input dependency: ${i[u]}`)}}return s.join("|")},Fy=(r,i,s)=>{var d,p;let u=r.name;return(d=r.shaderCache)!=null&&d.hint&&(u+="["+r.shaderCache.hint+"]"),u+=":"+s+`:${Iy(i,((p=r.shaderCache)==null?void 0:p.inputDependencies)??new Array(i.length).fill("dims"))}`,u},zy=class{constructor(r){r&&(this.architecture=r.architecture,this.vendor=r.vendor)}isArchitecture(r){return this.architecture===r}isVendor(r){return this.vendor===r}},Oy=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let r=this.kernelCustomData.get(this.currentKernelId);return r||(r={},this.kernelCustomData.set(this.currentKernelId,r)),r}async initialize(r,i){this.env=r;let s=[],u={requiredLimits:{maxComputeWorkgroupStorageSize:i.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:i.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:i.limits.maxStorageBufferBindingSize,maxBufferSize:i.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:i.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:i.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:i.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:i.limits.maxComputeWorkgroupSizeZ},requiredFeatures:s};i.features.has("chromium-experimental-timestamp-query-inside-passes")?s.push("chromium-experimental-timestamp-query-inside-passes"):i.features.has("timestamp-query")&&s.push("timestamp-query"),i.features.has("shader-f16")&&s.push("shader-f16"),this.device=await i.requestDevice(u),this.adapterInfo=new zy(i.info||await i.requestAdapterInfo()),this.gpuDataManager=sr(this),this.programManager=new Ay(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,bo(r.logLevel,!!r.debug),this.device.onuncapturederror=d=>{d.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${d.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:i,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let r=this.getCommandEncoder(),i={};this.queryType==="at-passes"&&(i.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=r.beginComputePass(i)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;et(),this.endComputePass();let r;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),r=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(r,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,r,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&r.mapAsync(GPUMapMode.READ).then(()=>{var u;let i=new BigUint64Array(r.getMappedRange()),s=this.pendingQueries.get(r);for(let d=0;d<i.length/2;d++){let p=s[d],c=p.kernelId,b=this.kernels.get(c),T=b.kernelType,E=b.kernelName,q=p.programName,H=p.inputTensorViews,w=p.outputTensorViews,Z=i[d*2],re=i[d*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=Z);let le=Number(Z-this.queryTimeBase),_e=Number(re-this.queryTimeBase);if(!Number.isSafeInteger(le)||!Number.isSafeInteger(_e))throw new RangeError("incorrect timestamp range");if((u=this.env.webgpu.profiling)!=null&&u.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:H.map(be=>({dims:be.dims,dataType:vi(be.dataType)})),outputsMetadata:w.map(be=>({dims:be.dims,dataType:vi(be.dataType)})),kernelId:c,kernelType:T,kernelName:E,programName:q,startTime:le,endTime:_e});else{let be="";H.forEach((Fe,Se)=>{be+=`input[${Se}]: [${Fe.dims}] | ${vi(Fe.dataType)}, `});let me="";w.forEach((Fe,Se)=>{me+=`output[${Se}]: [${Fe.dims}] | ${vi(Fe.dataType)}, `}),console.log(`[profiling] kernel "${c}|${T}|${E}|${q}" ${be}${me}execution time: ${_e-le} ns`)}je("GPU",`${q}::${Z}::${re}`)}r.unmap(),this.pendingQueries.delete(r)}),A()}run(r,i,s,u,d,p){et(r.name);let c=[];for(let me=0;me<i.length;++me){let Fe=i[me].data;if(Fe===0)continue;let Se=this.gpuDataManager.get(Fe);if(!Se)throw new Error(`no GPU data for input: ${Fe}`);c.push(Se)}let{outputs:b,dispatchGroup:T,programUniforms:E}=r.getRunData(i),q=s.length===0?b.map((me,Fe)=>Fe):s;if(q.length!==b.length)throw new Error(`Output size ${q.length} must be equal to ${b.length}.`);let H=[],w=[];for(let me=0;me<b.length;++me){if(!Number.isInteger(q[me])||q[me]<-3||q[me]>=p)throw new Error(`Invalid output index: ${q[me]}`);if(q[me]===-3)continue;let Fe=q[me]===-1,Se=q[me]===-2,ze=Fe||Se?d(b[me].dataType,b[me].dims):u(q[me],b[me].dataType,b[me].dims);if(H.push(ze),ze.data===0)continue;let dt=this.gpuDataManager.get(ze.data);if(!dt)throw new Error(`no GPU data for output: ${ze.data}`);if(Fe&&this.temporaryData.push(dt),Se){let lt=this.kernelPersistentData.get(this.currentKernelId);lt||(lt=[],this.kernelPersistentData.set(this.currentKernelId,lt)),lt.push(dt)}w.push(dt)}if(c.length!==i.length||w.length!==H.length){if(w.length===0)return A(r.name),H;throw new Error(`Program ${r.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let Z;if(E){let me=0,Fe=[];E.forEach(lt=>{let Mt=typeof lt.data=="number"?[lt.data]:lt.data;if(Mt.length===0)return;let Dt=lt.type===10?2:4,Vt,hr;lt.type===10?(hr=Mt.length>4?16:Mt.length>2?8:Mt.length*Dt,Vt=Mt.length>4?16:Dt*Mt.length):(hr=Mt.length<=2?Mt.length*Dt:16,Vt=16),me=Math.ceil(me/hr)*hr,Fe.push(me);let xr=lt.type===10?8:4;me+=Mt.length>4?Math.ceil(Mt.length/xr)*Vt:Mt.length*Dt});let Se=16;me=Math.ceil(me/Se)*Se;let ze=new ArrayBuffer(me);E.forEach((lt,Mt)=>{let Dt=Fe[Mt],Vt=typeof lt.data=="number"?[lt.data]:lt.data;if(lt.type===6)new Int32Array(ze,Dt,Vt.length).set(Vt);else if(lt.type===12)new Uint32Array(ze,Dt,Vt.length).set(Vt);else if(lt.type===10)new Uint16Array(ze,Dt,Vt.length).set(Vt);else if(lt.type===1)new Float32Array(ze,Dt,Vt.length).set(Vt);else throw new Error(`Unsupported uniform type: ${vi(lt.type)}`)});let dt=this.gpuDataManager.create(me,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(dt.buffer,0,ze,0,me),this.gpuDataManager.release(dt.id),Z={offset:0,size:me,buffer:dt.buffer}}let re=this.programManager.normalizeDispatchGroupSize(T),le=re[1]===1&&re[2]===1,_e=Fy(r,i,le),be=this.programManager.getArtifact(_e);if(be||(be=this.programManager.build(r,re),this.programManager.setArtifact(_e,be),Kr("info",()=>`[artifact] key: ${_e}, programName: ${r.name}`)),E&&be.uniformVariablesInfo){if(E.length!==be.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${be.uniformVariablesInfo.length}, got ${E.length} in program "${be.programInfo.name}".`);for(let me=0;me<E.length;me++){let Fe=E[me],Se=Fe.type,ze=typeof Fe.data=="number"?1:Fe.data.length,[dt,lt]=be.uniformVariablesInfo[me];if(Se!==dt||ze!==lt)throw new Error(`Uniform variable ${me} mismatch: expect type ${dt} with size ${lt}, got type ${Se} with size ${ze} in program "${be.programInfo.name}".`)}}if(Kr("info",()=>`[ProgramManager] run "${r.name}" (key=${_e}) with ${re[0]}x${re[1]}x${re[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let me={kernelId:this.currentKernelId,programName:be.programInfo.name,inputTensorViews:i,outputTensorViews:H};this.pendingKernels.push(me),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(me)}return this.programManager.run(be,c,w,re,Z),A(r.name),H}upload(r,i){this.gpuDataManager.upload(r,i)}memcpy(r,i){this.gpuDataManager.memcpy(r,i)}async download(r,i){await this.gpuDataManager.download(r,i)}alloc(r){return this.gpuDataManager.create(r).id}free(r){return this.gpuDataManager.release(r)}createKernel(r,i,s,u){let d=$y.get(r);if(!d)throw new Error(`kernel not implemented: ${r}`);let p={kernelType:r,kernelName:u,kernelEntry:d[0],attributes:[d[1],s]};this.kernels.set(i,p)}releaseKernel(r){let i=this.kernelPersistentData.get(r);if(i){for(let s of i)this.gpuDataManager.release(s.id);this.kernelPersistentData.delete(r)}this.kernelCustomData.delete(r),this.kernels.delete(r)}computeKernel(r,i,s){let u=this.kernels.get(r);if(!u)throw new Error(`kernel not created: ${r}`);let d=u.kernelType,p=u.kernelName,c=u.kernelEntry,b=u.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${d}] ${p}" is not allowed to be called recursively`);this.currentKernelId=r,b[0]&&(b[1]=b[0](b[1]),b[0]=void 0),Kr("info",()=>`[WebGPU] Start to run kernel "[${d}] ${p}"...`);let T=this.env.debug;this.temporaryData=[];try{return T&&this.device.pushErrorScope("validation"),c(i,b[1]),0}catch(E){return s.push(Promise.resolve(`[WebGPU] Kernel "[${d}] ${p}" failed. ${E}`)),1}finally{T&&s.push(this.device.popErrorScope().then(E=>E?`GPU validation error for kernel "[${d}] ${p}": ${E.message}`:null));for(let E of this.temporaryData)this.gpuDataManager.release(E.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(r,i,s,u){let d=this.sessionExternalDataMapping.get(r);d||(d=new Map,this.sessionExternalDataMapping.set(r,d));let p=d.get(i),c=this.gpuDataManager.registerExternalBuffer(s,u,p==null?void 0:p[1]);return d.set(i,[c,s]),c}unregisterBuffers(r){let i=this.sessionExternalDataMapping.get(r);i&&(i.forEach(s=>this.gpuDataManager.unregisterExternalBuffer(s[1])),this.sessionExternalDataMapping.delete(r))}getBuffer(r){let i=this.gpuDataManager.get(r);if(!i)throw new Error(`no GPU data for buffer: ${r}`);return i.buffer}createDownloader(r,i,s){return async()=>{let u=await Ct(this,r,i);return Ue(u.buffer,s)}}writeTimestamp(r){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,r)}setQueryType(){var r;this.queryType="none",(((r=this.env.webgpu.profiling)==null?void 0:r.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Kr("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Kr("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Kr("info","replay"),this.sessionStatus="replaying";let r=this.capturedCommandList.get(this.currentSessionId),i=this.capturedPendingKernels.get(this.currentSessionId),s=r.length;this.pendingKernels=[];for(let u=0;u<s;u++){let d=this.getComputePassEncoder(),p=r[u];this.writeTimestamp(this.pendingDispatchNumber*2),d.setPipeline(p.computePipeline),d.setBindGroup(0,p.bindGroup),d.dispatchWorkgroups(...p.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(i[u]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(r){this.unregisterBuffers(r),this.capturedCommandList.has(r)&&this.capturedCommandList.delete(r),this.capturedPendingKernels.has(r)&&this.capturedPendingKernels.delete(r),this.gpuDataManager.onReleaseSession(r)}onRunStart(r){this.currentSessionId=r,this.setQueryType()}}}),Dy={};g(Dy,{init:()=>By});var qp,Ly,By,zx=m(()=>{Zt(),Fx(),qn(),Jt(),qp=class xx{constructor(i,s,u,d){this.module=i,this.dataType=s,this.data=u,this.dims=d}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let i=Ze.size(this.dims);return i===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,i)}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let i=Ze.size(this.dims);return i===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,i)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let i=Ze.size(this.dims);return i===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,i)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let i=Ze.size(this.dims);return i===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,i)}reshape(i){if(Ze.size(i)!==Ze.size(this.dims))throw new Error("Invalid new shape");return new xx(this.module,this.dataType,this.data,i)}},Ly=class{constructor(r,i,s){this.module=r,this.backend=i,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=i.adapterInfo;let u=r.HEAPU32,d=s>>>2;this.opKernelContext=u[d++];let p=u[d++];this.outputCount=u[d++],this.customDataOffset=u[d++],this.customDataSize=u[d++];let c=[];for(let b=0;b<p;b++){let T=u[d++],E=u[d++],q=u[d++],H=[];for(let w=0;w<q;w++)H.push(u[d++]);c.push(new qp(r,T,E,H))}this.inputs=c}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(r,i){var c;let s=((c=i==null?void 0:i.inputs)==null?void 0:c.map(b=>typeof b=="number"?this.inputs[b]:b))??this.inputs,u=(i==null?void 0:i.outputs)??[],d=(b,T,E)=>new qp(this.module,T,this.output(b,E),E),p=(b,T)=>{let E=Hi(b,T);if(!E)throw new Error(`Unsupported data type: ${b}`);let q=E>0?this.backend.gpuDataManager.create(E).id:0;return new qp(this.module,b,q,T)};return this.backend.run(r,s,u,d,p,this.outputCount)}output(r,i){let s=this.module.stackSave();try{let u=this.module.stackAlloc((1+i.length)*4),d=u>>2;this.module.HEAPU32[d++]=i.length;for(let p=0;p<i.length;p++)this.module.HEAPU32[d++]=i[p];return this.module._JsepOutput(this.opKernelContext,r,u)}catch(u){throw new Error(`Failed to generate kernel's output[${r}] with dims [${i}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${u}`)}finally{this.module.stackRestore(s)}}},By=async(r,i,s,u)=>{let d=i.jsepInit;if(!d)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(r==="webgpu"){let p=new Oy;await p.initialize(s,u),d("webgpu",[p,c=>p.alloc(c),c=>p.free(c),(c,b,T,E=!1)=>{if(E)Kr("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${c}, dst=${b}, size=${T}`),p.memcpy(c,b);else{Kr("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${c}, gpuDataId=${b}, size=${T}`);let q=i.HEAPU8.subarray(c>>>0,(c>>>0)+T);p.upload(b,q)}},async(c,b,T)=>{Kr("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${c}, dataOffset=${b}, size=${T}`),await p.download(c,()=>i.HEAPU8.subarray(b>>>0,(b>>>0)+T))},(c,b,T)=>p.createKernel(c,b,T,i.UTF8ToString(i._JsepGetNodeName(b))),c=>p.releaseKernel(c),(c,b,T,E)=>{Kr("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${T}, kernel=${c}, contextDataOffset=${b}`);let q=new Ly(i,p,b);return p.computeKernel(c,q,E)},()=>p.captureBegin(),()=>p.captureEnd(),()=>p.replay()])}else d("webnn")}}),Ry,Rm,Nm,rs,Ny,Kp,jm,Um,Vm,Wm,Gm,Hm,jy=m(()=>{$s(),As(),Zt(),kn(),Wi(),Ho(),Ry=(r,i)=>{Qr()._OrtInit(r,i)!==0&&Nr("Can't initialize onnxruntime.")},Rm=async r=>{Ry(r.wasm.numThreads,ro(r.logLevel))},Nm=async(r,i)=>{{let s=(zx(),v(Dy)).init;if(i==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let u=r.webgpu.adapter;if(u){if(typeof u.limits!="object"||typeof u.features!="object"||typeof u.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let d=r.webgpu.powerPreference;if(d!==void 0&&d!=="low-power"&&d!=="high-performance")throw new Error(`Invalid powerPreference setting: "${d}"`);let p=r.webgpu.forceFallbackAdapter;if(p!==void 0&&typeof p!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${p}"`);if(u=await navigator.gpu.requestAdapter({powerPreference:d,forceFallbackAdapter:p}),!u)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await s("webgpu",Qr(),r,u)}if(i==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await s("webnn",Qr(),r)}}},rs=new Map,Ny=r=>{let i=Qr(),s=i.stackSave();try{let u=i.stackAlloc(8);return i._OrtGetInputOutputCount(r,u,u+4)!==0&&Nr("Can't get session input/output count."),[i.HEAP32[u/4],i.HEAP32[u/4+1]]}finally{i.stackRestore(s)}},Kp=r=>{let i=Qr(),s=i._malloc(r.byteLength);if(s===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${r.byteLength}.`);return i.HEAPU8.set(r,s),[s,r.byteLength]},jm=async(r,i)=>{var H,w;let s,u,d=Qr();Array.isArray(r)?[s,u]=r:r.buffer===d.HEAPU8.buffer?[s,u]=[r.byteOffset,r.byteLength]:[s,u]=Kp(r);let p=0,c=0,b=0,T=[],E=[],q=[];try{if([c,T]=Gi(i),(i==null?void 0:i.externalData)&&d.mountExternalData){let Se=[];for(let ze of i.externalData){let dt=typeof ze=="string"?ze:ze.path;Se.push(no(typeof ze=="string"?ze:ze.data).then(lt=>{d.mountExternalData(dt,lt)}))}await Promise.all(Se)}for(let Se of(i==null?void 0:i.executionProviders)??[])if((typeof Se=="string"?Se:Se.name)==="webnn"){if(d.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof Se!="string"){let ze=Se,dt=ze==null?void 0:ze.context,lt=ze==null?void 0:ze.gpuDevice,Mt=ze==null?void 0:ze.deviceType,Dt=ze==null?void 0:ze.numThreads,Vt=ze==null?void 0:ze.powerPreference;dt?d.currentContext=dt:lt?d.currentContext=await navigator.ml.createContext(lt):d.currentContext=await navigator.ml.createContext({deviceType:Mt,numThreads:Dt,powerPreference:Vt})}else d.currentContext=await navigator.ml.createContext();break}p=await d._OrtCreateSession(s,u,c),p===0&&Nr("Can't create a session."),d.currentContext&&(d.currentContext=void 0);let[Z,re]=Ny(p),le=!!(i!=null&&i.enableGraphCapture),_e=[],be=[],me=[];for(let Se=0;Se<Z;Se++){let ze=d._OrtGetInputName(p,Se);ze===0&&Nr("Can't get an input name."),E.push(ze),_e.push(d.UTF8ToString(ze))}for(let Se=0;Se<re;Se++){let ze=d._OrtGetOutputName(p,Se);ze===0&&Nr("Can't get an output name."),q.push(ze);let dt=d.UTF8ToString(ze);be.push(dt);{if(le&&(i==null?void 0:i.preferredOutputLocation)===void 0){me.push("gpu-buffer");continue}let lt=typeof(i==null?void 0:i.preferredOutputLocation)=="string"?i.preferredOutputLocation:((H=i==null?void 0:i.preferredOutputLocation)==null?void 0:H[dt])??"cpu";if(lt!=="cpu"&&lt!=="cpu-pinned"&&lt!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${lt}.`);if(le&&lt!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${lt}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);me.push(lt)}}let Fe=null;return me.some(Se=>Se==="gpu-buffer")&&(b=d._OrtCreateBinding(p),b===0&&Nr("Can't create IO binding."),Fe={handle:b,outputPreferredLocations:me,outputPreferredLocationsEncoded:me.map(Se=>wo(Se))}),rs.set(p,[p,E,q,Fe,le,!1]),[p,_e,be]}catch(Z){throw E.forEach(re=>d._OrtFree(re)),q.forEach(re=>d._OrtFree(re)),b!==0&&d._OrtReleaseBinding(b),p!==0&&d._OrtReleaseSession(p),Z}finally{d._free(s),c!==0&&d._OrtReleaseSessionOptions(c),T.forEach(Z=>d._free(Z)),(w=d.unmountExternalData)==null||w.call(d)}},Um=r=>{var T;let i=Qr(),s=rs.get(r);if(!s)throw new Error(`cannot release session. invalid session id: ${r}`);let[u,d,p,c,b]=s;c&&(b&&i._OrtClearBoundOutputs(c.handle),i._OrtReleaseBinding(c.handle)),(T=i.jsepOnReleaseSession)==null||T.call(i,r),d.forEach(E=>i._OrtFree(E)),p.forEach(E=>i._OrtFree(E)),i._OrtReleaseSession(u),rs.delete(r)},Vm=(r,i,s,u,d,p=!1)=>{if(!r){i.push(0);return}let c=Qr(),b=r[0],T=r[1],E=r[3],q,H;if(b==="string"&&E==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(p&&E!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${d} when enableGraphCapture is true.`);if(E==="gpu-buffer"){let re=r[2].gpuBuffer;H=Hi(_o(b),T);let le=c.jsepRegisterBuffer;if(!le)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');q=le(u,d,re,H)}else{let re=r[2];if(Array.isArray(re)){H=4*re.length,q=c._malloc(H),s.push(q);let le=q/4;for(let _e=0;_e<re.length;_e++){if(typeof re[_e]!="string")throw new TypeError(`tensor data at index ${_e} is not a string`);c.HEAPU32[le++]=Yr(re[_e],s)}}else H=re.byteLength,q=c._malloc(H),s.push(q),c.HEAPU8.set(new Uint8Array(re.buffer,re.byteOffset,H),q)}let w=c.stackSave(),Z=c.stackAlloc(4*T.length);try{let re=Z/4;T.forEach(_e=>c.HEAP32[re++]=_e);let le=c._OrtCreateTensor(_o(b),q,H,Z,T.length,wo(E));le===0&&Nr(`Can't create tensor for input/output. session=${u}, index=${d}.`),i.push(le)}finally{c.stackRestore(w)}},Wm=async(r,i,s,u,d,p)=>{var Vt,hr;let c=Qr(),b=rs.get(r);if(!b)throw new Error(`cannot run inference. invalid session id: ${r}`);let T=b[0],E=b[1],q=b[2],H=b[3],w=b[4],Z=b[5],re=i.length,le=u.length,_e=0,be=[],me=[],Fe=[],Se=[],ze=c.stackSave(),dt=c.stackAlloc(re*4),lt=c.stackAlloc(re*4),Mt=c.stackAlloc(le*4),Dt=c.stackAlloc(le*4);try{[_e,be]=Ii(p);for(let rr=0;rr<re;rr++)Vm(s[rr],me,Se,r,i[rr],w);for(let rr=0;rr<le;rr++)Vm(d[rr],Fe,Se,r,re+u[rr],w);let xr=dt/4,nr=lt/4,Wr=Mt/4,Jr=Dt/4;for(let rr=0;rr<re;rr++)c.HEAPU32[xr++]=me[rr],c.HEAPU32[nr++]=E[i[rr]];for(let rr=0;rr<le;rr++)c.HEAPU32[Wr++]=Fe[rr],c.HEAPU32[Jr++]=q[u[rr]];if(H&&!Z){let{handle:rr,outputPreferredLocations:wr,outputPreferredLocationsEncoded:Or}=H;if(E.length!==re)throw new Error(`input count from feeds (${re}) is expected to be always equal to model's input count (${E.length}).`);for(let ut=0;ut<re;ut++){let At=i[ut];await c._OrtBindInput(rr,E[At],me[ut])!==0&&Nr(`Can't bind input[${ut}] for session=${r}.`)}for(let ut=0;ut<le;ut++){let At=u[ut];(Vt=d[ut])!=null&&Vt[3]?c._OrtBindOutput(rr,q[At],Fe[ut],0)!==0&&Nr(`Can't bind pre-allocated output[${ut}] for session=${r}.`):c._OrtBindOutput(rr,q[At],0,Or[At])!==0&&Nr(`Can't bind output[${ut}] to ${wr[ut]} for session=${r}.`)}rs.set(r,[T,E,q,H,w,!0])}(hr=c.jsepOnRunStart)==null||hr.call(c,T);let Er;H?Er=await c._OrtRunWithBinding(T,H.handle,le,Mt,_e):Er=await c._OrtRun(T,lt,dt,re,Dt,le,Mt,_e),Er!==0&&Nr("failed to call OrtRun().");let Hr=[];for(let rr=0;rr<le;rr++){let wr=c.HEAPU32[Mt/4+rr];if(wr===Fe[rr]){Hr.push(d[rr]);continue}let Or=c.stackSave(),ut=c.stackAlloc(4*4),At=!1,ar,Gr=0;try{c._OrtGetTensorData(wr,ut,ut+4,ut+8,ut+12)!==0&&Nr(`Can't access output tensor data on index ${rr}.`);let gn=ut/4,Cn=c.HEAPU32[gn++];Gr=c.HEAPU32[gn++];let is=c.HEAPU32[gn++],Yp=c.HEAPU32[gn++],ki=[];for(let Vn=0;Vn<Yp;Vn++)ki.push(c.HEAPU32[is/4+Vn]);c._OrtFree(is);let Un=ki.reduce((Vn,ii)=>Vn*ii,1);ar=vi(Cn);let Mf=H==null?void 0:H.outputPreferredLocations[u[rr]];if(ar==="string"){if(Mf==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Vn=[],ii=Gr/4;for(let Oi=0;Oi<Un;Oi++){let os=c.HEAPU32[ii++],Zp=Oi===Un-1?void 0:c.HEAPU32[ii]-os;Vn.push(c.UTF8ToString(os,Zp))}Hr.push([ar,ki,Vn,"cpu"])}else if(Mf==="gpu-buffer"&&Un>0){let Vn=c.jsepGetBuffer;if(!Vn)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let ii=Vn(Gr),Oi=Hi(Cn,Un);if(Oi===void 0||!yo(ar))throw new Error(`Unsupported data type: ${ar}`);At=!0,Hr.push([ar,ki,{gpuBuffer:ii,download:c.jsepCreateDownloader(ii,Oi,ar),dispose:()=>{c._OrtReleaseTensor(wr)}},"gpu-buffer"])}else{let Vn=Fi(ar),ii=new Vn(Un);new Uint8Array(ii.buffer,ii.byteOffset,ii.byteLength).set(c.HEAPU8.subarray(Gr,Gr+ii.byteLength)),Hr.push([ar,ki,ii,"cpu"])}}finally{c.stackRestore(Or),ar==="string"&&Gr&&c._free(Gr),At||c._OrtReleaseTensor(wr)}}return H&&!w&&(c._OrtClearBoundOutputs(H.handle),rs.set(r,[T,E,q,H,w,!1])),Hr}finally{c.stackRestore(ze),me.forEach(xr=>c._OrtReleaseTensor(xr)),Fe.forEach(xr=>c._OrtReleaseTensor(xr)),Se.forEach(xr=>c._free(xr)),_e!==0&&c._OrtReleaseRunOptions(_e),be.forEach(xr=>c._free(xr))}},Gm=r=>{let i=Qr(),s=rs.get(r);if(!s)throw new Error("invalid session id");let u=s[0],d=i._OrtEndProfiling(u);d===0&&Nr("Can't get an profile file name."),i._OrtFree(d)},Hm=r=>{let i=[];for(let s of r){let u=s[2];!Array.isArray(u)&&"buffer"in u&&i.push(u.buffer)}return i}}),ns,di,Nl,bf,xf,Qp,qm,Xp,Ys,Zs,Uy,Vy,Wy,Gy,Hy,qy,Ky,Qy,Xy=m(()=>{bt(),jy(),kn(),lr(),ns=()=>!!N.wasm.proxy&&typeof document<"u",Nl=!1,bf=!1,xf=!1,Xp=new Map,Ys=(r,i)=>{let s=Xp.get(r);s?s.push(i):Xp.set(r,[i])},Zs=()=>{if(Nl||!bf||xf||!di)throw new Error("worker not ready")},Uy=r=>{switch(r.data.type){case"init-wasm":Nl=!1,r.data.err?(xf=!0,qm[1](r.data.err)):(bf=!0,qm[0]()),Qp&&(URL.revokeObjectURL(Qp),Qp=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let i=Xp.get(r.data.type);r.data.err?i.shift()[1](r.data.err):i.shift()[0](r.data.out);break}}},Vy=async()=>{if(!bf){if(Nl)throw new Error("multiple calls to 'initWasm()' detected.");if(xf)throw new Error("previous call to 'initWasm()' failed.");if(Nl=!0,ns())return new Promise((r,i)=>{di==null||di.terminate(),Gt().then(([s,u])=>{try{di=u,di.onerror=p=>i(p),di.onmessage=Uy,qm=[r,i];let d={type:"init-wasm",in:N};di.postMessage(d),Qp=s}catch(d){i(d)}},i)});try{await Ai(N.wasm),await Rm(N),bf=!0}catch(r){throw xf=!0,r}finally{Nl=!1}}},Wy=async r=>{if(ns())return Zs(),new Promise((i,s)=>{Ys("init-ep",[i,s]);let u={type:"init-ep",in:{epName:r,env:N}};di.postMessage(u)});await Nm(N,r)},Gy=async r=>ns()?(Zs(),new Promise((i,s)=>{Ys("copy-from",[i,s]);let u={type:"copy-from",in:{buffer:r}};di.postMessage(u,[r.buffer])})):Kp(r),Hy=async(r,i)=>{if(ns()){if(i!=null&&i.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Zs(),new Promise((s,u)=>{Ys("create",[s,u]);let d={type:"create",in:{model:r,options:{...i}}},p=[];r instanceof Uint8Array&&p.push(r.buffer),di.postMessage(d,p)})}else return jm(r,i)},qy=async r=>{if(ns())return Zs(),new Promise((i,s)=>{Ys("release",[i,s]);let u={type:"release",in:r};di.postMessage(u)});Um(r)},Ky=async(r,i,s,u,d,p)=>{if(ns()){if(s.some(c=>c[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(d.some(c=>c))throw new Error("pre-allocated output tensor is not supported for proxy.");return Zs(),new Promise((c,b)=>{Ys("run",[c,b]);let T=s,E={type:"run",in:{sessionId:r,inputIndices:i,inputs:T,outputIndices:u,options:p}};di.postMessage(E,Hm(T))})}else return Wm(r,i,s,u,d,p)},Qy=async r=>{if(ns())return Zs(),new Promise((i,s)=>{Ys("end-profiling",[i,s]);let u={type:"end-profiling",in:r};di.postMessage(u)});Gm(r)}}),Km,Yy,Zy,Ox=m(()=>{bt(),Xy(),Zt(),Ke(),Ho(),Km=(r,i)=>{switch(r.location){case"cpu":return[r.type,r.dims,r.data,"cpu"];case"gpu-buffer":return[r.type,r.dims,{gpuBuffer:r.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${r.location} for ${i()}`)}},Yy=r=>{switch(r[3]){case"cpu":return new Ge(r[0],r[2],r[1]);case"gpu-buffer":{let i=r[0];if(!yo(i))throw new Error(`not supported data type: ${i} for deserializing GPU tensor`);let{gpuBuffer:s,download:u,dispose:d}=r[2];return Ge.fromGpuBuffer(s,{dataType:i,dims:r[1],download:u,dispose:d})}default:throw new Error(`invalid data location: ${r[3]}`)}},Zy=class{async fetchModelAndCopyToWasmMemory(r){return Gy(await no(r))}async loadModel(r,i){et();let s;typeof r=="string"?s=await this.fetchModelAndCopyToWasmMemory(r):s=r,[this.sessionId,this.inputNames,this.outputNames]=await Hy(s,i),A()}async dispose(){return qy(this.sessionId)}async run(r,i,s){et();let u=[],d=[];Object.entries(r).forEach(H=>{let w=H[0],Z=H[1],re=this.inputNames.indexOf(w);if(re===-1)throw new Error(`invalid input '${w}'`);u.push(Z),d.push(re)});let p=[],c=[];Object.entries(i).forEach(H=>{let w=H[0],Z=H[1],re=this.outputNames.indexOf(w);if(re===-1)throw new Error(`invalid output '${w}'`);p.push(Z),c.push(re)});let b=u.map((H,w)=>Km(H,()=>`input "${this.inputNames[d[w]]}"`)),T=p.map((H,w)=>H?Km(H,()=>`output "${this.outputNames[c[w]]}"`):null),E=await Ky(this.sessionId,d,b,c,T,s),q={};for(let H=0;H<E.length;H++)q[this.outputNames[c[H]]]=p[H]??Yy(E[H]);return A(),q}startProfiling(){}endProfiling(){Qy(this.sessionId)}}}),Jy,ew,Dx=m(()=>{bt(),Xy(),Ox(),lr(),Jy=()=>{if((typeof N.wasm.initTimeout!="number"||N.wasm.initTimeout<0)&&(N.wasm.initTimeout=0),N.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof N.wasm.proxy!="boolean"&&(N.wasm.proxy=!1),typeof N.wasm.trace!="boolean"&&(N.wasm.trace=!1),typeof N.wasm.numThreads!="number"||!Number.isInteger(N.wasm.numThreads)||N.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)N.wasm.numThreads=1;else{let r=typeof navigator>"u"?_("node:os").cpus().length:navigator.hardwareConcurrency;N.wasm.numThreads=Math.min(4,Math.ceil((r||1)/2))}},ew=class{async init(r){Jy(),await Vy(),await Wy(r)}async createInferenceSessionHandler(r,i){let s=new Zy;return await s.loadModel(r,i),Promise.resolve(s)}}}),tw={};g(tw,{wasmBackend:()=>rw});var rw,Lx=m(()=>{Dx(),rw=new ew});bt(),bt(),bt();var Bx="1.20.0-dev.20240827-1d059b8702",Rx=wt;{let r=(Lx(),v(tw)).wasmBackend;z("webgpu",r,5),z("webnn",r,5),z("cpu",r,10),z("wasm",r,10)}Object.defineProperty(N.versions,"web",{value:Bx,enumerable:!0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},"./src/backends/onnx.js":(e,t,n)=>{var o;n.r(t),n.d(t,{Tensor:()=>_.Tensor,createInferenceSession:()=>$,deviceToExecutionProviders:()=>k,isONNXProxy:()=>x,isONNXTensor:()=>S});var a=n("./src/env.js"),l=n("?2ce3"),f=n("./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs"),_=n("./node_modules/onnxruntime-common/dist/esm/index.js");const m=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),g=[];let M,v;if(a.apis.IS_NODE_ENV){switch(v=l??(o||(o=n.t(l,2))),process.platform){case"win32":g.push("dml");break;case"linux":process.arch==="x64"&&g.push("cuda");break}g.push("cpu"),M=["cpu"]}else v=f,a.apis.IS_WEBNN_AVAILABLE&&g.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),a.apis.IS_WEBGPU_AVAILABLE&&g.push("webgpu"),g.push("wasm"),M=["wasm"];const C=v.InferenceSession;function k(I=null){if(!I)return M;switch(I){case"auto":return g;case"gpu":return g.filter(V=>["webgpu","cuda","dml","webnn-gpu"].includes(V))}if(g.includes(I))return[m[I]??I];throw new Error(`Unsupported device: "${I}". Should be one of: ${g.join(", ")}.`)}let z=null;async function $(I,V){z&&await z;const O=C.create(I,V);return z??(z=O),await O}function S(I){return I instanceof v.Tensor}const y=v==null?void 0:v.env;y!=null&&y.wasm&&(y.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${a.env.version}/dist/`,y.wasm.proxy=!1,(typeof crossOriginIsolated>"u"||!crossOriginIsolated)&&(y.wasm.numThreads=1)),y!=null&&y.webgpu&&(y.webgpu.powerPreference="high-performance");function x(){var I;return(I=y==null?void 0:y.wasm)==null?void 0:I.proxy}a.env.backends.onnx=y},"./src/configs.js":(e,t,n)=>{n.r(t),n.d(t,{AutoConfig:()=>g,PretrainedConfig:()=>m,getKeyValueShapes:()=>_});var o=n("./src/utils/core.js"),a=n("./src/utils/hub.js");async function l(M,v){return await(0,a.getModelJSON)(M,"config.json",!0,v)}function f(M){const v={};let C={};switch(M.model_type){case"llava":case"paligemma":case"florence2":C=f(M.text_config);break;case"moondream1":C=f(M.phi_config);break;case"musicgen":C=f(M.decoder);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":v.num_heads="n_head",v.num_layers="n_layer",v.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"phi":case"phi3":case"falcon":v.num_heads="num_attention_heads",v.num_layers="num_hidden_layers",v.hidden_size="hidden_size";break;case"llama":case"cohere":case"mistral":case"starcoder2":case"qwen2":v.num_heads="num_key_value_heads",v.num_layers="num_hidden_layers",v.hidden_size="hidden_size",v.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":v.num_heads="num_key_value_heads",v.num_layers="num_hidden_layers",v.dim_kv="head_dim";break;case"openelm":v.num_heads="num_kv_heads",v.num_layers="num_transformer_layers",v.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":v.num_heads="num_heads",v.num_layers="num_layers",v.hidden_size="hidden_size";break;case"bloom":v.num_heads="n_head",v.num_layers="n_layer",v.hidden_size="hidden_size";break;case"mpt":v.num_heads="n_heads",v.num_layers="n_layers",v.hidden_size="d_model";break;case"t5":case"mt5":case"longt5":v.num_decoder_layers="num_decoder_layers",v.num_decoder_heads="num_heads",v.decoder_dim_kv="d_kv",v.num_encoder_layers="num_layers",v.num_encoder_heads="num_heads",v.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":v.num_decoder_layers="decoder_layers",v.num_decoder_heads="decoder_attention_heads",v.decoder_hidden_size="d_model",v.num_encoder_layers="encoder_layers",v.num_encoder_heads="encoder_attention_heads",v.encoder_hidden_size="d_model";break;case"speecht5":v.num_decoder_layers="decoder_layers",v.num_decoder_heads="decoder_attention_heads",v.decoder_hidden_size="hidden_size",v.num_encoder_layers="encoder_layers",v.num_encoder_heads="encoder_attention_heads",v.encoder_hidden_size="hidden_size";break;case"trocr":v.num_encoder_layers=v.num_decoder_layers="decoder_layers",v.num_encoder_heads=v.num_decoder_heads="decoder_attention_heads",v.encoder_hidden_size=v.decoder_hidden_size="d_model";break;case"musicgen_decoder":v.num_encoder_layers=v.num_decoder_layers="num_hidden_layers",v.num_encoder_heads=v.num_decoder_heads="num_attention_heads",v.encoder_hidden_size=v.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const z=f(M.decoder),$="num_decoder_layers"in z,S=(0,o.pick)(M,["model_type","is_encoder_decoder"]);return $?(S.num_decoder_layers=z.num_decoder_layers,S.num_decoder_heads=z.num_decoder_heads,S.decoder_hidden_size=z.decoder_hidden_size,S.num_encoder_layers=z.num_encoder_layers,S.num_encoder_heads=z.num_encoder_heads,S.encoder_hidden_size=z.encoder_hidden_size):(S.num_layers=z.num_layers,S.num_heads=z.num_heads,S.hidden_size=z.hidden_size),S}const k={...C,...(0,o.pick)(M,["model_type","multi_query","is_encoder_decoder"])};for(const z in v)k[z]=M[v[z]];return k}function _(M,{prefix:v="past_key_values"}={}){const C={},k=M.normalized_config,z=1;if(k.is_encoder_decoder&&"num_encoder_heads"in k&&"num_decoder_heads"in k){const $=k.encoder_dim_kv??k.encoder_hidden_size/k.num_encoder_heads,S=k.decoder_dim_kv??k.decoder_hidden_size/k.num_decoder_heads,y=[z,k.num_encoder_heads,0,$],x=[z,k.num_decoder_heads,0,S];for(let I=0;I<k.num_decoder_layers;++I)C[`${v}.${I}.encoder.key`]=y,C[`${v}.${I}.encoder.value`]=y,C[`${v}.${I}.decoder.key`]=x,C[`${v}.${I}.decoder.value`]=x}else{const $=k.num_heads,S=k.num_layers,y=k.dim_kv??k.hidden_size/(k.num_attention_heads??$);if(k.model_type==="falcon"){const x=[z*$,0,y];for(let I=0;I<S;++I)C[`${v}.${I}.key`]=x,C[`${v}.${I}.value`]=x}else if(k.multi_query){const x=[z*$,0,2*y];for(let I=0;I<S;++I)C[`${v}.${I}.key_value`]=x}else if(k.model_type==="bloom"){const x=[z*$,y,0],I=[z*$,0,y];for(let V=0;V<S;++V)C[`${v}.${V}.key`]=x,C[`${v}.${V}.value`]=I}else if(k.model_type==="openelm")for(let x=0;x<S;++x){const I=[z,$[x],0,y];C[`${v}.${x}.key`]=I,C[`${v}.${x}.value`]=I}else{const x=[z,$,0,y];for(let I=0;I<S;++I)C[`${v}.${I}.key`]=x,C[`${v}.${I}.value`]=x}}return C}class m{constructor(v){He(this,"max_position_embeddings");this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,v),this.normalized_config=f(this)}static async from_pretrained(v,{progress_callback:C=null,config:k=null,cache_dir:z=null,local_files_only:$=!1,revision:S="main"}={}){k&&!(k instanceof m)&&(k=new m(k));const y=k??await l(v,{progress_callback:C,config:k,cache_dir:z,local_files_only:$,revision:S});return new this(y)}}class g{static async from_pretrained(...v){return m.from_pretrained(...v)}}},"./src/env.js":(e,t,n)=>{var N;n.r(t),n.d(t,{apis:()=>S,env:()=>B});var o=n("?569f"),a=n("?3f59"),l=n("?154a");const f="3.0.0-alpha.13",_=typeof self<"u",m=_&&self.constructor.name==="DedicatedWorkerGlobalScope",g=_&&"caches"in self,M=typeof navigator<"u"&&"gpu"in navigator,v=typeof navigator<"u"&&"ml"in navigator,C=typeof process<"u",k=C&&((N=process==null?void 0:process.release)==null?void 0:N.name)==="node",z=!j(o),$=!j(a),S=Object.freeze({IS_BROWSER_ENV:_,IS_WEBWORKER_ENV:m,IS_WEB_CACHE_AVAILABLE:g,IS_WEBGPU_AVAILABLE:M,IS_WEBNN_AVAILABLE:v,IS_PROCESS_AVAILABLE:C,IS_NODE_ENV:k,IS_FS_AVAILABLE:z,IS_PATH_AVAILABLE:$}),y=z&&$,x=y?a.dirname(a.dirname(l.fileURLToPath(import.meta.url))):"./",I=y?a.join(x,"/.cache/"):null,V="/models/",O=y?a.join(x,V):V,B={version:f,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!_,localModelPath:O,useFS:z,useBrowserCache:g,useFSCache:z,cacheDir:I,useCustomCache:!1,customCache:null};function j(oe){return Object.keys(oe).length===0}},"./src/generation/configuration_utils.js":(e,t,n)=>{n.r(t),n.d(t,{GenerationConfig:()=>a});var o=n("./src/utils/core.js");class a{constructor(f){He(this,"max_length",20);He(this,"max_new_tokens",null);He(this,"min_length",0);He(this,"min_new_tokens",null);He(this,"early_stopping",!1);He(this,"max_time",null);He(this,"do_sample",!1);He(this,"num_beams",1);He(this,"num_beam_groups",1);He(this,"penalty_alpha",null);He(this,"use_cache",!0);He(this,"temperature",1);He(this,"top_k",50);He(this,"top_p",1);He(this,"typical_p",1);He(this,"epsilon_cutoff",0);He(this,"eta_cutoff",0);He(this,"diversity_penalty",0);He(this,"repetition_penalty",1);He(this,"encoder_repetition_penalty",1);He(this,"length_penalty",1);He(this,"no_repeat_ngram_size",0);He(this,"bad_words_ids",null);He(this,"force_words_ids",null);He(this,"renormalize_logits",!1);He(this,"constraints",null);He(this,"forced_bos_token_id",null);He(this,"forced_eos_token_id",null);He(this,"remove_invalid_values",!1);He(this,"exponential_decay_length_penalty",null);He(this,"suppress_tokens",null);He(this,"begin_suppress_tokens",null);He(this,"forced_decoder_ids",null);He(this,"guidance_scale",null);He(this,"num_return_sequences",1);He(this,"output_attentions",!1);He(this,"output_hidden_states",!1);He(this,"output_scores",!1);He(this,"return_dict_in_generate",!1);He(this,"pad_token_id",null);He(this,"bos_token_id",null);He(this,"eos_token_id",null);He(this,"encoder_no_repeat_ngram_size",0);He(this,"decoder_start_token_id",null);He(this,"generation_kwargs",{});Object.assign(this,(0,o.pick)(f,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(e,t,n)=>{n.r(t),n.d(t,{ClassifierFreeGuidanceLogitsProcessor:()=>y,ForcedBOSTokenLogitsProcessor:()=>m,ForcedEOSTokenLogitsProcessor:()=>g,LogitsProcessor:()=>l,LogitsProcessorList:()=>_,LogitsWarper:()=>f,MinLengthLogitsProcessor:()=>z,MinNewTokensLengthLogitsProcessor:()=>$,NoBadWordsLogitsProcessor:()=>S,NoRepeatNGramLogitsProcessor:()=>C,RepetitionPenaltyLogitsProcessor:()=>k,SuppressTokensAtBeginLogitsProcessor:()=>M,TemperatureLogitsWarper:()=>x,TopKLogitsWarper:()=>V,TopPLogitsWarper:()=>I,WhisperTimeStampLogitsProcessor:()=>v});var o=n("./src/utils/generic.js");n("./src/utils/tensor.js");var a=n("./src/utils/maths.js");class l extends o.Callable{_call(B,j){throw Error("`_call` should be implemented in a subclass")}}class f extends o.Callable{_call(B,j){throw Error("`_call` should be implemented in a subclass")}}class _ extends o.Callable{constructor(){super(),this.processors=[]}push(B){this.processors.push(B)}extend(B){this.processors.push(...B)}_call(B,j){let N=j;for(const oe of this.processors)N=oe(B,N);return N}[Symbol.iterator](){return this.processors.values()}}class m extends l{constructor(B){super(),this.bos_token_id=B}_call(B,j){for(let N=0;N<B.length;++N)if(B[N].length===1){const oe=j[N].data;oe.fill(-1/0),oe[this.bos_token_id]=0}return j}}class g extends l{constructor(B,j){super(),this.max_length=B,this.eos_token_id=Array.isArray(j)?j:[j]}_call(B,j){for(let N=0;N<B.length;++N)if(B[N].length===this.max_length-1){const oe=j[N].data;oe.fill(-1/0);for(const he of this.eos_token_id)oe[he]=0}return j}}class M extends l{constructor(B,j){super(),this.begin_suppress_tokens=B,this.begin_index=j}_call(B,j){for(let N=0;N<B.length;++N)if(B[N].length===this.begin_index){const oe=j[N].data;for(const he of this.begin_suppress_tokens)oe[he]=-1/0}return j}}class v extends l{constructor(B,j){super(),this.eos_token_id=Array.isArray(B.eos_token_id)?B.eos_token_id[0]:B.eos_token_id,this.no_timestamps_token_id=B.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=j.length,j.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=B.max_initial_timestamp_index}_call(B,j){for(let N=0;N<B.length;++N){const oe=j[N].data;if(oe[this.no_timestamps_token_id]=-1/0,B[N].length===this.begin_index-1){oe.fill(-1/0),oe[this.timestamp_begin]=0;continue}const he=B[N].slice(this.begin_index),Ie=he.length>=1&&he[he.length-1]>=this.timestamp_begin,te=he.length<2||he[he.length-2]>=this.timestamp_begin;if(Ie&&(te?oe.subarray(this.timestamp_begin).fill(-1/0):oe.subarray(0,this.eos_token_id).fill(-1/0)),B[N].length===this.begin_index&&this.max_initial_timestamp_index!==null){const Xe=this.timestamp_begin+this.max_initial_timestamp_index;oe.subarray(Xe+1).fill(-1/0)}const we=(0,a.log_softmax)(oe),L=Math.log(we.subarray(this.timestamp_begin).map(Math.exp).reduce((Xe,ye)=>Xe+ye)),Ce=(0,a.max)(we.subarray(0,this.timestamp_begin))[0];L>Ce&&oe.subarray(0,this.timestamp_begin).fill(-1/0)}return j}}class C extends l{constructor(B){super(),this.no_repeat_ngram_size=B}getNgrams(B){const j=B.length,N=[];for(let he=0;he<j+1-this.no_repeat_ngram_size;++he){const Ie=[];for(let te=0;te<this.no_repeat_ngram_size;++te)Ie.push(B[he+te]);N.push(Ie.map(Number))}const oe=new Map;for(const he of N){const Ie=he.slice(0,he.length-1),te=JSON.stringify(Ie),we=oe.get(te)??[];we.push(he[he.length-1]),oe.set(te,we)}return oe}getGeneratedNgrams(B,j){const N=j.slice(j.length+1-this.no_repeat_ngram_size,j.length);return B.get(JSON.stringify(N.map(Number)))??[]}calcBannedNgramTokens(B){const j=[];if(B.length+1<this.no_repeat_ngram_size)return j;{const N=this.getNgrams(B);return this.getGeneratedNgrams(N,B)}}_call(B,j){for(let N=0;N<B.length;++N){const oe=j[N].data,he=this.calcBannedNgramTokens(B[N]);for(const Ie of he)oe[Ie]=-1/0}return j}}class k extends l{constructor(B){super(),this.penalty=B}_call(B,j){for(let N=0;N<B.length;++N){const oe=j[N].data;for(const he of B[N]){const Ie=Number(he);oe[Ie]<0?oe[Ie]*=this.penalty:oe[Ie]/=this.penalty}}return j}}class z extends l{constructor(B,j){super(),this.min_length=B,this.eos_token_id=Array.isArray(j)?j:[j]}_call(B,j){for(let N=0;N<B.length;++N)if(B[N].length<this.min_length){const oe=j[N].data;for(const he of this.eos_token_id)oe[he]=-1/0}return j}}class $ extends l{constructor(B,j,N){super(),this.prompt_length_to_skip=B,this.min_new_tokens=j,this.eos_token_id=Array.isArray(N)?N:[N]}_call(B,j){for(let N=0;N<B.length;++N)if(B[N].length-this.prompt_length_to_skip<this.min_new_tokens){const he=j[N].data;for(const Ie of this.eos_token_id)he[Ie]=-1/0}return j}}class S extends l{constructor(B,j){super(),this.bad_words_ids=B,this.eos_token_id=Array.isArray(j)?j:[j]}_call(B,j){for(let N=0;N<B.length;++N){const oe=j[N].data;for(const he of this.bad_words_ids){let Ie=!0;for(let te=1;te<=he.length-1&&he.length<B[te].length;++te)if(he.at(-te-1)!=B[te].at(-te)){Ie=!1;break}Ie&&(oe[he.at(-1)]=-1/0)}}return j}}class y extends l{constructor(B){if(super(),B<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${B}.`);this.guidance_scale=B}_call(B,j){if(j.dims[0]!==2*B.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${j.dims[0]} for the logits and ${B.length} for the input ids.`);const N=B.length,oe=j.slice([0,N],null),he=j.slice([N,j.dims[0]],null);for(let Ie=0;Ie<he.data.length;++Ie)he.data[Ie]+=(oe.data[Ie]-he.data[Ie])*this.guidance_scale;return he}}class x extends f{constructor(B){super(),this.temperature=B}_call(B,j){const N=j.data;for(let oe=0;oe<N.length;++oe)N[oe]/=this.temperature;return j}}class I extends f{constructor(B,{filter_value:j=-1/0,min_tokens_to_keep:N=1}={}){if(super(),B<0||B>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${B}`);if(!Number.isInteger(N)||N<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${N}`);this.top_p=B,this.filter_value=j,this.min_tokens_to_keep=N}}class V extends f{constructor(B,{filter_value:j=-1/0,min_tokens_to_keep:N=1}={}){if(super(),!Number.isInteger(B)||B<0)throw new Error(`\`top_k\` must be a positive integer, but is ${B}`);this.top_k=Math.max(B,N),this.filter_value=j}}},"./src/generation/logits_sampler.js":(e,t,n)=>{n.r(t),n.d(t,{LogitsSampler:()=>f});var o=n("./src/utils/generic.js"),a=n("./src/utils/tensor.js"),l=n("./src/utils/maths.js");n("./src/generation/configuration_utils.js");class f extends o.Callable{constructor(v){super(),this.generation_config=v}async _call(v){return this.sample(v)}async sample(v){throw Error("sample should be implemented in subclasses.")}getLogits(v,C){let k=v.dims.at(-1),z=v.data;if(C===-1)z=z.slice(-k);else{let $=C*k;z=z.slice($,$+k)}return z}randomSelect(v){let C=0;for(let z=0;z<v.length;++z)C+=v[z];let k=Math.random()*C;for(let z=0;z<v.length;++z)if(k-=v[z],k<=0)return z;return 0}static getSampler(v){if(v.do_sample)return new m(v);if(v.num_beams>1)return new g(v);if(v.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${v.num_return_sequences}.`);return new _(v)}}class _ extends f{async sample(v){const C=(0,l.max)(v.data)[1];return[[BigInt(C),0]]}}class m extends f{async sample(v){let C=v.dims.at(-1);this.generation_config.top_k>0&&(C=Math.min(this.generation_config.top_k,C));const[k,z]=await(0,a.topk)(v,C),$=(0,l.softmax)(k.data);return Array.from({length:this.generation_config.num_beams},()=>{const S=this.randomSelect($);return[z.data[S],Math.log($[S])]})}}class g extends f{async sample(v){let C=v.dims.at(-1);this.generation_config.top_k>0&&(C=Math.min(this.generation_config.top_k,C));const[k,z]=await(0,a.topk)(v,C),$=(0,l.softmax)(k.data);return Array.from({length:this.generation_config.num_beams},(S,y)=>[z.data[y],Math.log($[y])])}}},"./src/generation/stopping_criteria.js":(e,t,n)=>{n.r(t),n.d(t,{EosTokenCriteria:()=>_,InterruptableStoppingCriteria:()=>m,MaxLengthCriteria:()=>f,StoppingCriteria:()=>a,StoppingCriteriaList:()=>l});var o=n("./src/utils/generic.js");class a extends o.Callable{_call(M,v){throw Error("StoppingCriteria needs to be subclassed")}}class l extends o.Callable{constructor(){super(),this.criteria=[]}push(M){this.criteria.push(M)}extend(M){M instanceof l?M=M.criteria:M instanceof a&&(M=[M]),this.criteria.push(...M)}_call(M,v){const C=new Array(M.length).fill(!1);for(const k of this.criteria){const z=k(M,v);for(let $=0;$<C.length;++$)C[$]||(C[$]=z[$])}return C}[Symbol.iterator](){return this.criteria.values()}}class f extends a{constructor(M,v=null){super(),this.max_length=M,this.max_position_embeddings=v}_call(M){return M.map(v=>v.length>=this.max_length)}}class _ extends a{constructor(M){super(),Array.isArray(M)||(M=[M]),this.eos_token_id=M}_call(M,v){return M.map(C=>{const k=C.at(-1);return this.eos_token_id.some(z=>k==z)})}}class m extends a{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(M,v){return new Array(M.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(e,t,n)=>{n.r(t),n.d(t,{BaseStreamer:()=>f,TextStreamer:()=>m,WhisperTextStreamer:()=>g});var o=n("./src/utils/core.js"),a=n("./src/tokenizers.js"),l=n("./src/env.js");class f{put(v){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const _=l.apis.IS_PROCESS_AVAILABLE?M=>process.stdout.write(M):M=>console.log(M);class m extends f{constructor(v,{skip_prompt:C=!1,callback_function:k=null,token_callback_function:z=null,decode_kwargs:$={},...S}={}){super(),this.tokenizer=v,this.skip_prompt=C,this.callback_function=k??_,this.token_callback_function=z,this.decode_kwargs={...$,...S},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(v){var $;if(v.length>1)throw Error("TextStreamer only supports batch size of 1");if(this.skip_prompt&&this.next_tokens_are_prompt){this.next_tokens_are_prompt=!1;return}const C=v[0];($=this.token_callback_function)==null||$.call(this,C),this.token_cache=(0,o.mergeArrays)(this.token_cache,C);const k=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let z;k.endsWith(`
`)?(z=k.slice(this.print_len),this.token_cache=[],this.print_len=0):k.length>0&&(0,a.is_chinese_char)(k.charCodeAt(k.length-1))?(z=k.slice(this.print_len),this.print_len+=z.length):(z=k.slice(this.print_len,k.lastIndexOf(" ")+1),this.print_len+=z.length),this.on_finalized_text(z,!1)}end(){let v;this.token_cache.length>0?(v=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):v="",this.next_tokens_are_prompt=!0,this.on_finalized_text(v,!0)}on_finalized_text(v,C){var k,z;v.length>0&&((k=this.callback_function)==null||k.call(this,v)),C&&this.callback_function===_&&l.apis.IS_PROCESS_AVAILABLE&&((z=this.callback_function)==null||z.call(this,`
`))}}class g extends m{constructor(v,{skip_prompt:C=!1,callback_function:k=null,token_callback_function:z=null,on_chunk_start:$=null,on_chunk_end:S=null,on_finalize:y=null,time_precision:x=.02,skip_special_tokens:I=!0,decode_kwargs:V={}}={}){super(v,{skip_prompt:C,callback_function:k,token_callback_function:z,decode_kwargs:{skip_special_tokens:I,...V}}),this.timestamp_begin=v.timestamp_begin,this.on_chunk_start=$,this.on_chunk_end=S,this.on_finalize=y,this.time_precision=x,this.waiting_for_timestamp=!1}put(v){var k,z;if(v.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const C=v[0];if(C.length===1){const $=Number(C[0])-this.timestamp_begin;if($>=0){const S=$*this.time_precision;this.waiting_for_timestamp?(k=this.on_chunk_end)==null||k.call(this,S):(z=this.on_chunk_start)==null||z.call(this,S),this.waiting_for_timestamp=!this.waiting_for_timestamp,v=[[]]}}return super.put(v)}end(){var v;super.end(),(v=this.on_finalize)==null||v.call(this)}}},"./src/models.js":(e,t,n)=>{n.r(t),n.d(t,{ASTForAudioClassification:()=>Is,ASTModel:()=>jt,ASTPreTrainedModel:()=>Qn,AlbertForMaskedLM:()=>Zt,AlbertForQuestionAnswering:()=>wo,AlbertForSequenceClassification:()=>yo,AlbertModel:()=>ro,AlbertPreTrainedModel:()=>Fi,AutoModel:()=>Al,AutoModelForAudioClassification:()=>Up,AutoModelForAudioFrameClassification:()=>cf,AutoModelForCTC:()=>lf,AutoModelForCausalLM:()=>ef,AutoModelForDepthEstimation:()=>pf,AutoModelForDocumentQuestionAnswering:()=>df,AutoModelForImageClassification:()=>nf,AutoModelForImageFeatureExtraction:()=>mf,AutoModelForImageMatting:()=>ff,AutoModelForImageSegmentation:()=>of,AutoModelForImageToImage:()=>Vp,AutoModelForMaskGeneration:()=>Dl,AutoModelForMaskedLM:()=>tf,AutoModelForNormalEstimation:()=>hf,AutoModelForObjectDetection:()=>sf,AutoModelForQuestionAnswering:()=>zl,AutoModelForSemanticSegmentation:()=>Ol,AutoModelForSeq2SeqLM:()=>ts,AutoModelForSequenceClassification:()=>Il,AutoModelForSpeechSeq2Seq:()=>Zd,AutoModelForTextToSpectrogram:()=>Jd,AutoModelForTextToWaveform:()=>Fl,AutoModelForTokenClassification:()=>Yd,AutoModelForVision2Seq:()=>rf,AutoModelForXVector:()=>uf,AutoModelForZeroShotObjectDetection:()=>af,BartForConditionalGeneration:()=>W,BartForSequenceClassification:()=>fe,BartModel:()=>Ue,BartPretrainedModel:()=>qn,BaseModelOutput:()=>qe,BeitForImageClassification:()=>Mc,BeitModel:()=>xc,BeitPreTrainedModel:()=>Ba,BertForMaskedLM:()=>We,BertForQuestionAnswering:()=>Ge,BertForSequenceClassification:()=>st,BertForTokenClassification:()=>pt,BertModel:()=>Ne,BertPreTrainedModel:()=>Be,BlenderbotForConditionalGeneration:()=>Ot,BlenderbotModel:()=>Ct,BlenderbotPreTrainedModel:()=>Pt,BlenderbotSmallForConditionalGeneration:()=>cr,BlenderbotSmallModel:()=>Dr,BlenderbotSmallPreTrainedModel:()=>sr,BloomForCausalLM:()=>oc,BloomModel:()=>wp,BloomPreTrainedModel:()=>Ds,CLIPModel:()=>Tu,CLIPPreTrainedModel:()=>Yo,CLIPSegForImageSegmentation:()=>Iu,CLIPSegModel:()=>Au,CLIPSegPreTrainedModel:()=>ba,CLIPTextModelWithProjection:()=>bi,CLIPVisionModelWithProjection:()=>Su,CamembertForMaskedLM:()=>de,CamembertForQuestionAnswering:()=>ot,CamembertForSequenceClassification:()=>Ae,CamembertForTokenClassification:()=>Ve,CamembertModel:()=>Ke,CamembertPreTrainedModel:()=>bt,CausalLMOutput:()=>oo,CausalLMOutputWithPast:()=>Wp,ChineseCLIPModel:()=>$u,ChineseCLIPPreTrainedModel:()=>Pu,ClapAudioModelWithProjection:()=>xd,ClapModel:()=>vd,ClapPreTrainedModel:()=>yl,ClapTextModelWithProjection:()=>bd,CodeGenForCausalLM:()=>Vu,CodeGenModel:()=>ui,CodeGenPreTrainedModel:()=>zs,CohereForCausalLM:()=>qu,CohereModel:()=>Hu,CoherePreTrainedModel:()=>Ea,ConvBertForMaskedLM:()=>R,ConvBertForQuestionAnswering:()=>ce,ConvBertForSequenceClassification:()=>ee,ConvBertForTokenClassification:()=>D,ConvBertModel:()=>ve,ConvBertPreTrainedModel:()=>ne,ConvNextForImageClassification:()=>Hc,ConvNextModel:()=>Gc,ConvNextPreTrainedModel:()=>Za,ConvNextV2ForImageClassification:()=>Kc,ConvNextV2Model:()=>qc,ConvNextV2PreTrainedModel:()=>Ja,DPTForDepthEstimation:()=>Bc,DPTModel:()=>Lc,DPTPreTrainedModel:()=>Qa,DebertaForMaskedLM:()=>xt,DebertaForQuestionAnswering:()=>kt,DebertaForSequenceClassification:()=>vt,DebertaForTokenClassification:()=>$t,DebertaModel:()=>ft,DebertaPreTrainedModel:()=>Qe,DebertaV2ForMaskedLM:()=>Rt,DebertaV2ForQuestionAnswering:()=>Gt,DebertaV2ForSequenceClassification:()=>Qt,DebertaV2ForTokenClassification:()=>Ht,DebertaV2Model:()=>Nt,DebertaV2PreTrainedModel:()=>rt,DeiTForImageClassification:()=>Fc,DeiTModel:()=>Ic,DeiTPreTrainedModel:()=>Ua,DepthAnythingForDepthEstimation:()=>Nc,DepthAnythingPreTrainedModel:()=>Rc,DetrForObjectDetection:()=>Tc,DetrForSegmentation:()=>Zo,DetrModel:()=>kc,DetrObjectDetectionOutput:()=>Ra,DetrPreTrainedModel:()=>Bs,DetrSegmentationOutput:()=>Rs,Dinov2ForImageClassification:()=>Xc,Dinov2Model:()=>Qc,Dinov2PreTrainedModel:()=>el,DistilBertForMaskedLM:()=>Tt,DistilBertForQuestionAnswering:()=>mt,DistilBertForSequenceClassification:()=>lr,DistilBertForTokenClassification:()=>kr,DistilBertModel:()=>ir,DistilBertPreTrainedModel:()=>tr,DonutSwinModel:()=>ci,DonutSwinPreTrainedModel:()=>Wc,EfficientNetForImageClassification:()=>Ap,EfficientNetModel:()=>Sd,EfficientNetPreTrainedModel:()=>xl,ElectraForMaskedLM:()=>Re,ElectraForQuestionAnswering:()=>wt,ElectraForSequenceClassification:()=>ht,ElectraForTokenClassification:()=>tt,ElectraModel:()=>ke,ElectraPreTrainedModel:()=>ue,EsmForMaskedLM:()=>yi,EsmForSequenceClassification:()=>Ai,EsmForTokenClassification:()=>Qr,EsmModel:()=>nn,EsmPreTrainedModel:()=>Lt,FalconForCausalLM:()=>_l,FalconModel:()=>wd,FalconPreTrainedModel:()=>yd,FastViTForImageClassification:()=>vp,FastViTModel:()=>fc,FastViTPreTrainedModel:()=>za,Florence2ForConditionalGeneration:()=>wa,Florence2PreTrainedModel:()=>ku,GLPNForDepthEstimation:()=>Vc,GLPNModel:()=>xp,GLPNPreTrainedModel:()=>Ya,GPT2LMHeadModel:()=>zu,GPT2Model:()=>Fu,GPT2PreTrainedModel:()=>xa,GPTBigCodeForCausalLM:()=>Fs,GPTBigCodeModel:()=>Uu,GPTBigCodePreTrainedModel:()=>ri,GPTJForCausalLM:()=>yp,GPTJModel:()=>ju,GPTJPreTrainedModel:()=>Ta,GPTNeoForCausalLM:()=>Bu,GPTNeoModel:()=>Lu,GPTNeoPreTrainedModel:()=>Ma,GPTNeoXForCausalLM:()=>Nu,GPTNeoXModel:()=>Ru,GPTNeoXPreTrainedModel:()=>ka,Gemma2ForCausalLM:()=>Yu,Gemma2Model:()=>Xu,Gemma2PreTrainedModel:()=>ni,GemmaForCausalLM:()=>Qu,GemmaModel:()=>Ku,GemmaPreTrainedModel:()=>Ca,HubertForCTC:()=>cd,HubertForSequenceClassification:()=>Ep,HubertModel:()=>ud,HubertPreTrainedModel:()=>Sp,ImageMattingOutput:()=>_f,JAISLMHeadModel:()=>Du,JAISModel:()=>Ou,JAISPreTrainedModel:()=>ti,LlamaForCausalLM:()=>Gu,LlamaModel:()=>Wu,LlamaPreTrainedModel:()=>Sa,LlavaForConditionalGeneration:()=>xo,LlavaPreTrainedModel:()=>Mu,LongT5ForConditionalGeneration:()=>Qo,LongT5Model:()=>Ko,LongT5PreTrainedModel:()=>vo,M2M100ForConditionalGeneration:()=>nl,M2M100Model:()=>Ki,M2M100PreTrainedModel:()=>zi,MBartForCausalLM:()=>Et,MBartForConditionalGeneration:()=>Le,MBartForSequenceClassification:()=>nt,MBartModel:()=>Oe,MBartPreTrainedModel:()=>Ee,MPNetForMaskedLM:()=>Uo,MPNetForQuestionAnswering:()=>Go,MPNetForSequenceClassification:()=>Vo,MPNetForTokenClassification:()=>Wo,MPNetModel:()=>$s,MPNetPreTrainedModel:()=>Ii,MT5ForConditionalGeneration:()=>Kr,MT5Model:()=>Xo,MT5PreTrainedModel:()=>bo,MarianMTModel:()=>qi,MarianModel:()=>kp,MarianPreTrainedModel:()=>rl,MaskedLMOutput:()=>bn,MistralForCausalLM:()=>ml,MistralModel:()=>md,MistralPreTrainedModel:()=>hl,MobileBertForMaskedLM:()=>wi,MobileBertForQuestionAnswering:()=>Wi,MobileBertForSequenceClassification:()=>Nr,MobileBertModel:()=>Yr,MobileBertPreTrainedModel:()=>kn,MobileNetV1ForImageClassification:()=>Qs,MobileNetV1Model:()=>zp,MobileNetV1PreTrainedModel:()=>Tl,MobileNetV2ForImageClassification:()=>Ed,MobileNetV2Model:()=>Sl,MobileNetV2PreTrainedModel:()=>So,MobileNetV3ForImageClassification:()=>Pd,MobileNetV3Model:()=>Cd,MobileNetV3PreTrainedModel:()=>El,MobileNetV4ForImageClassification:()=>Ad,MobileNetV4Model:()=>$d,MobileNetV4PreTrainedModel:()=>Xs,MobileViTForImageClassification:()=>mc,MobileViTModel:()=>bp,MobileViTPreTrainedModel:()=>Oa,MobileViTV2ForImageClassification:()=>_c,MobileViTV2Model:()=>gc,MobileViTV2PreTrainedModel:()=>Tr,ModelOutput:()=>ge,Moondream1ForConditionalGeneration:()=>dr,MptForCausalLM:()=>ac,MptModel:()=>sc,MptPreTrainedModel:()=>Fa,MusicgenForCausalLM:()=>Fp,MusicgenForConditionalGeneration:()=>kl,MusicgenModel:()=>Ip,MusicgenPreTrainedModel:()=>Ml,NomicBertModel:()=>je,NomicBertPreTrainedModel:()=>xe,OPTForCausalLM:()=>uc,OPTModel:()=>lc,OPTPreTrainedModel:()=>ko,OpenELMForCausalLM:()=>Ju,OpenELMModel:()=>Zu,OpenELMPreTrainedModel:()=>Pa,OwlViTForObjectDetection:()=>wc,OwlViTModel:()=>yc,OwlViTPreTrainedModel:()=>Da,Owlv2ForObjectDetection:()=>bc,Owlv2Model:()=>vc,Owlv2PreTrainedModel:()=>La,Phi3ForCausalLM:()=>ic,Phi3Model:()=>nc,Phi3PreTrainedModel:()=>Os,PhiForCausalLM:()=>Ia,PhiModel:()=>rc,PhiPreTrainedModel:()=>Aa,PreTrainedModel:()=>X,PretrainedMixin:()=>Lr,PyAnnoteForAudioFrameClassification:()=>nd,PyAnnoteModel:()=>rd,PyAnnotePreTrainedModel:()=>sl,QuestionAnsweringModelOutput:()=>Fn,Qwen2ForCausalLM:()=>tc,Qwen2Model:()=>ec,Qwen2PreTrainedModel:()=>$a,RTDetrForObjectDetection:()=>Ec,RTDetrModel:()=>Sc,RTDetrObjectDetectionOutput:()=>Cc,RTDetrPreTrainedModel:()=>Na,ResNetForImageClassification:()=>Oc,ResNetModel:()=>zc,ResNetPreTrainedModel:()=>Va,RoFormerForMaskedLM:()=>A,RoFormerForQuestionAnswering:()=>ae,RoFormerForSequenceClassification:()=>$e,RoFormerForTokenClassification:()=>Pe,RoFormerModel:()=>et,RoFormerPreTrainedModel:()=>Ye,RobertaForMaskedLM:()=>An,RobertaForQuestionAnswering:()=>ei,RobertaForSequenceClassification:()=>vn,RobertaForTokenClassification:()=>Ze,RobertaModel:()=>vr,RobertaPreTrainedModel:()=>Xt,SamImageSegmentationOutput:()=>td,SamModel:()=>ed,SamPreTrainedModel:()=>Jc,SapiensForDepthEstimation:()=>jc,SapiensForNormalEstimation:()=>Uc,SapiensForSemanticSegmentation:()=>Xa,SapiensPreTrainedModel:()=>Ns,SegformerForImageClassification:()=>Md,SegformerForSemanticSegmentation:()=>kd,SegformerModel:()=>Pp,SegformerPreTrainedModel:()=>Ks,Seq2SeqLMOutput:()=>zm,SequenceClassifierOutput:()=>mr,SiglipModel:()=>Mo,SiglipPreTrainedModel:()=>va,SiglipTextModel:()=>Eu,SiglipVisionModel:()=>Cu,SpeechT5ForSpeechToText:()=>Hs,SpeechT5ForTextToSpeech:()=>hd,SpeechT5HifiGan:()=>qs,SpeechT5Model:()=>dl,SpeechT5PreTrainedModel:()=>Gs,SqueezeBertForMaskedLM:()=>_o,SqueezeBertForQuestionAnswering:()=>Hi,SqueezeBertForSequenceClassification:()=>vi,SqueezeBertModel:()=>As,SqueezeBertPreTrainedModel:()=>Gi,StableLmForCausalLM:()=>Td,StableLmModel:()=>$p,StableLmPreTrainedModel:()=>bl,Starcoder2ForCausalLM:()=>_d,Starcoder2Model:()=>gd,Starcoder2PreTrainedModel:()=>gl,Swin2SRForImageSuperResolution:()=>Ka,Swin2SRModel:()=>qa,Swin2SRPreTrainedModel:()=>Ha,SwinForImageClassification:()=>Ga,SwinModel:()=>Dc,SwinPreTrainedModel:()=>Wa,T5ForConditionalGeneration:()=>qo,T5Model:()=>Ho,T5PreTrainedModel:()=>no,TableTransformerForObjectDetection:()=>$c,TableTransformerModel:()=>Pc,TableTransformerObjectDetectionOutput:()=>Ac,TableTransformerPreTrainedModel:()=>ja,TokenClassifierOutput:()=>yn,TrOCRForCausalLM:()=>pl,TrOCRPreTrainedModel:()=>fl,UniSpeechForCTC:()=>id,UniSpeechForSequenceClassification:()=>ll,UniSpeechModel:()=>Ws,UniSpeechPreTrainedModel:()=>Vs,UniSpeechSatForAudioFrameClassification:()=>ad,UniSpeechSatForCTC:()=>sd,UniSpeechSatForSequenceClassification:()=>Tp,UniSpeechSatModel:()=>od,UniSpeechSatPreTrainedModel:()=>io,ViTForImageClassification:()=>dc,ViTModel:()=>cc,ViTPreTrainedModel:()=>Ls,VisionEncoderDecoderModel:()=>ya,VitMatteForImageMatting:()=>hc,VitMattePreTrainedModel:()=>pc,VitsModel:()=>vl,VitsModelOutput:()=>yf,VitsPreTrainedModel:()=>wl,Wav2Vec2BertForCTC:()=>ld,Wav2Vec2BertForSequenceClassification:()=>ul,Wav2Vec2BertModel:()=>es,Wav2Vec2BertPreTrainedModel:()=>Jo,Wav2Vec2ForAudioFrameClassification:()=>ol,Wav2Vec2ForCTC:()=>il,Wav2Vec2ForSequenceClassification:()=>js,Wav2Vec2Model:()=>Sn,Wav2Vec2PreTrainedModel:()=>Rn,WavLMForAudioFrameClassification:()=>pd,WavLMForCTC:()=>Cp,WavLMForSequenceClassification:()=>cl,WavLMForXVector:()=>fd,WavLMModel:()=>dd,WavLMPreTrainedModel:()=>To,WeSpeakerResNetModel:()=>al,WeSpeakerResNetPreTrainedModel:()=>Us,WhisperForConditionalGeneration:()=>_a,WhisperModel:()=>qt,WhisperPreTrainedModel:()=>gt,XLMForQuestionAnswering:()=>Tn,XLMForSequenceClassification:()=>Jt,XLMForTokenClassification:()=>Kn,XLMModel:()=>hn,XLMPreTrainedModel:()=>Pr,XLMRobertaForMaskedLM:()=>zt,XLMRobertaForQuestionAnswering:()=>Zr,XLMRobertaForSequenceClassification:()=>Ar,XLMRobertaForTokenClassification:()=>jr,XLMRobertaModel:()=>$r,XLMRobertaPreTrainedModel:()=>zr,XLMWithLMHeadModel:()=>Bn,XVectorOutput:()=>gf,YolosForObjectDetection:()=>Yc,YolosModel:()=>Mp,YolosObjectDetectionOutput:()=>Zc,YolosPreTrainedModel:()=>tl});var o=n("./src/configs.js"),a=n("./src/backends/onnx.js"),l=n("./src/utils/dtypes.js"),f=n("./src/utils/generic.js"),_=n("./src/utils/core.js"),m=n("./src/utils/hub.js"),g=n("./src/generation/logits_process.js"),M=n("./src/generation/configuration_utils.js"),v=n("./src/utils/tensor.js"),C=n("./src/utils/maths.js"),k=n("./src/generation/stopping_criteria.js"),z=n("./src/generation/logits_sampler.js"),$=n("./src/env.js"),S=n("./src/models/whisper/generation_whisper.js"),y=n("./src/models/whisper/common_whisper.js");const x={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7},I=new Map,V=new Map,O=new Map;async function B(U,G,ie){let Te=ie.device;Te&&typeof Te!="string"&&(Te.hasOwnProperty(G)?Te=Te[G]:(console.warn(`device not specified for "${G}". Using the default device.`),Te=null));const Je=Te??($.apis.IS_NODE_ENV?"cpu":"wasm"),at=(0,a.deviceToExecutionProviders)(Je);let _t=ie.dtype;typeof _t!="string"&&(_t&&_t.hasOwnProperty(G)?_t=_t[G]:(_t=l.DEFAULT_DEVICE_DTYPE_MAPPING[Je]??l.DATA_TYPES.fp32,console.warn(`dtype not specified for "${G}". Using the default dtype (${_t}) for this device (${Je}).`)));const It=_t;if(l.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(It)){if(It===l.DATA_TYPES.fp16&&Je==="webgpu"&&!await(0,l.isWebGpuFp16Supported)())throw new Error(`The device (${Je}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${It}. Should be one of: ${Object.keys(l.DATA_TYPES).join(", ")}`);const Kt=l.DEFAULT_DTYPE_SUFFIX_MAPPING[It],pr=`${ie.subfolder??""}/${G}${Kt}.onnx`,_r={...ie.session_options};_r.executionProviders??(_r.executionProviders=at);const Br=(0,m.getModelFile)(U,pr,!0,ie);let yr=[];if(ie.use_external_data_format&&(ie.use_external_data_format===!0||typeof ie.use_external_data_format=="object"&&ie.use_external_data_format.hasOwnProperty(G)&&ie.use_external_data_format[G]===!0)){if($.apis.IS_NODE_ENV)throw new Error("External data format is not yet supported in Node.js");const gr=`${G}${Kt}.onnx_data`,br=`${ie.subfolder??""}/${gr}`;yr.push(new Promise(async(Sr,Vr)=>{const Nn=await(0,m.getModelFile)(U,br,!0,ie);Sr({path:gr,data:Nn})}))}else _r.externalData!==void 0&&(yr=_r.externalData.map(async gr=>{if(typeof gr.data=="string"){const br=await(0,m.getModelFile)(U,gr.data,!0,ie);return{...gr,data:br}}return gr}));if(yr.length>0&&(_r.externalData=await Promise.all(yr)),Je==="webgpu"){const gr=(0,o.getKeyValueShapes)(ie.config,{prefix:"present"});if(Object.keys(gr).length>0&&!(0,a.isONNXProxy)()){const br={};for(const Sr in gr)br[Sr]="gpu-buffer";_r.preferredOutputLocation=br}}return{buffer:await Br,session_options:_r}}async function j(U,G,ie){return Object.fromEntries(await Promise.all(Object.keys(G).map(async Te=>{const{buffer:Je,session_options:at}=await B(U,G[Te],ie),_t=await(0,a.createInferenceSession)(Je,at);return[Te,_t]})))}function N(U,G){const ie=Object.create(null),Te=[];for(const _t of U.inputNames){const It=G[_t];if(!(It instanceof v.Tensor)){Te.push(_t);continue}ie[_t]=(0,a.isONNXProxy)()?It.clone():It}if(Te.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${Te.join(", ")}.`);const Je=Object.keys(G).length,at=U.inputNames.length;if(Je>at){let _t=Object.keys(G).filter(It=>!U.inputNames.includes(It));console.warn(`WARNING: Too many inputs were provided (${Je} > ${at}). The following inputs will be ignored: "${_t.join(", ")}".`)}return ie}async function oe(U,G){const ie=N(U,G);try{const Te=Object.fromEntries(Object.entries(ie).map(([at,_t])=>[at,_t.ort_tensor]));let Je=await U.run(Te);return Je=he(Je),Je}catch(Te){throw console.error(`An error occurred during model execution: "${Te}".`),console.error("Inputs given to model:",ie),Te}}function he(U){for(let G in U)(0,a.isONNXTensor)(U[G])?U[G]=new v.Tensor(U[G]):typeof U[G]=="object"&&he(U[G]);return U}function Ie(U){if(U instanceof v.Tensor)return U;if(U.length===0)throw Error("items must be non-empty");if(Array.isArray(U[0])){if(U.some(G=>G.length!==U[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new v.Tensor("int64",BigInt64Array.from(U.flat().map(G=>BigInt(G))),[U.length,U[0].length])}else return new v.Tensor("int64",BigInt64Array.from(U.map(G=>BigInt(G))),[1,U.length])}function te(U){return new v.Tensor("bool",[U],[1])}async function we(U,G){let{encoder_outputs:ie,input_ids:Te,decoder_input_ids:Je,...at}=G;if(!ie){const It=(0,_.pick)(G,U.sessions.model.inputNames);ie=(await L(U,It)).last_hidden_state}return at.input_ids=Je,at.encoder_hidden_states=ie,U.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(at.encoder_attention_mask=G.attention_mask),await Ce(U,at,!0)}async function L(U,G){const ie=U.sessions.model,Te=(0,_.pick)(G,ie.inputNames);if(ie.inputNames.includes("inputs_embeds")&&!Te.inputs_embeds){if(!G.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");Te.inputs_embeds=await U.encode_text({input_ids:G.input_ids})}return ie.inputNames.includes("token_type_ids")&&!Te.token_type_ids&&(Te.token_type_ids=new v.Tensor("int64",new BigInt64Array(Te.input_ids.data.length),Te.input_ids.dims)),await oe(ie,Te)}async function Ce(U,G,ie=!1){const Te=U.sessions[ie?"decoder_model_merged":"model"],{past_key_values:Je,...at}=G;Te.inputNames.includes("use_cache_branch")&&(at.use_cache_branch=te(!!Je)),Te.inputNames.includes("position_ids")&&at.attention_mask&&!at.position_ids&&(at.position_ids=ye(at,Je)),U.addPastKeyValues(at,Je);const _t=(0,_.pick)(at,Te.inputNames);return await oe(Te,_t)}async function Xe(U,{input_ids:G=null,attention_mask:ie=null,pixel_values:Te=null,position_ids:Je=null,inputs_embeds:at=null,past_key_values:_t=null,generation_config:It=null,logits_processor:Kt=null,...pr}){if(!at){if(at=await U.encode_text({input_ids:G}),Te&&G.dims[1]!==1){const Br=await U.encode_image({pixel_values:Te});({inputs_embeds:at,attention_mask:ie}=U._merge_input_ids_with_image_features({image_features:Br,inputs_embeds:at,input_ids:G,attention_mask:ie}))}else if(_t&&Te&&G.dims[1]===1){const Br=G.dims[1],yr=Object.values(_t)[0].dims.at(-2);ie=(0,v.cat)([(0,v.ones)([G.dims[0],yr]),ie.slice(null,[ie.dims[1]-Br,ie.dims[1]])],1)}}return await Ce(U,{inputs_embeds:at,past_key_values:_t,attention_mask:ie,position_ids:Je,generation_config:It,logits_processor:Kt},!0)}function ye(U,G=null){const{input_ids:ie,inputs_embeds:Te,attention_mask:Je}=U,[at,_t]=Je.dims,It=new BigInt64Array(Je.data.length);for(let pr=0;pr<at;++pr){const _r=pr*_t;let Br=BigInt(0);for(let yr=0;yr<_t;++yr){const Mr=_r+yr;Je.data[Mr]===0n?It[Mr]=BigInt(1):(It[Mr]=Br,Br+=Je.data[Mr])}}let Kt=new v.Tensor("int64",It,Je.dims);if(G){const pr=-(ie??Te).dims.at(1);Kt=Kt.slice(null,[pr,null])}return Kt}function Y(U,G,ie,Te){if(ie.past_key_values){const Je=Object.values(ie.past_key_values)[0].dims.at(-2),{input_ids:at,attention_mask:_t}=ie;if(!(_t&&_t.dims[1]>at.dims[1])){if(Je<at.dims[1])ie.input_ids=at.slice(null,[Je,null]);else if(U.config.image_token_index!=null&&at.data.some(It=>It==U.config.image_token_index)){const It=U.config.num_image_tokens;if(!It)throw new Error("`num_image_tokens` is missing in the model configuration.");const Kt=at.dims[1]-(Je-It);ie.input_ids=at.slice(null,[-Kt,null]),ie.attention_mask=(0,v.ones)([1,Je+Kt])}}}return ie}function se(U,G,ie,Te){return ie.past_key_values&&(G=G.map(Je=>[Je.at(-1)])),{...ie,decoder_input_ids:Ie(G)}}function Me(U,...G){return U.config.is_encoder_decoder?se(U,...G):Y(U,...G)}class X extends f.Callable{constructor(ie,Te){super();He(this,"main_input_name","input_ids");He(this,"forward_params",["input_ids","attention_mask"]);this.config=ie,this.sessions=Te;const Je=O.get(this.constructor),at=I.get(Je);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,at){case x.DecoderOnly:this.can_generate=!0,this._forward=Ce,this._prepare_inputs_for_generation=Y;break;case x.Seq2Seq:case x.Vision2Seq:case x.Musicgen:this.can_generate=!0,this._forward=we,this._prepare_inputs_for_generation=se;break;case x.EncoderDecoder:this._forward=we;break;case x.ImageTextToText:this.can_generate=!0,this._forward=Xe,this._prepare_inputs_for_generation=Me;break;default:this._forward=L;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){var Te;const ie=[];for(const Je of Object.values(this.sessions))(Te=Je==null?void 0:Je.handler)!=null&&Te.dispose&&ie.push(Je.handler.dispose());return await Promise.all(ie)}static async from_pretrained(ie,{progress_callback:Te=null,config:Je=null,cache_dir:at=null,local_files_only:_t=!1,revision:It="main",model_file_name:Kt=null,subfolder:pr="onnx",device:_r=null,dtype:Br=null,use_external_data_format:yr=null,session_options:Mr={}}={}){let gr={progress_callback:Te,config:Je,cache_dir:at,local_files_only:_t,revision:It,model_file_name:Kt,subfolder:pr,device:_r,dtype:Br,use_external_data_format:yr,session_options:Mr};const br=O.get(this),Sr=I.get(br);Je=gr.config=await o.AutoConfig.from_pretrained(ie,gr);let Vr;if(Sr===x.DecoderOnly)Vr=await Promise.all([j(ie,{model:gr.model_file_name??"model"},gr),(0,m.getModelJSON)(ie,"generation_config.json",!1,gr)]);else if(Sr===x.Seq2Seq||Sr===x.Vision2Seq)Vr=await Promise.all([j(ie,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},gr),(0,m.getModelJSON)(ie,"generation_config.json",!1,gr)]);else if(Sr===x.MaskGeneration)Vr=await Promise.all([j(ie,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},gr)]);else if(Sr===x.EncoderDecoder)Vr=await Promise.all([j(ie,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},gr)]);else if(Sr===x.ImageTextToText){const Nn={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};Je.is_encoder_decoder&&(Nn.model="encoder_model"),Vr=await Promise.all([j(ie,Nn,gr),(0,m.getModelJSON)(ie,"generation_config.json",!1,gr)])}else Sr===x.Musicgen?Vr=await Promise.all([j(ie,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},gr),(0,m.getModelJSON)(ie,"generation_config.json",!1,gr)]):(Sr!==x.EncoderOnly&&console.warn(`Model type for '${br??(Je==null?void 0:Je.model_type)}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),Vr=await Promise.all([j(ie,{model:gr.model_file_name??"model"},gr)]));return new this(Je,...Vr)}async _call(ie){return await this.forward(ie)}async forward(ie){return await this._forward(this,ie)}_get_logits_warper(ie){const Te=new g.LogitsProcessorList;return ie.temperature!==null&&ie.temperature!==1&&Te.push(new g.TemperatureLogitsWarper(ie.temperature)),ie.top_k!==null&&ie.top_k!==0&&Te.push(new g.TopKLogitsWarper(ie.top_k)),ie.top_p!==null&&ie.top_p<1&&Te.push(new g.TopPLogitsWarper(ie.top_p)),Te}_get_logits_processor(ie,Te,Je=null){const at=new g.LogitsProcessorList;if(ie.repetition_penalty!==null&&ie.repetition_penalty!==1&&at.push(new g.RepetitionPenaltyLogitsProcessor(ie.repetition_penalty)),ie.no_repeat_ngram_size!==null&&ie.no_repeat_ngram_size>0&&at.push(new g.NoRepeatNGramLogitsProcessor(ie.no_repeat_ngram_size)),ie.bad_words_ids!==null&&at.push(new g.NoBadWordsLogitsProcessor(ie.bad_words_ids,ie.eos_token_id)),ie.min_length!==null&&ie.eos_token_id!==null&&ie.min_length>0&&at.push(new g.MinLengthLogitsProcessor(ie.min_length,ie.eos_token_id)),ie.min_new_tokens!==null&&ie.eos_token_id!==null&&ie.min_new_tokens>0&&at.push(new g.MinNewTokensLengthLogitsProcessor(Te,ie.min_new_tokens,ie.eos_token_id)),ie.forced_bos_token_id!==null&&at.push(new g.ForcedBOSTokenLogitsProcessor(ie.forced_bos_token_id)),ie.forced_eos_token_id!==null&&at.push(new g.ForcedEOSTokenLogitsProcessor(ie.max_length,ie.forced_eos_token_id)),ie.begin_suppress_tokens!==null){const _t=Te>1||ie.forced_bos_token_id===null?Te:Te+1;at.push(new g.SuppressTokensAtBeginLogitsProcessor(ie.begin_suppress_tokens,_t))}return ie.guidance_scale!==null&&ie.guidance_scale>1&&at.push(new g.ClassifierFreeGuidanceLogitsProcessor(ie.guidance_scale)),Je!==null&&at.extend(Je),at}_prepare_generation_config(ie,Te,Je=M.GenerationConfig){const at={...this.config};for(const It of["decoder","generator","text_config"])It in at&&Object.assign(at,at[It]);const _t=new Je(at);return"generation_config"in this&&Object.assign(_t,this.generation_config),ie&&Object.assign(_t,ie),Te&&Object.assign(_t,(0,_.pick)(Te,Object.getOwnPropertyNames(_t))),_t}_get_stopping_criteria(ie,Te=null){const Je=new k.StoppingCriteriaList;return ie.max_length!==null&&Je.push(new k.MaxLengthCriteria(ie.max_length,this.config.max_position_embeddings??null)),ie.eos_token_id!==null&&Je.push(new k.EosTokenCriteria(ie.eos_token_id)),Te&&Je.extend(Te),Je}_validate_model_class(){if(!this.can_generate){const ie=[Dd,$l,Pl,Cl],Te=O.get(this.constructor),Je=new Set,at=this.config.model_type;for(const It of ie){const Kt=It.get(at);Kt&&Je.add(Kt[0])}let _t=`The current model class (${Te}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw Je.size>0&&(_t+=` Please use the following class instead: ${[...Je].join(", ")}`),Error(_t)}}prepare_inputs_for_generation(...ie){return this._prepare_inputs_for_generation(this,...ie)}_update_model_kwargs_for_generation({generated_input_ids:ie,outputs:Te,model_inputs:Je,is_encoder_decoder:at}){return Je.past_key_values=this.getPastKeyValues(Te,Je.past_key_values),Je.input_ids=new v.Tensor("int64",ie.flat(),[ie.length,1]),at||(Je.attention_mask=(0,v.cat)([Je.attention_mask,(0,v.ones)([Je.attention_mask.dims[0],1])],1)),Je.position_ids=null,Je}_prepare_model_inputs({inputs:ie,bos_token_id:Te,model_kwargs:Je}){const at=(0,_.pick)(Je,this.forward_params),_t=this.main_input_name;if(_t in at){if(ie)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else at[_t]=ie;return{inputs_tensor:at[_t],model_inputs:at,model_input_name:_t}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:ie,model_inputs:Te,model_input_name:Je,generation_config:at}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!Te.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:It,pixel_values:Kt,attention_mask:pr,..._r}=Te,Br=await this._prepare_inputs_embeds(Te);Te={..._r,...(0,_.pick)(Br,["inputs_embeds","attention_mask"])}}let{last_hidden_state:_t}=await L(this,Te);if(at.guidance_scale!==null&&at.guidance_scale>1)_t=(0,v.cat)([_t,(0,v.full_like)(_t,0)],0),"attention_mask"in Te&&(Te.attention_mask=(0,v.cat)([Te.attention_mask,(0,v.zeros_like)(Te.attention_mask)],0));else if(Te.decoder_input_ids){const It=Ie(Te.decoder_input_ids).dims[0];if(It!==_t.dims[0]){if(_t.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${_t.dims[0]}) than the decoder inputs (${It}).`);_t=(0,v.cat)(Array.from({length:It},()=>_t),0)}}return Te.encoder_outputs=_t,Te}_prepare_decoder_input_ids_for_generation({batch_size:ie,model_input_name:Te,model_kwargs:Je,decoder_start_token_id:at,bos_token_id:_t,generation_config:It}){let{decoder_input_ids:Kt,...pr}=Je;if(Kt)Array.isArray(Kt[0])||(Kt=Array.from({length:ie},()=>Kt));else if(at??(at=_t),this.config.model_type==="musicgen")Kt=Array.from({length:ie*this.config.decoder.num_codebooks},()=>[at]);else if(Array.isArray(at)){if(at.length!==ie)throw new Error(`\`decoder_start_token_id\` expcted to have length ${ie} but got ${at.length}`);Kt=at}else Kt=Array.from({length:ie},()=>[at]);return Kt=Ie(Kt),Je.decoder_attention_mask=(0,v.ones_like)(Kt),{input_ids:Kt,model_inputs:pr}}async generate({inputs:ie=null,generation_config:Te=null,logits_processor:Je=null,stopping_criteria:at=null,streamer:_t=null,...It}){this._validate_model_class(),Te=this._prepare_generation_config(Te,It);let{inputs_tensor:Kt,model_inputs:pr,model_input_name:_r}=this._prepare_model_inputs({inputs:ie,model_kwargs:It});const Br=this.config.is_encoder_decoder;Br&&("encoder_outputs"in pr||(pr=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:Kt,model_inputs:pr,model_input_name:_r,generation_config:Te})));let yr;Br?{input_ids:yr,model_inputs:pr}=this._prepare_decoder_input_ids_for_generation({batch_size:pr[_r].dims.at(0),model_input_name:_r,model_kwargs:pr,decoder_start_token_id:Te.decoder_start_token_id,bos_token_id:Te.bos_token_id,generation_config:Te}):yr=pr[_r];let Mr=yr.dims.at(-1);Te.max_new_tokens!==null&&(Te.max_length=Mr+Te.max_new_tokens);const gr=this._get_logits_processor(Te,Mr,Je),br=this._get_stopping_criteria(Te,at),Sr=pr[_r].dims.at(0),Vr=z.LogitsSampler.getSampler(Te),Nn=new Array(Sr).fill(0),jn=yr.tolist();_t&&_t.put(jn);let xi=null,zn={};for(;;){pr=this.prepare_inputs_for_generation(jn,pr,Te);const En=await this.forward(pr);if(Te.output_attentions&&Te.return_dict_in_generate){const Mi=this.getAttentions(En);for(const Eo in Mi)Eo in zn||(zn[Eo]=[]),zn[Eo].push(Mi[Eo])}const Ll=En.logits.slice(null,-1,null),Bl=gr(jn,Ll),Rl=[];for(let Mi=0;Mi<Bl.dims.at(0);++Mi){const Eo=Bl[Mi],Dm=await Vr(Eo);for(const[Gp,Hp]of Dm){const wf=BigInt(Gp);Nn[Mi]+=Hp,jn[Mi].push(wf),Rl.push([wf]);break}}if(_t&&_t.put(Rl),br(jn).every(Mi=>Mi)){Te.return_dict_in_generate&&(xi=this.getPastKeyValues(En,pr.past_key_values,!1));break}pr=this._update_model_kwargs_for_generation({generated_input_ids:Rl,outputs:En,model_inputs:pr,is_encoder_decoder:Br})}_t&&_t.end();const mn=new v.Tensor("int64",jn.flat(),[jn.length,jn[0].length]);return Te.return_dict_in_generate?{sequences:mn,past_key_values:xi,...zn}:mn}getPastKeyValues(ie,Te,Je=!0){const at=Object.create(null);for(const _t in ie)if(_t.startsWith("present")){const It=_t.replace("present","past_key_values");if(Te&&_t.includes("encoder"))at[It]=Te[It];else{if(Je&&Te){const Kt=Te[It];Kt.location==="gpu-buffer"&&Kt.dispose()}at[It]=ie[_t]}}return at}getAttentions(ie){const Te={};for(const Je of["cross_attentions","encoder_attentions","decoder_attentions"])for(const at in ie)at.startsWith(Je)&&(Je in Te||(Te[Je]=[]),Te[Je].push(ie[at]));return Te}addPastKeyValues(ie,Te){if(Te)Object.assign(ie,Te);else{const Je=this.custom_config.kv_cache_dtype??"float32",at=Je==="float16"?new Uint16Array:[],_t=(0,o.getKeyValueShapes)(this.config);for(const It in _t)ie[It]=new v.Tensor(Je,at,_t[It])}}async encode_image({pixel_values:ie}){const Te=(await oe(this.sessions.vision_encoder,{pixel_values:ie})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${Te.dims[1]}).`),this.config.num_image_tokens=Te.dims[1]),Te}async encode_text({input_ids:ie}){return(await oe(this.sessions.embed_tokens,{input_ids:ie})).inputs_embeds}}class ge{}class qe extends ge{constructor({last_hidden_state:G,hidden_states:ie=null,attentions:Te=null}){super(),this.last_hidden_state=G,this.hidden_states=ie,this.attentions=Te}}class Be extends X{}class Ne extends Be{}class We extends Be{async _call(G){return new bn(await super._call(G))}}class st extends Be{async _call(G){return new mr(await super._call(G))}}class pt extends Be{async _call(G){return new yn(await super._call(G))}}class Ge extends Be{async _call(G){return new Fn(await super._call(G))}}class xe extends X{}class je extends xe{}class Ye extends X{}class et extends Ye{}class A extends Ye{async _call(G){return new bn(await super._call(G))}}class $e extends Ye{async _call(G){return new mr(await super._call(G))}}class Pe extends Ye{async _call(G){return new yn(await super._call(G))}}class ae extends Ye{async _call(G){return new Fn(await super._call(G))}}class ne extends X{}class ve extends ne{}class R extends ne{async _call(G){return new bn(await super._call(G))}}class ee extends ne{async _call(G){return new mr(await super._call(G))}}class D extends ne{async _call(G){return new yn(await super._call(G))}}class ce extends ne{async _call(G){return new Fn(await super._call(G))}}class ue extends X{}class ke extends ue{}class Re extends ue{async _call(G){return new bn(await super._call(G))}}class ht extends ue{async _call(G){return new mr(await super._call(G))}}class tt extends ue{async _call(G){return new yn(await super._call(G))}}class wt extends ue{async _call(G){return new Fn(await super._call(G))}}class bt extends X{}class Ke extends bt{}class de extends bt{async _call(G){return new bn(await super._call(G))}}class Ae extends bt{async _call(G){return new mr(await super._call(G))}}class Ve extends bt{async _call(G){return new yn(await super._call(G))}}class ot extends bt{async _call(G){return new Fn(await super._call(G))}}class Qe extends X{}class ft extends Qe{}class xt extends Qe{async _call(G){return new bn(await super._call(G))}}class vt extends Qe{async _call(G){return new mr(await super._call(G))}}class $t extends Qe{async _call(G){return new yn(await super._call(G))}}class kt extends Qe{async _call(G){return new Fn(await super._call(G))}}class rt extends X{}class Nt extends rt{}class Rt extends rt{async _call(G){return new bn(await super._call(G))}}class Qt extends rt{async _call(G){return new mr(await super._call(G))}}class Ht extends rt{async _call(G){return new yn(await super._call(G))}}class Gt extends rt{async _call(G){return new Fn(await super._call(G))}}class tr extends X{}class ir extends tr{}class lr extends tr{async _call(G){return new mr(await super._call(G))}}class kr extends tr{async _call(G){return new yn(await super._call(G))}}class mt extends tr{async _call(G){return new Fn(await super._call(G))}}class Tt extends tr{async _call(G){return new bn(await super._call(G))}}class Lt extends X{}class nn extends Lt{}class yi extends Lt{async _call(G){return new bn(await super._call(G))}}class Ai extends Lt{async _call(G){return new mr(await super._call(G))}}class Qr extends Lt{async _call(G){return new yn(await super._call(G))}}class kn extends X{}class Yr extends kn{}class wi extends kn{async _call(G){return new bn(await super._call(G))}}class Nr extends kn{async _call(G){return new mr(await super._call(G))}}class Wi extends kn{async _call(G){return new Fn(await super._call(G))}}class Ii extends X{}class $s extends Ii{}class Uo extends Ii{async _call(G){return new bn(await super._call(G))}}class Vo extends Ii{async _call(G){return new mr(await super._call(G))}}class Wo extends Ii{async _call(G){return new yn(await super._call(G))}}class Go extends Ii{async _call(G){return new Fn(await super._call(G))}}class Gi extends X{}class As extends Gi{}class _o extends Gi{async _call(G){return new bn(await super._call(G))}}class vi extends Gi{async _call(G){return new mr(await super._call(G))}}class Hi extends Gi{async _call(G){return new Fn(await super._call(G))}}class Fi extends X{}class ro extends Fi{}class yo extends Fi{async _call(G){return new mr(await super._call(G))}}class wo extends Fi{async _call(G){return new Fn(await super._call(G))}}class Zt extends Fi{async _call(G){return new bn(await super._call(G))}}class no extends X{constructor(ie,Te,Je){super(ie,Te);He(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]);this.generation_config=Je}}class Ho extends no{}class qo extends no{}class vo extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Ko extends vo{}class Qo extends vo{}class bo extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Xo extends bo{}class Kr extends bo{}class qn extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Ue extends qn{}class W extends qn{}class fe extends qn{async _call(G){return new mr(await super._call(G))}}class Ee extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Oe extends Ee{}class Le extends Ee{}class nt extends Ee{async _call(G){return new mr(await super._call(G))}}class Et extends Ee{}class Pt extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Ct extends Pt{}class Ot extends Pt{}class sr extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Dr extends sr{}class cr extends sr{}class Xt extends X{}class vr extends Xt{}class An extends Xt{async _call(G){return new bn(await super._call(G))}}class vn extends Xt{async _call(G){return new mr(await super._call(G))}}class Ze extends Xt{async _call(G){return new yn(await super._call(G))}}class ei extends Xt{async _call(G){return new Fn(await super._call(G))}}class Pr extends X{}class hn extends Pr{}class Bn extends Pr{async _call(G){return new bn(await super._call(G))}}class Jt extends Pr{async _call(G){return new mr(await super._call(G))}}class Kn extends Pr{async _call(G){return new yn(await super._call(G))}}class Tn extends Pr{async _call(G){return new Fn(await super._call(G))}}class zr extends X{}class $r extends zr{}class zt extends zr{async _call(G){return new bn(await super._call(G))}}class Ar extends zr{async _call(G){return new mr(await super._call(G))}}class jr extends zr{async _call(G){return new yn(await super._call(G))}}class Zr extends zr{async _call(G){return new Fn(await super._call(G))}}class Qn extends X{}class jt extends Qn{}class Is extends Qn{}class gt extends X{constructor(ie,Te,Je){super(ie,Te);He(this,"requires_attention_mask",!1);He(this,"main_input_name","input_features");He(this,"forward_params",["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]);this.generation_config=Je}}class qt extends gt{}class _a extends gt{_prepare_generation_config(G,ie){return super._prepare_generation_config(G,ie,S.WhisperGenerationConfig)}_retrieve_init_tokens(G){const ie=[G.decoder_start_token_id];let Te=G.language;const Je=G.task;if(G.is_multilingual){Te||(console.warn("No language specified - defaulting to English (en)."),Te="en");const _t=`<|${(0,y.whisper_language_to_code)(Te)}|>`;ie.push(G.lang_to_id[_t]),ie.push(G.task_to_id[Je??"transcribe"])}else if(Te||Je)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!G.return_timestamps&&G.no_timestamps_token_id&&ie.at(-1)!==G.no_timestamps_token_id?ie.push(G.no_timestamps_token_id):G.return_timestamps&&ie.at(-1)===G.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),ie.pop()),ie.filter(at=>at!=null)}async generate({inputs:G=null,generation_config:ie=null,logits_processor:Te=null,stopping_criteria:Je=null,...at}){ie=this._prepare_generation_config(ie,at);const _t=at.decoder_input_ids??this._retrieve_init_tokens(ie);if(ie.return_timestamps&&(Te??(Te=new g.LogitsProcessorList),Te.push(new g.WhisperTimeStampLogitsProcessor(ie,_t))),ie.begin_suppress_tokens&&(Te??(Te=new g.LogitsProcessorList),Te.push(new g.SuppressTokensAtBeginLogitsProcessor(ie.begin_suppress_tokens,_t.length))),ie.return_token_timestamps){if(!ie.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");ie.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),ie.output_attentions=!0,ie.return_dict_in_generate=!0}const It=await super.generate({inputs:G,generation_config:ie,logits_processor:Te,decoder_input_ids:_t,...at});return ie.return_token_timestamps&&(It.token_timestamps=this._extract_token_timestamps(It,ie.alignment_heads,ie.num_frames)),It}_extract_token_timestamps(G,ie,Te=null,Je=.02){if(!G.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");Te==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let at=this.config.median_filter_width;at===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),at=7);const _t=G.cross_attentions,It=Array.from({length:this.config.decoder_layers},(br,Sr)=>(0,v.cat)(_t.map(Vr=>Vr[Sr]),2)),Kt=(0,v.stack)(ie.map(([br,Sr])=>{if(br>=It.length)throw new Error(`Layer index ${br} is out of bounds for cross attentions (length ${It.length}).`);return Te?It[br].slice(null,Sr,null,[0,Te]):It[br].slice(null,Sr)})).transpose(1,0,2,3),[pr,_r]=(0,v.std_mean)(Kt,-2,0,!0),Br=Kt.clone();for(let br=0;br<Br.dims[0];++br){const Sr=Br[br];for(let Vr=0;Vr<Sr.dims[0];++Vr){const Nn=Sr[Vr],jn=pr[br][Vr][0].data,xi=_r[br][Vr][0].data;for(let zn=0;zn<Nn.dims[0];++zn){let mn=Nn[zn].data;for(let En=0;En<mn.length;++En)mn[En]=(mn[En]-xi[En])/jn[En];mn.set((0,C.medianFilter)(mn,at))}}}const yr=[(0,v.mean)(Br,1)],Mr=G.sequences.dims,gr=new v.Tensor("float32",new Float32Array(Mr[0]*Mr[1]),Mr);for(let br=0;br<Mr[0];++br){const Sr=yr[br].neg().squeeze_(0),[Vr,Nn]=(0,C.dynamic_time_warping)(Sr.tolist()),jn=Array.from({length:Vr.length-1},(mn,En)=>Vr[En+1]-Vr[En]),xi=(0,_.mergeArrays)([1],jn).map(mn=>!!mn),zn=[];for(let mn=0;mn<xi.length;++mn)xi[mn]&&zn.push(Nn[mn]*Je);gr[br].data.set(zn,1)}return gr}}class ya extends X{constructor(ie,Te,Je){super(ie,Te);He(this,"main_input_name","pixel_values");He(this,"forward_params",["pixel_values","input_ids","encoder_hidden_states","past_key_values"]);this.generation_config=Je}}class Mu extends X{constructor(ie,Te,Je){super(ie,Te);He(this,"forward_params",["input_ids","pixel_values","attention_mask","position_ids","past_key_values"]);this.generation_config=Je}}class xo extends Mu{_merge_input_ids_with_image_features({inputs_embeds:G,image_features:ie,input_ids:Te,attention_mask:Je}){const at=this.config.image_token_index,It=Te.tolist().map(yr=>yr.findIndex(Mr=>Mr==at)),Kt=It.every(yr=>yr===-1),pr=It.every(yr=>yr!==-1);if(!Kt&&!pr)throw new Error("Every input should contain either 0 or 1 image token.");if(Kt)return{inputs_embeds:G,attention_mask:Je};const _r=[],Br=[];for(let yr=0;yr<It.length;++yr){const Mr=It[yr],gr=G[yr],br=ie[yr],Sr=Je[yr];_r.push((0,v.cat)([gr.slice([0,Mr]),br,gr.slice([Mr+1,gr.dims[0]])],0)),Br.push((0,v.cat)([Sr.slice([0,Mr]),(0,v.ones)([br.dims[0]]),Sr.slice([Mr+1,Sr.dims[0]])],0))}return{inputs_embeds:(0,v.stack)(_r,0),attention_mask:(0,v.stack)(Br,0)}}}class dr extends xo{}class ku extends X{constructor(ie,Te,Je){super(ie,Te);He(this,"forward_params",["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"]);He(this,"main_input_name","inputs_embeds");this.generation_config=Je}}class wa extends ku{_merge_input_ids_with_image_features({inputs_embeds:G,image_features:ie,input_ids:Te,attention_mask:Je}){return{inputs_embeds:(0,v.cat)([ie,G],1),attention_mask:(0,v.cat)([(0,v.ones)(ie.dims.slice(0,2)),Je],1)}}async _prepare_inputs_embeds({input_ids:G,pixel_values:ie,inputs_embeds:Te,attention_mask:Je}){if(!G&&!ie)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let at,_t;return G&&(at=await this.encode_text({input_ids:G})),ie&&(_t=await this.encode_image({pixel_values:ie})),at&&_t?{inputs_embeds:Te,attention_mask:Je}=this._merge_input_ids_with_image_features({inputs_embeds:at,image_features:_t,input_ids:G,attention_mask:Je}):Te=at||_t,{inputs_embeds:Te,attention_mask:Je}}async forward({input_ids:G,pixel_values:ie,attention_mask:Te,decoder_input_ids:Je,decoder_attention_mask:at,encoder_outputs:_t,past_key_values:It,inputs_embeds:Kt,decoder_inputs_embeds:pr}){if(Kt||({inputs_embeds:Kt,attention_mask:Te}=await this._prepare_inputs_embeds({input_ids:G,pixel_values:ie,inputs_embeds:Kt,attention_mask:Te})),!_t){let{last_hidden_state:yr}=await L(this,{inputs_embeds:Kt,attention_mask:Te});_t=yr}if(!pr){if(!Je)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");pr=await this.encode_text({input_ids:Je})}return await Ce(this,{inputs_embeds:pr,attention_mask:at,encoder_attention_mask:Te,encoder_hidden_states:_t,past_key_values:It},!0)}}class Yo extends X{}class Tu extends Yo{}class bi extends Yo{static async from_pretrained(G,ie={}){return ie.model_file_name??(ie.model_file_name="text_model"),super.from_pretrained(G,ie)}}class Su extends Yo{static async from_pretrained(G,ie={}){return ie.model_file_name??(ie.model_file_name="vision_model"),super.from_pretrained(G,ie)}}class va extends X{}class Mo extends va{}class Eu extends va{static async from_pretrained(G,ie={}){return ie.model_file_name??(ie.model_file_name="text_model"),super.from_pretrained(G,ie)}}class Cu extends Yo{static async from_pretrained(G,ie={}){return ie.model_file_name??(ie.model_file_name="vision_model"),super.from_pretrained(G,ie)}}class Pu extends X{}class $u extends Pu{}class ba extends X{}class Au extends ba{}class Iu extends ba{}class xa extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Fu extends xa{}class zu extends xa{}class ti extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Ou extends ti{}class Du extends ti{}class Ma extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Lu extends Ma{}class Bu extends Ma{}class ka extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Ru extends ka{}class Nu extends ka{}class Ta extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class ju extends Ta{}class yp extends Ta{}class ri extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Uu extends ri{}class Fs extends ri{}class zs extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class ui extends zs{}class Vu extends zs{}class Sa extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Wu extends Sa{}class Gu extends Sa{}class Ea extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Hu extends Ea{}class qu extends Ea{}class Ca extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Ku extends Ca{}class Qu extends Ca{}class ni extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Xu extends ni{}class Yu extends ni{}class Pa extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Zu extends Pa{}class Ju extends Pa{}class $a extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class ec extends $a{}class tc extends $a{}class Aa extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class rc extends Aa{}class Ia extends Aa{}class Os extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class nc extends Os{}class ic extends Os{}class Ds extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class wp extends Ds{}class oc extends Ds{}class Fa extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class sc extends Fa{}class ac extends Fa{}class ko extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class lc extends ko{}class uc extends ko{}class Ls extends X{}class cc extends Ls{}class dc extends Ls{async _call(G){return new mr(await super._call(G))}}class za extends X{}class fc extends za{}class vp extends za{async _call(G){return new mr(await super._call(G))}}class pc extends X{}class hc extends pc{async _call(G){return new _f(await super._call(G))}}class Oa extends X{}class bp extends Oa{}class mc extends Oa{async _call(G){return new mr(await super._call(G))}}class Tr extends X{}class gc extends Tr{}class _c extends Tr{async _call(G){return new mr(await super._call(G))}}class Da extends X{}class yc extends Da{}class wc extends Da{}class La extends X{}class vc extends La{}class bc extends La{}class Ba extends X{}class xc extends Ba{}class Mc extends Ba{async _call(G){return new mr(await super._call(G))}}class Bs extends X{}class kc extends Bs{}class Tc extends Bs{async _call(G){return new Ra(await super._call(G))}}class Zo extends Bs{async _call(G){return new Rs(await super._call(G))}}class Ra extends ge{constructor({logits:G,pred_boxes:ie}){super(),this.logits=G,this.pred_boxes=ie}}class Rs extends ge{constructor({logits:G,pred_boxes:ie,pred_masks:Te}){super(),this.logits=G,this.pred_boxes=ie,this.pred_masks=Te}}class Na extends X{}class Sc extends Na{}class Ec extends Na{async _call(G){return new Cc(await super._call(G))}}class Cc extends ge{constructor({logits:G,pred_boxes:ie}){super(),this.logits=G,this.pred_boxes=ie}}class ja extends X{}class Pc extends ja{}class $c extends ja{async _call(G){return new Ac(await super._call(G))}}class Ac extends Ra{}class Ua extends X{}class Ic extends Ua{}class Fc extends Ua{async _call(G){return new mr(await super._call(G))}}class Va extends X{}class zc extends Va{}class Oc extends Va{async _call(G){return new mr(await super._call(G))}}class Wa extends X{}class Dc extends Wa{}class Ga extends Wa{async _call(G){return new mr(await super._call(G))}}class Ha extends X{}class qa extends Ha{}class Ka extends Ha{}class Qa extends X{}class Lc extends Qa{}class Bc extends Qa{}class Rc extends X{}class Nc extends Rc{}class Ns extends X{}class Xa extends Ns{}class jc extends Ns{}class Uc extends Ns{}class Ya extends X{}class xp extends Ya{}class Vc extends Ya{}class Wc extends X{}class ci extends Wc{}class Za extends X{}class Gc extends Za{}class Hc extends Za{async _call(G){return new mr(await super._call(G))}}class Ja extends X{}class qc extends Ja{}class Kc extends Ja{async _call(G){return new mr(await super._call(G))}}class el extends X{}class Qc extends el{}class Xc extends el{async _call(G){return new mr(await super._call(G))}}class tl extends X{}class Mp extends tl{}class Yc extends tl{async _call(G){return new Zc(await super._call(G))}}class Zc extends ge{constructor({logits:G,pred_boxes:ie}){super(),this.logits=G,this.pred_boxes=ie}}class Jc extends X{}class ed extends Jc{async get_image_embeddings({pixel_values:G}){return await L(this,{pixel_values:G})}async forward(G){if((!G.image_embeddings||!G.image_positional_embeddings)&&(G={...G,...await this.get_image_embeddings(G)}),!G.input_labels&&G.input_points){const Te=G.input_points.dims.slice(0,-1),Je=Te.reduce((at,_t)=>at*_t,1);G.input_labels=new v.Tensor("int64",new BigInt64Array(Je).fill(1n),Te)}const ie={image_embeddings:G.image_embeddings,image_positional_embeddings:G.image_positional_embeddings};return G.input_points&&(ie.input_points=G.input_points),G.input_labels&&(ie.input_labels=G.input_labels),G.input_boxes&&(ie.input_boxes=G.input_boxes),await oe(this.sessions.prompt_encoder_mask_decoder,ie)}async _call(G){return new td(await super._call(G))}}class td extends ge{constructor({iou_scores:G,pred_masks:ie}){super(),this.iou_scores=G,this.pred_masks=ie}}class rl extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class kp extends rl{}class qi extends rl{}class zi extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class Ki extends zi{}class nl extends zi{}class Rn extends X{}class Sn extends Rn{}class il extends Rn{async _call(G){return new oo(await super._call(G))}}class js extends Rn{async _call(G){return new mr(await super._call(G))}}class ol extends Rn{async _call(G){return new yn(await super._call(G))}}class sl extends X{}class rd extends sl{}class nd extends sl{async _call(G){return new yn(await super._call(G))}}class Us extends X{}class al extends Us{}class Vs extends X{}class Ws extends Vs{}class id extends Vs{async _call(G){return new oo(await super._call(G))}}class ll extends Vs{async _call(G){return new mr(await super._call(G))}}class io extends X{}class od extends io{}class sd extends io{async _call(G){return new oo(await super._call(G))}}class Tp extends io{async _call(G){return new mr(await super._call(G))}}class ad extends io{async _call(G){return new yn(await super._call(G))}}class Jo extends X{}class es extends Jo{}class ld extends Jo{async _call(G){return new oo(await super._call(G))}}class ul extends Jo{async _call(G){return new mr(await super._call(G))}}class Sp extends X{}class ud extends Rn{}class cd extends Rn{async _call(G){return new oo(await super._call(G))}}class Ep extends Rn{async _call(G){return new mr(await super._call(G))}}class To extends X{}class dd extends To{}class Cp extends To{async _call(G){return new oo(await super._call(G))}}class cl extends To{async _call(G){return new mr(await super._call(G))}}class fd extends To{async _call(G){return new gf(await super._call(G))}}class pd extends To{async _call(G){return new yn(await super._call(G))}}class Gs extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class dl extends Gs{}class Hs extends Gs{}class hd extends Gs{async generate_speech(G,ie,{threshold:Te=.5,minlenratio:Je=0,maxlenratio:at=20,vocoder:_t=null}={}){const It={input_ids:G},{encoder_outputs:Kt,encoder_attention_mask:pr}=await L(this,It),_r=Kt.dims[1]/this.config.reduction_factor,Br=Math.floor(_r*at),yr=Math.floor(_r*Je),Mr=this.config.num_mel_bins;let gr=[],br=null,Sr=null,Vr=0;for(;;){++Vr;const xi=te(!!Sr);let zn;Sr?zn=Sr.output_sequence_out:zn=new v.Tensor("float32",new Float32Array(Mr),[1,1,Mr]);let mn={use_cache_branch:xi,output_sequence:zn,encoder_attention_mask:pr,speaker_embeddings:ie,encoder_hidden_states:Kt};this.addPastKeyValues(mn,br),Sr=await oe(this.sessions.decoder_model_merged,mn),br=this.getPastKeyValues(Sr,br);const{prob:En,spectrum:Ll}=Sr;if(gr.push(Ll),Vr>=yr&&(Array.from(En.data).filter(Bl=>Bl>=Te).length>0||Vr>=Br))break}const Nn=(0,v.cat)(gr),{waveform:jn}=await oe(_t.sessions.model,{spectrogram:Nn});return{spectrogram:Nn,waveform:jn}}}class qs extends X{constructor(){super(...arguments);He(this,"main_input_name","spectrogram")}}class fl extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class pl extends fl{}class hl extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class md extends hl{}class ml extends hl{}class gl extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class gd extends gl{}class _d extends gl{}class yd extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class wd extends yd{}class _l extends yd{}class yl extends X{}class vd extends yl{}class bd extends yl{static async from_pretrained(G,ie={}){return ie.model_file_name??(ie.model_file_name="text_model"),super.from_pretrained(G,ie)}}class xd extends yl{static async from_pretrained(G,ie={}){return ie.model_file_name??(ie.model_file_name="audio_model"),super.from_pretrained(G,ie)}}class wl extends X{}class vl extends wl{async _call(G){return new yf(await super._call(G))}}class Ks extends X{}class Pp extends Ks{}class Md extends Ks{}class kd extends Ks{}class bl extends X{constructor(G,ie,Te){super(G,ie),this.generation_config=Te}}class $p extends bl{}class Td extends bl{}class xl extends X{}class Sd extends xl{}class Ap extends xl{async _call(G){return new mr(await super._call(G))}}class Ml extends X{}class Ip extends Ml{}class Fp extends Ml{}class kl extends X{constructor(ie,Te,Je){super(ie,Te);He(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]);this.generation_config=Je}_apply_and_filter_by_delay_pattern_mask(ie){const[Te,Je]=ie.dims,at=this.config.decoder.num_codebooks,_t=Je-at;let It=0;for(let _r=0;_r<ie.size;++_r){if(ie.data[_r]===this.config.decoder.pad_token_id)continue;const Br=_r%Je,yr=Math.floor(_r/Je)%at,Mr=Br-yr;Mr>0&&Mr<=_t&&(ie.data[It++]=ie.data[_r])}const Kt=Math.floor(Te/at),pr=It/(Kt*at);return new v.Tensor(ie.type,ie.data.slice(0,It),[Kt,at,pr])}prepare_inputs_for_generation(ie,Te,Je){let at=structuredClone(ie);for(let It=0;It<at.length;++It)for(let Kt=0;Kt<at[It].length;++Kt)It%this.config.decoder.num_codebooks>=Kt&&(at[It][Kt]=BigInt(this.config.decoder.pad_token_id));return Je.guidance_scale!==null&&Je.guidance_scale>1&&(at=at.concat(at)),super.prepare_inputs_for_generation(at,Te,Je)}async generate(ie){const Te=await super.generate(ie),Je=this._apply_and_filter_by_delay_pattern_mask(Te).unsqueeze_(0),{audio_values:at}=await oe(this.sessions.encodec_decode,{audio_codes:Je});return at}}class Tl extends X{}class zp extends Tl{}class Qs extends Tl{async _call(G){return new mr(await super._call(G))}}class So extends X{}class Sl extends So{}class Ed extends So{async _call(G){return new mr(await super._call(G))}}class El extends X{}class Cd extends El{}class Pd extends El{async _call(G){return new mr(await super._call(G))}}class Xs extends X{}class $d extends Xs{}class Ad extends Xs{async _call(G){return new mr(await super._call(G))}}class Lr{static async from_pretrained(G,{progress_callback:ie=null,config:Te=null,cache_dir:Je=null,local_files_only:at=!1,revision:_t="main",model_file_name:It=null,subfolder:Kt="onnx",device:pr=null,dtype:_r=null,use_external_data_format:Br=null,session_options:yr={}}={}){let Mr={progress_callback:ie,config:Te,cache_dir:Je,local_files_only:at,revision:_t,model_file_name:It,subfolder:Kt,device:pr,dtype:_r,use_external_data_format:Br,session_options:yr};if(Mr.config=await o.AutoConfig.from_pretrained(G,Mr),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(let gr of this.MODEL_CLASS_MAPPINGS){const br=gr.get(Mr.config.model_type);if(br)return await br[1].from_pretrained(G,Mr)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${Mr.config.model_type}", attempting to construct from base class.`),await X.from_pretrained(G,Mr);throw Error(`Unsupported model type: ${Mr.config.model_type}`)}}He(Lr,"MODEL_CLASS_MAPPINGS",null),He(Lr,"BASE_IF_FAIL",!1);const Im=new Map([["bert",["BertModel",Ne]],["nomic_bert",["NomicBertModel",je]],["roformer",["RoFormerModel",et]],["electra",["ElectraModel",ke]],["esm",["EsmModel",nn]],["convbert",["ConvBertModel",ve]],["camembert",["CamembertModel",Ke]],["deberta",["DebertaModel",ft]],["deberta-v2",["DebertaV2Model",Nt]],["mpnet",["MPNetModel",$s]],["albert",["AlbertModel",ro]],["distilbert",["DistilBertModel",ir]],["roberta",["RobertaModel",vr]],["xlm",["XLMModel",hn]],["xlm-roberta",["XLMRobertaModel",$r]],["clap",["ClapModel",vd]],["clip",["CLIPModel",Tu]],["clipseg",["CLIPSegModel",Au]],["chinese_clip",["ChineseCLIPModel",$u]],["siglip",["SiglipModel",Mo]],["mobilebert",["MobileBertModel",Yr]],["squeezebert",["SqueezeBertModel",As]],["wav2vec2",["Wav2Vec2Model",Sn]],["wav2vec2-bert",["Wav2Vec2BertModel",es]],["unispeech",["UniSpeechModel",Ws]],["unispeech-sat",["UniSpeechSatModel",od]],["hubert",["HubertModel",ud]],["wavlm",["WavLMModel",dd]],["audio-spectrogram-transformer",["ASTModel",jt]],["vits",["VitsModel",vl]],["pyannote",["PyAnnoteModel",rd]],["wespeaker-resnet",["WeSpeakerResNetModel",al]],["detr",["DetrModel",kc]],["rt_detr",["RTDetrModel",Sc]],["table-transformer",["TableTransformerModel",Pc]],["vit",["ViTModel",cc]],["fastvit",["FastViTModel",fc]],["mobilevit",["MobileViTModel",bp]],["mobilevitv2",["MobileViTV2Model",gc]],["owlvit",["OwlViTModel",yc]],["owlv2",["Owlv2Model",vc]],["beit",["BeitModel",xc]],["deit",["DeiTModel",Ic]],["convnext",["ConvNextModel",Gc]],["convnextv2",["ConvNextV2Model",qc]],["dinov2",["Dinov2Model",Qc]],["resnet",["ResNetModel",zc]],["swin",["SwinModel",Dc]],["swin2sr",["Swin2SRModel",qa]],["donut-swin",["DonutSwinModel",ci]],["yolos",["YolosModel",Mp]],["dpt",["DPTModel",Lc]],["glpn",["GLPNModel",xp]],["hifigan",["SpeechT5HifiGan",qs]],["efficientnet",["EfficientNetModel",Sd]],["mobilenet_v1",["MobileNetV1Model",zp]],["mobilenet_v2",["MobileNetV2Model",Sl]],["mobilenet_v3",["MobileNetV3Model",Cd]],["mobilenet_v4",["MobileNetV4Model",$d]]]),Op=new Map([["t5",["T5Model",Ho]],["longt5",["LongT5Model",Ko]],["mt5",["MT5Model",Xo]],["bart",["BartModel",Ue]],["mbart",["MBartModel",Oe]],["marian",["MarianModel",kp]],["whisper",["WhisperModel",qt]],["m2m_100",["M2M100Model",Ki]],["blenderbot",["BlenderbotModel",Ct]],["blenderbot-small",["BlenderbotSmallModel",Dr]]]),Id=new Map([["bloom",["BloomModel",wp]],["jais",["JAISModel",Ou]],["gpt2",["GPT2Model",Fu]],["gptj",["GPTJModel",ju]],["gpt_bigcode",["GPTBigCodeModel",Uu]],["gpt_neo",["GPTNeoModel",Lu]],["gpt_neox",["GPTNeoXModel",Ru]],["codegen",["CodeGenModel",ui]],["llama",["LlamaModel",Wu]],["cohere",["CohereModel",Hu]],["gemma",["GemmaModel",Ku]],["gemma2",["Gemma2Model",Xu]],["openelm",["OpenELMModel",Zu]],["qwen2",["Qwen2Model",ec]],["phi",["PhiModel",rc]],["phi3",["Phi3Model",nc]],["mpt",["MptModel",sc]],["opt",["OPTModel",lc]],["mistral",["MistralModel",md]],["starcoder2",["Starcoder2Model",gd]],["falcon",["FalconModel",wd]],["stablelm",["StableLmModel",$p]]]),Cl=new Map([["speecht5",["SpeechT5ForSpeechToText",Hs]],["whisper",["WhisperForConditionalGeneration",_a]]]),Fd=new Map([["speecht5",["SpeechT5ForTextToSpeech",hd]]]),zd=new Map([["vits",["VitsModel",vl]],["musicgen",["MusicgenForConditionalGeneration",kl]]]),Dp=new Map([["bert",["BertForSequenceClassification",st]],["roformer",["RoFormerForSequenceClassification",$e]],["electra",["ElectraForSequenceClassification",ht]],["esm",["EsmForSequenceClassification",Ai]],["convbert",["ConvBertForSequenceClassification",ee]],["camembert",["CamembertForSequenceClassification",Ae]],["deberta",["DebertaForSequenceClassification",vt]],["deberta-v2",["DebertaV2ForSequenceClassification",Qt]],["mpnet",["MPNetForSequenceClassification",Vo]],["albert",["AlbertForSequenceClassification",yo]],["distilbert",["DistilBertForSequenceClassification",lr]],["roberta",["RobertaForSequenceClassification",vn]],["xlm",["XLMForSequenceClassification",Jt]],["xlm-roberta",["XLMRobertaForSequenceClassification",Ar]],["bart",["BartForSequenceClassification",fe]],["mbart",["MBartForSequenceClassification",nt]],["mobilebert",["MobileBertForSequenceClassification",Nr]],["squeezebert",["SqueezeBertForSequenceClassification",vi]]]),Od=new Map([["bert",["BertForTokenClassification",pt]],["roformer",["RoFormerForTokenClassification",Pe]],["electra",["ElectraForTokenClassification",tt]],["esm",["EsmForTokenClassification",Qr]],["convbert",["ConvBertForTokenClassification",D]],["camembert",["CamembertForTokenClassification",Ve]],["deberta",["DebertaForTokenClassification",$t]],["deberta-v2",["DebertaV2ForTokenClassification",Ht]],["mpnet",["MPNetForTokenClassification",Wo]],["distilbert",["DistilBertForTokenClassification",kr]],["roberta",["RobertaForTokenClassification",Ze]],["xlm",["XLMForTokenClassification",Kn]],["xlm-roberta",["XLMRobertaForTokenClassification",jr]]]),Pl=new Map([["t5",["T5ForConditionalGeneration",qo]],["longt5",["LongT5ForConditionalGeneration",Qo]],["mt5",["MT5ForConditionalGeneration",Kr]],["bart",["BartForConditionalGeneration",W]],["mbart",["MBartForConditionalGeneration",Le]],["marian",["MarianMTModel",qi]],["m2m_100",["M2M100ForConditionalGeneration",nl]],["blenderbot",["BlenderbotForConditionalGeneration",Ot]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",cr]]]),Dd=new Map([["bloom",["BloomForCausalLM",oc]],["gpt2",["GPT2LMHeadModel",zu]],["jais",["JAISLMHeadModel",Du]],["gptj",["GPTJForCausalLM",yp]],["gpt_bigcode",["GPTBigCodeForCausalLM",Fs]],["gpt_neo",["GPTNeoForCausalLM",Bu]],["gpt_neox",["GPTNeoXForCausalLM",Nu]],["codegen",["CodeGenForCausalLM",Vu]],["llama",["LlamaForCausalLM",Gu]],["cohere",["CohereForCausalLM",qu]],["gemma",["GemmaForCausalLM",Qu]],["gemma2",["Gemma2ForCausalLM",Yu]],["openelm",["OpenELMForCausalLM",Ju]],["qwen2",["Qwen2ForCausalLM",tc]],["phi",["PhiForCausalLM",Ia]],["phi3",["Phi3ForCausalLM",ic]],["mpt",["MptForCausalLM",ac]],["opt",["OPTForCausalLM",uc]],["mbart",["MBartForCausalLM",Et]],["mistral",["MistralForCausalLM",ml]],["starcoder2",["Starcoder2ForCausalLM",_d]],["falcon",["FalconForCausalLM",_l]],["trocr",["TrOCRForCausalLM",pl]],["stablelm",["StableLmForCausalLM",Td]]]),Ld=new Map([["bert",["BertForMaskedLM",We]],["roformer",["RoFormerForMaskedLM",A]],["electra",["ElectraForMaskedLM",Re]],["esm",["EsmForMaskedLM",yi]],["convbert",["ConvBertForMaskedLM",R]],["camembert",["CamembertForMaskedLM",de]],["deberta",["DebertaForMaskedLM",xt]],["deberta-v2",["DebertaV2ForMaskedLM",Rt]],["mpnet",["MPNetForMaskedLM",Uo]],["albert",["AlbertForMaskedLM",Zt]],["distilbert",["DistilBertForMaskedLM",Tt]],["roberta",["RobertaForMaskedLM",An]],["xlm",["XLMWithLMHeadModel",Bn]],["xlm-roberta",["XLMRobertaForMaskedLM",zt]],["mobilebert",["MobileBertForMaskedLM",wi]],["squeezebert",["SqueezeBertForMaskedLM",_o]]]),Bd=new Map([["bert",["BertForQuestionAnswering",Ge]],["roformer",["RoFormerForQuestionAnswering",ae]],["electra",["ElectraForQuestionAnswering",wt]],["convbert",["ConvBertForQuestionAnswering",ce]],["camembert",["CamembertForQuestionAnswering",ot]],["deberta",["DebertaForQuestionAnswering",kt]],["deberta-v2",["DebertaV2ForQuestionAnswering",Gt]],["mpnet",["MPNetForQuestionAnswering",Go]],["albert",["AlbertForQuestionAnswering",wo]],["distilbert",["DistilBertForQuestionAnswering",mt]],["roberta",["RobertaForQuestionAnswering",ei]],["xlm",["XLMForQuestionAnswering",Tn]],["xlm-roberta",["XLMRobertaForQuestionAnswering",Zr]],["mobilebert",["MobileBertForQuestionAnswering",Wi]],["squeezebert",["SqueezeBertForQuestionAnswering",Hi]]]),$l=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",ya]]]),Lp=new Map([["llava",["LlavaForConditionalGeneration",xo]],["moondream1",["Moondream1ForConditionalGeneration",dr]],["florence2",["Florence2ForConditionalGeneration",wa]]]),Fm=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",ya]]]),Rd=new Map([["vit",["ViTForImageClassification",dc]],["fastvit",["FastViTForImageClassification",vp]],["mobilevit",["MobileViTForImageClassification",mc]],["mobilevitv2",["MobileViTV2ForImageClassification",_c]],["beit",["BeitForImageClassification",Mc]],["deit",["DeiTForImageClassification",Fc]],["convnext",["ConvNextForImageClassification",Hc]],["convnextv2",["ConvNextV2ForImageClassification",Kc]],["dinov2",["Dinov2ForImageClassification",Xc]],["resnet",["ResNetForImageClassification",Oc]],["swin",["SwinForImageClassification",Ga]],["segformer",["SegformerForImageClassification",Md]],["efficientnet",["EfficientNetForImageClassification",Ap]],["mobilenet_v1",["MobileNetV1ForImageClassification",Qs]],["mobilenet_v2",["MobileNetV2ForImageClassification",Ed]],["mobilenet_v3",["MobileNetV3ForImageClassification",Pd]],["mobilenet_v4",["MobileNetV4ForImageClassification",Ad]]]),Nd=new Map([["detr",["DetrForObjectDetection",Tc]],["rt_detr",["RTDetrForObjectDetection",Ec]],["table-transformer",["TableTransformerForObjectDetection",$c]],["yolos",["YolosForObjectDetection",Yc]]]),jd=new Map([["owlvit",["OwlViTForObjectDetection",wc]],["owlv2",["Owlv2ForObjectDetection",bc]]]),Ud=new Map([["detr",["DetrForSegmentation",Zo]],["clipseg",["CLIPSegForImageSegmentation",Iu]]]),Bp=new Map([["segformer",["SegformerForSemanticSegmentation",kd]],["sapiens",["SapiensForSemanticSegmentation",Xa]]]),Vd=new Map([["sam",["SamModel",ed]]]),Wd=new Map([["wav2vec2",["Wav2Vec2ForCTC",il]],["wav2vec2-bert",["Wav2Vec2BertForCTC",ld]],["unispeech",["UniSpeechForCTC",id]],["unispeech-sat",["UniSpeechSatForCTC",sd]],["wavlm",["WavLMForCTC",Cp]],["hubert",["HubertForCTC",cd]]]),Gd=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",js]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",ul]],["unispeech",["UniSpeechForSequenceClassification",ll]],["unispeech-sat",["UniSpeechSatForSequenceClassification",Tp]],["wavlm",["WavLMForSequenceClassification",cl]],["hubert",["HubertForSequenceClassification",Ep]],["audio-spectrogram-transformer",["ASTForAudioClassification",Is]]]),Hd=new Map([["wavlm",["WavLMForXVector",fd]]]),Rp=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",ad]],["wavlm",["WavLMForAudioFrameClassification",pd]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",ol]],["pyannote",["PyAnnoteForAudioFrameClassification",nd]]]),qd=new Map([["vitmatte",["VitMatteForImageMatting",hc]]]),Kd=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Ka]]]),Qd=new Map([["dpt",["DPTForDepthEstimation",Bc]],["depth_anything",["DepthAnythingForDepthEstimation",Nc]],["glpn",["GLPNForDepthEstimation",Vc]],["sapiens",["SapiensForDepthEstimation",jc]]]),Xd=new Map([["sapiens",["SapiensForNormalEstimation",Uc]]]),Np=new Map([["clip",["CLIPVisionModelWithProjection",Su]],["siglip",["SiglipVisionModel",Cu]]]),In=[[Im,x.EncoderOnly],[Op,x.EncoderDecoder],[Id,x.DecoderOnly],[Dp,x.EncoderOnly],[Od,x.EncoderOnly],[Pl,x.Seq2Seq],[Cl,x.Seq2Seq],[Dd,x.DecoderOnly],[Ld,x.EncoderOnly],[Bd,x.EncoderOnly],[$l,x.Vision2Seq],[Lp,x.ImageTextToText],[Rd,x.EncoderOnly],[Ud,x.EncoderOnly],[Bp,x.EncoderOnly],[qd,x.EncoderOnly],[Kd,x.EncoderOnly],[Qd,x.EncoderOnly],[Xd,x.EncoderOnly],[Nd,x.EncoderOnly],[jd,x.EncoderOnly],[Vd,x.MaskGeneration],[Wd,x.EncoderOnly],[Gd,x.EncoderOnly],[Fd,x.Seq2Seq],[zd,x.EncoderOnly],[Hd,x.EncoderOnly],[Rp,x.EncoderOnly],[Np,x.EncoderOnly]];for(const[U,G]of In)for(const[ie,Te]of U.values())I.set(ie,G),O.set(Te,ie),V.set(ie,Te);const jp=[["MusicgenForConditionalGeneration",kl,x.Musicgen],["CLIPTextModelWithProjection",bi,x.EncoderOnly],["SiglipTextModel",Eu,x.EncoderOnly],["ClapTextModelWithProjection",bd,x.EncoderOnly],["ClapAudioModelWithProjection",xd,x.EncoderOnly]];for(const[U,G,ie]of jp)I.set(U,ie),O.set(G,U),V.set(U,G);class Al extends Lr{}He(Al,"MODEL_CLASS_MAPPINGS",In.map(G=>G[0])),He(Al,"BASE_IF_FAIL",!0);class Il extends Lr{}He(Il,"MODEL_CLASS_MAPPINGS",[Dp]);class Yd extends Lr{}He(Yd,"MODEL_CLASS_MAPPINGS",[Od]);class ts extends Lr{}He(ts,"MODEL_CLASS_MAPPINGS",[Pl]);class Zd extends Lr{}He(Zd,"MODEL_CLASS_MAPPINGS",[Cl]);class Jd extends Lr{}He(Jd,"MODEL_CLASS_MAPPINGS",[Fd]);class Fl extends Lr{}He(Fl,"MODEL_CLASS_MAPPINGS",[zd]);class ef extends Lr{}He(ef,"MODEL_CLASS_MAPPINGS",[Dd]);class tf extends Lr{}He(tf,"MODEL_CLASS_MAPPINGS",[Ld]);class zl extends Lr{}He(zl,"MODEL_CLASS_MAPPINGS",[Bd]);class rf extends Lr{}He(rf,"MODEL_CLASS_MAPPINGS",[$l]);class nf extends Lr{}He(nf,"MODEL_CLASS_MAPPINGS",[Rd]);class of extends Lr{}He(of,"MODEL_CLASS_MAPPINGS",[Ud]);class Ol extends Lr{}He(Ol,"MODEL_CLASS_MAPPINGS",[Bp]);class sf extends Lr{}He(sf,"MODEL_CLASS_MAPPINGS",[Nd]);class af extends Lr{}He(af,"MODEL_CLASS_MAPPINGS",[jd]);class Dl extends Lr{}He(Dl,"MODEL_CLASS_MAPPINGS",[Vd]);class lf extends Lr{}He(lf,"MODEL_CLASS_MAPPINGS",[Wd]);class Up extends Lr{}He(Up,"MODEL_CLASS_MAPPINGS",[Gd]);class uf extends Lr{}He(uf,"MODEL_CLASS_MAPPINGS",[Hd]);class cf extends Lr{}He(cf,"MODEL_CLASS_MAPPINGS",[Rp]);class df extends Lr{}He(df,"MODEL_CLASS_MAPPINGS",[Fm]);class ff extends Lr{}He(ff,"MODEL_CLASS_MAPPINGS",[qd]);class Vp extends Lr{}He(Vp,"MODEL_CLASS_MAPPINGS",[Kd]);class pf extends Lr{}He(pf,"MODEL_CLASS_MAPPINGS",[Qd]);class hf extends Lr{}He(hf,"MODEL_CLASS_MAPPINGS",[Xd]);class mf extends Lr{}He(mf,"MODEL_CLASS_MAPPINGS",[Np]);class zm extends ge{constructor({logits:G,past_key_values:ie,encoder_outputs:Te,decoder_attentions:Je=null,cross_attentions:at=null}){super(),this.logits=G,this.past_key_values=ie,this.encoder_outputs=Te,this.decoder_attentions=Je,this.cross_attentions=at}}class mr extends ge{constructor({logits:G}){super(),this.logits=G}}class gf extends ge{constructor({logits:G,embeddings:ie}){super(),this.logits=G,this.embeddings=ie}}class yn extends ge{constructor({logits:G}){super(),this.logits=G}}class bn extends ge{constructor({logits:G}){super(),this.logits=G}}class Fn extends ge{constructor({start_logits:G,end_logits:ie}){super(),this.start_logits=G,this.end_logits=ie}}class oo extends ge{constructor({logits:G}){super(),this.logits=G}}class Wp extends ge{constructor({logits:G,past_key_values:ie}){super(),this.logits=G,this.past_key_values=ie}}class _f extends ge{constructor({alphas:G}){super(),this.alphas=G}}class yf extends ge{constructor({waveform:G,spectrogram:ie}){super(),this.waveform=G,this.spectrogram=ie}}},"./src/models/whisper/common_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WHISPER_LANGUAGE_MAPPING:()=>a,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>l,whisper_language_to_code:()=>f});const o=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],a=new Map(o),l=new Map([...o.map(([_,m])=>[m,_]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function f(_){_=_.toLowerCase();let m=l.get(_);if(m===void 0)if(a.has(_))m=_;else{const M=_.length===2?a.keys():a.values();throw new Error(`Language "${_}" is not supported. Must be one of: ${JSON.stringify(M)}`)}return m}},"./src/models/whisper/generation_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperGenerationConfig:()=>a});var o=n("./src/generation/configuration_utils.js");class a extends o.GenerationConfig{constructor(){super(...arguments);He(this,"return_timestamps",null);He(this,"return_token_timestamps",null);He(this,"num_frames",null);He(this,"alignment_heads",null);He(this,"task",null);He(this,"language",null);He(this,"no_timestamps_token_id",null);He(this,"prompt_ids",null);He(this,"is_multilingual",null);He(this,"lang_to_id",null);He(this,"task_to_id",null);He(this,"max_initial_timestamp_index",1)}}},"./src/ops/registry.js":(e,t,n)=>{n.r(t),n.d(t,{TensorOpRegistry:()=>f});var o=n("./src/backends/onnx.js"),a=n("./src/utils/tensor.js");const l=async(_,m,g)=>{const M=await(0,o.createInferenceSession)(new Uint8Array(_),m);return async v=>{const C=Object.fromEntries(Object.entries(v).map(([z,$])=>[z,$.ort_tensor])),k=await M.run(C);return Array.isArray(g)?g.map(z=>new a.Tensor(k[z])):new a.Tensor(k[g])}};class f{static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=l([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=l([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=l([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=l([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=l([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=l([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}}He(f,"session_options",{})},"./src/pipelines.js":(e,t,n)=>{n.r(t),n.d(t,{AudioClassificationPipeline:()=>te,AutomaticSpeechRecognitionPipeline:()=>L,DepthEstimationPipeline:()=>Be,DocumentQuestionAnsweringPipeline:()=>X,FeatureExtractionPipeline:()=>he,FillMaskPipeline:()=>I,ImageClassificationPipeline:()=>Xe,ImageFeatureExtractionPipeline:()=>Ie,ImageSegmentationPipeline:()=>ye,ImageToImagePipeline:()=>qe,ImageToTextPipeline:()=>Ce,ObjectDetectionPipeline:()=>se,Pipeline:()=>$,QuestionAnsweringPipeline:()=>x,SummarizationPipeline:()=>O,Text2TextGenerationPipeline:()=>V,TextClassificationPipeline:()=>S,TextGenerationPipeline:()=>N,TextToAudioPipeline:()=>ge,TokenClassificationPipeline:()=>y,TranslationPipeline:()=>B,ZeroShotAudioClassificationPipeline:()=>we,ZeroShotClassificationPipeline:()=>oe,ZeroShotImageClassificationPipeline:()=>Y,ZeroShotObjectDetectionPipeline:()=>Me,pipeline:()=>st});var o=n("./src/tokenizers.js"),a=n("./src/models.js"),l=n("./src/processors.js"),f=n("./src/utils/generic.js"),_=n("./src/utils/core.js"),m=n("./src/utils/maths.js"),g=n("./src/utils/audio.js"),M=n("./src/utils/tensor.js"),v=n("./src/utils/image.js");async function C(Ge){return Array.isArray(Ge)||(Ge=[Ge]),await Promise.all(Ge.map(xe=>v.RawImage.read(xe)))}async function k(Ge,xe){return Array.isArray(Ge)||(Ge=[Ge]),await Promise.all(Ge.map(je=>typeof je=="string"||je instanceof URL?(0,g.read_audio)(je,xe):je instanceof Float64Array?new Float32Array(je):je))}function z(Ge,xe){xe&&(Ge=Ge.map($e=>$e|0));const[je,Ye,et,A]=Ge;return{xmin:je,ymin:Ye,xmax:et,ymax:A}}class $ extends f.Callable{constructor({task:xe,model:je,tokenizer:Ye=null,processor:et=null}){super(),this.task=xe,this.model=je,this.tokenizer=Ye,this.processor=et}async dispose(){await this.model.dispose()}}class S extends ${constructor(xe){super(xe)}async _call(xe,{top_k:je=1}={}){const Ye=this.tokenizer(xe,{padding:!0,truncation:!0}),et=await this.model(Ye),A=this.model.config.problem_type==="multi_label_classification"?ae=>ae.sigmoid():ae=>new M.Tensor("float32",(0,m.softmax)(ae.data),ae.dims),$e=this.model.config.id2label,Pe=[];for(const ae of et.logits){const ne=A(ae),ve=await(0,M.topk)(ne,je),R=ve[0].tolist(),D=ve[1].tolist().map((ce,ue)=>({label:$e?$e[ce]:`LABEL_${ce}`,score:R[ue]}));je===1?Pe.push(...D):Pe.push(D)}return Array.isArray(xe)||je===1?Pe:Pe[0]}}class y extends ${constructor(xe){super(xe)}async _call(xe,{ignore_labels:je=["O"]}={}){const Ye=Array.isArray(xe),et=this.tokenizer(Ye?xe:[xe],{padding:!0,truncation:!0}),$e=(await this.model(et)).logits,Pe=this.model.config.id2label,ae=[];for(let ne=0;ne<$e.dims[0];++ne){const ve=et.input_ids[ne],R=$e[ne],ee=[];for(let D=0;D<R.dims[0];++D){const ce=R[D],ue=(0,m.max)(ce.data)[1],ke=Pe?Pe[ue]:`LABEL_${ue}`;if(je.includes(ke))continue;const Re=this.tokenizer.decode([ve[D].item()],{skip_special_tokens:!0});if(Re==="")continue;const ht=(0,m.softmax)(ce.data);ee.push({entity:ke,score:ht[ue],index:D,word:Re})}ae.push(ee)}return Ye?ae:ae[0]}}class x extends ${constructor(xe){super(xe)}async _call(xe,je,{top_k:Ye=1}={}){const et=this.tokenizer(xe,{text_pair:je,padding:!0,truncation:!0}),{start_logits:A,end_logits:$e}=await this.model(et),Pe=et.input_ids.tolist(),ae=et.attention_mask.tolist(),ne=this.tokenizer.all_special_ids,ve=[];for(let R=0;R<A.dims[0];++R){const ee=Pe[R],D=ee.findIndex(tt=>tt==this.tokenizer.sep_token_id);ae[R].map((tt,wt)=>tt==1&&(wt===0||wt>D&&ne.findIndex(bt=>bt==ee[wt])===-1));const ce=A[R].tolist(),ue=$e[R].tolist();for(let tt=1;tt<ce.length;++tt)(ae[R]==0||tt<=D||ne.findIndex(wt=>wt==ee[tt])!==-1)&&(ce[tt]=-1/0,ue[tt]=-1/0);const ke=(0,m.softmax)(ce).map((tt,wt)=>[tt,wt]),Re=(0,m.softmax)(ue).map((tt,wt)=>[tt,wt]);ke[0][0]=0,Re[0][0]=0;const ht=(0,_.product)(ke,Re).filter(tt=>tt[0][1]<=tt[1][1]).map(tt=>[tt[0][1],tt[1][1],tt[0][0]*tt[1][0]]).sort((tt,wt)=>wt[2]-tt[2]);for(let tt=0;tt<Math.min(ht.length,Ye);++tt){const[wt,bt,Ke]=ht[tt],de=ee.slice(wt,bt+1),Ae=this.tokenizer.decode(de,{skip_special_tokens:!0});ve.push({answer:Ae,score:Ke})}}return Ye===1?ve[0]:ve}}class I extends ${constructor(xe){super(xe)}async _call(xe,{top_k:je=5}={}){const Ye=this.tokenizer(xe,{padding:!0,truncation:!0}),{logits:et}=await this.model(Ye),A=[],$e=Ye.input_ids.tolist();for(let Pe=0;Pe<$e.length;++Pe){const ae=$e[Pe],ne=ae.findIndex(ce=>ce==this.tokenizer.mask_token_id);if(ne===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const ve=et[Pe][ne],R=await(0,M.topk)(new M.Tensor("float32",(0,m.softmax)(ve.data),ve.dims),je),ee=R[0].tolist(),D=R[1].tolist();A.push(D.map((ce,ue)=>{const ke=ae.slice();return ke[ne]=ce,{score:ee[ue],token:Number(ce),token_str:this.tokenizer.model.vocab[ce],sequence:this.tokenizer.decode(ke,{skip_special_tokens:!0})}}))}return Array.isArray(xe)?A:A[0]}}class V extends ${constructor(je){super(je);He(this,"_key","generated_text")}async _call(je,Ye={}){Array.isArray(je)||(je=[je]),this.model.config.prefix&&(je=je.map(ne=>this.model.config.prefix+ne));const et=this.model.config.task_specific_params;et&&et[this.task]&&et[this.task].prefix&&(je=je.map(ne=>et[this.task].prefix+ne));const A=this.tokenizer,$e={padding:!0,truncation:!0};let Pe;this instanceof B&&"_build_translation_inputs"in A?Pe=A._build_translation_inputs(je,$e,Ye):Pe=A(je,$e);const ae=await this.model.generate({...Pe,...Ye});return A.batch_decode(ae,{skip_special_tokens:!0}).map(ne=>({[this._key]:ne}))}}class O extends V{constructor(je){super(je);He(this,"_key","summary_text")}}class B extends V{constructor(je){super(je);He(this,"_key","translation_text")}}function j(Ge){return Array.isArray(Ge)&&Ge.every(xe=>"role"in xe&&"content"in xe)}class N extends ${constructor(xe){super(xe)}async _call(xe,je={}){let Ye=!1,et=!1,A;if(typeof xe=="string")A=xe=[xe];else if(Array.isArray(xe)&&xe.every(D=>typeof D=="string"))Ye=!0,A=xe;else{if(j(xe))xe=[xe];else if(Array.isArray(xe)&&xe.every(j))Ye=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");et=!0,A=xe.map(D=>this.tokenizer.apply_chat_template(D,{tokenize:!1,add_generation_prompt:!0}))}const $e=je.add_special_tokens??!1,Pe=et?!1:je.return_full_text??!0;this.tokenizer.padding_side="left";const ae=this.tokenizer(A,{add_special_tokens:$e,padding:!0,truncation:!0}),ne=await this.model.generate({...ae,...je}),ve=this.tokenizer.batch_decode(ne,{skip_special_tokens:!0});let R;!Pe&&ae.input_ids.dims.at(-1)>0&&(R=this.tokenizer.batch_decode(ae.input_ids,{skip_special_tokens:!0}).map(D=>D.length));const ee=Array.from({length:xe.length},D=>[]);for(let D=0;D<ve.length;++D){const ce=Math.floor(D/ne.dims[0]*xe.length);R&&(ve[D]=ve[D].slice(R[ce])),ee[ce].push({generated_text:et?[...xe[ce],{role:"assistant",content:ve[D]}]:ve[D]})}return!Ye&&ee.length===1?ee[0]:ee}}class oe extends ${constructor(xe){super(xe),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([je,Ye])=>[je.toLowerCase(),Ye])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(xe,je,{hypothesis_template:Ye="This example is {}.",multi_label:et=!1}={}){const A=Array.isArray(xe);A||(xe=[xe]),Array.isArray(je)||(je=[je]);const $e=je.map(ne=>Ye.replace("{}",ne)),Pe=et||je.length===1,ae=[];for(const ne of xe){const ve=[];for(const D of $e){const ce=this.tokenizer(ne,{text_pair:D,padding:!0,truncation:!0}),ue=await this.model(ce);Pe?ve.push([ue.logits.data[this.contradiction_id],ue.logits.data[this.entailment_id]]):ve.push(ue.logits.data[this.entailment_id])}const ee=(Pe?ve.map(D=>(0,m.softmax)(D)[1]):(0,m.softmax)(ve)).map((D,ce)=>[D,ce]).sort((D,ce)=>ce[0]-D[0]);ae.push({sequence:ne,labels:ee.map(D=>je[D[1]]),scores:ee.map(D=>D[0])})}return A?ae:ae[0]}}class he extends ${constructor(xe){super(xe)}async _call(xe,{pooling:je="none",normalize:Ye=!1,quantize:et=!1,precision:A="binary"}={}){const $e=this.tokenizer(xe,{padding:!0,truncation:!0}),Pe=await this.model($e);let ae=Pe.last_hidden_state??Pe.logits??Pe.token_embeddings;if(je!=="none")if(je==="mean")ae=(0,M.mean_pooling)(ae,$e.attention_mask);else if(je==="cls")ae=ae.slice(null,0);else throw Error(`Pooling method '${je}' not supported.`);return Ye&&(ae=ae.normalize(2,-1)),et&&(ae=(0,M.quantize_embeddings)(ae,A)),ae}}class Ie extends ${constructor(xe){super(xe)}async _call(xe,{pool:je=null}={}){const Ye=await C(xe),{pixel_values:et}=await this.processor(Ye),A=await this.model({pixel_values:et});let $e;if(je){if(!("pooler_output"in A))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");$e=A.pooler_output}else $e=A.last_hidden_state??A.logits??A.image_embeds;return $e}}class te extends ${constructor(xe){super(xe)}async _call(xe,{top_k:je=5}={}){const Ye=this.processor.feature_extractor.config.sampling_rate,et=await k(xe,Ye),A=this.model.config.id2label,$e=[];for(const Pe of et){const ae=await this.processor(Pe),ve=(await this.model(ae)).logits[0],R=await(0,M.topk)(new M.Tensor("float32",(0,m.softmax)(ve.data),ve.dims),je),ee=R[0].tolist(),ce=R[1].tolist().map((ue,ke)=>({label:A?A[ue]:`LABEL_${ue}`,score:ee[ke]}));$e.push(ce)}return Array.isArray(xe)?$e:$e[0]}}class we extends ${constructor(xe){super(xe)}async _call(xe,je,{hypothesis_template:Ye="This is a sound of {}."}={}){const et=!Array.isArray(xe);et&&(xe=[xe]);const A=je.map(ve=>Ye.replace("{}",ve)),$e=this.tokenizer(A,{padding:!0,truncation:!0}),Pe=this.processor.feature_extractor.config.sampling_rate,ae=await k(xe,Pe),ne=[];for(const ve of ae){const R=await this.processor(ve),ee=await this.model({...$e,...R}),D=(0,m.softmax)(ee.logits_per_audio.data);ne.push([...D].map((ce,ue)=>({score:ce,label:je[ue]})))}return et?ne[0]:ne}}class L extends ${constructor(xe){super(xe)}async _call(xe,je={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(xe,je);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(xe,je);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(xe,je){je.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),je.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const Ye=!Array.isArray(xe);Ye&&(xe=[xe]);const et=this.processor.feature_extractor.config.sampling_rate,A=await k(xe,et),$e=[];for(const Pe of A){const ae=await this.processor(Pe),ve=(await this.model(ae)).logits[0],R=[];for(const D of ve)R.push((0,m.max)(D.data)[1]);const ee=this.tokenizer.decode(R);$e.push({text:ee})}return Ye?$e[0]:$e}async _call_whisper(xe,je){const Ye=je.return_timestamps??!1,et=je.chunk_length_s??0,A=je.force_full_sequences??!1;let $e=je.stride_length_s??null;const Pe={...je};Ye==="word"&&(Pe.return_token_timestamps=!0,Pe.return_timestamps=!1);const ae=!Array.isArray(xe);ae&&(xe=[xe]);const ne=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,ve=this.processor.feature_extractor.config.hop_length,R=this.processor.feature_extractor.config.sampling_rate,ee=await k(xe,R),D=[];for(const ce of ee){let ue=[];if(et>0){if($e===null)$e=et/6;else if(et<=$e)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const ht=R*et,tt=R*$e,wt=ht-2*tt;let bt=0;for(;;){const Ke=bt+ht,de=ce.subarray(bt,Ke),Ae=await this.processor(de),Ve=bt===0,ot=Ke>=ce.length;if(ue.push({stride:[de.length,Ve?0:tt,ot?0:tt],input_features:Ae.input_features,is_last:ot}),ot)break;bt+=wt}}else ue=[{stride:[ce.length,0,0],input_features:(await this.processor(ce)).input_features,is_last:!0}];for(const ht of ue){Pe.num_frames=Math.floor(ht.stride[0]/ve);const tt=await this.model.generate({inputs:ht.input_features,...Pe});Ye==="word"?(ht.tokens=tt.sequences.tolist()[0],ht.token_timestamps=tt.token_timestamps.tolist()[0].map(wt=>(0,m.round)(wt,2))):ht.tokens=tt[0].tolist(),ht.stride=ht.stride.map(wt=>wt/R)}const[ke,Re]=this.tokenizer._decode_asr(ue,{time_precision:ne,return_timestamps:Ye,force_full_sequences:A});D.push({text:ke,...Re})}return ae?D[0]:D}}class Ce extends ${constructor(xe){super(xe)}async _call(xe,je={}){const Ye=Array.isArray(xe),et=await C(xe),{pixel_values:A}=await this.processor(et),$e=[];for(const Pe of A){Pe.dims=[1,...Pe.dims];const ae=await this.model.generate({inputs:Pe,...je}),ne=this.tokenizer.batch_decode(ae,{skip_special_tokens:!0}).map(ve=>({generated_text:ve.trim()}));$e.push(ne)}return Ye?$e:$e[0]}}class Xe extends ${constructor(xe){super(xe)}async _call(xe,{top_k:je=5}={}){const Ye=await C(xe),{pixel_values:et}=await this.processor(Ye),A=await this.model({pixel_values:et}),$e=this.model.config.id2label,Pe=[];for(const ae of A.logits){const ne=await(0,M.topk)(new M.Tensor("float32",(0,m.softmax)(ae.data),ae.dims),je),ve=ne[0].tolist(),ee=ne[1].tolist().map((D,ce)=>({label:$e?$e[D]:`LABEL_${D}`,score:ve[ce]}));Pe.push(ee)}return Array.isArray(xe)?Pe:Pe[0]}}class ye extends ${constructor(xe){super(xe),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(xe,{threshold:je=.5,mask_threshold:Ye=.5,overlap_mask_area_threshold:et=.8,label_ids_to_fuse:A=null,target_sizes:$e=null,subtask:Pe=null}={}){if(Array.isArray(xe)&&xe.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const ne=await C(xe),ve=ne.map(Re=>[Re.height,Re.width]),{pixel_values:R,pixel_mask:ee}=await this.processor(ne),D=await this.model({pixel_values:R,pixel_mask:ee});let ce=null;if(Pe!==null)ce=this.subtasks_mapping[Pe];else for(let[Re,ht]of Object.entries(this.subtasks_mapping))if(ht in this.processor.feature_extractor){ce=this.processor.feature_extractor[ht].bind(this.processor.feature_extractor),Pe=Re;break}const ue=this.model.config.id2label,ke=[];if(Pe==="panoptic"||Pe==="instance"){const Re=ce(D,je,Ye,et,A,$e??ve)[0],ht=Re.segmentation;for(const tt of Re.segments_info){const wt=new Uint8ClampedArray(ht.data.length);for(let Ke=0;Ke<ht.data.length;++Ke)ht.data[Ke]===tt.id&&(wt[Ke]=255);const bt=new v.RawImage(wt,ht.dims[1],ht.dims[0],1);ke.push({score:tt.score,label:ue[tt.label_id],mask:bt})}}else if(Pe==="semantic"){const{segmentation:Re,labels:ht}=ce(D,$e??ve)[0];for(const tt of ht){const wt=new Uint8ClampedArray(Re.data.length);for(let Ke=0;Ke<Re.data.length;++Ke)Re.data[Ke]===tt&&(wt[Ke]=255);const bt=new v.RawImage(wt,Re.dims[1],Re.dims[0],1);ke.push({score:null,label:ue[tt],mask:bt})}}else throw Error(`Subtask ${Pe} not supported.`);return ke}}class Y extends ${constructor(xe){super(xe)}async _call(xe,je,{hypothesis_template:Ye="This is a photo of {}"}={}){const et=Array.isArray(xe),A=await C(xe),$e=je.map(ee=>Ye.replace("{}",ee)),Pe=this.tokenizer($e,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:ae}=await this.processor(A),ne=await this.model({...Pe,pixel_values:ae}),ve=this.model.config.model_type==="siglip"?ee=>ee.sigmoid().data:ee=>(0,m.softmax)(ee.data),R=[];for(const ee of ne.logits_per_image){const ce=[...ve(ee)].map((ue,ke)=>({score:ue,label:je[ke]}));ce.sort((ue,ke)=>ke.score-ue.score),R.push(ce)}return et?R:R[0]}}class se extends ${constructor(xe){super(xe)}async _call(xe,{threshold:je=.9,percentage:Ye=!1}={}){const et=Array.isArray(xe);if(et&&xe.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const A=await C(xe),$e=Ye?null:A.map(D=>[D.height,D.width]),{pixel_values:Pe,pixel_mask:ae}=await this.processor(A),ne=await this.model({pixel_values:Pe,pixel_mask:ae}),ve=this.processor.feature_extractor.post_process_object_detection(ne,je,$e),R=this.model.config.id2label,ee=ve.map(D=>D.boxes.map((ce,ue)=>({score:D.scores[ue],label:R[D.classes[ue]],box:z(ce,!Ye)})));return et?ee:ee[0]}}class Me extends ${constructor(xe){super(xe)}async _call(xe,je,{threshold:Ye=.1,top_k:et=null,percentage:A=!1}={}){const $e=Array.isArray(xe),Pe=await C(xe),ae=this.tokenizer(je,{padding:!0,truncation:!0}),ne=await this.processor(Pe),ve=[];for(let R=0;R<Pe.length;++R){const ee=Pe[R],D=A?null:[[ee.height,ee.width]],ce=ne.pixel_values[R].unsqueeze_(0),ue=await this.model({...ae,pixel_values:ce}),ke=this.processor.feature_extractor.post_process_object_detection(ue,Ye,D,!0)[0];let Re=ke.boxes.map((ht,tt)=>({score:ke.scores[tt],label:je[ke.classes[tt]],box:z(ht,!A)})).sort((ht,tt)=>tt.score-ht.score);et!==null&&(Re=Re.slice(0,et)),ve.push(Re)}return $e?ve:ve[0]}}class X extends ${constructor(xe){super(xe)}async _call(xe,je,Ye={}){throw new Error("This pipeline is not yet supported in Transformers.js v3.")}}class ge extends ${constructor(je){super(je);He(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=je.vocoder??null}async _call(je,{speaker_embeddings:Ye=null}={}){return this.processor?this._call_text_to_spectrogram(je,{speaker_embeddings:Ye}):this._call_text_to_waveform(je)}async _call_text_to_waveform(je){const Ye=this.tokenizer(je,{padding:!0,truncation:!0}),{waveform:et}=await this.model(Ye),A=this.model.config.sampling_rate;return{audio:et.data,sampling_rate:A}}async _call_text_to_spectrogram(je,{speaker_embeddings:Ye}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await a.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof Ye=="string"||Ye instanceof URL)&&(Ye=new Float32Array(await(await fetch(Ye)).arrayBuffer())),Ye instanceof Float32Array)Ye=new M.Tensor("float32",Ye,[1,Ye.length]);else if(!(Ye instanceof M.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:et}=this.tokenizer(je,{padding:!0,truncation:!0}),{waveform:A}=await this.model.generate_speech(et,Ye,{vocoder:this.vocoder}),$e=this.processor.feature_extractor.config.sampling_rate;return{audio:A.data,sampling_rate:$e}}}class qe extends ${constructor(xe){super(xe)}async _call(xe){const je=await C(xe),Ye=await this.processor(je),et=await this.model(Ye),A=[];for(const $e of et.reconstruction){const Pe=$e.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");A.push(v.RawImage.fromTensor(Pe))}return A.length>1?A:A[0]}}class Be extends ${constructor(xe){super(xe)}async _call(xe){const je=await C(xe),Ye=await this.processor(je),{predicted_depth:et}=await this.model(Ye),A=[];for(let $e=0;$e<je.length;++$e){const Pe=(0,M.interpolate)(et[$e],je[$e].size.reverse(),"bilinear",!1),ae=Pe.mul_(255/(0,m.max)(Pe.data)[0]).to("uint8");A.push({predicted_depth:et[$e],depth:v.RawImage.fromTensor(ae)})}return A.length>1?A:A[0]}}const Ne=Object.freeze({"text-classification":{tokenizer:o.AutoTokenizer,pipeline:S,model:a.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:o.AutoTokenizer,pipeline:y,model:a.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:o.AutoTokenizer,pipeline:x,model:a.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:o.AutoTokenizer,pipeline:I,model:a.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:o.AutoTokenizer,pipeline:O,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:o.AutoTokenizer,pipeline:B,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:o.AutoTokenizer,pipeline:V,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:o.AutoTokenizer,pipeline:N,model:a.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:o.AutoTokenizer,pipeline:oe,model:a.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:te,model:a.AutoModelForAudioClassification,processor:l.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:o.AutoTokenizer,pipeline:we,model:a.AutoModel,processor:l.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:o.AutoTokenizer,pipeline:L,model:[a.AutoModelForSpeechSeq2Seq,a.AutoModelForCTC],processor:l.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:o.AutoTokenizer,pipeline:ge,model:[a.AutoModelForTextToWaveform,a.AutoModelForTextToSpectrogram],processor:[l.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:o.AutoTokenizer,pipeline:Ce,model:a.AutoModelForVision2Seq,processor:l.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:Xe,model:a.AutoModelForImageClassification,processor:l.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:ye,model:[a.AutoModelForImageSegmentation,a.AutoModelForSemanticSegmentation],processor:l.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:o.AutoTokenizer,pipeline:Y,model:a.AutoModel,processor:l.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:se,model:a.AutoModelForObjectDetection,processor:l.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:o.AutoTokenizer,pipeline:Me,model:a.AutoModelForZeroShotObjectDetection,processor:l.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:o.AutoTokenizer,pipeline:X,model:a.AutoModelForDocumentQuestionAnswering,processor:l.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:qe,model:a.AutoModelForImageToImage,processor:l.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:Be,model:a.AutoModelForDepthEstimation,processor:l.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:o.AutoTokenizer,pipeline:he,model:a.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:l.AutoProcessor,pipeline:Ie,model:[a.AutoModelForImageFeatureExtraction,a.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),We=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function st(Ge,xe=null,{progress_callback:je=null,config:Ye=null,cache_dir:et=null,local_files_only:A=!1,revision:$e="main",device:Pe=null,dtype:ae=null,model_file_name:ne=null,session_options:ve={}}={}){Ge=We[Ge]??Ge;const R=Ne[Ge.split("_",1)[0]];if(!R)throw Error(`Unsupported pipeline: ${Ge}. Must be one of [${Object.keys(Ne)}]`);xe||(xe=R.default.model,console.log(`No model specified. Using default model: "${xe}".`));const ee={progress_callback:je,config:Ye,cache_dir:et,local_files_only:A,revision:$e,device:Pe,dtype:ae,model_file_name:ne,session_options:ve},D=new Map([["tokenizer",R.tokenizer],["model",R.model],["processor",R.processor]]),ce=await pt(D,xe,ee);ce.task=Ge,(0,_.dispatchCallback)(je,{status:"ready",task:Ge,model:xe});const ue=R.pipeline;return new ue(ce)}async function pt(Ge,xe,je){const Ye=Object.create(null),et=[];for(let[A,$e]of Ge.entries()){if(!$e)continue;let Pe;Array.isArray($e)?Pe=new Promise(async(ae,ne)=>{var R,ee;let ve;for(let D of $e){if(D===null){ae(null);return}try{ae(await D.from_pretrained(xe,je));return}catch(ce){if((R=ce.message)!=null&&R.includes("Unsupported model type"))ve=ce;else if((ee=ce.message)!=null&&ee.includes("Could not locate file"))ve=ce;else{ne(ce);return}}}ne(ve)}):Pe=$e.from_pretrained(xe,je),Ye[A]=Pe,et.push(Pe)}await Promise.all(et);for(let[A,$e]of Object.entries(Ye))Ye[A]=await $e;return Ye}},"./src/processors.js":(e,t,n)=>{n.r(t),n.d(t,{ASTFeatureExtractor:()=>ae,AutoProcessor:()=>bt,BeitFeatureExtractor:()=>We,BitImageProcessor:()=>O,CLIPFeatureExtractor:()=>j,CLIPImageProcessor:()=>N,ChineseCLIPFeatureExtractor:()=>oe,ClapFeatureExtractor:()=>ne,ConvNextFeatureExtractor:()=>Ie,ConvNextImageProcessor:()=>te,DPTFeatureExtractor:()=>I,DPTImageProcessor:()=>V,DeiTFeatureExtractor:()=>Ne,DetrFeatureExtractor:()=>Ge,DonutFeatureExtractor:()=>st,EfficientNetImageProcessor:()=>Ce,FeatureExtractor:()=>$,Florence2Processor:()=>wt,GLPNFeatureExtractor:()=>B,ImageFeatureExtractor:()=>S,MobileNetV1FeatureExtractor:()=>Xe,MobileNetV2FeatureExtractor:()=>ye,MobileNetV3FeatureExtractor:()=>Y,MobileNetV4FeatureExtractor:()=>se,MobileViTFeatureExtractor:()=>Me,MobileViTImageProcessor:()=>X,NougatImageProcessor:()=>pt,OwlViTFeatureExtractor:()=>ge,OwlViTProcessor:()=>tt,Owlv2ImageProcessor:()=>qe,Processor:()=>D,PyAnnoteFeatureExtractor:()=>ve,PyAnnoteProcessor:()=>Re,RTDetrImageProcessor:()=>Be,SamImageProcessor:()=>je,SamProcessor:()=>ce,SapiensFeatureExtractor:()=>y,SeamlessM4TFeatureExtractor:()=>Pe,SegformerFeatureExtractor:()=>x,SiglipImageProcessor:()=>he,SpeechT5FeatureExtractor:()=>ee,SpeechT5Processor:()=>ht,Swin2SRImageProcessor:()=>Ye,ViTFeatureExtractor:()=>we,ViTImageProcessor:()=>L,VitMatteImageProcessor:()=>et,Wav2Vec2FeatureExtractor:()=>$e,Wav2Vec2ProcessorWithLM:()=>ke,WeSpeakerFeatureExtractor:()=>R,WhisperFeatureExtractor:()=>A,WhisperProcessor:()=>ue,YolosFeatureExtractor:()=>xe});var o=n("./src/utils/generic.js"),a=n("./src/utils/core.js"),l=n("./src/utils/hub.js"),f=n("./src/utils/maths.js"),_=n("./src/utils/tensor.js");n("./src/utils/image.js");var m=n("./src/utils/audio.js");function g([Ke,de,Ae,Ve]){return[Ke-Ae/2,de-Ve/2,Ke+Ae/2,de+Ve/2]}function M(Ke,de=.5,Ae=null,Ve=!1){const ot=Ke.logits,Qe=Ke.pred_boxes,[ft,xt,vt]=ot.dims;if(Ae!==null&&Ae.length!==ft)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let $t=[];for(let kt=0;kt<ft;++kt){let rt=Ae!==null?Ae[kt]:null,Nt={boxes:[],classes:[],scores:[]},Rt=ot[kt],Qt=Qe[kt];for(let Ht=0;Ht<xt;++Ht){let Gt=Rt[Ht],tr=[],ir;if(Ve){ir=Gt.sigmoid().data;for(let lr=0;lr<ir.length;++lr)ir[lr]>de&&tr.push(lr)}else{let lr=(0,f.max)(Gt.data)[1];if(lr===vt-1||(ir=(0,f.softmax)(Gt.data),ir[lr]<de))continue;tr.push(lr)}for(const lr of tr){let kr=Qt[Ht].data;kr=g(kr),rt!==null&&(kr=kr.map((mt,Tt)=>mt*rt[(Tt+1)%2])),Nt.boxes.push(kr),Nt.classes.push(lr),Nt.scores.push(ir[lr])}}$t.push(Nt)}return $t}function v(Ke,de=null){const Ae=Ke.logits,Ve=Ae.dims[0];if(de!==null&&de.length!==Ve)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const ot=[];for(let Qe=0;Qe<Ve;++Qe){const ft=de!==null?de[Qe]:null;let xt=Ae[Qe];ft!==null&&(xt=(0,_.interpolate)(xt,ft,"bilinear",!1));const[vt,$t]=ft??xt.dims.slice(-2),kt=new _.Tensor("int32",new Int32Array(vt*$t),[vt,$t]),rt=xt[0].data,Nt=kt.data;for(let Gt=1;Gt<xt.dims[0];++Gt){const tr=xt[Gt].data;for(let ir=0;ir<tr.length;++ir)tr[ir]>rt[ir]&&(rt[ir]=tr[ir],Nt[ir]=Gt)}const Rt=new Array(xt.dims[0]),Qt=kt.data;for(let Gt=0;Gt<Qt.length;++Gt){const tr=Qt[Gt];Rt[tr]=tr}const Ht=Rt.filter(Gt=>Gt!==void 0);ot.push({segmentation:kt,labels:Ht})}return ot}function C(Ke,de){var Ae;if(!(Ke instanceof Float32Array||Ke instanceof Float64Array))throw new Error(`${de} expects input to be a Float32Array or a Float64Array, but got ${((Ae=Ke==null?void 0:Ke.constructor)==null?void 0:Ae.name)??typeof Ke} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function k(Ke,de,Ae=0,Ve=null){const ot=Ke/de;let Qe=(0,f.bankers_round)(ot)*de;return Ve!==null&&Qe>Ve&&(Qe=Math.floor(ot)*de),Qe<Ae&&(Qe=Math.ceil(ot)*de),Qe}function z([Ke,de],Ae){return[Math.max(Math.floor(Ke/Ae),1)*Ae,Math.max(Math.floor(de/Ae),1)*Ae]}class $ extends o.Callable{constructor(de){super(),this.config=de}}class S extends ${constructor(de){super(de),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=this.config.do_flip_channel_order??!1}async thumbnail(de,Ae,Ve=2){const ot=de.height,Qe=de.width,ft=Ae.height,xt=Ae.width;let vt=Math.min(ot,ft),$t=Math.min(Qe,xt);return vt===ot&&$t===Qe?de:(ot>Qe?$t=Math.floor(Qe*vt/ot):Qe>ot&&(vt=Math.floor(ot*$t/Qe)),await de.resize($t,vt,{resample:Ve}))}async crop_margin(de,Ae=200){const Ve=de.clone().grayscale(),ot=(0,f.min)(Ve.data)[0],ft=(0,f.max)(Ve.data)[0]-ot;if(ft===0)return de;const xt=Ae/255;let vt=Ve.width,$t=Ve.height,kt=0,rt=0;const Nt=Ve.data;for(let Rt=0;Rt<Ve.height;++Rt){const Qt=Rt*Ve.width;for(let Ht=0;Ht<Ve.width;++Ht)(Nt[Qt+Ht]-ot)/ft<xt&&(vt=Math.min(vt,Ht),$t=Math.min($t,Rt),kt=Math.max(kt,Ht),rt=Math.max(rt,Rt))}return de=await de.crop([vt,$t,kt,rt]),de}pad_image(de,Ae,Ve,{mode:ot="constant",center:Qe=!1,constant_values:ft=0}={}){const[xt,vt,$t]=Ae;let kt,rt;if(typeof Ve=="number"?(kt=Ve,rt=Ve):(kt=Ve.width,rt=Ve.height),kt!==vt||rt!==xt){const Nt=new Float32Array(kt*rt*$t);if(Array.isArray(ft))for(let Ht=0;Ht<Nt.length;++Ht)Nt[Ht]=ft[Ht%$t];else ft!==0&&Nt.fill(ft);const[Rt,Qt]=Qe?[Math.floor((kt-vt)/2),Math.floor((rt-xt)/2)]:[0,0];for(let Ht=0;Ht<xt;++Ht){const Gt=(Ht+Qt)*kt,tr=Ht*vt;for(let ir=0;ir<vt;++ir){const lr=(Gt+ir+Rt)*$t,kr=(tr+ir)*$t;for(let mt=0;mt<$t;++mt)Nt[lr+mt]=de[kr+mt]}}if(ot==="symmetric"){if(Qe)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const Ht=xt-1,Gt=vt-1;for(let tr=0;tr<rt;++tr){const ir=tr*kt,lr=(0,a.calculateReflectOffset)(tr,Ht)*vt;for(let kr=0;kr<kt;++kr){if(tr<xt&&kr<vt)continue;const mt=(ir+kr)*$t,Tt=(lr+(0,a.calculateReflectOffset)(kr,Gt))*$t;for(let Lt=0;Lt<$t;++Lt)Nt[mt+Lt]=de[Tt+Lt]}}}de=Nt,Ae=[rt,kt,$t]}return[de,Ae]}rescale(de){for(let Ae=0;Ae<de.length;++Ae)de[Ae]=this.rescale_factor*de[Ae]}get_resize_output_image_size(de,Ae){const[Ve,ot]=de.size;let Qe,ft;if(this.do_thumbnail){const{height:xt,width:vt}=Ae;Qe=Math.min(xt,vt)}else Number.isInteger(Ae)?(Qe=Ae,ft=this.config.max_size??Qe):Ae!==void 0&&(Qe=Ae.shortest_edge,ft=Ae.longest_edge);if(Qe!==void 0||ft!==void 0){const xt=Qe===void 0?1:Math.max(Qe/Ve,Qe/ot),vt=Ve*xt,$t=ot*xt,kt=ft===void 0?1:Math.min(ft/vt,ft/$t);let rt=Math.floor(Number((vt*kt).toFixed(2))),Nt=Math.floor(Number(($t*kt).toFixed(2)));return this.size_divisibility!==void 0&&([rt,Nt]=z([rt,Nt],this.size_divisibility)),[rt,Nt]}else if(Ae!==void 0&&Ae.width!==void 0&&Ae.height!==void 0){let xt=Ae.width,vt=Ae.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let $t=vt/ot,kt=xt/Ve;Math.abs(1-kt)<Math.abs(1-$t)?$t=kt:kt=$t,vt=k($t*ot,this.config.ensure_multiple_of),xt=k(kt*Ve,this.config.ensure_multiple_of)}return[xt,vt]}else{if(this.size_divisibility!==void 0)return z([Ve,ot],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(Ae)}`)}}async resize(de){const[Ae,Ve]=this.get_resize_output_image_size(de,this.size);return await de.resize(Ae,Ve,{resample:this.resample})}async preprocess(de,{do_normalize:Ae=null,do_pad:Ve=null,do_convert_rgb:ot=null,do_convert_grayscale:Qe=null,do_flip_channel_order:ft=null}={}){this.do_crop_margin&&(de=await this.crop_margin(de));const[xt,vt]=de.size;if(ot??this.do_convert_rgb?de=de.rgb():Qe&&(de=de.grayscale()),this.do_resize&&(de=await this.resize(de)),this.do_thumbnail&&(de=await this.thumbnail(de,this.size,this.resample)),this.do_center_crop){let Rt,Qt;Number.isInteger(this.crop_size)?(Rt=this.crop_size,Qt=this.crop_size):(Rt=this.crop_size.width,Qt=this.crop_size.height),de=await de.center_crop(Rt,Qt)}const $t=[de.height,de.width];let kt=Float32Array.from(de.data),rt=[de.height,de.width,de.channels];if(this.do_rescale&&this.rescale(kt),Ae??this.do_normalize){let Rt=this.image_mean;Array.isArray(this.image_mean)||(Rt=new Array(de.channels).fill(Rt));let Qt=this.image_std;if(Array.isArray(this.image_std)||(Qt=new Array(de.channels).fill(Rt)),Rt.length!==de.channels||Qt.length!==de.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${Rt.length}) and \`image_std\` (${Qt.length}) must match the number of channels in the image (${de.channels}).`);for(let Ht=0;Ht<kt.length;Ht+=de.channels)for(let Gt=0;Gt<de.channels;++Gt)kt[Ht+Gt]=(kt[Ht+Gt]-Rt[Gt])/Qt[Gt]}if(Ve??this.do_pad){if(this.pad_size)[kt,rt]=this.pad_image(kt,[de.height,de.width,de.channels],this.pad_size);else if(this.size_divisibility){const[Rt,Qt]=z([rt[1],rt[0]],this.size_divisibility);[kt,rt]=this.pad_image(kt,rt,{width:Rt,height:Qt})}}if(ft??this.do_flip_channel_order){if(rt[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let Rt=0;Rt<kt.length;Rt+=3){const Qt=kt[Rt];kt[Rt]=kt[Rt+2],kt[Rt+2]=Qt}}const Nt=new _.Tensor("float32",kt,rt).permute(2,0,1);return{original_size:[vt,xt],reshaped_input_size:$t,pixel_values:Nt}}async _call(de,...Ae){Array.isArray(de)||(de=[de]);const Ve=await Promise.all(de.map(Qe=>this.preprocess(Qe)));return{pixel_values:(0,_.stack)(Ve.map(Qe=>Qe.pixel_values),0),original_sizes:Ve.map(Qe=>Qe.original_size),reshaped_input_sizes:Ve.map(Qe=>Qe.reshaped_input_size)}}}class y extends S{post_process_semantic_segmentation(...de){return v(...de)}}class x extends S{post_process_semantic_segmentation(...de){return v(...de)}}class I extends S{}class V extends I{}class O extends S{}class B extends S{}class j extends S{}class N extends j{}class oe extends S{}class he extends S{}class Ie extends S{constructor(de){super(de),this.crop_pct=this.config.crop_pct??224/256}async resize(de){var Ve;const Ae=(Ve=this.size)==null?void 0:Ve.shortest_edge;if(Ae===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(Ae<384){const ot=Math.floor(Ae/this.crop_pct),[Qe,ft]=this.get_resize_output_image_size(de,{shortest_edge:ot});de=await de.resize(Qe,ft,{resample:this.resample}),de=await de.center_crop(Ae,Ae)}else de=await de.resize(Ae,Ae,{resample:this.resample});return de}}class te extends Ie{}class we extends S{}class L extends S{}class Ce extends S{constructor(de){super(de),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(Ae=>Ae*Ae))}}class Xe extends S{}class ye extends S{}class Y extends S{}class se extends S{}class Me extends S{}class X extends Me{}class ge extends S{post_process_object_detection(...de){return M(...de)}}class qe extends ge{}class Be extends S{post_process_object_detection(...de){return M(...de)}}class Ne extends S{}class We extends S{}class st extends S{pad_image(de,Ae,Ve,ot={}){const[Qe,ft,xt]=Ae;let vt=this.image_mean;Array.isArray(this.image_mean)||(vt=new Array(xt).fill(vt));let $t=this.image_std;Array.isArray($t)||($t=new Array(xt).fill(vt));const kt=vt.map((rt,Nt)=>-rt/$t[Nt]);return super.pad_image(de,Ae,Ve,{center:!0,constant_values:kt,...ot})}}class pt extends st{}class Ge extends S{async _call(de){const Ae=await super._call(de),Ve=[Ae.pixel_values.dims[0],64,64],ot=new _.Tensor("int64",new BigInt64Array(Ve.reduce((Qe,ft)=>Qe*ft)).fill(1n),Ve);return{...Ae,pixel_mask:ot}}post_process_object_detection(...de){return M(...de)}remove_low_and_no_objects(de,Ae,Ve,ot){let Qe=[],ft=[],xt=[];for(let vt=0;vt<de.dims[0];++vt){let $t=de[vt],kt=Ae[vt],rt=(0,f.max)($t.data)[1];if(rt===ot)continue;let Rt=(0,f.softmax)($t.data)[rt];Rt>Ve&&(Qe.push(kt),ft.push(Rt),xt.push(rt))}return[Qe,ft,xt]}check_segment_validity(de,Ae,Ve,ot=.5,Qe=.8){let ft=[],xt=0,vt=0;const $t=Ae[Ve].data;for(let rt=0;rt<de.length;++rt)de[rt]===Ve&&(ft.push(rt),++xt),$t[rt]>=ot&&++vt;let kt=xt>0&&vt>0;return kt&&(kt=xt/vt>Qe),[kt,ft]}compute_segments(de,Ae,Ve,ot,Qe,ft=null,xt=null){let[vt,$t]=xt??de[0].dims,kt=new _.Tensor("int32",new Int32Array(vt*$t),[vt,$t]),rt=[];if(xt!==null)for(let Gt=0;Gt<de.length;++Gt)de[Gt]=(0,_.interpolate)(de[Gt],xt,"bilinear",!1);let Nt=new Int32Array(de[0].data.length),Rt=new Float32Array(de[0].data.length);for(let Gt=0;Gt<de.length;++Gt){let tr=Ae[Gt];const ir=de[Gt].data;for(let lr=0;lr<ir.length;++lr)ir[lr]*=tr,ir[lr]>Rt[lr]&&(Nt[lr]=Gt,Rt[lr]=ir[lr])}let Qt=0;const Ht=kt.data;for(let Gt=0;Gt<Ve.length;++Gt){let tr=Ve[Gt],[ir,lr]=this.check_segment_validity(Nt,de,Gt,ot,Qe);if(ir){++Qt;for(let kr of lr)Ht[kr]=Qt;rt.push({id:Qt,label_id:tr,score:Ae[Gt]})}}return[kt,rt]}post_process_panoptic_segmentation(de,Ae=.5,Ve=.5,ot=.8,Qe=null,ft=null){Qe===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),Qe=new Set);const xt=de.logits,$t=de.pred_masks.sigmoid();let[kt,rt,Nt]=xt.dims;if(Nt-=1,ft!==null&&ft.length!==kt)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Rt=[];for(let Qt=0;Qt<kt;++Qt){let Ht=ft!==null?ft[Qt]:null,Gt=xt[Qt],tr=$t[Qt],[ir,lr,kr]=this.remove_low_and_no_objects(Gt,tr,Ae,Nt);if(kr.length===0){let[Lt,nn]=Ht??tr.dims.slice(-2),yi=new _.Tensor("int32",new Int32Array(Lt*nn).fill(-1),[Lt,nn]);Rt.push({segmentation:yi,segments_info:[]});continue}let[mt,Tt]=this.compute_segments(ir,lr,kr,Ve,ot,Qe,Ht);Rt.push({segmentation:mt,segments_info:Tt})}return Rt}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class xe extends S{post_process_object_detection(...de){return M(...de)}}class je extends S{reshape_input_points(de,Ae,Ve,ot=!1){de=structuredClone(de);let Qe=(0,a.calculateDimensions)(de);if(Qe.length===3)ot||(Qe=[1,...Qe]),de=[de];else if(Qe.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let ft=0;ft<de.length;++ft){let xt=Ae[ft],vt=Ve[ft],$t=[vt[0]/xt[0],vt[1]/xt[1]];for(let kt=0;kt<de[ft].length;++kt)for(let rt=0;rt<de[ft][kt].length;++rt)for(let Nt=0;Nt<de[ft][kt][rt].length;++Nt)de[ft][kt][rt][Nt]*=$t[Nt%2]}return new _.Tensor("float32",Float32Array.from(de.flat(1/0)),Qe)}add_input_labels(de,Ae){let Ve=(0,a.calculateDimensions)(de);if(Ve.length===2)Ve=[1,...Ve],de=[de];else if(Ve.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(Ve.some((ot,Qe)=>ot!==Ae.dims[Qe]))throw Error(`The first ${Ve.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new _.Tensor("int64",de.flat(1/0).map(BigInt),Ve)}async _call(de,{input_points:Ae=null,input_labels:Ve=null,input_boxes:ot=null}={}){const Qe=await super._call(de);if(Ae&&(Qe.input_points=this.reshape_input_points(Ae,Qe.original_sizes,Qe.reshaped_input_sizes)),Ve){if(!Qe.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");Qe.input_labels=this.add_input_labels(Ve,Qe.input_points)}return ot&&(Qe.input_boxes=this.reshape_input_points(ot,Qe.original_sizes,Qe.reshaped_input_sizes,!0)),Qe}async post_process_masks(de,Ae,Ve,{mask_threshold:ot=0,binarize:Qe=!0,pad_size:ft=null}={}){const xt=[];ft=ft??this.pad_size;const vt=[ft.height,ft.width];for(let $t=0;$t<Ae.length;++$t){const kt=Ae[$t],rt=Ve[$t];let Nt=await(0,_.interpolate_4d)(de[$t],{mode:"bilinear",size:vt});if(Nt=Nt.slice(null,null,[0,rt[0]],[0,rt[1]]),Nt=await(0,_.interpolate_4d)(Nt,{mode:"bilinear",size:kt}),Qe){const Rt=Nt.data,Qt=new Uint8Array(Rt.length);for(let Ht=0;Ht<Rt.length;++Ht)Rt[Ht]>ot&&(Qt[Ht]=1);Nt=new _.Tensor("bool",Qt,Nt.dims)}xt.push(Nt)}return xt}generate_crop_boxes(de,Ae,{crop_n_layers:Ve=0,overlap_ratio:ot=512/1500,points_per_crop:Qe=32,crop_n_points_downscale_factor:ft=1}={}){}}class Ye extends S{pad_image(de,Ae,Ve,ot={}){const[Qe,ft,xt]=Ae;return super.pad_image(de,Ae,{width:ft+(Ve-ft%Ve)%Ve,height:Qe+(Ve-Qe%Ve)%Ve},{mode:"symmetric",center:!1,constant_values:-1,...ot})}}class et extends S{async _call(de,Ae){Array.isArray(de)||(de=[de]),Array.isArray(Ae)||(Ae=[Ae]);const Ve=await Promise.all(de.map(ft=>this.preprocess(ft))),ot=await Promise.all(Ae.map(ft=>this.preprocess(ft,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,_.stack)(Ve.map((ft,xt)=>(0,_.cat)([ft.pixel_values,ot[xt].pixel_values],0)),0),original_sizes:Ve.map(ft=>ft.original_size),reshaped_input_sizes:Ve.map(ft=>ft.reshaped_input_size)}}}class A extends ${constructor(de){var Ae;super(de),(Ae=this.config).mel_filters??(Ae.mel_filters=(0,m.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=(0,m.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(de){const Ae=await(0,m.spectrogram)(de,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),Ve=Ae.data,ot=(0,f.max)(Ve)[0];for(let Qe=0;Qe<Ve.length;++Qe)Ve[Qe]=(Math.max(Ve[Qe],ot-8)+4)/4;return Ae}async _call(de){C(de,"WhisperFeatureExtractor");let Ae;return de.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),Ae=de.slice(0,this.config.n_samples)):(Ae=new Float32Array(this.config.n_samples),Ae.set(de)),{input_features:(await this._extract_fbank_features(Ae)).unsqueeze_(0)}}}class $e extends ${_zero_mean_unit_var_norm(de){const Ve=de.reduce((Qe,ft)=>Qe+ft,0)/de.length,ot=de.reduce((Qe,ft)=>Qe+(ft-Ve)**2,0)/de.length;return de.map(Qe=>(Qe-Ve)/Math.sqrt(ot+1e-7))}async _call(de){C(de,"Wav2Vec2FeatureExtractor"),de instanceof Float64Array&&(de=new Float32Array(de));let Ae=de;this.config.do_normalize&&(Ae=this._zero_mean_unit_var_norm(Ae));const Ve=[1,Ae.length];return{input_values:new _.Tensor("float32",Ae,Ve),attention_mask:new _.Tensor("int64",new BigInt64Array(Ae.length).fill(1n),Ve)}}}class Pe extends ${constructor(de){super(de);const Ae=this.config.sampling_rate,Ve=(0,m.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Ae/2),Ae,null,"kaldi",!0);for(let ot=0;ot<Ve.length;++ot)Ve[ot].push(0);this.mel_filters=Ve,this.window=(0,m.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(de,Ae){return de=de.map(Ve=>Ve*32768),(0,m.spectrogram)(de,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:Ae,transpose:!0})}async _call(de,{padding:Ae=!0,pad_to_multiple_of:Ve=2,do_normalize_per_mel_bins:ot=!0,return_attention_mask:Qe=!0}={}){C(de,"SeamlessM4TFeatureExtractor");let ft=await this._extract_fbank_features(de,this.config.max_length);if(ot){const[Qt,Ht]=ft.dims,Gt=ft.data;for(let tr=0;tr<Ht;++tr){let ir=0;for(let Tt=0;Tt<Qt;++Tt)ir+=Gt[Tt*Ht+tr];const lr=ir/Qt;let kr=0;for(let Tt=0;Tt<Qt;++Tt)kr+=(Gt[Tt*Ht+tr]-lr)**2;kr/=Qt-1;const mt=Math.sqrt(kr+1e-7);for(let Tt=0;Tt<Qt;++Tt){const Lt=Tt*Ht+tr;Gt[Lt]=(Gt[Lt]-lr)/mt}}}let xt;if(Ae){const[Qt,Ht]=ft.dims,Gt=ft.data,tr=Qt%Ve;if(tr>0){const ir=new Float32Array(Ht*(Qt+tr));ir.set(Gt),ir.fill(this.config.padding_value,Gt.length);const lr=Qt+tr;ft=new _.Tensor(ft.type,ir,[lr,Ht]),Qe&&(xt=new _.Tensor("int64",new BigInt64Array(lr),[1,lr]),xt.data.fill(1n,0,Qt))}}const[vt,$t]=ft.dims,kt=this.config.stride;if(vt%kt!==0)throw new Error(`The number of frames (${vt}) must be a multiple of the stride (${kt}).`);const Nt=ft.view(1,Math.floor(vt/kt),$t*kt),Rt={input_features:Nt};if(Qe){const Qt=Nt.dims[1],Ht=new BigInt64Array(Qt);if(xt){const Gt=xt.data;for(let tr=1,ir=0;tr<vt;tr+=kt,++ir)Ht[ir]=Gt[tr]}else Ht.fill(1n);Rt.attention_mask=new _.Tensor("int64",Ht,[1,Qt])}return Rt}}class ae extends ${constructor(de){super(de);const Ae=this.config.sampling_rate,Ve=(0,m.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Ae/2),Ae,null,"kaldi",!0);for(let ot=0;ot<Ve.length;++ot)Ve[ot].push(0);this.mel_filters=Ve,this.window=(0,m.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(de,Ae){return(0,m.spectrogram)(de,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:Ae,transpose:!0})}async _call(de){C(de,"ASTFeatureExtractor");const Ae=await this._extract_fbank_features(de,this.config.max_length);if(this.config.do_normalize){const Ve=this.std*2,ot=Ae.data;for(let Qe=0;Qe<ot.length;++Qe)ot[Qe]=(ot[Qe]-this.mean)/Ve}return{input_values:Ae.unsqueeze_(0)}}}class ne extends ${constructor(de){super(de),this.mel_filters=(0,m.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,m.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,m.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(de,Ae,Ve,ot){let Qe;const ft=de.length-Ae;if(ft>0)if(Ve==="rand_trunc"){const xt=Math.floor(Math.random()*(ft+1));de=de.subarray(xt,xt+Ae),Qe=await this._extract_fbank_features(de,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${Ve}" not implemented`);else{if(ft<0){let xt=new Float64Array(Ae);if(xt.set(de),ot==="repeat")for(let vt=de.length;vt<Ae;vt+=de.length)xt.set(de.subarray(0,Math.min(de.length,Ae-vt)),vt);else if(ot==="repeatpad")for(let vt=de.length;vt<-ft;vt+=de.length)xt.set(de,vt);de=xt}if(Ve==="fusion")throw new Error(`Truncation strategy "${Ve}" not implemented`);Qe=await this._extract_fbank_features(de,this.mel_filters_slaney,this.config.nb_max_samples)}return Qe.unsqueeze_(0)}async _extract_fbank_features(de,Ae,Ve=null){return(0,m.spectrogram)(de,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:Ae,log_mel:"dB",max_num_frames:Ve,do_pad:!1,transpose:!0})}async _call(de,{max_length:Ae=null}={}){return C(de,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(de,Ae??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}class ve extends ${async _call(de){C(de,"PyAnnoteFeatureExtractor"),de instanceof Float64Array&&(de=new Float32Array(de));const Ae=[1,1,de.length];return{input_values:new _.Tensor("float32",de,Ae)}}samples_to_frames(de){return(de-this.config.offset)/this.config.step}post_process_speaker_diarization(de,Ae){const Ve=Ae/this.samples_to_frames(Ae)/this.config.sampling_rate,ot=[];for(const Qe of de.tolist()){const ft=[];let xt=-1;for(let vt=0;vt<Qe.length;++vt){const $t=(0,f.softmax)(Qe[vt]),[kt,rt]=(0,f.max)($t),[Nt,Rt]=[vt,vt+1];rt!==xt?(xt=rt,ft.push({id:rt,start:Nt,end:Rt,score:kt})):(ft.at(-1).end=Rt,ft.at(-1).score+=kt)}ot.push(ft.map(({id:vt,start:$t,end:kt,score:rt})=>({id:vt,start:$t*Ve,end:kt*Ve,confidence:rt/(kt-$t)})))}return ot}}class R extends ${constructor(de){super(de);const Ae=this.config.sampling_rate,Ve=(0,m.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Ae/2),Ae,null,"kaldi",!0);for(let ot=0;ot<Ve.length;++ot)Ve[ot].push(0);this.mel_filters=Ve,this.window=(0,m.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(de){return de=de.map(Ae=>Ae*32768),(0,m.spectrogram)(de,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(de){C(de,"WeSpeakerFeatureExtractor");const Ae=(await this._extract_fbank_features(de)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const Ve=Ae.mean(1).data,ot=Ae.data,[Qe,ft,xt]=Ae.dims;for(let vt=0;vt<Qe;++vt){const $t=vt*ft*xt,kt=vt*xt;for(let rt=0;rt<ft;++rt){const Nt=$t+rt*xt;for(let Rt=0;Rt<xt;++Rt)ot[Nt+Rt]-=Ve[kt+Rt]}}}return{input_features:Ae}}}class ee extends ${}class D extends o.Callable{constructor(de){super(),this.feature_extractor=de}async _call(de,...Ae){return await this.feature_extractor(de,...Ae)}}class ce extends D{async _call(...de){return await this.feature_extractor(...de)}post_process_masks(...de){return this.feature_extractor.post_process_masks(...de)}reshape_input_points(...de){return this.feature_extractor.reshape_input_points(...de)}}class ue extends D{async _call(de){return await this.feature_extractor(de)}}class ke extends D{async _call(de){return await this.feature_extractor(de)}}class Re extends D{async _call(de){return await this.feature_extractor(de)}post_process_speaker_diarization(...de){return this.feature_extractor.post_process_speaker_diarization(...de)}}class ht extends D{async _call(de){return await this.feature_extractor(de)}}class tt extends D{}class wt extends D{constructor(de){super(de);const{tasks_answer_post_processing_type:Ae,task_prompts_without_inputs:Ve,task_prompts_with_input:ot}=de.config;this.tasks_answer_post_processing_type=new Map(Object.entries(Ae??{})),this.task_prompts_without_inputs=new Map(Object.entries(Ve??{})),this.task_prompts_with_input=new Map(Object.entries(ot??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(de){typeof de=="string"&&(de=[de]);const Ae=[];for(const Ve of de)if(this.task_prompts_without_inputs.has(Ve))Ae.push(this.task_prompts_without_inputs.get(Ve));else{for(const[ot,Qe]of this.task_prompts_with_input)if(Ve.includes(ot)){Ae.push(Qe.replaceAll("{input}",Ve).replaceAll(ot,""));break}Ae.length!==de.length&&Ae.push(Ve)}return Ae}post_process_generation(de,Ae,Ve){const ot=this.tasks_answer_post_processing_type.get(Ae)??"pure_text";de=de.replaceAll("<s>","").replaceAll("</s>","");let Qe;switch(ot){case"pure_text":Qe=de;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const ft=ot==="ocr"?"quad_boxes":"bboxes",xt=de.matchAll(this.regexes[ft]),vt=[],$t=[];for(const[kt,rt,...Nt]of xt)vt.push(rt?rt.trim():vt.at(-1)??""),$t.push(Nt.map((Rt,Qt)=>(Number(Rt)+.5)/this.size_per_bin*Ve[Qt%2]));Qe={labels:vt,[ft]:$t};break;default:throw new Error(`Task "${Ae}" (of type "${ot}") not yet implemented.`)}return{[Ae]:Qe}}}class bt{static async from_pretrained(de,{progress_callback:Ae=null,config:Ve=null,cache_dir:ot=null,local_files_only:Qe=!1,revision:ft="main"}={}){let xt=Ve??await(0,l.getModelJSON)(de,"preprocessor_config.json",!0,{progress_callback:Ae,config:Ve,cache_dir:ot,local_files_only:Qe,revision:ft}),vt=xt.feature_extractor_type??xt.image_processor_type,$t=this.FEATURE_EXTRACTOR_CLASS_MAPPING[vt];if(!$t)if(xt.size!==void 0)console.warn(`Feature extractor type "${vt}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),$t=S;else throw new Error(`Unknown Feature Extractor type: ${vt}`);let kt=this.PROCESSOR_CLASS_MAPPING[xt.processor_class]??D,rt=new $t(xt);return new kt(rt)}}He(bt,"FEATURE_EXTRACTOR_CLASS_MAPPING",{ImageFeatureExtractor:S,WhisperFeatureExtractor:A,ViTFeatureExtractor:we,MobileViTFeatureExtractor:Me,MobileViTImageProcessor:X,MobileNetV1FeatureExtractor:Xe,MobileNetV2FeatureExtractor:ye,MobileNetV3FeatureExtractor:Y,MobileNetV4FeatureExtractor:se,OwlViTFeatureExtractor:ge,Owlv2ImageProcessor:qe,CLIPFeatureExtractor:j,CLIPImageProcessor:N,Florence2Processor:wt,ChineseCLIPFeatureExtractor:oe,SiglipImageProcessor:he,ConvNextFeatureExtractor:Ie,ConvNextImageProcessor:te,SegformerFeatureExtractor:x,SapiensFeatureExtractor:y,BitImageProcessor:O,DPTImageProcessor:V,DPTFeatureExtractor:I,GLPNFeatureExtractor:B,BeitFeatureExtractor:We,DeiTFeatureExtractor:Ne,DetrFeatureExtractor:Ge,RTDetrImageProcessor:Be,YolosFeatureExtractor:xe,DonutFeatureExtractor:st,NougatImageProcessor:pt,EfficientNetImageProcessor:Ce,ViTImageProcessor:L,VitMatteImageProcessor:et,SamImageProcessor:je,Swin2SRImageProcessor:Ye,Wav2Vec2FeatureExtractor:$e,SeamlessM4TFeatureExtractor:Pe,SpeechT5FeatureExtractor:ee,ASTFeatureExtractor:ae,ClapFeatureExtractor:ne,PyAnnoteFeatureExtractor:ve,WeSpeakerFeatureExtractor:R}),He(bt,"PROCESSOR_CLASS_MAPPING",{WhisperProcessor:ue,Wav2Vec2ProcessorWithLM:ke,PyAnnoteProcessor:Re,SamProcessor:ce,SpeechT5Processor:ht,OwlViTProcessor:tt,Florence2Processor:wt})},"./src/tokenizers.js":(e,t,n)=>{n.r(t),n.d(t,{AlbertTokenizer:()=>Rt,AutoTokenizer:()=>qn,BartTokenizer:()=>Qr,BertTokenizer:()=>Nt,BlenderbotSmallTokenizer:()=>Ko,BlenderbotTokenizer:()=>vo,BloomTokenizer:()=>Nr,CLIPTokenizer:()=>Zt,CamembertTokenizer:()=>Tt,CodeGenTokenizer:()=>wo,CodeLlamaTokenizer:()=>$s,CohereTokenizer:()=>Kr,ConvBertTokenizer:()=>lr,DebertaTokenizer:()=>Gt,DebertaV2Tokenizer:()=>tr,DistilBertTokenizer:()=>mt,ElectraTokenizer:()=>nn,EsmTokenizer:()=>Gi,FalconTokenizer:()=>Wo,GPT2Tokenizer:()=>Ai,GPTNeoXTokenizer:()=>Go,GemmaTokenizer:()=>_o,Grok1Tokenizer:()=>vi,HerbertTokenizer:()=>ir,LlamaTokenizer:()=>Ii,M2M100Tokenizer:()=>ro,MBart50Tokenizer:()=>Yr,MBartTokenizer:()=>kn,MPNetTokenizer:()=>Vo,MarianTokenizer:()=>Ho,MobileBertTokenizer:()=>Qt,NllbTokenizer:()=>Fi,NougatTokenizer:()=>bo,PreTrainedTokenizer:()=>rt,Qwen2Tokenizer:()=>As,RoFormerTokenizer:()=>kr,RobertaTokenizer:()=>wi,SiglipTokenizer:()=>no,SpeechT5Tokenizer:()=>Qo,SqueezeBertTokenizer:()=>Ht,T5Tokenizer:()=>yi,TokenizerModel:()=>Ie,VitsTokenizer:()=>Xo,Wav2Vec2CTCTokenizer:()=>qo,WhisperTokenizer:()=>yo,XLMRobertaTokenizer:()=>Uo,XLMTokenizer:()=>Lt,is_chinese_char:()=>V});var o=n("./src/utils/generic.js"),a=n("./src/utils/core.js"),l=n("./src/utils/hub.js"),f=n("./src/utils/maths.js"),_=n("./src/utils/tensor.js"),m=n("./src/utils/data-structures.js"),g=n("./node_modules/@huggingface/jinja/dist/index.js"),M=n("./src/models/whisper/common_whisper.js"),v=n("./src/utils/constants.js");async function C(Ue,W){const fe=await Promise.all([(0,l.getModelJSON)(Ue,"tokenizer.json",!0,W),(0,l.getModelJSON)(Ue,"tokenizer_config.json",!0,W)]);return W.legacy!==null&&(fe[1].legacy=W.legacy),fe}function k(Ue,W){const fe=[];let Ee=0;for(const Oe of Ue.matchAll(W)){const Le=Oe[0];Ee<Oe.index&&fe.push(Ue.slice(Ee,Oe.index)),Le.length>0&&fe.push(Le),Ee=Oe.index+Le.length}return Ee<Ue.length&&fe.push(Ue.slice(Ee)),fe}function z(Ue,W=!0){if(Ue.Regex!==void 0){let fe=Ue.Regex.replace(/\\([#&~])/g,"$1");for(const[Ee,Oe]of oe)fe=fe.replaceAll(Ee,Oe);return new RegExp(fe,"gu")}else if(Ue.String!==void 0){const fe=(0,a.escapeRegExp)(Ue.String);return new RegExp(W?fe:`(${fe})`,"gu")}else return console.warn("Unknown pattern type:",Ue),null}function $(Ue){return new Map(Object.entries(Ue))}function S(Ue){const W=Ue.dims;switch(W.length){case 1:return Ue.tolist();case 2:if(W[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return Ue.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${W.length}.`)}}function y(Ue){return Ue.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function x(Ue){return Ue.replace(/[\u0300-\u036f]/g,"")}function I(Ue){return x(Ue.toLowerCase())}function V(Ue){return Ue>=19968&&Ue<=40959||Ue>=13312&&Ue<=19903||Ue>=131072&&Ue<=173791||Ue>=173824&&Ue<=177983||Ue>=177984&&Ue<=178207||Ue>=178208&&Ue<=183983||Ue>=63744&&Ue<=64255||Ue>=194560&&Ue<=195103}function O(Ue,W,fe){const Ee=[];let Oe=0;for(;Oe<Ue.length;){if(Ee.push(Ue[Oe]),(fe.get(Ue[Oe])??W)!==W){++Oe;continue}for(;Oe<Ue.length&&(fe.get(Ue[Oe])??W)===W;)++Oe}return Ee}function B(Ue){return Ue.match(/\S+/g)||[]}const j="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",N=new RegExp(`^[${j}]+$`,"gu"),oe=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);class he{constructor(W){this.content=W.content,this.id=W.id,this.single_word=W.single_word??!1,this.lstrip=W.lstrip??!1,this.rstrip=W.rstrip??!1,this.special=W.special??!1,this.normalized=W.normalized??null}}class Ie extends o.Callable{constructor(W){super(),this.config=W,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(W,...fe){switch(W.type){case"WordPiece":return new te(W);case"Unigram":return new we(W,...fe);case"BPE":return new Xe(W);default:if(W.vocab)return new ye(W,...fe);throw new Error(`Unknown TokenizerModel type: ${W.type}`)}}_call(W){let fe=this.encode(W);return this.fuse_unk&&(fe=O(fe,this.unk_token_id,this.tokens_to_ids)),fe}encode(W){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(W){return W.map(fe=>this.tokens_to_ids.get(fe)??this.unk_token_id)}convert_ids_to_tokens(W){return W.map(fe=>this.vocab[fe]??this.unk_token)}}class te extends Ie{constructor(W){super(W),this.tokens_to_ids=$(W.vocab),this.unk_token_id=this.tokens_to_ids.get(W.unk_token),this.unk_token=W.unk_token,this.max_input_chars_per_word=W.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[fe,Ee]of this.tokens_to_ids)this.vocab[Ee]=fe}encode(W){const fe=[];for(const Ee of W){const Oe=[...Ee];if(Oe.length>this.max_input_chars_per_word){fe.push(this.unk_token);continue}let Le=!1,nt=0;const Et=[];for(;nt<Oe.length;){let Pt=Oe.length,Ct=null;for(;nt<Pt;){let Ot=Oe.slice(nt,Pt).join("");if(nt>0&&(Ot=this.config.continuing_subword_prefix+Ot),this.tokens_to_ids.has(Ot)){Ct=Ot;break}--Pt}if(Ct===null){Le=!0;break}Et.push(Ct),nt=Pt}Le?fe.push(this.unk_token):fe.push(...Et)}return fe}}class we extends Ie{constructor(W,fe){super(W);const Ee=W.vocab.length;this.vocab=new Array(Ee),this.scores=new Array(Ee);for(let Oe=0;Oe<Ee;++Oe){const Le=W.vocab[Oe];this.vocab[Oe]=Le[0],this.scores[Oe]=Le[1]}this.unk_token_id=W.unk_id,this.unk_token=this.vocab[W.unk_id],this.tokens_to_ids=new Map(this.vocab.map((Oe,Le)=>[Oe,Le])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=fe.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=(0,f.min)(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new m.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(W){const fe=W.sentence,Ee=fe.length;let Oe=0;for(;Oe<Ee;){let nt=!1;for(let Et of this.trie.commonPrefixSearch(fe.slice(Oe))){const Pt=this.tokens_to_ids.get(Et),Ct=this.scores[Pt],Ot=Et.length;W.insert(Oe,Ot,Ct,Pt),!nt&&Ot===1&&(nt=!0)}nt||W.insert(Oe,1,this.unkScore,this.unk_token_id),Oe+=1}}tokenize(W){const fe=new m.TokenLattice(W,this.bosTokenId,this.eosTokenId);return this.populateNodes(fe),fe.tokens()}encode(W){const fe=[];for(const Ee of W){const Oe=this.tokenize(Ee);fe.push(...Oe)}return fe}}const L=(()=>{const Ue=[...Array.from({length:94},(Oe,Le)=>Le+33),...Array.from({length:12},(Oe,Le)=>Le+161),...Array.from({length:82},(Oe,Le)=>Le+174)],W=Ue.slice();let fe=0;for(let Oe=0;Oe<256;++Oe)Ue.includes(Oe)||(Ue.push(Oe),W.push(256+fe),fe+=1);const Ee=W.map(Oe=>String.fromCharCode(Oe));return Object.fromEntries(Ue.map((Oe,Le)=>[Oe,Ee[Le]]))})(),Ce=(0,a.reverseDictionary)(L);class Xe extends Ie{constructor(W){super(W),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=$(W.vocab),this.unk_token_id=this.tokens_to_ids.get(W.unk_token),this.unk_token=W.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[fe,Ee]of this.tokens_to_ids)this.vocab[Ee]=fe;this.bpe_ranks=new Map(W.merges.map((fe,Ee)=>[fe,Ee])),this.merges=W.merges.map(fe=>fe.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=W.end_of_word_suffix,this.continuing_subword_suffix=W.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(W){if(W.length===0)return[];const fe=this.cache.get(W);if(fe!==void 0)return fe;const Ee=Array.from(W);this.end_of_word_suffix&&(Ee[Ee.length-1]+=this.end_of_word_suffix);let Oe=[];if(Ee.length>1){const Le=new m.PriorityQueue((Pt,Ct)=>Pt.score<Ct.score);let nt={token:Ee[0],bias:0,prev:null,next:null},Et=nt;for(let Pt=1;Pt<Ee.length;++Pt){const Ct={bias:Pt/Ee.length,token:Ee[Pt],prev:Et,next:null};Et.next=Ct,this._add_node(Le,Et),Et=Ct}for(;!Le.isEmpty();){const Pt=Le.pop();if(Pt.deleted||!Pt.next||Pt.next.deleted)continue;if(Pt.deleted=!0,Pt.next.deleted=!0,Pt.prev){const Ot={...Pt.prev};Pt.prev.deleted=!0,Pt.prev=Ot,Ot.prev?Ot.prev.next=Ot:nt=Ot}const Ct={token:Pt.token+Pt.next.token,bias:Pt.bias,prev:Pt.prev,next:Pt.next.next};Ct.prev?(Ct.prev.next=Ct,this._add_node(Le,Ct.prev)):nt=Ct,Ct.next&&(Ct.next.prev=Ct,this._add_node(Le,Ct))}for(let Pt=nt;Pt!==null;Pt=Pt.next)Oe.push(Pt.token)}else Oe=Ee;if(this.continuing_subword_suffix)for(let Le=0;Le<Oe.length-1;++Le)Oe[Le]+=this.continuing_subword_suffix;return this.cache.set(W,Oe),Oe}_add_node(W,fe){const Ee=this.bpe_ranks.get(fe.token+this.BPE_SPLIT_TOKEN+fe.next.token);Ee!==void 0&&(fe.score=Ee+fe.bias,W.push(fe))}encode(W){const fe=[];for(const Ee of W){if(this.ignore_merges&&this.tokens_to_ids.has(Ee)){fe.push(Ee);continue}const Oe=this.bpe(Ee);for(const Le of Oe)this.tokens_to_ids.has(Le)?fe.push(Le):this.byte_fallback?fe.push(...Array.from(this.text_encoder.encode(Le)).map(nt=>`<0x${nt.toString(16).toUpperCase().padStart(2,"0")}>`)):fe.push(this.unk_token)}return fe}}class ye extends Ie{constructor(W,fe){super(W),this.tokens_to_ids=$(fe.target_lang?W.vocab[fe.target_lang]:W.vocab),this.bos_token=fe.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=fe.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=fe.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=fe.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[Ee,Oe]of this.tokens_to_ids)this.vocab[Oe]=Ee}encode(W){return W}}class Y extends o.Callable{constructor(W){super(),this.config=W}static fromConfig(W){if(W===null)return null;switch(W.type){case"BertNormalizer":return new pt(W);case"Precompiled":return new Ve(W);case"Sequence":return new st(W);case"Replace":return new se(W);case"NFC":return new Me(W);case"NFKC":return new X(W);case"NFKD":return new ge(W);case"Strip":return new qe(W);case"StripAccents":return new Be(W);case"Lowercase":return new Ne(W);case"Prepend":return new We(W);default:throw new Error(`Unknown Normalizer type: ${W.type}`)}}normalize(W){throw Error("normalize should be implemented in subclass.")}_call(W){return this.normalize(W)}}class se extends Y{normalize(W){const fe=z(this.config.pattern);return fe===null?W:W.replaceAll(fe,this.config.content)}}class Me extends Y{normalize(W){return W=W.normalize("NFC"),W}}class X extends Y{normalize(W){return W=W.normalize("NFKC"),W}}class ge extends Y{normalize(W){return W=W.normalize("NFKD"),W}}class qe extends Y{normalize(W){return this.config.strip_left&&this.config.strip_right?W=W.trim():(this.config.strip_left&&(W=W.trimStart()),this.config.strip_right&&(W=W.trimEnd())),W}}class Be extends Y{normalize(W){return W=x(W),W}}class Ne extends Y{normalize(W){return W=W.toLowerCase(),W}}class We extends Y{normalize(W){return W=this.config.prepend+W,W}}class st extends Y{constructor(W){super(W),this.normalizers=W.normalizers.map(fe=>Y.fromConfig(fe))}normalize(W){return this.normalizers.reduce((fe,Ee)=>Ee.normalize(fe),W)}}class pt extends Y{_tokenize_chinese_chars(W){const fe=[];for(let Ee=0;Ee<W.length;++Ee){const Oe=W[Ee],Le=Oe.charCodeAt(0);V(Le)?(fe.push(" "),fe.push(Oe),fe.push(" ")):fe.push(Oe)}return fe.join("")}stripAccents(W){return W.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}_is_control(W){switch(W){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(W)}}_clean_text(W){const fe=[];for(const Ee of W){const Oe=Ee.charCodeAt(0);Oe===0||Oe===65533||this._is_control(Ee)||(/^\s$/.test(Ee)?fe.push(" "):fe.push(Ee))}return fe.join("")}normalize(W){return this.config.clean_text&&(W=this._clean_text(W)),this.config.handle_chinese_chars&&(W=this._tokenize_chinese_chars(W)),this.config.lowercase?(W=W.toLowerCase(),this.config.strip_accents!==!1&&(W=this.stripAccents(W))):this.config.strip_accents&&(W=this.stripAccents(W)),W}}class Ge extends o.Callable{static fromConfig(W){if(W===null)return null;switch(W.type){case"BertPreTokenizer":return new xe(W);case"Sequence":return new ot(W);case"Whitespace":return new Qe(W);case"WhitespaceSplit":return new ft(W);case"Metaspace":return new de(W);case"ByteLevel":return new je(W);case"Split":return new Ye(W);case"Punctuation":return new et(W);case"Digits":return new A(W);case"Replace":return new xt(W);default:throw new Error(`Unknown PreTokenizer type: ${W.type}`)}}pre_tokenize_text(W,fe){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(W,fe){return(Array.isArray(W)?W.map(Ee=>this.pre_tokenize_text(Ee,fe)):this.pre_tokenize_text(W,fe)).flat()}_call(W,fe){return this.pre_tokenize(W,fe)}}class xe extends Ge{constructor(W){super(),this.pattern=new RegExp(`[^\\s${j}]+|[${j}]`,"gu")}pre_tokenize_text(W,fe){return W.trim().match(this.pattern)||[]}}class je extends Ge{constructor(W){super(),this.config=W,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=L,this.text_encoder=new TextEncoder}pre_tokenize_text(W,fe){return this.add_prefix_space&&!W.startsWith(" ")&&(W=" "+W),(this.use_regex?W.match(this.pattern)||[]:[W]).map(Oe=>Array.from(this.text_encoder.encode(Oe),Le=>this.byte_encoder[Le]).join(""))}}class Ye extends Ge{constructor(W){super(),this.config=W,this.pattern=z(this.config.pattern,this.config.invert)}pre_tokenize_text(W,fe){return this.pattern===null?[]:this.config.invert?W.match(this.pattern)||[]:k(W,this.pattern)}}class et extends Ge{constructor(W){super(),this.config=W,this.pattern=new RegExp(`[^${j}]+|[${j}]+`,"gu")}pre_tokenize_text(W,fe){return W.match(this.pattern)||[]}}class A extends Ge{constructor(W){super(),this.config=W;const fe=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(fe,"gu")}pre_tokenize_text(W,fe){return W.match(this.pattern)||[]}}class $e extends o.Callable{constructor(W){super(),this.config=W}static fromConfig(W){if(W===null)return null;switch(W.type){case"TemplateProcessing":return new ne(W);case"ByteLevel":return new ve(W);case"RobertaProcessing":return new ae(W);case"BertProcessing":return new Pe(W);case"Sequence":return new R(W);default:throw new Error(`Unknown PostProcessor type: ${W.type}`)}}post_process(W,...fe){throw Error("post_process should be implemented in subclass.")}_call(W,...fe){return this.post_process(W,...fe)}}class Pe extends $e{constructor(W){super(W),this.cls=W.cls[0],this.sep=W.sep[0]}post_process(W,fe=null,{add_special_tokens:Ee=!0}={}){Ee&&(W=(0,a.mergeArrays)([this.cls],W,[this.sep]));let Oe=new Array(W.length).fill(0);if(fe!==null){const Le=Ee&&this instanceof ae?[this.sep]:[],nt=Ee?[this.sep]:[];W=(0,a.mergeArrays)(W,Le,fe,nt),Oe=(0,a.mergeArrays)(Oe,new Array(fe.length+Le.length+nt.length).fill(1))}return{tokens:W,token_type_ids:Oe}}}class ae extends Pe{}class ne extends $e{constructor(W){super(W),this.single=W.single,this.pair=W.pair}post_process(W,fe=null,{add_special_tokens:Ee=!0}={}){const Oe=fe===null?this.single:this.pair;let Le=[],nt=[];for(const Et of Oe)"SpecialToken"in Et?Ee&&(Le.push(Et.SpecialToken.id),nt.push(Et.SpecialToken.type_id)):"Sequence"in Et&&(Et.Sequence.id==="A"?(Le=(0,a.mergeArrays)(Le,W),nt=(0,a.mergeArrays)(nt,new Array(W.length).fill(Et.Sequence.type_id))):Et.Sequence.id==="B"&&(Le=(0,a.mergeArrays)(Le,fe),nt=(0,a.mergeArrays)(nt,new Array(fe.length).fill(Et.Sequence.type_id))));return{tokens:Le,token_type_ids:nt}}}class ve extends $e{post_process(W,fe=null){return fe&&(W=(0,a.mergeArrays)(W,fe)),{tokens:W}}}class R extends $e{constructor(W){super(W),this.processors=W.processors.map(fe=>$e.fromConfig(fe))}post_process(W,fe=null,Ee={}){let Oe;for(const Le of this.processors)if(Le instanceof ve)W=Le.post_process(W).tokens,fe&&(fe=Le.post_process(fe).tokens);else{const nt=Le.post_process(W,fe,Ee);W=nt.tokens,Oe=nt.token_type_ids}return{tokens:W,token_type_ids:Oe}}}class ee extends o.Callable{constructor(W){super(),this.config=W,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=W.trim_offsets}static fromConfig(W){if(W===null)return null;switch(W.type){case"WordPiece":return new Re(W);case"Metaspace":return new Ae(W);case"ByteLevel":return new ht(W);case"Replace":return new D(W);case"ByteFallback":return new ce(W);case"Fuse":return new ue(W);case"Strip":return new ke(W);case"Sequence":return new wt(W);case"CTC":return new tt(W);case"BPEDecoder":return new bt(W);default:throw new Error(`Unknown Decoder type: ${W.type}`)}}_call(W){return this.decode(W)}decode(W){return this.decode_chain(W).join("")}decode_chain(W){throw Error("`decode_chain` should be implemented in subclass.")}}class D extends ee{decode_chain(W){const fe=z(this.config.pattern);return fe===null?W:W.map(Ee=>Ee.replaceAll(fe,this.config.content))}}class ce extends ee{constructor(W){super(W),this.text_decoder=new TextDecoder}decode_chain(W){const fe=[];let Ee=[];for(const Oe of W){let Le=null;if(Oe.length===6&&Oe.startsWith("<0x")&&Oe.endsWith(">")){const nt=parseInt(Oe.slice(3,5),16);isNaN(nt)||(Le=nt)}if(Le!==null)Ee.push(Le);else{if(Ee.length>0){const nt=this.text_decoder.decode(Uint8Array.from(Ee));fe.push(nt),Ee=[]}fe.push(Oe)}}if(Ee.length>0){const Oe=this.text_decoder.decode(Uint8Array.from(Ee));fe.push(Oe),Ee=[]}return fe}}class ue extends ee{decode_chain(W){return[W.join("")]}}class ke extends ee{constructor(W){super(W),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(W){return W.map(fe=>{let Ee=0;for(let Le=0;Le<this.start&&fe[Le]===this.content;++Le){Ee=Le+1;continue}let Oe=fe.length;for(let Le=0;Le<this.stop;++Le){const nt=fe.length-Le-1;if(fe[nt]===this.content){Oe=nt;continue}else break}return fe.slice(Ee,Oe)})}}class Re extends ee{constructor(W){super(W),this.cleanup=W.cleanup}decode_chain(W){return W.map((fe,Ee)=>(Ee!==0&&(fe.startsWith(this.config.prefix)?fe=fe.replace(this.config.prefix,""):fe=" "+fe),this.cleanup&&(fe=y(fe)),fe))}}class ht extends ee{constructor(W){super(W),this.byte_decoder=Ce,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(W){const fe=W.join(""),Ee=new Uint8Array([...fe].map(Le=>this.byte_decoder[Le]));return this.text_decoder.decode(Ee)}decode_chain(W){const fe=[];let Ee=[];for(const Oe of W)this.added_tokens.find(Le=>Le.content===Oe)!==void 0?(Ee.length>0&&(fe.push(this.convert_tokens_to_string(Ee)),Ee=[]),fe.push(Oe)):Ee.push(Oe);return Ee.length>0&&fe.push(this.convert_tokens_to_string(Ee)),fe}}class tt extends ee{constructor(W){super(W),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(W){if(W.length===0)return"";const fe=[W[0]];for(let Le=1;Le<W.length;++Le)W[Le]!==fe.at(-1)&&fe.push(W[Le]);let Oe=fe.filter(Le=>Le!==this.pad_token).join("");return this.cleanup&&(Oe=y(Oe).replaceAll(this.word_delimiter_token," ").trim()),Oe}decode_chain(W){return[this.convert_tokens_to_string(W)]}}class wt extends ee{constructor(W){super(W),this.decoders=W.decoders.map(fe=>ee.fromConfig(fe))}decode_chain(W){return this.decoders.reduce((fe,Ee)=>Ee.decode_chain(fe),W)}}class bt extends ee{constructor(W){super(W),this.suffix=this.config.suffix}decode_chain(W){return W.map((fe,Ee)=>fe.replaceAll(this.suffix,Ee===W.length-1?"":" "))}}class Ke extends ee{decode_chain(W){let fe="";for(let Ee=1;Ee<W.length;Ee+=2)fe+=W[Ee];return[fe]}}class de extends Ge{constructor(W){super(),this.addPrefixSpace=W.add_prefix_space,this.replacement=W.replacement,this.strRep=W.str_rep||this.replacement,this.prepend_scheme=W.prepend_scheme??"always"}pre_tokenize_text(W,{section_index:fe=void 0}={}){let Ee=W.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!Ee.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&fe===0)&&(Ee=this.strRep+Ee),[Ee]}}class Ae extends ee{constructor(W){super(W),this.addPrefixSpace=W.add_prefix_space,this.replacement=W.replacement}decode_chain(W){const fe=[];for(let Ee=0;Ee<W.length;++Ee){let Oe=W[Ee].replaceAll(this.replacement," ");this.addPrefixSpace&&Ee==0&&Oe.startsWith(" ")&&(Oe=Oe.substring(1)),fe.push(Oe)}return fe}}class Ve extends Y{constructor(W){super(W),this.charsmap=W.precompiled_charsmap}normalize(W){return W=W.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),W=W.replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," "),W.includes("")?W=W.split("").map(Ee=>Ee.normalize("NFKC")).join(""):W=W.normalize("NFKC"),W}}class ot extends Ge{constructor(W){super(),this.tokenizers=W.pretokenizers.map(fe=>Ge.fromConfig(fe))}pre_tokenize_text(W,fe){return this.tokenizers.reduce((Ee,Oe)=>Oe.pre_tokenize(Ee,fe),[W])}}class Qe extends Ge{constructor(W){super()}pre_tokenize_text(W,fe){return W.match(/\w+|[^\w\s]+/g)||[]}}class ft extends Ge{constructor(W){super()}pre_tokenize_text(W,fe){return B(W)}}class xt extends Ge{constructor(W){super(),this.config=W,this.pattern=z(this.config.pattern),this.content=this.config.content}pre_tokenize_text(W,fe){return this.pattern===null?[W]:[W.replaceAll(this.pattern,this.config.content)]}}const vt=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function $t(Ue,W,fe,Ee){for(const Oe of Object.keys(Ue)){const Le=W-Ue[Oe].length,nt=fe(Oe),Et=new Array(Le).fill(nt);Ue[Oe]=Ee==="right"?(0,a.mergeArrays)(Ue[Oe],Et):(0,a.mergeArrays)(Et,Ue[Oe])}}function kt(Ue,W){for(const fe of Object.keys(Ue))Ue[fe].length=W}class rt extends o.Callable{constructor(fe,Ee){super();He(this,"return_token_type_ids",!1);He(this,"padding_side","right");this._tokenizer_config=Ee,this.normalizer=Y.fromConfig(fe.normalizer),this.pre_tokenizer=Ge.fromConfig(fe.pre_tokenizer),this.model=Ie.fromConfig(fe.model,Ee),this.post_processor=$e.fromConfig(fe.post_processor),this.decoder=ee.fromConfig(fe.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const Oe of fe.added_tokens){const Le=new he(Oe);this.added_tokens.push(Le),this.model.tokens_to_ids.set(Le.content,Le.id),this.model.vocab[Le.id]=Le.content,Le.special&&(this.special_tokens.push(Le.content),this.all_special_ids.push(Le.id))}if(this.additional_special_tokens=Ee.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.toSorted((Oe,Le)=>Le.content.length-Oe.content.length).map(Oe=>`${Oe.lstrip?"\\s*":""}(${(0,a.escapeRegExp)(Oe.content)})${Oe.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=Ee.model_max_length,this.remove_space=Ee.remove_space,this.clean_up_tokenization_spaces=Ee.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=Ee.do_lowercase_and_remove_accent??!1,Ee.padding_side&&(this.padding_side=Ee.padding_side),this.legacy=!1,this.chat_template=Ee.chat_template??null,Array.isArray(this.chat_template)){const Oe=Object.create(null);for(const{name:Le,template:nt}of this.chat_template){if(typeof Le!="string"||typeof nt!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');Oe[Le]=nt}this.chat_template=Oe}this._compiled_template_cache=new Map}getToken(...fe){for(const Ee of fe){const Oe=this._tokenizer_config[Ee];if(Oe)if(typeof Oe=="object"){if(Oe.__type==="AddedToken")return Oe.content;throw Error(`Unknown token: ${Oe}`)}else return Oe}return null}static async from_pretrained(fe,{progress_callback:Ee=null,config:Oe=null,cache_dir:Le=null,local_files_only:nt=!1,revision:Et="main",legacy:Pt=null}={}){const Ct=await C(fe,{progress_callback:Ee,config:Oe,cache_dir:Le,local_files_only:nt,revision:Et,legacy:Pt});return new this(...Ct)}_call(fe,{text_pair:Ee=null,add_special_tokens:Oe=!0,padding:Le=!1,truncation:nt=null,max_length:Et=null,return_tensor:Pt=!0,return_token_type_ids:Ct=null}={}){const Ot=Array.isArray(fe);let sr;if(Ot){if(fe.length===0)throw Error("text array must be non-empty");if(Ee!==null){if(Array.isArray(Ee)){if(fe.length!==Ee.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");sr=fe.map((cr,Xt)=>this._encode_plus(cr,{text_pair:Ee[Xt],add_special_tokens:Oe,return_token_type_ids:Ct}))}else sr=fe.map(cr=>this._encode_plus(cr,{add_special_tokens:Oe,return_token_type_ids:Ct}))}else{if(fe==null)throw Error("text may not be null or undefined");if(Array.isArray(Ee))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");sr=[this._encode_plus(fe,{text_pair:Ee,add_special_tokens:Oe,return_token_type_ids:Ct})]}if(Et===null?Le==="max_length"?Et=this.model_max_length:Et=(0,f.max)(sr.map(cr=>cr.input_ids.length))[0]:nt||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),Et=Math.min(Et,this.model_max_length??1/0),Le||nt)for(let cr=0;cr<sr.length;++cr)sr[cr].input_ids.length!==Et&&(sr[cr].input_ids.length>Et?nt&&kt(sr[cr],Et):Le&&$t(sr[cr],Et,Xt=>Xt==="input_ids"?this.pad_token_id:0,this.padding_side));const Dr={};if(Pt){if(!(Le&&nt)&&sr.some(Xt=>{var vr;for(const An of Object.keys(Xt))if(Xt[An].length!==((vr=sr[0][An])==null?void 0:vr.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const cr=[sr.length,sr[0].input_ids.length];for(const Xt of Object.keys(sr[0]))Dr[Xt]=new _.Tensor("int64",BigInt64Array.from(sr.flatMap(vr=>vr[Xt]).map(BigInt)),cr)}else{for(const cr of Object.keys(sr[0]))Dr[cr]=sr.map(Xt=>Xt[cr]);if(!Ot)for(const cr of Object.keys(Dr))Dr[cr]=Dr[cr][0]}return Dr}_encode_text(fe){return fe===null?null:(this.added_tokens_regex?fe.split(this.added_tokens_regex).filter(Le=>Le):[fe]).map((Le,nt)=>{if(this.added_tokens.find(Pt=>Pt.content===Le)!==void 0)return Le;{if(this.remove_space===!0&&(Le=Le.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(Le=I(Le)),this.normalizer!==null&&(Le=this.normalizer(Le)),Le.length===0)return[];const Pt=this.pre_tokenizer!==null?this.pre_tokenizer(Le,{section_index:nt}):[Le];return this.model(Pt)}}).flat()}_encode_plus(fe,{text_pair:Ee=null,add_special_tokens:Oe=!0,return_token_type_ids:Le=null}={}){const{tokens:nt,token_type_ids:Et}=this._tokenize_helper(fe,{pair:Ee,add_special_tokens:Oe}),Pt=this.model.convert_tokens_to_ids(nt),Ct={input_ids:Pt,attention_mask:new Array(Pt.length).fill(1)};return(Le??this.return_token_type_ids)&&Et&&(Ct.token_type_ids=Et),Ct}_tokenize_helper(fe,{pair:Ee=null,add_special_tokens:Oe=!1}={}){const Le=this._encode_text(fe),nt=this._encode_text(Ee);return this.post_processor?this.post_processor(Le,nt,{add_special_tokens:Oe}):{tokens:(0,a.mergeArrays)(Le??[],nt??[])}}tokenize(fe,{pair:Ee=null,add_special_tokens:Oe=!1}={}){return this._tokenize_helper(fe,{pair:Ee,add_special_tokens:Oe}).tokens}encode(fe,{text_pair:Ee=null,add_special_tokens:Oe=!0,return_token_type_ids:Le=null}={}){return this._encode_plus(fe,{text_pair:Ee,add_special_tokens:Oe,return_token_type_ids:Le}).input_ids}batch_decode(fe,Ee={}){return fe instanceof _.Tensor&&(fe=fe.tolist()),fe.map(Oe=>this.decode(Oe,Ee))}decode(fe,Ee={}){if(fe instanceof _.Tensor&&(fe=S(fe)),!Array.isArray(fe)||fe.length===0||!(0,a.isIntegralNumber)(fe[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(fe,Ee)}decode_single(fe,{skip_special_tokens:Ee=!1,clean_up_tokenization_spaces:Oe=null}){let Le=this.model.convert_ids_to_tokens(fe);Ee&&(Le=Le.filter(Et=>!this.special_tokens.includes(Et)));let nt=this.decoder?this.decoder(Le):Le.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(nt=nt.replaceAll(this.decoder.end_of_word_suffix," "),Ee&&(nt=nt.trim())),(Oe??this.clean_up_tokenization_spaces)&&(nt=y(nt)),nt}apply_chat_template(fe,{tools:Ee=null,documents:Oe=null,chat_template:Le=null,add_generation_prompt:nt=!1,tokenize:Et=!0,padding:Pt=!1,truncation:Ct=!1,max_length:Ot=null,return_tensor:sr=!0,return_dict:Dr=!1,tokenizer_kwargs:cr={},...Xt}={}){if(this.chat_template&&typeof this.chat_template=="object"||this.chat_template===null){const Ze=this.chat_template;if(Le!==null&&Object.hasOwn(Ze,Le))Le=Ze[Le];else if(Le===null&&"default"in Ze)Le=Ze.default;else if(Le===null)throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(Ze).sort()}.`)}else if(this.chat_template)Le=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");if(typeof Le!="string")throw Error(`chat_template must be a string, but got ${typeof Le}`);let vr=this._compiled_template_cache.get(Le);vr===void 0&&(vr=new g.Template(Le),this._compiled_template_cache.set(Le,vr));const An=Object.create(null);for(const Ze of vt){const ei=this.getToken(Ze);ei&&(An[Ze]=ei)}const vn=vr.render({messages:fe,add_generation_prompt:nt,tools:Ee,documents:Oe,...An,...Xt});if(Et){const Ze=this._call(vn,{add_special_tokens:!1,padding:Pt,truncation:Ct,max_length:Ot,return_tensor:sr,...cr});return Dr?Ze:Ze.input_ids}return vn}}class Nt extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class Rt extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class Qt extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class Ht extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class Gt extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class tr extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class ir extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class lr extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class kr extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class mt extends rt{}class Tt extends rt{}class Lt extends rt{constructor(fe,Ee){super(fe,Ee);He(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class nn extends rt{constructor(){super(...arguments);He(this,"return_token_type_ids",!0)}}class yi extends rt{}class Ai extends rt{}class Qr extends rt{}class kn extends rt{constructor(W,fe){super(W,fe),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(Ee=>this.languageRegex.test(Ee)),this.lang_to_token=Ee=>Ee}_build_translation_inputs(W,fe,Ee){return Hi(this,W,fe,Ee)}}class Yr extends kn{}class wi extends rt{}class Nr extends rt{constructor(W,fe){var Le,nt;const Ee=".,!?",Oe=(nt=(Le=W.pre_tokenizer)==null?void 0:Le.pretokenizers[0])==null?void 0:nt.pattern;Oe&&Oe.Regex===` ?[^(\\s|[${Ee}])]+`&&(Oe.Regex=` ?[^\\s${Ee}]+`),super(W,fe)}}const Wi="";class Ii extends rt{constructor(fe,Ee){super(fe,Ee);He(this,"padding_side","left");this.legacy=Ee.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new de({replacement:Wi,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(fe){if(fe===null)return null;if(this.legacy||fe.length===0)return super._encode_text(fe);let Ee=super._encode_text(Wi+fe.replaceAll(Wi," "));return Ee.length>1&&Ee[0]===Wi&&this.special_tokens.includes(Ee[1])&&(Ee=Ee.slice(1)),Ee}}class $s extends rt{}class Uo extends rt{}class Vo extends rt{}class Wo extends rt{}class Go extends rt{}class Gi extends rt{}class As extends rt{}class _o extends rt{}class vi extends rt{}function Hi(Ue,W,fe,Ee){if(!("language_codes"in Ue)||!Array.isArray(Ue.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in Ue)||!(Ue.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in Ue)||typeof Ue.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const Oe=Ee.src_lang,Le=Ee.tgt_lang;if(!Ue.language_codes.includes(Le))throw new Error(`Target language code "${Le}" is not valid. Must be one of: {${Ue.language_codes.join(", ")}}`);if(Oe!==void 0){if(!Ue.language_codes.includes(Oe))throw new Error(`Source language code "${Oe}" is not valid. Must be one of: {${Ue.language_codes.join(", ")}}`);for(const nt of Ue.post_processor.config.single)if("SpecialToken"in nt&&Ue.languageRegex.test(nt.SpecialToken.id)){nt.SpecialToken.id=Ue.lang_to_token(Oe);break}}return Ee.forced_bos_token_id=Ue.model.convert_tokens_to_ids([Ue.lang_to_token(Le)])[0],Ue._call(W,fe)}class Fi extends rt{constructor(W,fe){super(W,fe),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(Ee=>this.languageRegex.test(Ee)),this.lang_to_token=Ee=>Ee}_build_translation_inputs(W,fe,Ee){return Hi(this,W,fe,Ee)}}class ro extends rt{constructor(W,fe){super(W,fe),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(Ee=>this.languageRegex.test(Ee)).map(Ee=>Ee.slice(2,-2)),this.lang_to_token=Ee=>`__${Ee}__`}_build_translation_inputs(W,fe,Ee){return Hi(this,W,fe,Ee)}}class yo extends rt{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(W,{return_timestamps:fe=!1,return_language:Ee=!1,time_precision:Oe=null,force_full_sequences:Le=!0}={}){if(Oe===null)throw Error("Must specify time_precision");let nt=null;const Et=fe==="word";function Pt(){return{language:nt,timestamp:[null,null],text:""}}const Ct=[];let Ot=Pt(),sr=0;const Dr=this.timestamp_begin;let cr=[],Xt=[],vr=!1,An=null;const vn=new Set(this.all_special_ids);for(const Pr of W){const hn=Pr.tokens,Bn=Et?Pr.token_timestamps:null;let Jt=null,Kn=Dr;if("stride"in Pr){const[$r,zt,Ar]=Pr.stride;if(sr-=zt,An=$r-Ar,zt&&(Kn=zt/Oe+Dr),Ar)for(let jr=hn.length-1;jr>=0;--jr){const Zr=Number(hn[jr]);if(Zr>=Dr){if(Jt!==null&&(Zr-Dr)*Oe<An)break;Jt=Zr}}}let Tn=[],zr=[];for(let $r=0;$r<hn.length;++$r){const zt=Number(hn[$r]);if(vn.has(zt)){const Ar=this.decode([zt]),jr=M.WHISPER_LANGUAGE_MAPPING.get(Ar.slice(2,-2));if(jr!==void 0){if(nt!==null&&jr!==nt&&!fe){cr.push(Tn);const Zr=this.findLongestCommonSequence(cr)[0],Qn=this.decode(Zr);Ot.text=Qn,Ct.push(Ot),cr=[],Tn=[],Ot=Pt()}nt=Ot.language=jr}}else if(zt>=Dr){const Ar=(zt-Dr)*Oe+sr,jr=(0,f.round)(Ar,2);if(Jt!==null&&zt>=Jt)vr=!0;else if(vr||cr.length>0&&zt<Kn)vr=!1;else if(Ot.timestamp[0]===null)Ot.timestamp[0]=jr;else if(jr!==Ot.timestamp[0]){Ot.timestamp[1]=jr,cr.push(Tn),Et&&Xt.push(zr);const[Zr,Qn]=this.findLongestCommonSequence(cr,Xt),jt=this.decode(Zr);Ot.text=jt,Et&&(Ot.words=this.collateWordTimestamps(Zr,Qn,nt)),Ct.push(Ot),cr=[],Tn=[],Xt=[],zr=[],Ot=Pt()}}else if(Tn.push(zt),Et){let Ar=(0,f.round)(Bn[$r]+sr,2),jr;if($r+1<Bn.length){jr=(0,f.round)(Bn[$r+1]+sr,2);const Zr=this.decode([zt]);N.test(Zr)&&(jr=(0,f.round)(Math.min(Ar+Oe,jr),2))}else jr=null;zr.push([Ar,jr])}}if("stride"in Pr){const[$r,zt,Ar]=Pr.stride;sr+=$r-Ar}Tn.length>0?(cr.push(Tn),Et&&Xt.push(zr)):cr.every($r=>$r.length===0)&&(Ot=Pt(),cr=[],Tn=[],Xt=[],zr=[])}if(cr.length>0){if(Le&&fe)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[Pr,hn]=this.findLongestCommonSequence(cr,Xt),Bn=this.decode(Pr);Ot.text=Bn,Et&&(Ot.words=this.collateWordTimestamps(Pr,hn,nt)),Ct.push(Ot)}let Ze=Object.create(null);const ei=Ct.map(Pr=>Pr.text).join("");if(fe||Ee){for(let Pr=0;Pr<Ct.length;++Pr){const hn=Ct[Pr];fe||delete hn.timestamp,Ee||delete hn.language}if(Et){const Pr=[];for(const hn of Ct)for(const Bn of hn.words)Pr.push(Bn);Ze={chunks:Pr}}else Ze={chunks:Ct}}return[ei,Ze]}findLongestCommonSequence(W,fe=null){let Ee=W[0],Oe=Ee.length,Le=[];const nt=Array.isArray(fe)&&fe.length>0;let Et=nt?[]:null,Pt=nt?fe[0]:null;for(let Ct=1;Ct<W.length;++Ct){const Ot=W[Ct];let sr=0,Dr=[Oe,Oe,0,0];const cr=Ot.length;for(let Pr=1;Pr<Oe+cr;++Pr){const hn=Math.max(0,Oe-Pr),Bn=Math.min(Oe,Oe+cr-Pr),Jt=Ee.slice(hn,Bn),Kn=Math.max(0,Pr-Oe),Tn=Math.min(cr,Pr),zr=Ot.slice(Kn,Tn);if(Jt.length!==zr.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let $r;nt?$r=Jt.filter((jr,Zr)=>jr===zr[Zr]&&Pt[hn+Zr]<=fe[Ct][Kn+Zr]).length:$r=Jt.filter((jr,Zr)=>jr===zr[Zr]).length;const zt=Pr/1e4,Ar=$r/Pr+zt;$r>1&&Ar>sr&&(sr=Ar,Dr=[hn,Bn,Kn,Tn])}const[Xt,vr,An,vn]=Dr,Ze=Math.floor((vr+Xt)/2),ei=Math.floor((vn+An)/2);Le.push(...Ee.slice(0,Ze)),Ee=Ot.slice(ei),Oe=Ee.length,nt&&(Et.push(...Pt.slice(0,Ze)),Pt=fe[Ct].slice(ei))}return Le.push(...Ee),nt?(Et.push(...Pt),[Le,Et]):[Le,[]]}collateWordTimestamps(W,fe,Ee){const[Oe,Le,nt]=this.combineTokensIntoWords(W,Ee),Et=[];for(let Pt=0;Pt<Oe.length;++Pt){const Ct=nt[Pt];Et.push({text:Oe[Pt],timestamp:[fe[Ct.at(0)][0],fe[Ct.at(-1)][1]]})}return Et}combineTokensIntoWords(W,fe,Ee=`"'([{-`,Oe=`"'.,!?:)]}`){fe=fe??"english";let Le,nt,Et;return["chinese","japanese","thai","lao","myanmar"].includes(fe)?[Le,nt,Et]=this.splitTokensOnUnicode(W):[Le,nt,Et]=this.splitTokensOnSpaces(W),this.mergePunctuations(Le,nt,Et,Ee,Oe)}decode(W,fe){let Ee;return fe!=null&&fe.decode_with_timestamps?(W instanceof _.Tensor&&(W=S(W)),Ee=this.decodeWithTimestamps(W,fe)):Ee=super.decode(W,fe),Ee}decodeWithTimestamps(W,fe){const Ee=(fe==null?void 0:fe.time_precision)??.02,Oe=Array.from(this.all_special_ids).at(-1)+1;let Le=[[]];for(let nt of W)if(nt=Number(nt),nt>=Oe){const Et=((nt-Oe)*Ee).toFixed(2);Le.push(`<|${Et}|>`),Le.push([])}else Le[Le.length-1].push(nt);return Le=Le.map(nt=>typeof nt=="string"?nt:super.decode(nt,fe)),Le.join("")}splitTokensOnUnicode(W){const fe=this.decode(W,{decode_with_timestamps:!0}),Ee="",Oe=[],Le=[],nt=[];let Et=[],Pt=[],Ct=0;for(let Ot=0;Ot<W.length;++Ot){const sr=W[Ot];Et.push(sr),Pt.push(Ot);const Dr=this.decode(Et,{decode_with_timestamps:!0});(!Dr.includes(Ee)||fe[Ct+Dr.indexOf(Ee)]===Ee)&&(Oe.push(Dr),Le.push(Et),nt.push(Pt),Et=[],Pt=[],Ct+=Dr.length)}return[Oe,Le,nt]}splitTokensOnSpaces(W){const[fe,Ee,Oe]=this.splitTokensOnUnicode(W),Le=[],nt=[],Et=[],Pt=new RegExp(`^[${j}]$`,"gu");for(let Ct=0;Ct<fe.length;++Ct){const Ot=fe[Ct],sr=Ee[Ct],Dr=Oe[Ct],cr=sr[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),Xt=Ot.startsWith(" "),vr=Ot.trim(),An=Pt.test(vr);if(cr||Xt||An||Le.length===0)Le.push(Ot),nt.push(sr),Et.push(Dr);else{const vn=Le.length-1;Le[vn]+=Ot,nt[vn].push(...sr),Et[vn].push(...Dr)}}return[Le,nt,Et]}mergePunctuations(W,fe,Ee,Oe,Le){const nt=structuredClone(W),Et=structuredClone(fe),Pt=structuredClone(Ee);let Ct=nt.length-2,Ot=nt.length-1;for(;Ct>=0;)nt[Ct].startsWith(" ")&&Oe.includes(nt[Ct].trim())?(nt[Ot]=nt[Ct]+nt[Ot],Et[Ot]=(0,a.mergeArrays)(Et[Ct],Et[Ot]),Pt[Ot]=(0,a.mergeArrays)(Pt[Ct],Pt[Ot]),nt[Ct]="",Et[Ct]=[],Pt[Ct]=[]):Ot=Ct,--Ct;for(Ct=0,Ot=1;Ot<nt.length;)!nt[Ct].endsWith(" ")&&Le.includes(nt[Ot])?(nt[Ct]+=nt[Ot],Et[Ct]=(0,a.mergeArrays)(Et[Ct],Et[Ot]),Pt[Ct]=(0,a.mergeArrays)(Pt[Ct],Pt[Ot]),nt[Ot]="",Et[Ot]=[],Pt[Ot]=[]):Ct=Ot,++Ot;return[nt.filter(sr=>sr),Et.filter(sr=>sr.length>0),Pt.filter(sr=>sr.length>0)]}get_decoder_prompt_ids({language:W=null,task:fe=null,no_timestamps:Ee=!0}={}){const Oe=[];if(W){const Le=(0,M.whisper_language_to_code)(W),nt=this.model.tokens_to_ids.get(`<|${Le}|>`);if(nt===void 0)throw new Error(`Unable to find language "${Le}" in model vocabulary. Please report this issue at ${v.GITHUB_ISSUE_URL}.`);Oe.push(nt)}else Oe.push(null);if(fe){if(fe=fe.toLowerCase(),fe!=="transcribe"&&fe!=="translate")throw new Error(`Task "${fe}" is not supported. Must be one of: ["transcribe", "translate"]`);const Le=this.model.tokens_to_ids.get(`<|${fe}|>`);if(Le===void 0)throw new Error(`Unable to find task "${fe}" in model vocabulary. Please report this issue at ${v.GITHUB_ISSUE_URL}.`);Oe.push(Le)}else Oe.push(null);if(Ee){const Le=this.model.tokens_to_ids.get("<|notimestamps|>");if(Le===void 0)throw new Error(`Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at ${v.GITHUB_ISSUE_URL}.`);Oe.push(Le)}return Oe.map((Le,nt)=>[nt+1,Le]).filter(Le=>Le[1]!==null)}}class wo extends rt{}class Zt extends rt{}class no extends rt{}class Ho extends rt{constructor(W,fe){super(W,fe),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(Ee=>this.languageRegex.test(Ee)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(W){if(W===null)return null;const[fe,...Ee]=W.trim().split(this.languageRegex);if(Ee.length===0)return super._encode_text(fe);if(Ee.length===2){const[Oe,Le]=Ee;return this.supported_language_codes.includes(Oe)||console.warn(`Unsupported language code "${Oe}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,a.mergeArrays)([Oe],super._encode_text(Le))}}}class qo extends rt{}class vo extends rt{}class Ko extends rt{}class Qo extends rt{}class bo extends rt{}class Xo extends rt{constructor(W,fe){super(W,fe),this.decoder=new Ke({})}}class Kr extends rt{}class qn{static async from_pretrained(W,{progress_callback:fe=null,config:Ee=null,cache_dir:Oe=null,local_files_only:Le=!1,revision:nt="main",legacy:Et=null}={}){var Dr;const[Pt,Ct]=await C(W,{progress_callback:fe,config:Ee,cache_dir:Oe,local_files_only:Le,revision:nt,legacy:Et}),Ot=((Dr=Ct.tokenizer_class)==null?void 0:Dr.replace(/Fast$/,""))??"PreTrainedTokenizer";let sr=this.TOKENIZER_CLASS_MAPPING[Ot];return sr||(console.warn(`Unknown tokenizer class "${Ot}", attempting to construct from base class.`),sr=rt),new sr(Pt,Ct)}}He(qn,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer:yi,DistilBertTokenizer:mt,CamembertTokenizer:Tt,DebertaTokenizer:Gt,DebertaV2Tokenizer:tr,BertTokenizer:Nt,HerbertTokenizer:ir,ConvBertTokenizer:lr,RoFormerTokenizer:kr,XLMTokenizer:Lt,ElectraTokenizer:nn,MobileBertTokenizer:Qt,SqueezeBertTokenizer:Ht,AlbertTokenizer:Rt,GPT2Tokenizer:Ai,BartTokenizer:Qr,MBartTokenizer:kn,MBart50Tokenizer:Yr,RobertaTokenizer:wi,WhisperTokenizer:yo,CodeGenTokenizer:wo,CLIPTokenizer:Zt,SiglipTokenizer:no,MarianTokenizer:Ho,BloomTokenizer:Nr,NllbTokenizer:Fi,M2M100Tokenizer:ro,LlamaTokenizer:Ii,CodeLlamaTokenizer:$s,XLMRobertaTokenizer:Uo,MPNetTokenizer:Vo,FalconTokenizer:Wo,GPTNeoXTokenizer:Go,EsmTokenizer:Gi,Wav2Vec2CTCTokenizer:qo,BlenderbotTokenizer:vo,BlenderbotSmallTokenizer:Ko,SpeechT5Tokenizer:Qo,NougatTokenizer:bo,VitsTokenizer:Xo,Qwen2Tokenizer:As,GemmaTokenizer:_o,Grok1Tokenizer:vi,CohereTokenizer:Kr,PreTrainedTokenizer:rt})},"./src/utils/audio.js":(e,t,n)=>{n.r(t),n.d(t,{hamming:()=>M,hanning:()=>g,mel_filter_bank:()=>y,read_audio:()=>_,spectrogram:()=>B,window_function:()=>j});var o=n("./src/utils/hub.js"),a=n("./src/utils/maths.js"),l=n("./src/utils/core.js"),f=n("./src/utils/tensor.js");async function _(N,oe){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const he=await(await(0,o.getFile)(N)).arrayBuffer(),Ie=new AudioContext({sampleRate:oe});typeof oe>"u"&&console.warn(`No sampling rate provided, using default of ${Ie.sampleRate}Hz.`);const te=await Ie.decodeAudioData(he);let we;if(te.numberOfChannels===2){const L=Math.sqrt(2),Ce=te.getChannelData(0),Xe=te.getChannelData(1);we=new Float32Array(Ce.length);for(let ye=0;ye<te.length;++ye)we[ye]=L*(Ce[ye]+Xe[ye])/2}else we=te.getChannelData(0);return we}function m(N,oe){if(N<1)return new Float64Array;if(N===1)return new Float64Array([1]);const he=1-oe,Ie=2*Math.PI/(N-1),te=new Float64Array(N);for(let we=0;we<N;++we)te[we]=oe-he*Math.cos(we*Ie);return te}function g(N){return m(N,.5)}function M(N){return m(N,.54)}const v={htk:N=>2595*Math.log10(1+N/700),kaldi:N=>1127*Math.log(1+N/700),slaney:(N,oe=1e3,he=15,Ie=27/Math.log(6.4))=>N>=oe?he+Math.log(N/oe)*Ie:3*N/200};function C(N,oe="htk"){const he=v[oe];if(!he)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof N=="number"?he(N):N.map(Ie=>he(Ie))}const k={htk:N=>700*(10**(N/2595)-1),kaldi:N=>700*(Math.exp(N/1127)-1),slaney:(N,oe=1e3,he=15,Ie=Math.log(6.4)/27)=>N>=he?oe*Math.exp(Ie*(N-he)):200*N/3};function z(N,oe="htk"){const he=k[oe];if(!he)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof N=="number"?he(N):N.map(Ie=>he(Ie))}function $(N,oe){const he=Float64Array.from({length:oe.length-1},(L,Ce)=>oe[Ce+1]-oe[Ce]),Ie=Array.from({length:N.length},()=>new Array(oe.length));for(let L=0;L<N.length;++L){const Ce=Ie[L];for(let Xe=0;Xe<oe.length;++Xe)Ce[Xe]=oe[Xe]-N[L]}const te=oe.length-2,we=Array.from({length:te},()=>new Array(N.length));for(let L=0;L<N.length;++L){const Ce=Ie[L];for(let Xe=0;Xe<te;++Xe){const ye=-Ce[Xe]/he[Xe],Y=Ce[Xe+2]/he[Xe+1];we[Xe][L]=Math.max(0,Math.min(ye,Y))}}return we}function S(N,oe,he){const Ie=(oe-N)/(he-1);return Float64Array.from({length:he},(te,we)=>N+Ie*we)}function y(N,oe,he,Ie,te,we=null,L="htk",Ce=!1){if(we!==null&&we!=="slaney")throw new Error('norm must be one of null or "slaney"');const Xe=C(he,L),ye=C(Ie,L),Y=S(Xe,ye,oe+2);let se=z(Y,L),Me;if(Ce){const ge=te/(N*2);Me=C(Float64Array.from({length:N},(qe,Be)=>Be*ge),L),se=Y}else Me=S(0,Math.floor(te/2),N);const X=$(Me,se);if(we!==null&&we==="slaney")for(let ge=0;ge<oe;++ge){const qe=X[ge],Be=2/(se[ge+2]-se[ge]);for(let Ne=0;Ne<N;++Ne)qe[Ne]*=Be}return X}function x(N,oe,he){const Ie=new N.constructor(N.length+oe+he),te=N.length-1;for(let we=0;we<N.length;++we)Ie[oe+we]=N[we];for(let we=1;we<=oe;++we)Ie[oe-we]=N[(0,l.calculateReflectOffset)(we,te)];for(let we=1;we<=he;++we)Ie[te+oe+we]=N[(0,l.calculateReflectOffset)(te-we,te)];return Ie}function I(N,oe,he,Ie,te){if(he<=0)throw new Error("reference must be greater than zero");if(Ie<=0)throw new Error("min_value must be greater than zero");he=Math.max(Ie,he);const we=Math.log10(he);for(let L=0;L<N.length;++L)N[L]=oe*Math.log10(Math.max(Ie,N[L])-we);if(te!==null){if(te<=0)throw new Error("db_range must be greater than zero");const L=(0,a.max)(N)[0]-te;for(let Ce=0;Ce<N.length;++Ce)N[Ce]=Math.max(N[Ce],L)}return N}function V(N,oe=1,he=1e-5,Ie=null){return I(N,20,oe,he,Ie)}function O(N,oe=1,he=1e-10,Ie=null){return I(N,10,oe,he,Ie)}async function B(N,oe,he,Ie,{fft_length:te=null,power:we=1,center:L=!0,pad_mode:Ce="reflect",onesided:Xe=!0,preemphasis:ye=null,mel_filters:Y=null,mel_floor:se=1e-10,log_mel:Me=null,reference:X=1,min_value:ge=1e-10,db_range:qe=null,remove_dc_offset:Be=null,min_num_frames:Ne=null,max_num_frames:We=null,do_pad:st=!0,transpose:pt=!1}={}){const Ge=oe.length;if(te===null&&(te=he),he>te)throw Error(`frame_length (${he}) may not be larger than fft_length (${te})`);if(Ge!==he)throw new Error(`Length of the window (${Ge}) must equal frame_length (${he})`);if(Ie<=0)throw new Error("hop_length must be greater than zero");if(we===null&&Y!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(L){if(Ce!=="reflect")throw new Error(`pad_mode="${Ce}" not implemented yet.`);const ee=Math.floor((te-1)/2)+1;N=x(N,ee,ee)}let xe=Math.floor(1+Math.floor((N.length-he)/Ie));Ne!==null&&xe<Ne&&(xe=Ne);const je=Xe?Math.floor(te/2)+1:te;let Ye=xe,et=xe;We!==null&&(We>xe?st&&(et=We):et=Ye=We);const A=new a.FFT(te),$e=new Float64Array(te),Pe=new Float64Array(A.outputBufferSize),ae=new Float32Array(je*et);for(let ee=0;ee<Ye;++ee){const D=ee*Ie,ce=Math.min(N.length-D,he);ce!==he&&$e.fill(0,0,he);for(let ue=0;ue<ce;++ue)$e[ue]=N[D+ue];if(Be){let ue=0;for(let Re=0;Re<ce;++Re)ue+=$e[Re];const ke=ue/ce;for(let Re=0;Re<ce;++Re)$e[Re]-=ke}if(ye!==null){for(let ue=ce-1;ue>=1;--ue)$e[ue]-=ye*$e[ue-1];$e[0]*=1-ye}for(let ue=0;ue<oe.length;++ue)$e[ue]*=oe[ue];A.realTransform(Pe,$e);for(let ue=0;ue<je;++ue){const ke=ue<<1;ae[ue*et+ee]=Pe[ke]**2+Pe[ke+1]**2}}if(we!==null&&we!==2){const ee=2/we;for(let D=0;D<ae.length;++D)ae[D]**=ee}const ne=Y.length;let ve=await(0,f.matmul)(new f.Tensor("float32",Y.flat(),[ne,je]),new f.Tensor("float32",ae,[je,et]));pt&&(ve=ve.transpose(1,0));const R=ve.data;for(let ee=0;ee<R.length;++ee)R[ee]=Math.max(se,R[ee]);if(we!==null&&Me!==null){const ee=Math.min(R.length,Ye*ne);switch(Me){case"log":for(let D=0;D<ee;++D)R[D]=Math.log(R[D]);break;case"log10":for(let D=0;D<ee;++D)R[D]=Math.log10(R[D]);break;case"dB":if(we===1)V(R,X,ge,qe);else if(we===2)O(R,X,ge,qe);else throw new Error(`Cannot use log_mel option '${Me}' with power ${we}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${Me}'`)}}return ve}function j(N,oe,{periodic:he=!0,frame_length:Ie=null,center:te=!0}={}){const we=he?N+1:N;let L;switch(oe){case"boxcar":L=new Float64Array(we).fill(1);break;case"hann":case"hann_window":L=g(we);break;case"hamming":L=M(we);break;case"povey":L=g(we).map(Ce=>Math.pow(Ce,.85));break;default:throw new Error(`Unknown window type ${oe}.`)}if(he&&(L=L.subarray(0,N)),Ie===null)return L;if(N>Ie)throw new Error(`Length of the window (${N}) may not be larger than frame_length (${Ie})`);return L}},"./src/utils/constants.js":(e,t,n)=>{n.r(t),n.d(t,{GITHUB_ISSUE_URL:()=>o});const o="https://github.com/xenova/transformers.js/issues/new/choose"},"./src/utils/core.js":(e,t,n)=>{n.r(t),n.d(t,{calculateDimensions:()=>m,calculateReflectOffset:()=>C,dispatchCallback:()=>o,escapeRegExp:()=>l,isIntegralNumber:()=>_,isTypedArray:()=>f,mergeArrays:()=>M,pick:()=>k,pop:()=>g,product:()=>v,reverseDictionary:()=>a});function o(z,$){z&&z($)}function a(z){return Object.fromEntries(Object.entries(z).map(([$,S])=>[S,$]))}function l(z){return z.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function f(z){var $,S,y;return((y=(S=($=z==null?void 0:z.prototype)==null?void 0:$.__proto__)==null?void 0:S.constructor)==null?void 0:y.name)==="TypedArray"}function _(z){return Number.isInteger(z)||typeof z=="bigint"}function m(z){const $=[];let S=z;for(;Array.isArray(S);)$.push(S.length),S=S[0];return $}function g(z,$,S=void 0){const y=z[$];if(y!==void 0)return delete z[$],y;if(S===void 0)throw Error(`Key ${$} does not exist in object.`);return S}function M(...z){return Array.prototype.concat.apply([],z)}function v(...z){return z.reduce(($,S)=>$.flatMap(y=>S.map(x=>[y,x])))}function C(z,$){return Math.abs((z+$)%(2*$)-$)}function k(z,$){return Object.assign({},...$.map(S=>{if(z[S]!==void 0)return{[S]:z[S]}}))}},"./src/utils/data-structures.js":(e,t,n)=>{n.r(t),n.d(t,{CharTrie:()=>a,PriorityQueue:()=>o,TokenLattice:()=>f});class o{constructor(g=(v,C)=>v>C,M=1/0){this._heap=[],this._comparator=g,this._maxSize=M}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...g){return this.extend(g)}extend(g){for(const M of g)if(this.size<this._maxSize)this._heap.push(M),this._siftUp();else{const v=this._smallest();this._comparator(M,this._heap[v])&&(this._heap[v]=M,this._siftUpFrom(v))}return this.size}pop(){const g=this.peek(),M=this.size-1;return M>0&&this._swap(0,M),this._heap.pop(),this._siftDown(),g}replace(g){const M=this.peek();return this._heap[0]=g,this._siftDown(),M}_parent(g){return(g+1>>>1)-1}_left(g){return(g<<1)+1}_right(g){return g+1<<1}_greater(g,M){return this._comparator(this._heap[g],this._heap[M])}_swap(g,M){const v=this._heap[g];this._heap[g]=this._heap[M],this._heap[M]=v}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(g){for(;g>0&&this._greater(g,this._parent(g));)this._swap(g,this._parent(g)),g=this._parent(g)}_siftDown(){let g=0;for(;this._left(g)<this.size&&this._greater(this._left(g),g)||this._right(g)<this.size&&this._greater(this._right(g),g);){const M=this._right(g)<this.size&&this._greater(this._right(g),this._left(g))?this._right(g):this._left(g);this._swap(g,M),g=M}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class a{constructor(){this.root=l.default()}extend(g){for(let M of g)this.push(M)}push(g){let M=this.root;for(let v of g){let C=M.children.get(v);C===void 0&&(C=l.default(),M.children.set(v,C)),M=C}M.isLeaf=!0}*commonPrefixSearch(g){let M=this.root,v="";for(let C=0;C<g.length&&M!==void 0;++C){const k=g[C];v+=k,M=M.children.get(k),M!==void 0&&M.isLeaf&&(yield v)}}}class l{constructor(g,M){this.isLeaf=g,this.children=M}static default(){return new l(!1,new Map)}}class f{constructor(g,M,v){this.sentence=g,this.len=g.length,this.bosTokenId=M,this.eosTokenId=v,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const C=new _(this.bosTokenId,0,0,0,0),k=new _(this.eosTokenId,1,this.len,0,0);this.nodes.push(C.clone()),this.nodes.push(k.clone()),this.beginNodes[this.len].push(k),this.endNodes[0].push(C)}insert(g,M,v,C){const k=this.nodes.length,z=new _(C,k,g,M,v);this.beginNodes[g].push(z),this.endNodes[g+M].push(z),this.nodes.push(z)}viterbi(){const g=this.len;let M=0;for(;M<=g;){if(this.beginNodes[M].length==0)return[];for(let $ of this.beginNodes[M]){$.prev=null;let S=0,y=null;for(let x of this.endNodes[M]){const I=x.backtraceScore+$.score;(y===null||I>S)&&(y=x.clone(),S=I)}if(y!==null)$.prev=y,$.backtraceScore=S;else return[]}++M}const v=[],k=this.beginNodes[g][0].prev;if(k===null)return[];let z=k.clone();for(;z.prev!==null;)v.push(z.clone()),z=z.clone().prev.clone();return v.reverse(),v}piece(g){return this.sentence.slice(g.pos,g.pos+g.length)}tokens(){return this.viterbi().map(M=>this.piece(M))}tokenIds(){return this.viterbi().map(M=>M.tokenId)}}class _{constructor(g,M,v,C,k){this.tokenId=g,this.nodeId=M,this.pos=v,this.length=C,this.score=k,this.prev=null,this.backtraceScore=0}clone(){const g=new _(this.tokenId,this.nodeId,this.pos,this.length,this.score);return g.prev=this.prev,g.backtraceScore=this.backtraceScore,g}}},"./src/utils/devices.js":(e,t,n)=>{n.r(t),n.d(t,{DEVICE_TYPES:()=>o});const o=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(e,t,n)=>{n.r(t),n.d(t,{DATA_TYPES:()=>f,DEFAULT_DEVICE_DTYPE_MAPPING:()=>_,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>m,isWebGpuFp16Supported:()=>l});var o=n("./src/env.js"),a=n("./src/utils/devices.js");const l=function(){let g;return async function(){if(g===void 0)if(!o.apis.IS_WEBGPU_AVAILABLE)g=!1;else try{g=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{g=!1}return g}}(),f=Object.freeze({fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),_=Object.freeze({[a.DEVICE_TYPES.wasm]:f.q8}),m=Object.freeze({[f.fp32]:"",[f.fp16]:"_fp16",[f.int8]:"_int8",[f.uint8]:"_uint8",[f.q8]:"_quantized",[f.q4]:"_q4",[f.q4f16]:"_q4f16",[f.bnb4]:"_bnb4"})},"./src/utils/generic.js":(e,t,n)=>{n.r(t),n.d(t,{Callable:()=>o});const o=class{constructor(){let a=function(...l){return a._call(...l)};return Object.setPrototypeOf(a,new.target.prototype)}_call(...a){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(e,t,n)=>{n.r(t),n.d(t,{getFile:()=>M,getModelFile:()=>$,getModelJSON:()=>S});var o=n("?7a2c"),a=n("?a42a"),l=n("./src/env.js"),f=n("./src/utils/core.js");const _={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class m{constructor(V){if(this.filePath=V,this.headers=new Headers,this.exists=o.existsSync(V),this.exists){this.status=200,this.statusText="OK";let O=o.statSync(V);this.headers.set("content-length",O.size.toString()),this.updateContentType();let B=this;this.body=new ReadableStream({start(j){B.arrayBuffer().then(N=>{j.enqueue(new Uint8Array(N)),j.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const V=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",_[V]??"application/octet-stream")}clone(){let V=new m(this.filePath);return V.exists=this.exists,V.status=this.status,V.statusText=this.statusText,V.headers=new Headers(this.headers),V}async arrayBuffer(){return(await o.promises.readFile(this.filePath)).buffer}async blob(){const V=await o.promises.readFile(this.filePath);return new Blob([V],{type:this.headers.get("content-type")})}async text(){return await o.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function g(I,V=null,O=null){let B;try{B=new URL(I)}catch{return!1}return!(V&&!V.includes(B.protocol)||O&&!O.includes(B.hostname))}async function M(I){var V;if(l.env.useFS&&!g(I,["http:","https:","blob:"]))return new m(I);if(typeof process<"u"&&((V=process==null?void 0:process.release)==null?void 0:V.name)==="node"){const O=!!($o!=null&&$o.TESTING_REMOTELY),B=l.env.version,j=new Headers;if(j.set("User-Agent",`transformers.js/${B}; is_ci/${O};`),g(I,["http:","https:"],["huggingface.co","hf.co"])){const oe=($o==null?void 0:$o.HF_TOKEN)??($o==null?void 0:$o.HF_ACCESS_TOKEN);oe&&j.set("Authorization",`Bearer ${oe}`)}return fetch(I,{headers:j})}else return fetch(I)}const v={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function C(I,V,O){if(!O)return null;const B=v[I]??`Error (${I}) occurred while trying to load file`;throw Error(`${B}: "${V}".`)}class k{constructor(V){this.path=V}async match(V){let O=a.join(this.path,V),B=new m(O);if(B.exists)return B}async put(V,O){const B=Buffer.from(await O.arrayBuffer());let j=a.join(this.path,V);try{await o.promises.mkdir(a.dirname(j),{recursive:!0}),await o.promises.writeFile(j,B)}catch(N){console.warn("An error occurred while writing the file to cache:",N)}}}async function z(I,...V){for(let O of V)try{let B=await I.match(O);if(B)return B}catch{continue}}async function $(I,V,O=!0,B={}){if(!l.env.allowLocalModels){if(B.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!l.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,f.dispatchCallback)(B.progress_callback,{status:"initiate",name:I,file:V});let j;if(!j&&l.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{j=await caches.open("transformers-cache")}catch(Me){console.warn("An error occurred while opening the browser cache:",Me)}}if(!j&&l.env.useFSCache&&(j=new k(B.cache_dir??l.env.cacheDir)),!j&&l.env.useCustomCache){if(!l.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!l.env.customCache.match||!l.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");j=l.env.customCache}const N=B.revision??"main";let oe=x(I,V),he=x(l.env.localModelPath,oe),Ie=x(l.env.remoteHost,l.env.remotePathTemplate.replaceAll("{model}",I).replaceAll("{revision}",encodeURIComponent(N)),V),te=N==="main"?oe:x(I,N,V),we,L=j instanceof k?te:Ie,Ce=!1,Xe;j&&(Xe=await z(j,he,L));const ye=Xe!==void 0;if(Xe===void 0){if(l.env.allowLocalModels)if(g(oe,["http:","https:"])){if(B.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${oe}.`);if(!l.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${oe}.`)}else try{Xe=await M(he),we=he}catch(X){console.warn(`Unable to load from local path "${he}": "${X}"`)}if(Xe===void 0||Xe.status===404){if(B.local_files_only||!l.env.allowRemoteModels){if(O)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${he}".`);return null}if(Xe=await M(Ie),Xe.status!==200)return C(Xe.status,Ie,O);we=L}Ce=j&&typeof Response<"u"&&Xe instanceof Response&&Xe.status===200}(0,f.dispatchCallback)(B.progress_callback,{status:"download",name:I,file:V});const Y={status:"progress",name:I,file:V};let se;return B.progress_callback?ye&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(se=new Uint8Array(await Xe.arrayBuffer()),(0,f.dispatchCallback)(B.progress_callback,{...Y,progress:100,loaded:se.length,total:se.length})):se=await y(Xe,Me=>{(0,f.dispatchCallback)(B.progress_callback,{...Y,...Me})}):se=new Uint8Array(await Xe.arrayBuffer()),Ce&&we&&await j.match(we)===void 0&&await j.put(we,new Response(se,{headers:Xe.headers})).catch(Me=>{console.warn(`Unable to add response to browser cache: ${Me}.`)}),(0,f.dispatchCallback)(B.progress_callback,{status:"done",name:I,file:V}),se}async function S(I,V,O=!0,B={}){let j=await $(I,V,O,B);if(j===null)return{};let oe=new TextDecoder("utf-8").decode(j);return JSON.parse(oe)}async function y(I,V){const O=I.headers.get("Content-Length");O===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let B=parseInt(O??"0"),j=new Uint8Array(B),N=0;const oe=I.body.getReader();async function he(){const{done:Ie,value:te}=await oe.read();if(Ie)return;let we=N+te.length;if(we>B){B=we;let Ce=new Uint8Array(B);Ce.set(j),j=Ce}j.set(te,N),N=we;const L=N/B*100;return V({progress:L,loaded:N,total:B}),he()}return await he(),j}function x(...I){return I=I.map((V,O)=>(O&&(V=V.replace(new RegExp("^/"),"")),O!==I.length-1&&(V=V.replace(new RegExp("/$"),"")),V)),I.join("/")}},"./src/utils/image.js":(e,t,n)=>{n.r(t),n.d(t,{RawImage:()=>z});var o=n("./src/utils/hub.js"),a=n("./src/env.js"),l=n("./src/utils/tensor.js"),f=n("?2b25");const _=typeof self<"u",m=_&&self.constructor.name==="DedicatedWorkerGlobalScope";let g,M,v;if(_)g=($,S)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas($,S)},v=self.createImageBitmap,M=self.ImageData;else if(f)v=async $=>{const y=(await $.metadata()).channels,{data:x,info:I}=await $.rotate().raw().toBuffer({resolveWithObject:!0}),V=new z(new Uint8ClampedArray(x),I.width,I.height,I.channels);return y!==void 0&&y!==I.channels&&V.convert(y),V};else throw new Error("Unable to load image processing library.");const C={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},k=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class z{constructor(S,y,x,I){this.data=S,this.width=y,this.height=x,this.channels=I}get size(){return[this.width,this.height]}static async read(S){if(S instanceof z)return S;if(typeof S=="string"||S instanceof URL)return await this.fromURL(S);throw new Error(`Unsupported input type: ${typeof S}`)}static fromCanvas(S){if(!_)throw new Error("fromCanvas() is only supported in browser environments.");const x=S.getContext("2d").getImageData(0,0,S.width,S.height).data;return new z(x,S.width,S.height,4)}static async fromURL(S){const y=await(0,o.getFile)(S);if(y.status!==200)throw new Error(`Unable to read image from "${S}" (${y.status} ${y.statusText})`);const x=await y.blob();return this.fromBlob(x)}static async fromBlob(S){if(_){const y=await v(S),x=g(y.width,y.height).getContext("2d");return x.drawImage(y,0,0),new this(x.getImageData(0,0,y.width,y.height).data,y.width,y.height,4)}else{const y=f(await S.arrayBuffer());return await v(y)}}static fromTensor(S,y="CHW"){if(S.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${S.dims.length} dimensions.`);if(y==="CHW")S=S.transpose(1,2,0);else if(y!=="HWC")throw new Error(`Unsupported channel format: ${y}`);if(!(S.data instanceof Uint8ClampedArray||S.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${S.type}`);switch(S.dims[2]){case 1:case 2:case 3:case 4:return new z(S.data,S.dims[1],S.dims[0],S.dims[2]);default:throw new Error(`Unsupported number of channels: ${S.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const S=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let y=0,x=0;y<this.data.length;y+=this.channels){const I=this.data[y],V=this.data[y+1],O=this.data[y+2];S[x++]=Math.round(.2989*I+.587*V+.114*O)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(S,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const S=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let y=0,x=0;y<this.data.length;++y)S[x++]=this.data[y],S[x++]=this.data[y],S[x++]=this.data[y];break;case 4:for(let y=0,x=0;y<this.data.length;y+=4)S[x++]=this.data[y],S[x++]=this.data[y+1],S[x++]=this.data[y+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(S,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const S=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let y=0,x=0;y<this.data.length;++y)S[x++]=this.data[y],S[x++]=this.data[y],S[x++]=this.data[y],S[x++]=255;break;case 3:for(let y=0,x=0;y<this.data.length;y+=3)S[x++]=this.data[y],S[x++]=this.data[y+1],S[x++]=this.data[y+2],S[x++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(S,this.width,this.height,4)}async resize(S,y,{resample:x=2}={}){let I=C[x]??x;if(_){const V=this.channels,O=this.toCanvas(),B=g(S,y).getContext("2d");return B.drawImage(O,0,0,S,y),new z(B.getImageData(0,0,S,y).data,S,y,4).convert(V)}else{let V=this.toSharp();switch(I){case"box":case"hamming":(I==="box"||I==="hamming")&&(console.warn(`Resampling method ${I} is not yet supported. Using bilinear instead.`),I="bilinear");case"nearest":case"bilinear":case"bicubic":V=V.affine([S/this.width,0,0,y/this.height],{interpolator:I});break;case"lanczos":V=V.resize({width:S,height:y,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${I} is not supported.`)}return await v(V)}}async pad([S,y,x,I]){if(S=Math.max(S,0),y=Math.max(y,0),x=Math.max(x,0),I=Math.max(I,0),S===0&&y===0&&x===0&&I===0)return this;if(_){const V=this.channels,O=this.toCanvas(),B=this.width+S+y,j=this.height+x+I,N=g(B,j).getContext("2d");return N.drawImage(O,0,0,this.width,this.height,S,x,B,j),new z(N.getImageData(0,0,B,j).data,B,j,4).convert(V)}else{const V=this.toSharp().extend({left:S,right:y,top:x,bottom:I});return await v(V)}}async crop([S,y,x,I]){if(S=Math.max(S,0),y=Math.max(y,0),x=Math.min(x,this.width-1),I=Math.min(I,this.height-1),S===0&&y===0&&x===this.width-1&&I===this.height-1)return this;const V=x-S+1,O=I-y+1;if(_){const B=this.channels,j=this.toCanvas(),N=g(V,O).getContext("2d");return N.drawImage(j,S,y,V,O,0,0,V,O),new z(N.getImageData(0,0,V,O).data,V,O,4).convert(B)}else{const B=this.toSharp().extract({left:S,top:y,width:V,height:O});return await v(B)}}async center_crop(S,y){if(this.width===S&&this.height===y)return this;const x=(this.width-S)/2,I=(this.height-y)/2;if(_){const V=this.channels,O=this.toCanvas(),B=g(S,y).getContext("2d");let j=0,N=0,oe=0,he=0;return x>=0?j=x:oe=-x,I>=0?N=I:he=-I,B.drawImage(O,j,N,S,y,oe,he,S,y),new z(B.getImageData(0,0,S,y).data,S,y,4).convert(V)}else{let V=this.toSharp();if(x>=0&&I>=0)V=V.extract({left:Math.floor(x),top:Math.floor(I),width:S,height:y});else if(x<=0&&I<=0){const O=Math.floor(-I),B=Math.floor(-x);V=V.extend({top:O,left:B,right:S-this.width-B,bottom:y-this.height-O})}else{let O=[0,0],B=0;I<0?(O[0]=Math.floor(-I),O[1]=y-this.height-O[0]):B=Math.floor(I);let j=[0,0],N=0;x<0?(j[0]=Math.floor(-x),j[1]=S-this.width-j[0]):N=Math.floor(x),V=V.extend({top:O[0],bottom:O[1],left:j[0],right:j[1]}).extract({left:N,top:B,width:S,height:y})}return await v(V)}}async toBlob(S="image/png",y=1){if(!_)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:S,quality:y})}toTensor(S="CHW"){let y=new l.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(S!=="HWC")if(S==="CHW")y=y.permute(2,0,1);else throw new Error(`Unsupported channel format: ${S}`);return y}toCanvas(){if(!_)throw new Error("toCanvas() is only supported in browser environments.");const S=this.clone().rgba(),y=g(S.width,S.height),x=new M(S.data,S.width,S.height);return y.getContext("2d").putImageData(x,0,0),y}_update(S,y,x,I=null){return this.data=S,this.width=y,this.height=x,I!==null&&(this.channels=I),this}clone(){return new z(this.data.slice(),this.width,this.height,this.channels)}convert(S){if(this.channels===S)return this;switch(S){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(S){if(_){if(m)throw new Error("Unable to save an image from a Web Worker.");const y=S.split(".").pop().toLowerCase(),x=k.get(y)??"image/png",I=await this.toBlob(x),V=URL.createObjectURL(I),O=document.createElement("a");O.href=V,O.download=S,O.click(),O.remove()}else{if(a.env.useFS)return await this.toSharp().toFile(S);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(_)throw new Error("toSharp() is only supported in server-side environments.");return f(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}},"./src/utils/maths.js":(e,t,n)=>{n.r(t),n.d(t,{FFT:()=>$,bankers_round:()=>x,cos_sim:()=>m,dot:()=>_,dynamic_time_warping:()=>I,interpolate_data:()=>o,log_softmax:()=>f,magnitude:()=>g,max:()=>v,medianFilter:()=>S,min:()=>M,permute_data:()=>a,round:()=>y,softmax:()=>l});function o(V,[O,B,j],[N,oe],he="bilinear",Ie=!1){const te=oe/j,we=N/B,L=new V.constructor(N*oe*O),Ce=B*j,Xe=N*oe;for(let ye=0;ye<N;++ye)for(let Y=0;Y<oe;++Y){const se=ye*oe+Y,Me=(Y+.5)/te-.5,X=(ye+.5)/we-.5;let ge=Math.floor(Me),qe=Math.floor(X);const Be=Math.min(ge+1,j-1),Ne=Math.min(qe+1,B-1);ge=Math.max(ge,0),qe=Math.max(qe,0);const We=Me-ge,st=X-qe,pt=(1-We)*(1-st),Ge=We*(1-st),xe=(1-We)*st,je=We*st,Ye=qe*j,et=Ne*j,A=Ye+ge,$e=Ye+Be,Pe=et+ge,ae=et+Be;for(let ne=0;ne<O;++ne){const ve=ne*Ce;L[ne*Xe+se]=pt*V[ve+A]+Ge*V[ve+$e]+xe*V[ve+Pe]+je*V[ve+ae]}}return L}function a(V,O,B){const j=new Array(B.length),N=new Array(B.length);for(let Ie=B.length-1,te=1;Ie>=0;--Ie)N[Ie]=te,j[Ie]=O[B[Ie]],te*=j[Ie];const oe=B.map((Ie,te)=>N[B.indexOf(te)]),he=new V.constructor(V.length);for(let Ie=0;Ie<V.length;++Ie){let te=0;for(let we=O.length-1,L=Ie;we>=0;--we)te+=L%O[we]*oe[we],L=Math.floor(L/O[we]);he[te]=V[Ie]}return[he,j]}function l(V){const O=v(V)[0],B=V.map(oe=>Math.exp(oe-O)),j=B.reduce((oe,he)=>oe+he,0);return B.map(oe=>oe/j)}function f(V){return l(V).map(j=>Math.log(j))}function _(V,O){let B=0;for(let j=0;j<V.length;++j)B+=V[j]*O[j];return B}function m(V,O){const B=_(V,O),j=g(V),N=g(O);return B/(j*N)}function g(V){return Math.sqrt(V.reduce((O,B)=>O+B*B,0))}function M(V){if(V.length===0)throw Error("Array must not be empty");let O=V[0],B=0;for(let j=1;j<V.length;++j)V[j]<O&&(O=V[j],B=j);return[O,B]}function v(V){if(V.length===0)throw Error("Array must not be empty");let O=V[0],B=0;for(let j=1;j<V.length;++j)V[j]>O&&(O=V[j],B=j);return[Number(O),B]}function C(V){return V>0&&(V&V-1)===0}class k{constructor(O){if(this.size=O|0,this.size<=1||!C(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=O<<1,this.table=new Float64Array(this.size*2);for(let j=0;j<this.table.length;j+=2){const N=Math.PI*j/this.size;this.table[j]=Math.cos(N),this.table[j+1]=-Math.sin(N)}let B=0;for(let j=1;this.size>j;j<<=1)++B;this._width=B%2===0?B-1:B,this._bitrev=new Int32Array(1<<this._width);for(let j=0;j<this._bitrev.length;++j){this._bitrev[j]=0;for(let N=0;N<this._width;N+=2){const oe=this._width-N-2;this._bitrev[j]|=(j>>>N&3)<<oe}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(O,B){const j=B||new Array(O.length>>>1);for(let N=0;N<O.length;N+=2)j[N>>>1]=O[N];return j}toComplexArray(O,B){const j=B||this.createComplexArray();for(let N=0;N<j.length;N+=2)j[N]=O[N>>>1],j[N+1]=0;return j}transform(O,B){if(O===B)throw new Error("Input and output buffers must be different");this._transform4(O,B,1)}realTransform(O,B){if(O===B)throw new Error("Input and output buffers must be different");this._realTransform4(O,B,1)}inverseTransform(O,B){if(O===B)throw new Error("Input and output buffers must be different");this._transform4(O,B,-1);for(let j=0;j<O.length;++j)O[j]/=this.size}_transform4(O,B,j){const N=this._csize;let he=1<<this._width,Ie=N/he<<1,te,we;const L=this._bitrev;if(Ie===4)for(te=0,we=0;te<N;te+=Ie,++we){const Xe=L[we];this._singleTransform2(B,O,te,Xe,he)}else for(te=0,we=0;te<N;te+=Ie,++we){const Xe=L[we];this._singleTransform4(B,O,te,Xe,he,j)}const Ce=this.table;for(he>>=2;he>=2;he>>=2){Ie=N/he<<1;const Xe=Ie>>>2;for(te=0;te<N;te+=Ie){const ye=te+Xe-1;for(let Y=te,se=0;Y<ye;Y+=2,se+=he){const Me=Y,X=Me+Xe,ge=X+Xe,qe=ge+Xe,Be=O[Me],Ne=O[Me+1],We=O[X],st=O[X+1],pt=O[ge],Ge=O[ge+1],xe=O[qe],je=O[qe+1],Ye=Ce[se],et=j*Ce[se+1],A=We*Ye-st*et,$e=We*et+st*Ye,Pe=Ce[2*se],ae=j*Ce[2*se+1],ne=pt*Pe-Ge*ae,ve=pt*ae+Ge*Pe,R=Ce[3*se],ee=j*Ce[3*se+1],D=xe*R-je*ee,ce=xe*ee+je*R,ue=Be+ne,ke=Ne+ve,Re=Be-ne,ht=Ne-ve,tt=A+D,wt=$e+ce,bt=j*(A-D),Ke=j*($e-ce);O[Me]=ue+tt,O[Me+1]=ke+wt,O[X]=Re+Ke,O[X+1]=ht-bt,O[ge]=ue-tt,O[ge+1]=ke-wt,O[qe]=Re-Ke,O[qe+1]=ht+bt}}}}_singleTransform2(O,B,j,N,oe){const he=O[N],Ie=O[N+1],te=O[N+oe],we=O[N+oe+1];B[j]=he+te,B[j+1]=Ie+we,B[j+2]=he-te,B[j+3]=Ie-we}_singleTransform4(O,B,j,N,oe,he){const Ie=oe*2,te=oe*3,we=O[N],L=O[N+1],Ce=O[N+oe],Xe=O[N+oe+1],ye=O[N+Ie],Y=O[N+Ie+1],se=O[N+te],Me=O[N+te+1],X=we+ye,ge=L+Y,qe=we-ye,Be=L-Y,Ne=Ce+se,We=Xe+Me,st=he*(Ce-se),pt=he*(Xe-Me);B[j]=X+Ne,B[j+1]=ge+We,B[j+2]=qe+pt,B[j+3]=Be-st,B[j+4]=X-Ne,B[j+5]=ge-We,B[j+6]=qe-pt,B[j+7]=Be+st}_realTransform4(O,B,j){const N=this._csize;let he=1<<this._width,Ie=N/he<<1,te,we;const L=this._bitrev;if(Ie===4)for(te=0,we=0;te<N;te+=Ie,++we){const ye=L[we];this._singleRealTransform2(B,O,te,ye>>>1,he>>>1)}else for(te=0,we=0;te<N;te+=Ie,++we){const ye=L[we];this._singleRealTransform4(B,O,te,ye>>>1,he>>>1,j)}const Ce=this.table;for(he>>=2;he>=2;he>>=2){Ie=N/he<<1;const ye=Ie>>>1,Y=ye>>>1,se=Y>>>1;for(te=0;te<N;te+=Ie)for(let Me=0,X=0;Me<=se;Me+=2,X+=he){const ge=te+Me,qe=ge+Y,Be=qe+Y,Ne=Be+Y,We=O[ge],st=O[ge+1],pt=O[qe],Ge=O[qe+1],xe=O[Be],je=O[Be+1],Ye=O[Ne],et=O[Ne+1],A=We,$e=st,Pe=Ce[X],ae=j*Ce[X+1],ne=pt*Pe-Ge*ae,ve=pt*ae+Ge*Pe,R=Ce[2*X],ee=j*Ce[2*X+1],D=xe*R-je*ee,ce=xe*ee+je*R,ue=Ce[3*X],ke=j*Ce[3*X+1],Re=Ye*ue-et*ke,ht=Ye*ke+et*ue,tt=A+D,wt=$e+ce,bt=A-D,Ke=$e-ce,de=ne+Re,Ae=ve+ht,Ve=j*(ne-Re),ot=j*(ve-ht);if(O[ge]=tt+de,O[ge+1]=wt+Ae,O[qe]=bt+ot,O[qe+1]=Ke-Ve,Me===0){O[Be]=tt-de,O[Be+1]=wt-Ae;continue}if(Me===se)continue;const Qe=te+Y-Me,ft=te+ye-Me;O[Qe]=bt-j*ot,O[Qe+1]=-Ke-j*Ve,O[ft]=tt-j*de,O[ft+1]=-wt+j*Ae}}const Xe=N>>>1;for(let ye=2;ye<Xe;ye+=2)O[N-ye]=O[ye],O[N-ye+1]=-O[ye+1]}_singleRealTransform2(O,B,j,N,oe){const he=O[N],Ie=O[N+oe];B[j]=he+Ie,B[j+1]=0,B[j+2]=he-Ie,B[j+3]=0}_singleRealTransform4(O,B,j,N,oe,he){const Ie=oe*2,te=oe*3,we=O[N],L=O[N+oe],Ce=O[N+Ie],Xe=O[N+te],ye=we+Ce,Y=we-Ce,se=L+Xe,Me=he*(L-Xe);B[j]=ye+se,B[j+1]=0,B[j+2]=Y,B[j+3]=-Me,B[j+4]=ye-se,B[j+5]=0,B[j+6]=Y,B[j+7]=Me}}class z{constructor(O){const B=2*(O-1),j=2*(2*O-1),N=2**Math.ceil(Math.log2(j));this.bufferSize=N,this._a=B;const oe=new Float64Array(j),he=new Float64Array(N);this._chirpBuffer=new Float64Array(N),this._buffer1=new Float64Array(N),this._buffer2=new Float64Array(N),this._outBuffer1=new Float64Array(N),this._outBuffer2=new Float64Array(N);const Ie=-2*Math.PI/O,te=Math.cos(Ie),we=Math.sin(Ie);for(let L=0;L<j>>1;++L){const Ce=(L+1-O)**2/2,Xe=Math.sqrt(te**2+we**2)**Ce,ye=Ce*Math.atan2(we,te),Y=2*L;oe[Y]=Xe*Math.cos(ye),oe[Y+1]=Xe*Math.sin(ye),he[Y]=oe[Y],he[Y+1]=-oe[Y+1]}this._slicedChirpBuffer=oe.subarray(B,j),this._f=new k(N>>1),this._f.transform(this._chirpBuffer,he)}_transform(O,B,j){const N=this._buffer1,oe=this._buffer2,he=this._outBuffer1,Ie=this._outBuffer2,te=this._chirpBuffer,we=this._slicedChirpBuffer,L=this._a;if(j)for(let Ce=0;Ce<we.length;Ce+=2){const Xe=Ce+1,ye=Ce>>1,Y=B[ye];N[Ce]=Y*we[Ce],N[Xe]=Y*we[Xe]}else for(let Ce=0;Ce<we.length;Ce+=2){const Xe=Ce+1;N[Ce]=B[Ce]*we[Ce]-B[Xe]*we[Xe],N[Xe]=B[Ce]*we[Xe]+B[Xe]*we[Ce]}this._f.transform(he,N);for(let Ce=0;Ce<te.length;Ce+=2){const Xe=Ce+1;oe[Ce]=he[Ce]*te[Ce]-he[Xe]*te[Xe],oe[Xe]=he[Ce]*te[Xe]+he[Xe]*te[Ce]}this._f.inverseTransform(Ie,oe);for(let Ce=0;Ce<Ie.length;Ce+=2){const Xe=Ie[Ce+L],ye=Ie[Ce+L+1],Y=we[Ce],se=we[Ce+1];O[Ce]=Xe*Y-ye*se,O[Ce+1]=Xe*se+ye*Y}}transform(O,B){this._transform(O,B,!1)}realTransform(O,B){this._transform(O,B,!0)}}class ${constructor(O){this.fft_length=O,this.isPowerOfTwo=C(O),this.isPowerOfTwo?(this.fft=new k(O),this.outputBufferSize=2*O):(this.fft=new z(O),this.outputBufferSize=this.fft.bufferSize)}realTransform(O,B){this.fft.realTransform(O,B)}transform(O,B){this.fft.transform(O,B)}}function S(V,O){if(O%2===0||O<=0)throw new Error("Window size must be a positive odd number");const B=new V.constructor(V.length),j=new V.constructor(O),N=Math.floor(O/2);for(let oe=0;oe<V.length;++oe){let he=0;for(let Ie=-N;Ie<=N;++Ie){let te=oe+Ie;te<0?te=Math.abs(te):te>=V.length&&(te=2*(V.length-1)-te),j[he++]=V[te]}j.sort(),B[oe]=j[N]}return B}function y(V,O){const B=Math.pow(10,O);return Math.round(V*B)/B}function x(V){const O=Math.round(V);return Math.abs(V)%1===.5?O%2===0?O:O-1:O}function I(V){const O=V.length,B=V[0].length,j=[O+1,B+1],N=Array.from({length:j[0]},()=>Array(j[1]).fill(1/0));N[0][0]=0;const oe=Array.from({length:j[0]},()=>Array(j[1]).fill(-1));for(let L=1;L<j[1];++L)for(let Ce=1;Ce<j[0];++Ce){const Xe=N[Ce-1][L-1],ye=N[Ce-1][L],Y=N[Ce][L-1];let se,Me;Xe<ye&&Xe<Y?(se=Xe,Me=0):ye<Xe&&ye<Y?(se=ye,Me=1):(se=Y,Me=2),N[Ce][L]=V[Ce-1][L-1]+se,oe[Ce][L]=Me}for(let L=0;L<j[1];++L)oe[0][L]=2;for(let L=0;L<j[0];++L)oe[L][0]=1;let he=O,Ie=B,te=[],we=[];for(;he>0||Ie>0;)switch(te.push(he-1),we.push(Ie-1),oe[he][Ie]){case 0:--he,--Ie;break;case 1:--he;break;case 2:--Ie;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${he}, ${Ie}]. Please file a bug report.`)}return te.reverse(),we.reverse(),[te,we]}},"./src/utils/tensor.js":(e,t,n)=>{n.r(t),n.d(t,{Tensor:()=>_,cat:()=>V,full:()=>he,full_like:()=>Ie,interpolate:()=>M,interpolate_4d:()=>v,layer_norm:()=>S,matmul:()=>C,mean:()=>j,mean_pooling:()=>$,ones:()=>te,ones_like:()=>we,permute:()=>g,quantize_embeddings:()=>Xe,rfft:()=>k,stack:()=>O,std_mean:()=>B,topk:()=>z,zeros:()=>L,zeros_like:()=>Ce});var o=n("./src/utils/maths.js"),a=n("./src/backends/onnx.js"),l=n("./src/ops/registry.js");const f=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array});class _{constructor(...Y){He(this,"ort_tensor");return(0,a.isONNXTensor)(Y[0])?this.ort_tensor=Y[0]:this.ort_tensor=new a.Tensor(Y[0],Y[1],Y[2]),new Proxy(this,{get:(se,Me)=>{if(typeof Me=="string"){let X=Number(Me);if(Number.isInteger(X))return se._getitem(X)}return se[Me]},set:(se,Me,X)=>se[Me]=X})}get dims(){return this.ort_tensor.dims}set dims(Y){this.ort_tensor.dims=Y}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[Y,...se]=this.dims;if(se.length>0){const Me=se.reduce((X,ge)=>X*ge);for(let X=0;X<Y;++X)yield this._subarray(X,Me,se)}else yield*this.data}_getitem(Y){const[se,...Me]=this.dims;if(Y=I(Y,se),Me.length>0){const X=Me.reduce((ge,qe)=>ge*qe);return this._subarray(Y,X,Me)}else return new _(this.type,[this.data[Y]],Me)}indexOf(Y){const se=this.data;for(let Me=0;Me<se.length;++Me)if(se[Me]==Y)return Me;return-1}_subarray(Y,se,Me){const X=Y*se,ge=(Y+1)*se,qe="subarray"in this.data?this.data.subarray(X,ge):this.data.slice(X,ge);return new _(this.type,qe,Me)}item(){const Y=this.data;if(Y.length!==1)throw new Error(`a Tensor with ${Y.length} elements cannot be converted to Scalar`);return Y[0]}tolist(){return m(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const Y=this.data;for(let se=0;se<Y.length;++se)Y[se]=1/(1+Math.exp(-Y[se]));return this}mul(Y){return this.clone().mul_(Y)}mul_(Y){const se=this.data;for(let Me=0;Me<se.length;++Me)se[Me]*=Y;return this}div(Y){return this.clone().div_(Y)}div_(Y){const se=this.data;for(let Me=0;Me<se.length;++Me)se[Me]/=Y;return this}add(Y){return this.clone().add_(Y)}add_(Y){const se=this.data;for(let Me=0;Me<se.length;++Me)se[Me]+=Y;return this}sub(Y){return this.clone().sub_(Y)}sub_(Y){const se=this.data;for(let Me=0;Me<se.length;++Me)se[Me]-=Y;return this}clone(){return new _(this.type,this.data.slice(),this.dims.slice())}slice(...Y){const se=[],Me=[];for(let We=0;We<this.dims.length;++We){let st=Y[We];if(st==null)Me.push([0,this.dims[We]]),se.push(this.dims[We]);else if(typeof st=="number")st=I(st,this.dims[We],We),Me.push([st,st+1]);else if(Array.isArray(st)&&st.length===2){let[pt,Ge]=st;if(pt=pt===null?0:I(pt,this.dims[We],We,!1),Ge=Ge===null?this.dims[We]:I(Ge,this.dims[We],We,!1),pt>Ge)throw new Error(`Invalid slice: ${st}`);const xe=[Math.max(pt,0),Math.min(Ge,this.dims[We])];Me.push(xe),se.push(xe[1]-xe[0])}else throw new Error(`Invalid slice: ${st}`)}const X=Me.map(([We,st])=>st-We),ge=X.reduce((We,st)=>We*st),qe=this.data,Be=new qe.constructor(ge),Ne=this.stride();for(let We=0;We<ge;++We){let st=0;for(let pt=X.length-1,Ge=We;pt>=0;--pt){const xe=X[pt];st+=(Ge%xe+Me[pt][0])*Ne[pt],Ge=Math.floor(Ge/xe)}Be[We]=qe[st]}return new _(this.type,Be,se)}permute(...Y){return g(this,Y)}transpose(...Y){return this.permute(...Y)}sum(Y=null,se=!1){return this.norm(1,Y,se)}norm(Y="fro",se=null,Me=!1){if(Y==="fro")Y=2;else if(typeof Y=="string")throw Error(`Unsupported norm: ${Y}`);const X=this.data;if(se===null){let Be=X.reduce((Ne,We)=>Ne+We**Y,0)**(1/Y);return new _(this.type,[Be],[])}se=I(se,this.dims.length);const ge=this.dims.slice();ge[se]=1;const qe=new X.constructor(X.length/this.dims[se]);for(let Be=0;Be<X.length;++Be){let Ne=0;for(let We=this.dims.length-1,st=Be,pt=1;We>=0;--We){const Ge=this.dims[We];if(We!==se){const xe=st%Ge;Ne+=xe*pt,pt*=ge[We]}st=Math.floor(st/Ge)}qe[Ne]+=X[Be]**Y}if(Y!==1)for(let Be=0;Be<qe.length;++Be)qe[Be]=qe[Be]**(1/Y);return Me||ge.splice(se,1),new _(this.type,qe,ge)}normalize_(Y=2,se=1){se=I(se,this.dims.length);const Me=this.norm(Y,se,!0),X=this.data,ge=Me.data;for(let qe=0;qe<X.length;++qe){let Be=0;for(let Ne=this.dims.length-1,We=qe,st=1;Ne>=0;--Ne){const pt=this.dims[Ne];if(Ne!==se){const Ge=We%pt;Be+=Ge*st,st*=this.dims[Ne]}We=Math.floor(We/pt)}X[qe]/=ge[Be]}return this}normalize(Y=2,se=1){return this.clone().normalize_(Y,se)}stride(){return N(this.dims)}squeeze(Y=null){return new _(this.type,this.data,y(this.dims,Y))}squeeze_(Y=null){return this.dims=y(this.dims,Y),this}unsqueeze(Y=null){return new _(this.type,this.data,x(this.dims,Y))}unsqueeze_(Y=null){return this.dims=x(this.dims,Y),this}flatten_(Y=0,se=-1){se=(se+this.dims.length)%this.dims.length;let Me=this.dims.slice(0,Y),X=this.dims.slice(Y,se+1),ge=this.dims.slice(se+1);return this.dims=[...Me,X.reduce((qe,Be)=>qe*Be,1),...ge],this}flatten(Y=0,se=-1){return this.clone().flatten_(Y,se)}view(...Y){let se=-1;for(let X=0;X<Y.length;++X)if(Y[X]===-1){if(se!==-1)throw new Error("Only one dimension can be inferred");se=X}const Me=this.data;if(se!==-1){const X=Y.reduce((ge,qe,Be)=>Be!==se?ge*qe:ge,1);Y[se]=Me.length/X}return new _(this.type,Me,Y)}neg_(){const Y=this.data;for(let se=0;se<Y.length;++se)Y[se]=-Y[se];return this}neg(){return this.clone().neg_()}clamp_(Y,se){const Me=this.data;for(let X=0;X<Me.length;++X)Me[X]=Math.min(Math.max(Me[X],Y),se);return this}clamp(Y,se){return this.clone().clamp_(Y,se)}round_(){const Y=this.data;for(let se=0;se<Y.length;++se)Y[se]=Math.round(Y[se]);return this}round(){return this.clone().round_()}mean(Y=null,se=!1){return j(this,Y,se)}to(Y){if(this.type===Y)return this;if(!f.hasOwnProperty(Y))throw new Error(`Unsupported type: ${Y}`);return new _(Y,f[Y].from(this.data),this.dims)}}function m(ye,Y){const se=ye.length,Me=Y.reduce((ge,qe)=>ge*qe);if(se!==Me)throw Error(`cannot reshape array of size ${se} into shape (${Y})`);let X=ye;for(let ge=Y.length-1;ge>=0;ge--)X=X.reduce((qe,Be)=>{let Ne=qe[qe.length-1];return Ne.length<Y[ge]?Ne.push(Be):qe.push([Be]),qe},[[]]);return X[0]}function g(ye,Y){const[se,Me]=(0,o.permute_data)(ye.data,ye.dims,Y);return new _(ye.type,se,Me)}function M(ye,[Y,se],Me="bilinear",X=!1){const ge=ye.dims.at(-3)??1,qe=ye.dims.at(-2),Be=ye.dims.at(-1);let Ne=(0,o.interpolate_data)(ye.data,[ge,qe,Be],[Y,se],Me,X);return new _(ye.type,Ne,[ge,Y,se])}async function v(ye,{size:Y=null,mode:se="bilinear"}={}){if(ye.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!Y)throw new Error("`interpolate_4d` requires a `size` argument.");let Me;if(Y.length===2)Me=[...ye.dims.slice(0,2),...Y];else if(Y.length===3)Me=[ye.dims[0],...Y];else if(Y.length===4)Me=Y;else throw new Error("`size` must be of length 2, 3, or 4.");let X;if(se==="bilinear")X=await l.TensorOpRegistry.bilinear_interpolate_4d;else if(se==="bicubic")X=await l.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${se}`);const ge=new _("int64",new BigInt64Array(Me.map(BigInt)),[Me.length]);return await X({x:ye,s:ge})}async function C(ye,Y){return await(await l.TensorOpRegistry.matmul)({a:ye,b:Y})}async function k(ye,Y){return await(await l.TensorOpRegistry.rfft)({x:ye,a:Y})}async function z(ye,Y){const se=await l.TensorOpRegistry.top_k;return Y===null?Y=ye.dims.at(-1):Y=Math.min(Y,ye.dims.at(-1)),await se({x:ye,k:new _("int64",[BigInt(Y)],[1])})}function $(ye,Y){const se=ye.data,Me=Y.data,X=[ye.dims[0],ye.dims[2]],ge=new se.constructor(X[0]*X[1]),[qe,Be,Ne]=ye.dims;let We=0;for(let st=0;st<qe;++st){const pt=st*Ne*Be;for(let Ge=0;Ge<Ne;++Ge){let xe=0,je=0;const Ye=st*Be,et=pt+Ge;for(let $e=0;$e<Be;++$e){const Pe=Number(Me[Ye+$e]);je+=Pe,xe+=se[et+$e*Ne]*Pe}const A=xe/je;ge[We++]=A}}return new _(ye.type,ge,X)}function S(ye,Y,{eps:se=1e-5}={}){if(ye.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[Me,X]=ye.dims;if(Y.length!==1&&Y[0]!==X)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[ge,qe]=B(ye,1,0,!0),Be=ge.data,Ne=qe.data,We=ye.data,st=new We.constructor(We.length);for(let pt=0;pt<Me;++pt){const Ge=pt*X;for(let xe=0;xe<X;++xe){const je=Ge+xe;st[je]=(We[je]-Ne[pt])/(Be[pt]+se)}}return new _(ye.type,st,ye.dims)}function y(ye,Y){return ye=ye.slice(),Y===null?ye=ye.filter(se=>se!==1):typeof Y=="number"?ye[Y]===1&&ye.splice(Y,1):Array.isArray(Y)&&(ye=ye.filter((se,Me)=>se!==1||!Y.includes(Me))),ye}function x(ye,Y){return Y=I(Y,ye.length+1),ye=ye.slice(),ye.splice(Y,0,1),ye}function I(ye,Y,se=null,Me=!0){if(Me&&(ye<-Y||ye>=Y))throw new Error(`IndexError: index ${ye} is out of bounds for dimension${se===null?"":" "+se} with size ${Y}`);return ye<0&&(ye=(ye%Y+Y)%Y),ye}function V(ye,Y=0){Y=I(Y,ye[0].dims.length);const se=ye[0].dims.slice();se[Y]=ye.reduce((qe,Be)=>qe+Be.dims[Y],0);const Me=se.reduce((qe,Be)=>qe*Be,1),X=new ye[0].data.constructor(Me),ge=ye[0].type;if(Y===0){let qe=0;for(const Be of ye){const Ne=Be.data;X.set(Ne,qe),qe+=Ne.length}}else{let qe=0;for(let Be=0;Be<ye.length;++Be){const{data:Ne,dims:We}=ye[Be];for(let st=0;st<Ne.length;++st){let pt=0;for(let Ge=We.length-1,xe=st,je=1;Ge>=0;--Ge){const Ye=We[Ge];let et=xe%Ye;Ge===Y&&(et+=qe),pt+=et*je,je*=se[Ge],xe=Math.floor(xe/Ye)}X[pt]=Ne[st]}qe+=We[Y]}}return new _(ge,X,se)}function O(ye,Y=0){return V(ye.map(se=>se.unsqueeze(Y)),Y)}function B(ye,Y=null,se=1,Me=!1){const X=ye.data,ge=ye.dims;if(Y===null){const Ge=X.reduce((et,A)=>et+A,0)/X.length,xe=Math.sqrt(X.reduce((et,A)=>et+(A-Ge)**2,0)/(X.length-se)),je=new _(ye.type,[Ge],[]);return[new _(ye.type,[xe],[]),je]}Y=I(Y,ge.length);const qe=j(ye,Y,Me),Be=qe.data,Ne=ge.slice();Ne[Y]=1;const We=new X.constructor(X.length/ge[Y]);for(let pt=0;pt<X.length;++pt){let Ge=0;for(let xe=ge.length-1,je=pt,Ye=1;xe>=0;--xe){const et=ge[xe];if(xe!==Y){const A=je%et;Ge+=A*Ye,Ye*=Ne[xe]}je=Math.floor(je/et)}We[Ge]+=(X[pt]-Be[Ge])**2}for(let pt=0;pt<We.length;++pt)We[pt]=Math.sqrt(We[pt]/(ge[Y]-se));return Me||Ne.splice(Y,1),[new _(ye.type,We,Ne),qe]}function j(ye,Y=null,se=!1){const Me=ye.data;if(Y===null){const Be=Me.reduce((Ne,We)=>Ne+We,0);return new _(ye.type,[Be/Me.length],[])}const X=ye.dims;Y=I(Y,X.length);const ge=X.slice();ge[Y]=1;const qe=new Me.constructor(Me.length/X[Y]);for(let Be=0;Be<Me.length;++Be){let Ne=0;for(let We=X.length-1,st=Be,pt=1;We>=0;--We){const Ge=X[We];if(We!==Y){const xe=st%Ge;Ne+=xe*pt,pt*=ge[We]}st=Math.floor(st/Ge)}qe[Ne]+=Me[Be]}if(X[Y]!==1)for(let Be=0;Be<qe.length;++Be)qe[Be]=qe[Be]/X[Y];return se||ge.splice(Y,1),new _(ye.type,qe,ge)}function N(ye){const Y=new Array(ye.length);for(let se=ye.length-1,Me=1;se>=0;--se)Y[se]=Me,Me*=ye[se];return Y}function oe(ye,Y,se,Me){const X=ye.reduce((ge,qe)=>ge*qe,1);return new _(se,new Me(X).fill(Y),ye)}function he(ye,Y){let se,Me;if(typeof Y=="number")se="float32",Me=Float32Array;else if(typeof Y=="bigint")se="int64",Me=BigInt64Array;else throw new Error(`Unsupported data type: ${typeof Y}`);return oe(ye,Y,se,Me)}function Ie(ye,Y){return he(ye.dims,Y)}function te(ye){return oe(ye,1n,"int64",BigInt64Array)}function we(ye){return te(ye.dims)}function L(ye){return oe(ye,0n,"int64",BigInt64Array)}function Ce(ye){return L(ye.dims)}function Xe(ye,Y){if(ye.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(ye.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(Y))throw new Error("The precision must be either 'binary' or 'ubinary'");const se=Y==="binary",Me=se?"int8":"uint8",X=se?Int8Array:Uint8Array,ge=ye.data,qe=new X(ge.length/8);for(let Be=0;Be<ge.length;++Be){const Ne=ge[Be]>0?1:0,We=Math.floor(Be/8),st=Be%8;qe[We]|=Ne<<7-st,se&&st===0&&(qe[We]-=128)}return new _(Me,qe,[ye.dims[0],ye.dims[1]/8])}}},Uv={};function rn(e){var t=Uv[e];if(t!==void 0)return t.exports;var n=Uv[e]={exports:{}};return wx[e](n,n.exports,rn),n.exports}rn.m=wx;(()=>{var e=Object.getPrototypeOf?n=>Object.getPrototypeOf(n):n=>n.__proto__,t;rn.t=function(n,o){if(o&1&&(n=this(n)),o&8||typeof n=="object"&&n&&(o&4&&n.__esModule||o&16&&typeof n.then=="function"))return n;var a=Object.create(null);rn.r(a);var l={};t=t||[null,e({}),e([]),e(e)];for(var f=o&2&&n;typeof f=="object"&&!~t.indexOf(f);f=e(f))Object.getOwnPropertyNames(f).forEach(_=>l[_]=()=>n[_]);return l.default=()=>n,rn.d(a,l),a}})();rn.d=(e,t)=>{for(var n in t)rn.o(t,n)&&!rn.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})};rn.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);rn.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};(()=>{var e;if(typeof import.meta.url=="string"&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),rn.p=e})();rn.b=new URL("./",import.meta.url);var P={};/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/rn.r(P);rn.d(P,{ASTFeatureExtractor:()=>or.ASTFeatureExtractor,ASTForAudioClassification:()=>Q.ASTForAudioClassification,ASTModel:()=>Q.ASTModel,ASTPreTrainedModel:()=>Q.ASTPreTrainedModel,AlbertForMaskedLM:()=>Q.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>Q.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>Q.AlbertForSequenceClassification,AlbertModel:()=>Q.AlbertModel,AlbertPreTrainedModel:()=>Q.AlbertPreTrainedModel,AlbertTokenizer:()=>ur.AlbertTokenizer,AudioClassificationPipeline:()=>en.AudioClassificationPipeline,AutoConfig:()=>Gg.AutoConfig,AutoModel:()=>Q.AutoModel,AutoModelForAudioClassification:()=>Q.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>Q.AutoModelForAudioFrameClassification,AutoModelForCTC:()=>Q.AutoModelForCTC,AutoModelForCausalLM:()=>Q.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>Q.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>Q.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>Q.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>Q.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>Q.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>Q.AutoModelForImageSegmentation,AutoModelForImageToImage:()=>Q.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>Q.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>Q.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>Q.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>Q.AutoModelForObjectDetection,AutoModelForQuestionAnswering:()=>Q.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>Q.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>Q.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>Q.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>Q.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>Q.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>Q.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>Q.AutoModelForTokenClassification,AutoModelForVision2Seq:()=>Q.AutoModelForVision2Seq,AutoModelForXVector:()=>Q.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>Q.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>or.AutoProcessor,AutoTokenizer:()=>ur.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>en.AutomaticSpeechRecognitionPipeline,BartForConditionalGeneration:()=>Q.BartForConditionalGeneration,BartForSequenceClassification:()=>Q.BartForSequenceClassification,BartModel:()=>Q.BartModel,BartPretrainedModel:()=>Q.BartPretrainedModel,BartTokenizer:()=>ur.BartTokenizer,BaseModelOutput:()=>Q.BaseModelOutput,BaseStreamer:()=>Hg.BaseStreamer,BeitFeatureExtractor:()=>or.BeitFeatureExtractor,BeitForImageClassification:()=>Q.BeitForImageClassification,BeitModel:()=>Q.BeitModel,BeitPreTrainedModel:()=>Q.BeitPreTrainedModel,BertForMaskedLM:()=>Q.BertForMaskedLM,BertForQuestionAnswering:()=>Q.BertForQuestionAnswering,BertForSequenceClassification:()=>Q.BertForSequenceClassification,BertForTokenClassification:()=>Q.BertForTokenClassification,BertModel:()=>Q.BertModel,BertPreTrainedModel:()=>Q.BertPreTrainedModel,BertTokenizer:()=>ur.BertTokenizer,BitImageProcessor:()=>or.BitImageProcessor,BlenderbotForConditionalGeneration:()=>Q.BlenderbotForConditionalGeneration,BlenderbotModel:()=>Q.BlenderbotModel,BlenderbotPreTrainedModel:()=>Q.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>Q.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>Q.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>Q.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>ur.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>ur.BlenderbotTokenizer,BloomForCausalLM:()=>Q.BloomForCausalLM,BloomModel:()=>Q.BloomModel,BloomPreTrainedModel:()=>Q.BloomPreTrainedModel,BloomTokenizer:()=>ur.BloomTokenizer,CLIPFeatureExtractor:()=>or.CLIPFeatureExtractor,CLIPImageProcessor:()=>or.CLIPImageProcessor,CLIPModel:()=>Q.CLIPModel,CLIPPreTrainedModel:()=>Q.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>Q.CLIPSegForImageSegmentation,CLIPSegModel:()=>Q.CLIPSegModel,CLIPSegPreTrainedModel:()=>Q.CLIPSegPreTrainedModel,CLIPTextModelWithProjection:()=>Q.CLIPTextModelWithProjection,CLIPTokenizer:()=>ur.CLIPTokenizer,CLIPVisionModelWithProjection:()=>Q.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>Q.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>Q.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>Q.CamembertForSequenceClassification,CamembertForTokenClassification:()=>Q.CamembertForTokenClassification,CamembertModel:()=>Q.CamembertModel,CamembertPreTrainedModel:()=>Q.CamembertPreTrainedModel,CamembertTokenizer:()=>ur.CamembertTokenizer,CausalLMOutput:()=>Q.CausalLMOutput,CausalLMOutputWithPast:()=>Q.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>or.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>Q.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>Q.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>Q.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>or.ClapFeatureExtractor,ClapModel:()=>Q.ClapModel,ClapPreTrainedModel:()=>Q.ClapPreTrainedModel,ClapTextModelWithProjection:()=>Q.ClapTextModelWithProjection,CodeGenForCausalLM:()=>Q.CodeGenForCausalLM,CodeGenModel:()=>Q.CodeGenModel,CodeGenPreTrainedModel:()=>Q.CodeGenPreTrainedModel,CodeGenTokenizer:()=>ur.CodeGenTokenizer,CodeLlamaTokenizer:()=>ur.CodeLlamaTokenizer,CohereForCausalLM:()=>Q.CohereForCausalLM,CohereModel:()=>Q.CohereModel,CoherePreTrainedModel:()=>Q.CoherePreTrainedModel,CohereTokenizer:()=>ur.CohereTokenizer,ConvBertForMaskedLM:()=>Q.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>Q.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>Q.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>Q.ConvBertForTokenClassification,ConvBertModel:()=>Q.ConvBertModel,ConvBertPreTrainedModel:()=>Q.ConvBertPreTrainedModel,ConvBertTokenizer:()=>ur.ConvBertTokenizer,ConvNextFeatureExtractor:()=>or.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>Q.ConvNextForImageClassification,ConvNextImageProcessor:()=>or.ConvNextImageProcessor,ConvNextModel:()=>Q.ConvNextModel,ConvNextPreTrainedModel:()=>Q.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>Q.ConvNextV2ForImageClassification,ConvNextV2Model:()=>Q.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>Q.ConvNextV2PreTrainedModel,DPTFeatureExtractor:()=>or.DPTFeatureExtractor,DPTForDepthEstimation:()=>Q.DPTForDepthEstimation,DPTImageProcessor:()=>or.DPTImageProcessor,DPTModel:()=>Q.DPTModel,DPTPreTrainedModel:()=>Q.DPTPreTrainedModel,DebertaForMaskedLM:()=>Q.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>Q.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>Q.DebertaForSequenceClassification,DebertaForTokenClassification:()=>Q.DebertaForTokenClassification,DebertaModel:()=>Q.DebertaModel,DebertaPreTrainedModel:()=>Q.DebertaPreTrainedModel,DebertaTokenizer:()=>ur.DebertaTokenizer,DebertaV2ForMaskedLM:()=>Q.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>Q.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>Q.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>Q.DebertaV2ForTokenClassification,DebertaV2Model:()=>Q.DebertaV2Model,DebertaV2PreTrainedModel:()=>Q.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>ur.DebertaV2Tokenizer,DeiTFeatureExtractor:()=>or.DeiTFeatureExtractor,DeiTForImageClassification:()=>Q.DeiTForImageClassification,DeiTModel:()=>Q.DeiTModel,DeiTPreTrainedModel:()=>Q.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>Q.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>Q.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>en.DepthEstimationPipeline,DetrFeatureExtractor:()=>or.DetrFeatureExtractor,DetrForObjectDetection:()=>Q.DetrForObjectDetection,DetrForSegmentation:()=>Q.DetrForSegmentation,DetrModel:()=>Q.DetrModel,DetrObjectDetectionOutput:()=>Q.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>Q.DetrPreTrainedModel,DetrSegmentationOutput:()=>Q.DetrSegmentationOutput,Dinov2ForImageClassification:()=>Q.Dinov2ForImageClassification,Dinov2Model:()=>Q.Dinov2Model,Dinov2PreTrainedModel:()=>Q.Dinov2PreTrainedModel,DistilBertForMaskedLM:()=>Q.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>Q.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>Q.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>Q.DistilBertForTokenClassification,DistilBertModel:()=>Q.DistilBertModel,DistilBertPreTrainedModel:()=>Q.DistilBertPreTrainedModel,DistilBertTokenizer:()=>ur.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>en.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>or.DonutFeatureExtractor,DonutSwinModel:()=>Q.DonutSwinModel,DonutSwinPreTrainedModel:()=>Q.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>Q.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>or.EfficientNetImageProcessor,EfficientNetModel:()=>Q.EfficientNetModel,EfficientNetPreTrainedModel:()=>Q.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>Q.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>Q.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>Q.ElectraForSequenceClassification,ElectraForTokenClassification:()=>Q.ElectraForTokenClassification,ElectraModel:()=>Q.ElectraModel,ElectraPreTrainedModel:()=>Q.ElectraPreTrainedModel,ElectraTokenizer:()=>ur.ElectraTokenizer,EosTokenCriteria:()=>Ff.EosTokenCriteria,EsmForMaskedLM:()=>Q.EsmForMaskedLM,EsmForSequenceClassification:()=>Q.EsmForSequenceClassification,EsmForTokenClassification:()=>Q.EsmForTokenClassification,EsmModel:()=>Q.EsmModel,EsmPreTrainedModel:()=>Q.EsmPreTrainedModel,EsmTokenizer:()=>ur.EsmTokenizer,FFT:()=>fi.FFT,FalconForCausalLM:()=>Q.FalconForCausalLM,FalconModel:()=>Q.FalconModel,FalconPreTrainedModel:()=>Q.FalconPreTrainedModel,FalconTokenizer:()=>ur.FalconTokenizer,FastViTForImageClassification:()=>Q.FastViTForImageClassification,FastViTModel:()=>Q.FastViTModel,FastViTPreTrainedModel:()=>Q.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>en.FeatureExtractionPipeline,FeatureExtractor:()=>or.FeatureExtractor,FillMaskPipeline:()=>en.FillMaskPipeline,Florence2ForConditionalGeneration:()=>Q.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>Q.Florence2PreTrainedModel,Florence2Processor:()=>or.Florence2Processor,GLPNFeatureExtractor:()=>or.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>Q.GLPNForDepthEstimation,GLPNModel:()=>Q.GLPNModel,GLPNPreTrainedModel:()=>Q.GLPNPreTrainedModel,GPT2LMHeadModel:()=>Q.GPT2LMHeadModel,GPT2Model:()=>Q.GPT2Model,GPT2PreTrainedModel:()=>Q.GPT2PreTrainedModel,GPT2Tokenizer:()=>ur.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>Q.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>Q.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>Q.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>Q.GPTJForCausalLM,GPTJModel:()=>Q.GPTJModel,GPTJPreTrainedModel:()=>Q.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>Q.GPTNeoForCausalLM,GPTNeoModel:()=>Q.GPTNeoModel,GPTNeoPreTrainedModel:()=>Q.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>Q.GPTNeoXForCausalLM,GPTNeoXModel:()=>Q.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>Q.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>ur.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>Q.Gemma2ForCausalLM,Gemma2Model:()=>Q.Gemma2Model,Gemma2PreTrainedModel:()=>Q.Gemma2PreTrainedModel,GemmaForCausalLM:()=>Q.GemmaForCausalLM,GemmaModel:()=>Q.GemmaModel,GemmaPreTrainedModel:()=>Q.GemmaPreTrainedModel,GemmaTokenizer:()=>ur.GemmaTokenizer,Grok1Tokenizer:()=>ur.Grok1Tokenizer,HerbertTokenizer:()=>ur.HerbertTokenizer,HubertForCTC:()=>Q.HubertForCTC,HubertForSequenceClassification:()=>Q.HubertForSequenceClassification,HubertModel:()=>Q.HubertModel,HubertPreTrainedModel:()=>Q.HubertPreTrainedModel,ImageClassificationPipeline:()=>en.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>en.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>or.ImageFeatureExtractor,ImageMattingOutput:()=>Q.ImageMattingOutput,ImageSegmentationPipeline:()=>en.ImageSegmentationPipeline,ImageToImagePipeline:()=>en.ImageToImagePipeline,ImageToTextPipeline:()=>en.ImageToTextPipeline,InterruptableStoppingCriteria:()=>Ff.InterruptableStoppingCriteria,JAISLMHeadModel:()=>Q.JAISLMHeadModel,JAISModel:()=>Q.JAISModel,JAISPreTrainedModel:()=>Q.JAISPreTrainedModel,LlamaForCausalLM:()=>Q.LlamaForCausalLM,LlamaModel:()=>Q.LlamaModel,LlamaPreTrainedModel:()=>Q.LlamaPreTrainedModel,LlamaTokenizer:()=>ur.LlamaTokenizer,LlavaForConditionalGeneration:()=>Q.LlavaForConditionalGeneration,LlavaPreTrainedModel:()=>Q.LlavaPreTrainedModel,LongT5ForConditionalGeneration:()=>Q.LongT5ForConditionalGeneration,LongT5Model:()=>Q.LongT5Model,LongT5PreTrainedModel:()=>Q.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>Q.M2M100ForConditionalGeneration,M2M100Model:()=>Q.M2M100Model,M2M100PreTrainedModel:()=>Q.M2M100PreTrainedModel,M2M100Tokenizer:()=>ur.M2M100Tokenizer,MBart50Tokenizer:()=>ur.MBart50Tokenizer,MBartForCausalLM:()=>Q.MBartForCausalLM,MBartForConditionalGeneration:()=>Q.MBartForConditionalGeneration,MBartForSequenceClassification:()=>Q.MBartForSequenceClassification,MBartModel:()=>Q.MBartModel,MBartPreTrainedModel:()=>Q.MBartPreTrainedModel,MBartTokenizer:()=>ur.MBartTokenizer,MPNetForMaskedLM:()=>Q.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>Q.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>Q.MPNetForSequenceClassification,MPNetForTokenClassification:()=>Q.MPNetForTokenClassification,MPNetModel:()=>Q.MPNetModel,MPNetPreTrainedModel:()=>Q.MPNetPreTrainedModel,MPNetTokenizer:()=>ur.MPNetTokenizer,MT5ForConditionalGeneration:()=>Q.MT5ForConditionalGeneration,MT5Model:()=>Q.MT5Model,MT5PreTrainedModel:()=>Q.MT5PreTrainedModel,MarianMTModel:()=>Q.MarianMTModel,MarianModel:()=>Q.MarianModel,MarianPreTrainedModel:()=>Q.MarianPreTrainedModel,MarianTokenizer:()=>ur.MarianTokenizer,MaskedLMOutput:()=>Q.MaskedLMOutput,MaxLengthCriteria:()=>Ff.MaxLengthCriteria,MistralForCausalLM:()=>Q.MistralForCausalLM,MistralModel:()=>Q.MistralModel,MistralPreTrainedModel:()=>Q.MistralPreTrainedModel,MobileBertForMaskedLM:()=>Q.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>Q.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>Q.MobileBertForSequenceClassification,MobileBertModel:()=>Q.MobileBertModel,MobileBertPreTrainedModel:()=>Q.MobileBertPreTrainedModel,MobileBertTokenizer:()=>ur.MobileBertTokenizer,MobileNetV1FeatureExtractor:()=>or.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>Q.MobileNetV1ForImageClassification,MobileNetV1Model:()=>Q.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>Q.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>or.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>Q.MobileNetV2ForImageClassification,MobileNetV2Model:()=>Q.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>Q.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>or.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>Q.MobileNetV3ForImageClassification,MobileNetV3Model:()=>Q.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>Q.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>or.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>Q.MobileNetV4ForImageClassification,MobileNetV4Model:()=>Q.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>Q.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>or.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>Q.MobileViTForImageClassification,MobileViTImageProcessor:()=>or.MobileViTImageProcessor,MobileViTModel:()=>Q.MobileViTModel,MobileViTPreTrainedModel:()=>Q.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>Q.MobileViTV2ForImageClassification,MobileViTV2Model:()=>Q.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>Q.MobileViTV2PreTrainedModel,ModelOutput:()=>Q.ModelOutput,Moondream1ForConditionalGeneration:()=>Q.Moondream1ForConditionalGeneration,MptForCausalLM:()=>Q.MptForCausalLM,MptModel:()=>Q.MptModel,MptPreTrainedModel:()=>Q.MptPreTrainedModel,MusicgenForCausalLM:()=>Q.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>Q.MusicgenForConditionalGeneration,MusicgenModel:()=>Q.MusicgenModel,MusicgenPreTrainedModel:()=>Q.MusicgenPreTrainedModel,NllbTokenizer:()=>ur.NllbTokenizer,NomicBertModel:()=>Q.NomicBertModel,NomicBertPreTrainedModel:()=>Q.NomicBertPreTrainedModel,NougatImageProcessor:()=>or.NougatImageProcessor,NougatTokenizer:()=>ur.NougatTokenizer,OPTForCausalLM:()=>Q.OPTForCausalLM,OPTModel:()=>Q.OPTModel,OPTPreTrainedModel:()=>Q.OPTPreTrainedModel,ObjectDetectionPipeline:()=>en.ObjectDetectionPipeline,OpenELMForCausalLM:()=>Q.OpenELMForCausalLM,OpenELMModel:()=>Q.OpenELMModel,OpenELMPreTrainedModel:()=>Q.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>or.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>Q.OwlViTForObjectDetection,OwlViTModel:()=>Q.OwlViTModel,OwlViTPreTrainedModel:()=>Q.OwlViTPreTrainedModel,OwlViTProcessor:()=>or.OwlViTProcessor,Owlv2ForObjectDetection:()=>Q.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>or.Owlv2ImageProcessor,Owlv2Model:()=>Q.Owlv2Model,Owlv2PreTrainedModel:()=>Q.Owlv2PreTrainedModel,Phi3ForCausalLM:()=>Q.Phi3ForCausalLM,Phi3Model:()=>Q.Phi3Model,Phi3PreTrainedModel:()=>Q.Phi3PreTrainedModel,PhiForCausalLM:()=>Q.PhiForCausalLM,PhiModel:()=>Q.PhiModel,PhiPreTrainedModel:()=>Q.PhiPreTrainedModel,Pipeline:()=>en.Pipeline,PreTrainedModel:()=>Q.PreTrainedModel,PreTrainedTokenizer:()=>ur.PreTrainedTokenizer,PretrainedConfig:()=>Gg.PretrainedConfig,PretrainedMixin:()=>Q.PretrainedMixin,Processor:()=>or.Processor,PyAnnoteFeatureExtractor:()=>or.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>Q.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>Q.PyAnnoteModel,PyAnnotePreTrainedModel:()=>Q.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>or.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>Q.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>en.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>Q.Qwen2ForCausalLM,Qwen2Model:()=>Q.Qwen2Model,Qwen2PreTrainedModel:()=>Q.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>ur.Qwen2Tokenizer,RTDetrForObjectDetection:()=>Q.RTDetrForObjectDetection,RTDetrImageProcessor:()=>or.RTDetrImageProcessor,RTDetrModel:()=>Q.RTDetrModel,RTDetrObjectDetectionOutput:()=>Q.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>Q.RTDetrPreTrainedModel,RawImage:()=>VE.RawImage,ResNetForImageClassification:()=>Q.ResNetForImageClassification,ResNetModel:()=>Q.ResNetModel,ResNetPreTrainedModel:()=>Q.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>Q.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>Q.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>Q.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>Q.RoFormerForTokenClassification,RoFormerModel:()=>Q.RoFormerModel,RoFormerPreTrainedModel:()=>Q.RoFormerPreTrainedModel,RoFormerTokenizer:()=>ur.RoFormerTokenizer,RobertaForMaskedLM:()=>Q.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>Q.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>Q.RobertaForSequenceClassification,RobertaForTokenClassification:()=>Q.RobertaForTokenClassification,RobertaModel:()=>Q.RobertaModel,RobertaPreTrainedModel:()=>Q.RobertaPreTrainedModel,RobertaTokenizer:()=>ur.RobertaTokenizer,SamImageProcessor:()=>or.SamImageProcessor,SamImageSegmentationOutput:()=>Q.SamImageSegmentationOutput,SamModel:()=>Q.SamModel,SamPreTrainedModel:()=>Q.SamPreTrainedModel,SamProcessor:()=>or.SamProcessor,SapiensFeatureExtractor:()=>or.SapiensFeatureExtractor,SapiensForDepthEstimation:()=>Q.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>Q.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>Q.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>Q.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>or.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>or.SegformerFeatureExtractor,SegformerForImageClassification:()=>Q.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>Q.SegformerForSemanticSegmentation,SegformerModel:()=>Q.SegformerModel,SegformerPreTrainedModel:()=>Q.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>Q.Seq2SeqLMOutput,SequenceClassifierOutput:()=>Q.SequenceClassifierOutput,SiglipImageProcessor:()=>or.SiglipImageProcessor,SiglipModel:()=>Q.SiglipModel,SiglipPreTrainedModel:()=>Q.SiglipPreTrainedModel,SiglipTextModel:()=>Q.SiglipTextModel,SiglipTokenizer:()=>ur.SiglipTokenizer,SiglipVisionModel:()=>Q.SiglipVisionModel,SpeechT5FeatureExtractor:()=>or.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>Q.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>Q.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>Q.SpeechT5HifiGan,SpeechT5Model:()=>Q.SpeechT5Model,SpeechT5PreTrainedModel:()=>Q.SpeechT5PreTrainedModel,SpeechT5Processor:()=>or.SpeechT5Processor,SpeechT5Tokenizer:()=>ur.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>Q.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>Q.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>Q.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>Q.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>Q.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>ur.SqueezeBertTokenizer,StableLmForCausalLM:()=>Q.StableLmForCausalLM,StableLmModel:()=>Q.StableLmModel,StableLmPreTrainedModel:()=>Q.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>Q.Starcoder2ForCausalLM,Starcoder2Model:()=>Q.Starcoder2Model,Starcoder2PreTrainedModel:()=>Q.Starcoder2PreTrainedModel,StoppingCriteria:()=>Ff.StoppingCriteria,StoppingCriteriaList:()=>Ff.StoppingCriteriaList,SummarizationPipeline:()=>en.SummarizationPipeline,Swin2SRForImageSuperResolution:()=>Q.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>or.Swin2SRImageProcessor,Swin2SRModel:()=>Q.Swin2SRModel,Swin2SRPreTrainedModel:()=>Q.Swin2SRPreTrainedModel,SwinForImageClassification:()=>Q.SwinForImageClassification,SwinModel:()=>Q.SwinModel,SwinPreTrainedModel:()=>Q.SwinPreTrainedModel,T5ForConditionalGeneration:()=>Q.T5ForConditionalGeneration,T5Model:()=>Q.T5Model,T5PreTrainedModel:()=>Q.T5PreTrainedModel,T5Tokenizer:()=>ur.T5Tokenizer,TableTransformerForObjectDetection:()=>Q.TableTransformerForObjectDetection,TableTransformerModel:()=>Q.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>Q.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>Q.TableTransformerPreTrainedModel,Tensor:()=>xn.Tensor,Text2TextGenerationPipeline:()=>en.Text2TextGenerationPipeline,TextClassificationPipeline:()=>en.TextClassificationPipeline,TextGenerationPipeline:()=>en.TextGenerationPipeline,TextStreamer:()=>Hg.TextStreamer,TextToAudioPipeline:()=>en.TextToAudioPipeline,TokenClassificationPipeline:()=>en.TokenClassificationPipeline,TokenClassifierOutput:()=>Q.TokenClassifierOutput,TokenizerModel:()=>ur.TokenizerModel,TrOCRForCausalLM:()=>Q.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>Q.TrOCRPreTrainedModel,TranslationPipeline:()=>en.TranslationPipeline,UniSpeechForCTC:()=>Q.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>Q.UniSpeechForSequenceClassification,UniSpeechModel:()=>Q.UniSpeechModel,UniSpeechPreTrainedModel:()=>Q.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>Q.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>Q.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>Q.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>Q.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>Q.UniSpeechSatPreTrainedModel,ViTFeatureExtractor:()=>or.ViTFeatureExtractor,ViTForImageClassification:()=>Q.ViTForImageClassification,ViTImageProcessor:()=>or.ViTImageProcessor,ViTModel:()=>Q.ViTModel,ViTPreTrainedModel:()=>Q.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>Q.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>Q.VitMatteForImageMatting,VitMatteImageProcessor:()=>or.VitMatteImageProcessor,VitMattePreTrainedModel:()=>Q.VitMattePreTrainedModel,VitsModel:()=>Q.VitsModel,VitsModelOutput:()=>Q.VitsModelOutput,VitsPreTrainedModel:()=>Q.VitsPreTrainedModel,VitsTokenizer:()=>ur.VitsTokenizer,Wav2Vec2BertForCTC:()=>Q.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>Q.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>Q.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>Q.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>ur.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>or.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>Q.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>Q.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>Q.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>Q.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>Q.Wav2Vec2PreTrainedModel,Wav2Vec2ProcessorWithLM:()=>or.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>Q.WavLMForAudioFrameClassification,WavLMForCTC:()=>Q.WavLMForCTC,WavLMForSequenceClassification:()=>Q.WavLMForSequenceClassification,WavLMForXVector:()=>Q.WavLMForXVector,WavLMModel:()=>Q.WavLMModel,WavLMPreTrainedModel:()=>Q.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>or.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>Q.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>Q.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>or.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>Q.WhisperForConditionalGeneration,WhisperModel:()=>Q.WhisperModel,WhisperPreTrainedModel:()=>Q.WhisperPreTrainedModel,WhisperProcessor:()=>or.WhisperProcessor,WhisperTextStreamer:()=>Hg.WhisperTextStreamer,WhisperTokenizer:()=>ur.WhisperTokenizer,XLMForQuestionAnswering:()=>Q.XLMForQuestionAnswering,XLMForSequenceClassification:()=>Q.XLMForSequenceClassification,XLMForTokenClassification:()=>Q.XLMForTokenClassification,XLMModel:()=>Q.XLMModel,XLMPreTrainedModel:()=>Q.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>Q.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>Q.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>Q.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>Q.XLMRobertaForTokenClassification,XLMRobertaModel:()=>Q.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>Q.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>ur.XLMRobertaTokenizer,XLMTokenizer:()=>ur.XLMTokenizer,XLMWithLMHeadModel:()=>Q.XLMWithLMHeadModel,XVectorOutput:()=>Q.XVectorOutput,YolosFeatureExtractor:()=>or.YolosFeatureExtractor,YolosForObjectDetection:()=>Q.YolosForObjectDetection,YolosModel:()=>Q.YolosModel,YolosObjectDetectionOutput:()=>Q.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>Q.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>en.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>en.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>en.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>en.ZeroShotObjectDetectionPipeline,bankers_round:()=>fi.bankers_round,cat:()=>xn.cat,cos_sim:()=>fi.cos_sim,dot:()=>fi.dot,dynamic_time_warping:()=>fi.dynamic_time_warping,env:()=>UE.env,full:()=>xn.full,full_like:()=>xn.full_like,getKeyValueShapes:()=>Gg.getKeyValueShapes,hamming:()=>Hl.hamming,hanning:()=>Hl.hanning,interpolate:()=>xn.interpolate,interpolate_4d:()=>xn.interpolate_4d,interpolate_data:()=>fi.interpolate_data,is_chinese_char:()=>ur.is_chinese_char,layer_norm:()=>xn.layer_norm,log_softmax:()=>fi.log_softmax,magnitude:()=>fi.magnitude,matmul:()=>xn.matmul,max:()=>fi.max,mean:()=>xn.mean,mean_pooling:()=>xn.mean_pooling,medianFilter:()=>fi.medianFilter,mel_filter_bank:()=>Hl.mel_filter_bank,min:()=>fi.min,ones:()=>xn.ones,ones_like:()=>xn.ones_like,permute:()=>xn.permute,permute_data:()=>fi.permute_data,pipeline:()=>en.pipeline,quantize_embeddings:()=>xn.quantize_embeddings,read_audio:()=>Hl.read_audio,rfft:()=>xn.rfft,round:()=>fi.round,softmax:()=>fi.softmax,spectrogram:()=>Hl.spectrogram,stack:()=>xn.stack,std_mean:()=>xn.std_mean,topk:()=>xn.topk,window_function:()=>Hl.window_function,zeros:()=>xn.zeros,zeros_like:()=>xn.zeros_like});var UE=rn("./src/env.js"),en=rn("./src/pipelines.js"),Q=rn("./src/models.js"),ur=rn("./src/tokenizers.js"),or=rn("./src/processors.js"),Gg=rn("./src/configs.js"),Hl=rn("./src/utils/audio.js"),VE=rn("./src/utils/image.js"),xn=rn("./src/utils/tensor.js"),fi=rn("./src/utils/maths.js"),Hg=rn("./src/generation/streamers.js"),Ff=rn("./src/generation/stopping_criteria.js");P.ASTFeatureExtractor;P.ASTForAudioClassification;P.ASTModel;P.ASTPreTrainedModel;P.AlbertForMaskedLM;P.AlbertForQuestionAnswering;P.AlbertForSequenceClassification;P.AlbertModel;P.AlbertPreTrainedModel;P.AlbertTokenizer;P.AudioClassificationPipeline;P.AutoConfig;var WE=P.AutoModel;P.AutoModelForAudioClassification;P.AutoModelForAudioFrameClassification;P.AutoModelForCTC;P.AutoModelForCausalLM;P.AutoModelForDepthEstimation;P.AutoModelForDocumentQuestionAnswering;P.AutoModelForImageClassification;P.AutoModelForImageFeatureExtraction;P.AutoModelForImageMatting;P.AutoModelForImageSegmentation;P.AutoModelForImageToImage;P.AutoModelForMaskGeneration;P.AutoModelForMaskedLM;P.AutoModelForNormalEstimation;P.AutoModelForObjectDetection;P.AutoModelForQuestionAnswering;P.AutoModelForSemanticSegmentation;P.AutoModelForSeq2SeqLM;P.AutoModelForSequenceClassification;P.AutoModelForSpeechSeq2Seq;P.AutoModelForTextToSpectrogram;P.AutoModelForTextToWaveform;P.AutoModelForTokenClassification;P.AutoModelForVision2Seq;P.AutoModelForXVector;P.AutoModelForZeroShotObjectDetection;var GE=P.AutoProcessor;P.AutoTokenizer;P.AutomaticSpeechRecognitionPipeline;P.BartForConditionalGeneration;P.BartForSequenceClassification;P.BartModel;P.BartPretrainedModel;P.BartTokenizer;P.BaseModelOutput;P.BaseStreamer;P.BeitFeatureExtractor;P.BeitForImageClassification;P.BeitModel;P.BeitPreTrainedModel;P.BertForMaskedLM;P.BertForQuestionAnswering;P.BertForSequenceClassification;P.BertForTokenClassification;P.BertModel;P.BertPreTrainedModel;P.BertTokenizer;P.BitImageProcessor;P.BlenderbotForConditionalGeneration;P.BlenderbotModel;P.BlenderbotPreTrainedModel;P.BlenderbotSmallForConditionalGeneration;P.BlenderbotSmallModel;P.BlenderbotSmallPreTrainedModel;P.BlenderbotSmallTokenizer;P.BlenderbotTokenizer;P.BloomForCausalLM;P.BloomModel;P.BloomPreTrainedModel;P.BloomTokenizer;P.CLIPFeatureExtractor;P.CLIPImageProcessor;P.CLIPModel;P.CLIPPreTrainedModel;P.CLIPSegForImageSegmentation;P.CLIPSegModel;P.CLIPSegPreTrainedModel;P.CLIPTextModelWithProjection;P.CLIPTokenizer;P.CLIPVisionModelWithProjection;P.CamembertForMaskedLM;P.CamembertForQuestionAnswering;P.CamembertForSequenceClassification;P.CamembertForTokenClassification;P.CamembertModel;P.CamembertPreTrainedModel;P.CamembertTokenizer;P.CausalLMOutput;P.CausalLMOutputWithPast;P.ChineseCLIPFeatureExtractor;P.ChineseCLIPModel;P.ChineseCLIPPreTrainedModel;P.ClapAudioModelWithProjection;P.ClapFeatureExtractor;P.ClapModel;P.ClapPreTrainedModel;P.ClapTextModelWithProjection;P.CodeGenForCausalLM;P.CodeGenModel;P.CodeGenPreTrainedModel;P.CodeGenTokenizer;P.CodeLlamaTokenizer;P.CohereForCausalLM;P.CohereModel;P.CoherePreTrainedModel;P.CohereTokenizer;P.ConvBertForMaskedLM;P.ConvBertForQuestionAnswering;P.ConvBertForSequenceClassification;P.ConvBertForTokenClassification;P.ConvBertModel;P.ConvBertPreTrainedModel;P.ConvBertTokenizer;P.ConvNextFeatureExtractor;P.ConvNextForImageClassification;P.ConvNextImageProcessor;P.ConvNextModel;P.ConvNextPreTrainedModel;P.ConvNextV2ForImageClassification;P.ConvNextV2Model;P.ConvNextV2PreTrainedModel;P.DPTFeatureExtractor;P.DPTForDepthEstimation;P.DPTImageProcessor;P.DPTModel;P.DPTPreTrainedModel;P.DebertaForMaskedLM;P.DebertaForQuestionAnswering;P.DebertaForSequenceClassification;P.DebertaForTokenClassification;P.DebertaModel;P.DebertaPreTrainedModel;P.DebertaTokenizer;P.DebertaV2ForMaskedLM;P.DebertaV2ForQuestionAnswering;P.DebertaV2ForSequenceClassification;P.DebertaV2ForTokenClassification;P.DebertaV2Model;P.DebertaV2PreTrainedModel;P.DebertaV2Tokenizer;P.DeiTFeatureExtractor;P.DeiTForImageClassification;P.DeiTModel;P.DeiTPreTrainedModel;P.DepthAnythingForDepthEstimation;P.DepthAnythingPreTrainedModel;P.DepthEstimationPipeline;P.DetrFeatureExtractor;P.DetrForObjectDetection;P.DetrForSegmentation;P.DetrModel;P.DetrObjectDetectionOutput;P.DetrPreTrainedModel;P.DetrSegmentationOutput;P.Dinov2ForImageClassification;P.Dinov2Model;P.Dinov2PreTrainedModel;P.DistilBertForMaskedLM;P.DistilBertForQuestionAnswering;P.DistilBertForSequenceClassification;P.DistilBertForTokenClassification;P.DistilBertModel;P.DistilBertPreTrainedModel;P.DistilBertTokenizer;P.DocumentQuestionAnsweringPipeline;P.DonutFeatureExtractor;P.DonutSwinModel;P.DonutSwinPreTrainedModel;P.EfficientNetForImageClassification;P.EfficientNetImageProcessor;P.EfficientNetModel;P.EfficientNetPreTrainedModel;P.ElectraForMaskedLM;P.ElectraForQuestionAnswering;P.ElectraForSequenceClassification;P.ElectraForTokenClassification;P.ElectraModel;P.ElectraPreTrainedModel;P.ElectraTokenizer;P.EosTokenCriteria;P.EsmForMaskedLM;P.EsmForSequenceClassification;P.EsmForTokenClassification;P.EsmModel;P.EsmPreTrainedModel;P.EsmTokenizer;P.FFT;P.FalconForCausalLM;P.FalconModel;P.FalconPreTrainedModel;P.FalconTokenizer;P.FastViTForImageClassification;P.FastViTModel;P.FastViTPreTrainedModel;P.FeatureExtractionPipeline;P.FeatureExtractor;P.FillMaskPipeline;P.Florence2ForConditionalGeneration;P.Florence2PreTrainedModel;P.Florence2Processor;P.GLPNFeatureExtractor;P.GLPNForDepthEstimation;P.GLPNModel;P.GLPNPreTrainedModel;P.GPT2LMHeadModel;P.GPT2Model;P.GPT2PreTrainedModel;P.GPT2Tokenizer;P.GPTBigCodeForCausalLM;P.GPTBigCodeModel;P.GPTBigCodePreTrainedModel;P.GPTJForCausalLM;P.GPTJModel;P.GPTJPreTrainedModel;P.GPTNeoForCausalLM;P.GPTNeoModel;P.GPTNeoPreTrainedModel;P.GPTNeoXForCausalLM;P.GPTNeoXModel;P.GPTNeoXPreTrainedModel;P.GPTNeoXTokenizer;P.Gemma2ForCausalLM;P.Gemma2Model;P.Gemma2PreTrainedModel;P.GemmaForCausalLM;P.GemmaModel;P.GemmaPreTrainedModel;P.GemmaTokenizer;P.Grok1Tokenizer;P.HerbertTokenizer;P.HubertForCTC;P.HubertForSequenceClassification;P.HubertModel;P.HubertPreTrainedModel;P.ImageClassificationPipeline;P.ImageFeatureExtractionPipeline;P.ImageFeatureExtractor;P.ImageMattingOutput;P.ImageSegmentationPipeline;P.ImageToImagePipeline;P.ImageToTextPipeline;P.InterruptableStoppingCriteria;P.JAISLMHeadModel;P.JAISModel;P.JAISPreTrainedModel;P.LlamaForCausalLM;P.LlamaModel;P.LlamaPreTrainedModel;P.LlamaTokenizer;P.LlavaForConditionalGeneration;P.LlavaPreTrainedModel;P.LongT5ForConditionalGeneration;P.LongT5Model;P.LongT5PreTrainedModel;P.M2M100ForConditionalGeneration;P.M2M100Model;P.M2M100PreTrainedModel;P.M2M100Tokenizer;P.MBart50Tokenizer;P.MBartForCausalLM;P.MBartForConditionalGeneration;P.MBartForSequenceClassification;P.MBartModel;P.MBartPreTrainedModel;P.MBartTokenizer;P.MPNetForMaskedLM;P.MPNetForQuestionAnswering;P.MPNetForSequenceClassification;P.MPNetForTokenClassification;P.MPNetModel;P.MPNetPreTrainedModel;P.MPNetTokenizer;P.MT5ForConditionalGeneration;P.MT5Model;P.MT5PreTrainedModel;P.MarianMTModel;P.MarianModel;P.MarianPreTrainedModel;P.MarianTokenizer;P.MaskedLMOutput;P.MaxLengthCriteria;P.MistralForCausalLM;P.MistralModel;P.MistralPreTrainedModel;P.MobileBertForMaskedLM;P.MobileBertForQuestionAnswering;P.MobileBertForSequenceClassification;P.MobileBertModel;P.MobileBertPreTrainedModel;P.MobileBertTokenizer;P.MobileNetV1FeatureExtractor;P.MobileNetV1ForImageClassification;P.MobileNetV1Model;P.MobileNetV1PreTrainedModel;P.MobileNetV2FeatureExtractor;P.MobileNetV2ForImageClassification;P.MobileNetV2Model;P.MobileNetV2PreTrainedModel;P.MobileNetV3FeatureExtractor;P.MobileNetV3ForImageClassification;P.MobileNetV3Model;P.MobileNetV3PreTrainedModel;P.MobileNetV4FeatureExtractor;P.MobileNetV4ForImageClassification;P.MobileNetV4Model;P.MobileNetV4PreTrainedModel;P.MobileViTFeatureExtractor;P.MobileViTForImageClassification;P.MobileViTImageProcessor;P.MobileViTModel;P.MobileViTPreTrainedModel;P.MobileViTV2ForImageClassification;P.MobileViTV2Model;P.MobileViTV2PreTrainedModel;P.ModelOutput;P.Moondream1ForConditionalGeneration;P.MptForCausalLM;P.MptModel;P.MptPreTrainedModel;P.MusicgenForCausalLM;P.MusicgenForConditionalGeneration;P.MusicgenModel;P.MusicgenPreTrainedModel;P.NllbTokenizer;P.NomicBertModel;P.NomicBertPreTrainedModel;P.NougatImageProcessor;P.NougatTokenizer;P.OPTForCausalLM;P.OPTModel;P.OPTPreTrainedModel;P.ObjectDetectionPipeline;P.OpenELMForCausalLM;P.OpenELMModel;P.OpenELMPreTrainedModel;P.OwlViTFeatureExtractor;P.OwlViTForObjectDetection;P.OwlViTModel;P.OwlViTPreTrainedModel;P.OwlViTProcessor;P.Owlv2ForObjectDetection;P.Owlv2ImageProcessor;P.Owlv2Model;P.Owlv2PreTrainedModel;P.Phi3ForCausalLM;P.Phi3Model;P.Phi3PreTrainedModel;P.PhiForCausalLM;P.PhiModel;P.PhiPreTrainedModel;P.Pipeline;P.PreTrainedModel;P.PreTrainedTokenizer;P.PretrainedConfig;P.PretrainedMixin;P.Processor;P.PyAnnoteFeatureExtractor;P.PyAnnoteForAudioFrameClassification;P.PyAnnoteModel;P.PyAnnotePreTrainedModel;P.PyAnnoteProcessor;P.QuestionAnsweringModelOutput;P.QuestionAnsweringPipeline;P.Qwen2ForCausalLM;P.Qwen2Model;P.Qwen2PreTrainedModel;P.Qwen2Tokenizer;P.RTDetrForObjectDetection;P.RTDetrImageProcessor;P.RTDetrModel;P.RTDetrObjectDetectionOutput;P.RTDetrPreTrainedModel;var Vv=P.RawImage;P.ResNetForImageClassification;P.ResNetModel;P.ResNetPreTrainedModel;P.RoFormerForMaskedLM;P.RoFormerForQuestionAnswering;P.RoFormerForSequenceClassification;P.RoFormerForTokenClassification;P.RoFormerModel;P.RoFormerPreTrainedModel;P.RoFormerTokenizer;P.RobertaForMaskedLM;P.RobertaForQuestionAnswering;P.RobertaForSequenceClassification;P.RobertaForTokenClassification;P.RobertaModel;P.RobertaPreTrainedModel;P.RobertaTokenizer;P.SamImageProcessor;P.SamImageSegmentationOutput;P.SamModel;P.SamPreTrainedModel;P.SamProcessor;P.SapiensFeatureExtractor;P.SapiensForDepthEstimation;P.SapiensForNormalEstimation;P.SapiensForSemanticSegmentation;P.SapiensPreTrainedModel;P.SeamlessM4TFeatureExtractor;P.SegformerFeatureExtractor;P.SegformerForImageClassification;P.SegformerForSemanticSegmentation;P.SegformerModel;P.SegformerPreTrainedModel;P.Seq2SeqLMOutput;P.SequenceClassifierOutput;P.SiglipImageProcessor;P.SiglipModel;P.SiglipPreTrainedModel;P.SiglipTextModel;P.SiglipTokenizer;P.SiglipVisionModel;P.SpeechT5FeatureExtractor;P.SpeechT5ForSpeechToText;P.SpeechT5ForTextToSpeech;P.SpeechT5HifiGan;P.SpeechT5Model;P.SpeechT5PreTrainedModel;P.SpeechT5Processor;P.SpeechT5Tokenizer;P.SqueezeBertForMaskedLM;P.SqueezeBertForQuestionAnswering;P.SqueezeBertForSequenceClassification;P.SqueezeBertModel;P.SqueezeBertPreTrainedModel;P.SqueezeBertTokenizer;P.StableLmForCausalLM;P.StableLmModel;P.StableLmPreTrainedModel;P.Starcoder2ForCausalLM;P.Starcoder2Model;P.Starcoder2PreTrainedModel;P.StoppingCriteria;P.StoppingCriteriaList;P.SummarizationPipeline;P.Swin2SRForImageSuperResolution;P.Swin2SRImageProcessor;P.Swin2SRModel;P.Swin2SRPreTrainedModel;P.SwinForImageClassification;P.SwinModel;P.SwinPreTrainedModel;P.T5ForConditionalGeneration;P.T5Model;P.T5PreTrainedModel;P.T5Tokenizer;P.TableTransformerForObjectDetection;P.TableTransformerModel;P.TableTransformerObjectDetectionOutput;P.TableTransformerPreTrainedModel;P.Tensor;P.Text2TextGenerationPipeline;P.TextClassificationPipeline;P.TextGenerationPipeline;P.TextStreamer;P.TextToAudioPipeline;P.TokenClassificationPipeline;P.TokenClassifierOutput;P.TokenizerModel;P.TrOCRForCausalLM;P.TrOCRPreTrainedModel;P.TranslationPipeline;P.UniSpeechForCTC;P.UniSpeechForSequenceClassification;P.UniSpeechModel;P.UniSpeechPreTrainedModel;P.UniSpeechSatForAudioFrameClassification;P.UniSpeechSatForCTC;P.UniSpeechSatForSequenceClassification;P.UniSpeechSatModel;P.UniSpeechSatPreTrainedModel;P.ViTFeatureExtractor;P.ViTForImageClassification;P.ViTImageProcessor;P.ViTModel;P.ViTPreTrainedModel;P.VisionEncoderDecoderModel;P.VitMatteForImageMatting;P.VitMatteImageProcessor;P.VitMattePreTrainedModel;P.VitsModel;P.VitsModelOutput;P.VitsPreTrainedModel;P.VitsTokenizer;P.Wav2Vec2BertForCTC;P.Wav2Vec2BertForSequenceClassification;P.Wav2Vec2BertModel;P.Wav2Vec2BertPreTrainedModel;P.Wav2Vec2CTCTokenizer;P.Wav2Vec2FeatureExtractor;P.Wav2Vec2ForAudioFrameClassification;P.Wav2Vec2ForCTC;P.Wav2Vec2ForSequenceClassification;P.Wav2Vec2Model;P.Wav2Vec2PreTrainedModel;P.Wav2Vec2ProcessorWithLM;P.WavLMForAudioFrameClassification;P.WavLMForCTC;P.WavLMForSequenceClassification;P.WavLMForXVector;P.WavLMModel;P.WavLMPreTrainedModel;P.WeSpeakerFeatureExtractor;P.WeSpeakerResNetModel;P.WeSpeakerResNetPreTrainedModel;P.WhisperFeatureExtractor;P.WhisperForConditionalGeneration;P.WhisperModel;P.WhisperPreTrainedModel;P.WhisperProcessor;P.WhisperTextStreamer;P.WhisperTokenizer;P.XLMForQuestionAnswering;P.XLMForSequenceClassification;P.XLMForTokenClassification;P.XLMModel;P.XLMPreTrainedModel;P.XLMRobertaForMaskedLM;P.XLMRobertaForQuestionAnswering;P.XLMRobertaForSequenceClassification;P.XLMRobertaForTokenClassification;P.XLMRobertaModel;P.XLMRobertaPreTrainedModel;P.XLMRobertaTokenizer;P.XLMTokenizer;P.XLMWithLMHeadModel;P.XVectorOutput;P.YolosFeatureExtractor;P.YolosForObjectDetection;P.YolosModel;P.YolosObjectDetectionOutput;P.YolosPreTrainedModel;P.ZeroShotAudioClassificationPipeline;P.ZeroShotClassificationPipeline;P.ZeroShotImageClassificationPipeline;P.ZeroShotObjectDetectionPipeline;P.bankers_round;P.cat;P.cos_sim;P.dot;P.dynamic_time_warping;var HE=P.env;P.full;P.full_like;P.getKeyValueShapes;P.hamming;P.hanning;P.interpolate;P.interpolate_4d;P.interpolate_data;P.is_chinese_char;P.layer_norm;P.log_softmax;P.magnitude;P.matmul;P.max;P.mean;P.mean_pooling;P.medianFilter;P.mel_filter_bank;P.min;P.ones;P.ones_like;P.permute;P.permute_data;P.pipeline;P.quantize_embeddings;P.read_audio;P.rfft;P.round;P.softmax;P.spectrogram;P.stack;P.std_mean;P.topk;P.window_function;P.zeros;P.zeros_like;const qE=async({images:e,setProcessedImages:t,modelRef:n,processorRef:o})=>{try{const a=n.current,l=o.current;for(let f=0;f<e.length;++f){const _=await Vv.fromURL(e[f]),{pixel_values:m}=await l(_),{output:g}=await a({input:m}),M=(await Vv.fromTensor(g[0].mul(255).to("uint8")).resize(_.width,_.height)).data,v=document.createElement("canvas");v.width=_.width,v.height=_.height;const C=v.getContext("2d");C.drawImage(_.toCanvas(),0,0);const k=C.getImageData(0,0,_.width,_.height);for(let z=0;z<M.length;++z)k.data[4*z+3]=M[z];C.putImageData(k,0,0),t(z=>[...z,v.toDataURL("image/png")])}}catch(a){console.log("Error processing images:",a)}},KE=async({modelRef:e,processorRef:t})=>{try{const n="Xenova/modnet";HE.backends.onnx.wasm.proxy=!1,e.current??(e.current=await WE.from_pretrained(n,{device:"webgpu"})),t.current??(t.current=await GE.from_pretrained(n))}catch(n){console.error("Failed to initialize model or processor:",n),n instanceof DOMException&&n.name==="AbortError"&&console.error("GPU context may be lost or buffer is invalid.")}},QE="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%20190%20190'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%3e%3clinearGradient%20id='d'%20x1='28.3'%20x2='80.8'%20y1='75'%20y2='44.4'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0'%20stop-color='%23a52714'%20stop-opacity='.6'/%3e%3cstop%20offset='.7'%20stop-color='%23a52714'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='f'%20x1='109.9'%20x2='51.5'%20y1='164.5'%20y2='130.3'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0'%20stop-color='%23055524'%20stop-opacity='.4'/%3e%3cstop%20offset='.3'%20stop-color='%23055524'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='h'%20x1='121.9'%20x2='136.6'%20y1='49.8'%20y2='114.1'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0'%20stop-color='%23ea6100'%20stop-opacity='.3'/%3e%3cstop%20offset='.7'%20stop-color='%23ea6100'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3cradialGradient%20id='a'%20cx='91.2'%20cy='55'%20r='84.1'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0'%20stop-color='%233e2723'%20stop-opacity='.2'/%3e%3cstop%20offset='1'%20stop-color='%233e2723'%20stop-opacity='0'/%3e%3c/radialGradient%3e%3cradialGradient%20id='i'%20cx='20.9'%20cy='47.5'%20r='78'%20xlink:href='%23a'/%3e%3cradialGradient%20id='j'%20cx='94.8'%20cy='95.1'%20r='87.9'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0'%20stop-color='%23263238'%20stop-opacity='.2'/%3e%3cstop%20offset='1'%20stop-color='%23263238'%20stop-opacity='0'/%3e%3c/radialGradient%3e%3cradialGradient%20id='k'%20cx='33.3'%20cy='31'%20r='176.8'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0'%20stop-color='%23ffffff'%20stop-opacity='.1'/%3e%3cstop%20offset='1'%20stop-color='%23ffffff'%20stop-opacity='0'/%3e%3c/radialGradient%3e%3cclipPath%20id='b'%3e%3ccircle%20cx='95'%20cy='95'%20r='88'/%3e%3c/clipPath%3e%3cg%20clip-path='url(%23b)'%3e%3cuse%20fill='%23db4437'%20xlink:href='%23c'/%3e%3cuse%20fill='url(%23d)'%20xlink:href='%23c'/%3e%3cuse%20fill='%230f9d58'%20xlink:href='%23e'/%3e%3cuse%20fill='url(%23f)'%20xlink:href='%23e'/%3e%3cuse%20fill='%23ffcd40'%20xlink:href='%23g'/%3e%3cuse%20fill='url(%23h)'%20xlink:href='%23g'/%3e%3cg%20fill-opacity='.1'%3e%3cpath%20fill='%233e2723'%20d='M61.3%20114.7L21%2047.4l39%2067.8z'/%3e%3cpath%20fill='%23263238'%20d='M128.8%20116.3l-.8-.4-37.3%2067%2038.3-67z'/%3e%3c/g%3e%3cpath%20id='e'%20d='M7%20183h83.8l39-39v-29H60.2L7%2023.5z'/%3e%3cpath%20id='g'%20d='M95%2055l34.6%2060L91%20183h92V55z'/%3e%3cpath%20id='c'%20d='M21%207v108h39.4L95%2055h88V7z'/%3e%3cpath%20fill='url(%23a)'%20d='M95%2055v21l78.4-21z'/%3e%3cpath%20fill='url(%23i)'%20d='M21%2047.5l57.2%2057.2L60.4%20115z'/%3e%3cpath%20fill='url(%23j)'%20d='M90.8%20183l21-78.3%2017.8%2010.3z'/%3e%3ccircle%20cx='95'%20cy='95'%20r='40'%20fill='%23f1f1f1'/%3e%3ccircle%20cx='95'%20cy='95'%20r='32'%20fill='%234285f4'/%3e%3ccircle%20cx='95'%20cy='95'%20r='88'%20fill='url(%23k)'/%3e%3cg%20fill='%233e2723'%20fill-opacity='.1'%3e%3cpath%20fill='%23ffffff'%20d='M129.6%20115a40%2040%200%2001-69.2%200L7%2024.5%2060.4%20116a40%2040%200%200069.2%200z'/%3e%3cpath%20d='M96%2055h-.5a40%2040%200%20110%2080h.5c22%200%2040-18%2040-40s-18-40-40-40zm-1%20127a88%2088%200%200088-87.5v.5A88%2088%200%20017%2095v-.5A88%2088%200%200095%20182z'/%3e%3cg%20fill-opacity='.2'%3e%3cpath%20fill='%23ffffff'%20d='M130%20116.3a39.3%2039.3%200%20003.4-32%2038%2038%200%2001-3.8%2030.7L92%20183l38.2-66.5zM95%208a88%2088%200%200188%2087.5V95A88%2088%200%20007%2095v.5A88%2088%200%200195%208z'/%3e%3cpath%20d='M95%2054c-22%200-40%2018-40%2040v1c0-22%2018-40%2040-40h88v-1z'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e",XE="/background-remover/assets/firefox-FC5QDl5e.svg",YE="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%205120%205120'%20xmlns='http://www.w3.org/2000/svg'%3e%3clinearGradient%20id='a'%20x2='0'%20y2='100%25'%3e%3cstop%20offset='0'%20stop-color='%2319d7ff'/%3e%3cstop%20offset='1'%20stop-color='%231e64f0'/%3e%3c/linearGradient%3e%3cg%20fill='%23ffffff'%3e%3crect%20width='5130'%20height='5120'%20rx='1050'/%3e%3ccircle%20cx='2560'%20cy='2560'%20r='2240'%20fill='url(%23a)'/%3e%3cpath%20fill='red'%20d='M4090%201020%202370%202370l4e2%204e2z'/%3e%3cpath%20d='M1020%204090l1350-1720%204e2%204e2z'/%3e%3c/g%3e%3cpath%20stroke='%23ffffff'%20stroke-width='30'%20d='M2560%20540v330m0%203370v330m350-4e3-57%20325m-586%203318-57%20327M3250%20662l-113%20310M1984%204138l-113%20310m339-3878%2057%20325m586%203318%2057%20327M1870%20662l113%20310m1152%203166%20113%20310M1552%20810l166%20286m1685%202918%20165%20286M1265%201010l212%20253m2166%202582%20212%20253M1015%201258l253%20212m2582%202168%20253%20212M813%201548l286%20165m2920%201685%20286%20165M665%201866l310%20113m3166%201150%20310%20113M574%202202l326%2058m3320%20588%20325%2057M545%202555h330m3370%200h330M575%202905l325-57m3320-586%20325-57M668%203245l310-113m3165-1152%20310-113M815%203563l286-165m2920-1685%20286-165M1016%203850l253-212m2580-2166%20253-212M1262%2041e2l212-253m2166-2582%20212-253M1552%2043e2l166-286m1685-2918%20165-286M2384%20548l16%20180m320%203656%2016%20180M2038%20610l47%20174m950%203544%2047%20174M1708%20730l76%20163m1550%203326%2077%20163M1404%20904l103%20148m2106%203006%20103%20148M1135%201130l127%20127m2596%202596%20127%20127M910%2014e2l148%20103m3006%202107%20146%201e2M734%201703l163%2076m3326%201550%20163%2077M614%202033l174%2047m3544%20950%20174%2047M553%202380l180%2016m3656%20320%20180%2016m-4014%200%20180-16m3656-320%20180-16M614%203077l174-47m3544-950%20174-47M734%203407l163-76m3326-1550%20163-76M910%203710l148-103m3006-2107%20146-1e2M1404%204206l103-148m2105-3006%20104-148M1708%204380l77-163M3335%20890l77-163M2038%2045e2l47-174m950-3544%2047-174m-698%203952%2016-180m320-3656%2016-180'/%3e%3c/svg%3e",ZE="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20width='800px'%20height='800px'%20viewBox='0%200%2027600%2027600'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3clinearGradient%20id='A'%20gradientUnits='userSpaceOnUse'/%3e%3clinearGradient%20id='B'%20x1='6870'%20x2='24704'%20y1='18705'%20y2='18705'%20xlink:href='%23A'%3e%3cstop%20offset='0'%20stop-color='%230c59a4'/%3e%3cstop%20offset='1'%20stop-color='%23114a8b'/%3e%3c/linearGradient%3e%3clinearGradient%20id='C'%20x1='16272'%20x2='5133'%20y1='10968'%20y2='23102'%20xlink:href='%23A'%3e%3cstop%20offset='0'%20stop-color='%231b9de2'/%3e%3cstop%20offset='.16'%20stop-color='%231595df'/%3e%3cstop%20offset='.67'%20stop-color='%230680d7'/%3e%3cstop%20offset='1'%20stop-color='%230078d4'/%3e%3c/linearGradient%3e%3cradialGradient%20id='D'%20cx='16720'%20cy='18747'%20r='9538'%20xlink:href='%23A'%3e%3cstop%20offset='.72'%20stop-opacity='0'/%3e%3cstop%20offset='.95'%20stop-opacity='.53'/%3e%3cstop%20offset='1'/%3e%3c/radialGradient%3e%3cradialGradient%20id='E'%20cx='7130'%20cy='19866'%20r='14324'%20gradientTransform='matrix(.14843%20-.98892%20.79688%20.1196%20-8759%2025542)'%20xlink:href='%23A'%3e%3cstop%20offset='.76'%20stop-opacity='0'/%3e%3cstop%20offset='.95'%20stop-opacity='.5'/%3e%3cstop%20offset='1'/%3e%3c/radialGradient%3e%3cradialGradient%20id='F'%20cx='2523'%20cy='4680'%20r='20243'%20gradientTransform='matrix(-.03715%20.99931%20-2.12836%20-.07913%2013579%203530)'%20xlink:href='%23A'%3e%3cstop%20offset='0'%20stop-color='%2335c1f1'/%3e%3cstop%20offset='.11'%20stop-color='%2334c1ed'/%3e%3cstop%20offset='.23'%20stop-color='%232fc2df'/%3e%3cstop%20offset='.31'%20stop-color='%232bc3d2'/%3e%3cstop%20offset='.67'%20stop-color='%2336c752'/%3e%3c/radialGradient%3e%3cradialGradient%20id='G'%20cx='24247'%20cy='7758'%20r='9734'%20gradientTransform='matrix(.28109%20.95968%20-.78353%20.22949%2024510%20-16292)'%20xlink:href='%23A'%3e%3cstop%20offset='0'%20stop-color='%2366eb6e'/%3e%3cstop%20offset='1'%20stop-color='%2366eb6e'%20stop-opacity='0'/%3e%3c/radialGradient%3e%3cpath%20id='H'%20d='M24105%2020053a9345%209345%200%2001-1053%20472%2010202%2010202%200%2001-3590%20646c-4732%200-8855-3255-8855-7432%200-1175%20680-2193%201643-2729-4280%20180-5380%204640-5380%207253%200%207387%206810%208137%208276%208137%20791%200%201984-230%202704-456l130-44a12834%2012834%200%20006660-5282c220-350-168-757-535-565z'/%3e%3cpath%20id='I'%20d='M11571%2025141a7913%207913%200%2001-2273-2137%208145%208145%200%2001-1514-4740%208093%208093%200%20013093-6395%208082%208082%200%20011373-859c312-148%20846-414%201554-404a3236%203236%200%20012569%201297%203184%203184%200%2001636%201866c0-21%202446-7960-8005-7960-4390%200-8004%204166-8004%207820%200%202319%20538%204170%201212%205604a12833%2012833%200%20007684%206757%2012795%2012795%200%20003908%20610c1414%200%202774-233%204045-656a7575%207575%200%2001-6278-803z'/%3e%3cpath%20id='J'%20d='M16231%2015886c-80%20105-330%20250-330%20566%200%20260%20170%20512%20472%20723%201438%201003%204149%20868%204156%20868a5954%205954%200%20003027-839%206147%206147%200%20001133-850%206180%206180%200%20001910-4437c26-2242-796-3732-1133-4392-2120-4141-6694-6525-11668-6525-7011%200-12703%205635-12798%2012620%2047-3654%203679-6605%207996-6605%20350%200%202346%2034%204200%201007%201634%20858%202490%201894%203086%202921%20618%201067%20728%202415%20728%202952s-271%201333-780%201990z'/%3e%3cuse%20fill='url(%23B)'%20xlink:href='%23H'/%3e%3cuse%20fill='url(%23D)'%20opacity='.35'%20xlink:href='%23H'/%3e%3cuse%20fill='url(%23C)'%20xlink:href='%23I'/%3e%3cuse%20fill='url(%23E)'%20opacity='.4'%20xlink:href='%23I'/%3e%3cuse%20fill='url(%23F)'%20xlink:href='%23J'/%3e%3cuse%20fill='url(%23G)'%20xlink:href='%23J'/%3e%3c/svg%3e";function JE(){const e=[{label:"Chrome",logo:QE,minVersion:"113"},{label:"Firefox",logo:XE,enabled:!1},{label:"Safari",logo:YE,minVersion:"16"},{label:"Edge",logo:ZE,minVersion:"113"}];return Ut.jsxs("main",{className:"min-h-screen  text-white ",children:[Ut.jsx("div",{className:"line"}),Ut.jsx("h3",{children:"Borrados de fondos de imagenes"}),Ut.jsx("h5",{children:"Gratuito, sencillo y privado."}),Ut.jsxs("article",{className:"webgpu-info",children:[Ut.jsx("h4",{children:"WebGPU no es soportado por tu navegador :("}),Ut.jsx("p",{children:"Este sitio web utiliza WebGPU para procesar las imagenes de forma rapida y privada. Para poder utilizar esta herramienta, debes actualizar tu navegador a uno que soporte WebGPU."}),Ut.jsx("div",{className:"grid",children:e.map(({label:t,logo:n,minVersion:o})=>Ut.jsxs("div",{className:"browser",children:[Ut.jsxs("div",{className:"left-row",children:[Ut.jsx("img",{src:n,alt:t}),Ut.jsx("h5",{children:t})]}),Ut.jsx("p",{children:o?Ut.jsxs("span",{className:"text-green-400",children:["Version minima: ",o]}):Ut.jsx("span",{className:"text-red-400",children:"No soportado"})})]}))})]})]})}function eC(){const[e,t]=fr.useState([]),[n,o]=fr.useState([]),[a,l]=fr.useState(!1),[f,_]=fr.useState(!1),[m,g]=fr.useState(!0),[M,v]=fr.useState(null),[C,k]=fr.useState(!0),z=fr.useRef(null),$=fr.useRef(null);fr.useEffect(()=>{S()},[]);const S=async()=>{try{if(!(navigator.gpu!=null)){k(!1);return}KE({modelRef:z,processorRef:$})}catch(he){v(he)}finally{g(!1)}},y=fr.useCallback(he=>{t(Ie=>[...Ie,...he.map(te=>URL.createObjectURL(te))])},[]),x=he=>{t(Ie=>Ie.filter((te,we)=>we!==he)),o(Ie=>Ie.filter((te,we)=>we!==he))},I=async()=>{l(!0),o([]),await qE({images:e,setProcessedImages:o,modelRef:z,processorRef:$}),l(!1),_(!0)},V=()=>{t([]),o([]),_(!1)},{getRootProps:O,getInputProps:B,isDragActive:j,isDragAccept:N,isDragReject:oe}=gx({onDrop:y,accept:{"image/*":[".jpeg",".jpg",".png"]}});return C?M?Ut.jsx(NE,{error:M}):m?Ut.jsx(jE,{}):Ut.jsxs("main",{className:"min-h-screen  text-white ",children:[Ut.jsx("div",{className:"line"}),Ut.jsx("h3",{children:"Borrados de fondos de imagenes"}),Ut.jsx("h5",{children:"Gratuito, sencillo y privado."}),e.length==0?Ut.jsx(AE,{isDragActive:j,isDragAccept:N,isDragReject:oe,getRootProps:O,getInputProps:B}):Ut.jsxs(Ut.Fragment,{children:[Ut.jsx(RE,{images:e,processedImages:n,isProcessing:a,removeImage:x}),Ut.jsx(BE,{isProcessing:a,images:e,processImages:I,processedImages:n,isDownloadReady:f,clearAll:V})]}),Ut.jsx("div",{className:"credits",children:Ut.jsx("p",{children:"Martn Fenocchio"})})]}):Ut.jsx(JE,{})}rx(document.getElementById("root")).render(Ut.jsx(fr.StrictMode,{children:Ut.jsx(eC,{})}));
