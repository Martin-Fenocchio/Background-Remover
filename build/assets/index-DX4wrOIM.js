var nT = Object.defineProperty;
var iT = (e, t, n) =>
  t in e
    ? nT(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (e[t] = n);
var He = (e, t, n) => iT(e, typeof t != "symbol" ? t + "" : t, n);
(function () {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const a of document.querySelectorAll('link[rel="modulepreload"]')) o(a);
  new MutationObserver((a) => {
    for (const l of a)
      if (l.type === "childList")
        for (const f of l.addedNodes)
          f.tagName === "LINK" && f.rel === "modulepreload" && o(f);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(a) {
    const l = {};
    return (
      a.integrity && (l.integrity = a.integrity),
      a.referrerPolicy && (l.referrerPolicy = a.referrerPolicy),
      a.crossOrigin === "use-credentials"
        ? (l.credentials = "include")
        : a.crossOrigin === "anonymous"
        ? (l.credentials = "omit")
        : (l.credentials = "same-origin"),
      l
    );
  }
  function o(a) {
    if (a.ep) return;
    a.ep = !0;
    const l = n(a);
    fetch(a.href, l);
  }
})();
var Fo =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function W_(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e;
}
var W1 = { exports: {} },
  gm = {},
  G1 = { exports: {} },
  Ir = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var fp = Symbol.for("react.element"),
  oT = Symbol.for("react.portal"),
  sT = Symbol.for("react.fragment"),
  aT = Symbol.for("react.strict_mode"),
  lT = Symbol.for("react.profiler"),
  uT = Symbol.for("react.provider"),
  cT = Symbol.for("react.context"),
  dT = Symbol.for("react.forward_ref"),
  fT = Symbol.for("react.suspense"),
  pT = Symbol.for("react.memo"),
  hT = Symbol.for("react.lazy"),
  bv = Symbol.iterator;
function mT(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (bv && e[bv]) || e["@@iterator"]),
      typeof e == "function" ? e : null);
}
var H1 = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  q1 = Object.assign,
  K1 = {};
function yu(e, t, n) {
  (this.props = e),
    (this.context = t),
    (this.refs = K1),
    (this.updater = n || H1);
}
yu.prototype.isReactComponent = {};
yu.prototype.setState = function (e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, e, t, "setState");
};
yu.prototype.forceUpdate = function (e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate");
};
function Q1() {}
Q1.prototype = yu.prototype;
function G_(e, t, n) {
  (this.props = e),
    (this.context = t),
    (this.refs = K1),
    (this.updater = n || H1);
}
var H_ = (G_.prototype = new Q1());
H_.constructor = G_;
q1(H_, yu.prototype);
H_.isPureReactComponent = !0;
var xv = Array.isArray,
  X1 = Object.prototype.hasOwnProperty,
  q_ = { current: null },
  Y1 = { key: !0, ref: !0, __self: !0, __source: !0 };
function Z1(e, t, n) {
  var o,
    a = {},
    l = null,
    f = null;
  if (t != null)
    for (o in (t.ref !== void 0 && (f = t.ref),
    t.key !== void 0 && (l = "" + t.key),
    t))
      X1.call(t, o) && !Y1.hasOwnProperty(o) && (a[o] = t[o]);
  var _ = arguments.length - 2;
  if (_ === 1) a.children = n;
  else if (1 < _) {
    for (var m = Array(_), g = 0; g < _; g++) m[g] = arguments[g + 2];
    a.children = m;
  }
  if (e && e.defaultProps)
    for (o in ((_ = e.defaultProps), _)) a[o] === void 0 && (a[o] = _[o]);
  return {
    $$typeof: fp,
    type: e,
    key: l,
    ref: f,
    props: a,
    _owner: q_.current
  };
}
function gT(e, t) {
  return {
    $$typeof: fp,
    type: e.type,
    key: t,
    ref: e.ref,
    props: e.props,
    _owner: e._owner
  };
}
function K_(e) {
  return typeof e == "object" && e !== null && e.$$typeof === fp;
}
function _T(e) {
  var t = { "=": "=0", ":": "=2" };
  return (
    "$" +
    e.replace(/[=:]/g, function (n) {
      return t[n];
    })
  );
}
var Mv = /\/+/g;
function yg(e, t) {
  return typeof e == "object" && e !== null && e.key != null
    ? _T("" + e.key)
    : t.toString(36);
}
function $h(e, t, n, o, a) {
  var l = typeof e;
  (l === "undefined" || l === "boolean") && (e = null);
  var f = !1;
  if (e === null) f = !0;
  else
    switch (l) {
      case "string":
      case "number":
        f = !0;
        break;
      case "object":
        switch (e.$$typeof) {
          case fp:
          case oT:
            f = !0;
        }
    }
  if (f)
    return (
      (f = e),
      (a = a(f)),
      (e = o === "" ? "." + yg(f, 0) : o),
      xv(a)
        ? ((n = ""),
          e != null && (n = e.replace(Mv, "$&/") + "/"),
          $h(a, t, n, "", function (g) {
            return g;
          }))
        : a != null &&
          (K_(a) &&
            (a = gT(
              a,
              n +
                (!a.key || (f && f.key === a.key)
                  ? ""
                  : ("" + a.key).replace(Mv, "$&/") + "/") +
                e
            )),
          t.push(a)),
      1
    );
  if (((f = 0), (o = o === "" ? "." : o + ":"), xv(e)))
    for (var _ = 0; _ < e.length; _++) {
      l = e[_];
      var m = o + yg(l, _);
      f += $h(l, t, n, m, a);
    }
  else if (((m = mT(e)), typeof m == "function"))
    for (e = m.call(e), _ = 0; !(l = e.next()).done; )
      (l = l.value), (m = o + yg(l, _++)), (f += $h(l, t, n, m, a));
  else if (l === "object")
    throw (
      ((t = String(e)),
      Error(
        "Objects are not valid as a React child (found: " +
          (t === "[object Object]"
            ? "object with keys {" + Object.keys(e).join(", ") + "}"
            : t) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return f;
}
function dh(e, t, n) {
  if (e == null) return e;
  var o = [],
    a = 0;
  return (
    $h(e, o, "", "", function (l) {
      return t.call(n, l, a++);
    }),
    o
  );
}
function yT(e) {
  if (e._status === -1) {
    var t = e._result;
    (t = t()),
      t.then(
        function (n) {
          (e._status === 0 || e._status === -1) &&
            ((e._status = 1), (e._result = n));
        },
        function (n) {
          (e._status === 0 || e._status === -1) &&
            ((e._status = 2), (e._result = n));
        }
      ),
      e._status === -1 && ((e._status = 0), (e._result = t));
  }
  if (e._status === 1) return e._result.default;
  throw e._result;
}
var ai = { current: null },
  Ah = { transition: null },
  wT = {
    ReactCurrentDispatcher: ai,
    ReactCurrentBatchConfig: Ah,
    ReactCurrentOwner: q_
  };
function J1() {
  throw Error("act(...) is not supported in production builds of React.");
}
Ir.Children = {
  map: dh,
  forEach: function (e, t, n) {
    dh(
      e,
      function () {
        t.apply(this, arguments);
      },
      n
    );
  },
  count: function (e) {
    var t = 0;
    return (
      dh(e, function () {
        t++;
      }),
      t
    );
  },
  toArray: function (e) {
    return (
      dh(e, function (t) {
        return t;
      }) || []
    );
  },
  only: function (e) {
    if (!K_(e))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return e;
  }
};
Ir.Component = yu;
Ir.Fragment = sT;
Ir.Profiler = lT;
Ir.PureComponent = G_;
Ir.StrictMode = aT;
Ir.Suspense = fT;
Ir.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = wT;
Ir.act = J1;
Ir.cloneElement = function (e, t, n) {
  if (e == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        e +
        "."
    );
  var o = q1({}, e.props),
    a = e.key,
    l = e.ref,
    f = e._owner;
  if (t != null) {
    if (
      (t.ref !== void 0 && ((l = t.ref), (f = q_.current)),
      t.key !== void 0 && (a = "" + t.key),
      e.type && e.type.defaultProps)
    )
      var _ = e.type.defaultProps;
    for (m in t)
      X1.call(t, m) &&
        !Y1.hasOwnProperty(m) &&
        (o[m] = t[m] === void 0 && _ !== void 0 ? _[m] : t[m]);
  }
  var m = arguments.length - 2;
  if (m === 1) o.children = n;
  else if (1 < m) {
    _ = Array(m);
    for (var g = 0; g < m; g++) _[g] = arguments[g + 2];
    o.children = _;
  }
  return { $$typeof: fp, type: e.type, key: a, ref: l, props: o, _owner: f };
};
Ir.createContext = function (e) {
  return (
    (e = {
      $$typeof: cT,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
    }),
    (e.Provider = { $$typeof: uT, _context: e }),
    (e.Consumer = e)
  );
};
Ir.createElement = Z1;
Ir.createFactory = function (e) {
  var t = Z1.bind(null, e);
  return (t.type = e), t;
};
Ir.createRef = function () {
  return { current: null };
};
Ir.forwardRef = function (e) {
  return { $$typeof: dT, render: e };
};
Ir.isValidElement = K_;
Ir.lazy = function (e) {
  return { $$typeof: hT, _payload: { _status: -1, _result: e }, _init: yT };
};
Ir.memo = function (e, t) {
  return { $$typeof: pT, type: e, compare: t === void 0 ? null : t };
};
Ir.startTransition = function (e) {
  var t = Ah.transition;
  Ah.transition = {};
  try {
    e();
  } finally {
    Ah.transition = t;
  }
};
Ir.unstable_act = J1;
Ir.useCallback = function (e, t) {
  return ai.current.useCallback(e, t);
};
Ir.useContext = function (e) {
  return ai.current.useContext(e);
};
Ir.useDebugValue = function () {};
Ir.useDeferredValue = function (e) {
  return ai.current.useDeferredValue(e);
};
Ir.useEffect = function (e, t) {
  return ai.current.useEffect(e, t);
};
Ir.useId = function () {
  return ai.current.useId();
};
Ir.useImperativeHandle = function (e, t, n) {
  return ai.current.useImperativeHandle(e, t, n);
};
Ir.useInsertionEffect = function (e, t) {
  return ai.current.useInsertionEffect(e, t);
};
Ir.useLayoutEffect = function (e, t) {
  return ai.current.useLayoutEffect(e, t);
};
Ir.useMemo = function (e, t) {
  return ai.current.useMemo(e, t);
};
Ir.useReducer = function (e, t, n) {
  return ai.current.useReducer(e, t, n);
};
Ir.useRef = function (e) {
  return ai.current.useRef(e);
};
Ir.useState = function (e) {
  return ai.current.useState(e);
};
Ir.useSyncExternalStore = function (e, t, n) {
  return ai.current.useSyncExternalStore(e, t, n);
};
Ir.useTransition = function () {
  return ai.current.useTransition();
};
Ir.version = "18.3.1";
G1.exports = Ir;
var yr = G1.exports;
const vT = W_(yr);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var bT = yr,
  xT = Symbol.for("react.element"),
  MT = Symbol.for("react.fragment"),
  TT = Object.prototype.hasOwnProperty,
  kT = bT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  ST = { key: !0, ref: !0, __self: !0, __source: !0 };
function eb(e, t, n) {
  var o,
    a = {},
    l = null,
    f = null;
  n !== void 0 && (l = "" + n),
    t.key !== void 0 && (l = "" + t.key),
    t.ref !== void 0 && (f = t.ref);
  for (o in t) TT.call(t, o) && !ST.hasOwnProperty(o) && (a[o] = t[o]);
  if (e && e.defaultProps)
    for (o in ((t = e.defaultProps), t)) a[o] === void 0 && (a[o] = t[o]);
  return {
    $$typeof: xT,
    type: e,
    key: l,
    ref: f,
    props: a,
    _owner: kT.current
  };
}
gm.Fragment = MT;
gm.jsx = eb;
gm.jsxs = eb;
W1.exports = gm;
var Br = W1.exports,
  tb = { exports: {} },
  Pi = {},
  rb = { exports: {} },
  nb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (e) {
  function t(X, oe) {
    var xe = X.length;
    X.push(oe);
    e: for (; 0 < xe; ) {
      var Y = (xe - 1) >>> 1,
        ge = X[Y];
      if (0 < a(ge, oe)) (X[Y] = oe), (X[xe] = ge), (xe = Y);
      else break e;
    }
  }
  function n(X) {
    return X.length === 0 ? null : X[0];
  }
  function o(X) {
    if (X.length === 0) return null;
    var oe = X[0],
      xe = X.pop();
    if (xe !== oe) {
      X[0] = xe;
      e: for (var Y = 0, ge = X.length, qe = ge >>> 1; Y < qe; ) {
        var Be = 2 * (Y + 1) - 1,
          Ne = X[Be],
          We = Be + 1,
          st = X[We];
        if (0 > a(Ne, xe))
          We < ge && 0 > a(st, Ne)
            ? ((X[Y] = st), (X[We] = xe), (Y = We))
            : ((X[Y] = Ne), (X[Be] = xe), (Y = Be));
        else if (We < ge && 0 > a(st, xe)) (X[Y] = st), (X[We] = xe), (Y = We);
        else break e;
      }
    }
    return oe;
  }
  function a(X, oe) {
    var xe = X.sortIndex - oe.sortIndex;
    return xe !== 0 ? xe : X.id - oe.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var l = performance;
    e.unstable_now = function () {
      return l.now();
    };
  } else {
    var f = Date,
      _ = f.now();
    e.unstable_now = function () {
      return f.now() - _;
    };
  }
  var m = [],
    g = [],
    M = 1,
    v = null,
    C = 3,
    T = !1,
    z = !1,
    $ = !1,
    S = typeof setTimeout == "function" ? setTimeout : null,
    y = typeof clearTimeout == "function" ? clearTimeout : null,
    x = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function I(X) {
    for (var oe = n(g); oe !== null; ) {
      if (oe.callback === null) o(g);
      else if (oe.startTime <= X)
        o(g), (oe.sortIndex = oe.expirationTime), t(m, oe);
      else break;
      oe = n(g);
    }
  }
  function V(X) {
    if ((($ = !1), I(X), !z))
      if (n(m) !== null) (z = !0), Qe(O);
      else {
        var oe = n(g);
        oe !== null && _e(V, oe.startTime - X);
      }
  }
  function O(X, oe) {
    (z = !1), $ && (($ = !1), y(N), (N = -1)), (T = !0);
    var xe = C;
    try {
      for (
        I(oe), v = n(m);
        v !== null && (!(v.expirationTime > oe) || (X && !Me()));

      ) {
        var Y = v.callback;
        if (typeof Y == "function") {
          (v.callback = null), (C = v.priorityLevel);
          var ge = Y(v.expirationTime <= oe);
          (oe = e.unstable_now()),
            typeof ge == "function" ? (v.callback = ge) : v === n(m) && o(m),
            I(oe);
        } else o(m);
        v = n(m);
      }
      if (v !== null) var qe = !0;
      else {
        var Be = n(g);
        Be !== null && _e(V, Be.startTime - oe), (qe = !1);
      }
      return qe;
    } finally {
      (v = null), (C = xe), (T = !1);
    }
  }
  var B = !1,
    j = null,
    N = -1,
    se = 5,
    de = -1;
  function Me() {
    return !(e.unstable_now() - de < se);
  }
  function J() {
    if (j !== null) {
      var X = e.unstable_now();
      de = X;
      var oe = !0;
      try {
        oe = j(!0, X);
      } finally {
        oe ? ye() : ((B = !1), (j = null));
      }
    } else B = !1;
  }
  var ye;
  if (typeof x == "function")
    ye = function () {
      x(J);
    };
  else if (typeof MessageChannel < "u") {
    var L = new MessageChannel(),
      Ee = L.port2;
    (L.port1.onmessage = J),
      (ye = function () {
        Ee.postMessage(null);
      });
  } else
    ye = function () {
      S(J, 0);
    };
  function Qe(X) {
    (j = X), B || ((B = !0), ye());
  }
  function _e(X, oe) {
    N = S(function () {
      X(e.unstable_now());
    }, oe);
  }
  (e.unstable_IdlePriority = 5),
    (e.unstable_ImmediatePriority = 1),
    (e.unstable_LowPriority = 4),
    (e.unstable_NormalPriority = 3),
    (e.unstable_Profiling = null),
    (e.unstable_UserBlockingPriority = 2),
    (e.unstable_cancelCallback = function (X) {
      X.callback = null;
    }),
    (e.unstable_continueExecution = function () {
      z || T || ((z = !0), Qe(O));
    }),
    (e.unstable_forceFrameRate = function (X) {
      0 > X || 125 < X
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (se = 0 < X ? Math.floor(1e3 / X) : 5);
    }),
    (e.unstable_getCurrentPriorityLevel = function () {
      return C;
    }),
    (e.unstable_getFirstCallbackNode = function () {
      return n(m);
    }),
    (e.unstable_next = function (X) {
      switch (C) {
        case 1:
        case 2:
        case 3:
          var oe = 3;
          break;
        default:
          oe = C;
      }
      var xe = C;
      C = oe;
      try {
        return X();
      } finally {
        C = xe;
      }
    }),
    (e.unstable_pauseExecution = function () {}),
    (e.unstable_requestPaint = function () {}),
    (e.unstable_runWithPriority = function (X, oe) {
      switch (X) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          X = 3;
      }
      var xe = C;
      C = X;
      try {
        return oe();
      } finally {
        C = xe;
      }
    }),
    (e.unstable_scheduleCallback = function (X, oe, xe) {
      var Y = e.unstable_now();
      switch (
        (typeof xe == "object" && xe !== null
          ? ((xe = xe.delay),
            (xe = typeof xe == "number" && 0 < xe ? Y + xe : Y))
          : (xe = Y),
        X)
      ) {
        case 1:
          var ge = -1;
          break;
        case 2:
          ge = 250;
          break;
        case 5:
          ge = 1073741823;
          break;
        case 4:
          ge = 1e4;
          break;
        default:
          ge = 5e3;
      }
      return (
        (ge = xe + ge),
        (X = {
          id: M++,
          callback: oe,
          priorityLevel: X,
          startTime: xe,
          expirationTime: ge,
          sortIndex: -1
        }),
        xe > Y
          ? ((X.sortIndex = xe),
            t(g, X),
            n(m) === null &&
              X === n(g) &&
              ($ ? (y(N), (N = -1)) : ($ = !0), _e(V, xe - Y)))
          : ((X.sortIndex = ge), t(m, X), z || T || ((z = !0), Qe(O))),
        X
      );
    }),
    (e.unstable_shouldYield = Me),
    (e.unstable_wrapCallback = function (X) {
      var oe = C;
      return function () {
        var xe = C;
        C = oe;
        try {
          return X.apply(this, arguments);
        } finally {
          C = xe;
        }
      };
    });
})(nb);
rb.exports = nb;
var ET = rb.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var CT = yr,
  Ci = ET;
function St(e) {
  for (
    var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1;
    n < arguments.length;
    n++
  )
    t += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    e +
    "; visit " +
    t +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var ib = new Set(),
  Kf = {};
function ma(e, t) {
  du(e, t), du(e + "Capture", t);
}
function du(e, t) {
  for (Kf[e] = t, e = 0; e < t.length; e++) ib.add(t[e]);
}
var Lo = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  qg = Object.prototype.hasOwnProperty,
  PT =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Tv = {},
  kv = {};
function $T(e) {
  return qg.call(kv, e)
    ? !0
    : qg.call(Tv, e)
    ? !1
    : PT.test(e)
    ? (kv[e] = !0)
    : ((Tv[e] = !0), !1);
}
function AT(e, t, n, o) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof t) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return o
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((e = e.toLowerCase().slice(0, 5)), e !== "data-" && e !== "aria-");
    default:
      return !1;
  }
}
function IT(e, t, n, o) {
  if (t === null || typeof t > "u" || AT(e, t, n, o)) return !0;
  if (o) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !t;
      case 4:
        return t === !1;
      case 5:
        return isNaN(t);
      case 6:
        return isNaN(t) || 1 > t;
    }
  return !1;
}
function li(e, t, n, o, a, l, f) {
  (this.acceptsBooleans = t === 2 || t === 3 || t === 4),
    (this.attributeName = o),
    (this.attributeNamespace = a),
    (this.mustUseProperty = n),
    (this.propertyName = e),
    (this.type = t),
    (this.sanitizeURL = l),
    (this.removeEmptyString = f);
}
var Hn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (e) {
    Hn[e] = new li(e, 0, !1, e, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(function (e) {
  var t = e[0];
  Hn[t] = new li(t, 1, !1, e[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) {
  Hn[e] = new li(e, 2, !1, e.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach(function (e) {
  Hn[e] = new li(e, 2, !1, e, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (e) {
    Hn[e] = new li(e, 3, !1, e.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (e) {
  Hn[e] = new li(e, 3, !0, e, null, !1, !1);
});
["capture", "download"].forEach(function (e) {
  Hn[e] = new li(e, 4, !1, e, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (e) {
  Hn[e] = new li(e, 6, !1, e, null, !1, !1);
});
["rowSpan", "start"].forEach(function (e) {
  Hn[e] = new li(e, 5, !1, e.toLowerCase(), null, !1, !1);
});
var Q_ = /[\-:]([a-z])/g;
function X_(e) {
  return e[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace(Q_, X_);
    Hn[t] = new li(t, 1, !1, e, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace(Q_, X_);
    Hn[t] = new li(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
  var t = e.replace(Q_, X_);
  Hn[t] = new li(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (e) {
  Hn[e] = new li(e, 1, !1, e.toLowerCase(), null, !1, !1);
});
Hn.xlinkHref = new li(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (e) {
  Hn[e] = new li(e, 1, !1, e.toLowerCase(), null, !0, !0);
});
function Y_(e, t, n, o) {
  var a = Hn.hasOwnProperty(t) ? Hn[t] : null;
  (a !== null
    ? a.type !== 0
    : o ||
      !(2 < t.length) ||
      (t[0] !== "o" && t[0] !== "O") ||
      (t[1] !== "n" && t[1] !== "N")) &&
    (IT(t, n, a, o) && (n = null),
    o || a === null
      ? $T(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n))
      : a.mustUseProperty
      ? (e[a.propertyName] = n === null ? (a.type === 3 ? !1 : "") : n)
      : ((t = a.attributeName),
        (o = a.attributeNamespace),
        n === null
          ? e.removeAttribute(t)
          : ((a = a.type),
            (n = a === 3 || (a === 4 && n === !0) ? "" : "" + n),
            o ? e.setAttributeNS(o, t, n) : e.setAttribute(t, n))));
}
var jo = CT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  fh = Symbol.for("react.element"),
  ql = Symbol.for("react.portal"),
  Kl = Symbol.for("react.fragment"),
  Z_ = Symbol.for("react.strict_mode"),
  Kg = Symbol.for("react.profiler"),
  ob = Symbol.for("react.provider"),
  sb = Symbol.for("react.context"),
  J_ = Symbol.for("react.forward_ref"),
  Qg = Symbol.for("react.suspense"),
  Xg = Symbol.for("react.suspense_list"),
  e0 = Symbol.for("react.memo"),
  ds = Symbol.for("react.lazy"),
  ab = Symbol.for("react.offscreen"),
  Sv = Symbol.iterator;
function kf(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (Sv && e[Sv]) || e["@@iterator"]),
      typeof e == "function" ? e : null);
}
var pn = Object.assign,
  wg;
function zf(e) {
  if (wg === void 0)
    try {
      throw Error();
    } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/);
      wg = (t && t[1]) || "";
    }
  return (
    `
` +
    wg +
    e
  );
}
var vg = !1;
function bg(e, t) {
  if (!e || vg) return "";
  vg = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (t)
      if (
        ((t = function () {
          throw Error();
        }),
        Object.defineProperty(t.prototype, "props", {
          set: function () {
            throw Error();
          }
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(t, []);
        } catch (g) {
          var o = g;
        }
        Reflect.construct(e, [], t);
      } else {
        try {
          t.call();
        } catch (g) {
          o = g;
        }
        e.call(t.prototype);
      }
    else {
      try {
        throw Error();
      } catch (g) {
        o = g;
      }
      e();
    }
  } catch (g) {
    if (g && o && typeof g.stack == "string") {
      for (
        var a = g.stack.split(`
`),
          l = o.stack.split(`
`),
          f = a.length - 1,
          _ = l.length - 1;
        1 <= f && 0 <= _ && a[f] !== l[_];

      )
        _--;
      for (; 1 <= f && 0 <= _; f--, _--)
        if (a[f] !== l[_]) {
          if (f !== 1 || _ !== 1)
            do
              if ((f--, _--, 0 > _ || a[f] !== l[_])) {
                var m =
                  `
` + a[f].replace(" at new ", " at ");
                return (
                  e.displayName &&
                    m.includes("<anonymous>") &&
                    (m = m.replace("<anonymous>", e.displayName)),
                  m
                );
              }
            while (1 <= f && 0 <= _);
          break;
        }
    }
  } finally {
    (vg = !1), (Error.prepareStackTrace = n);
  }
  return (e = e ? e.displayName || e.name : "") ? zf(e) : "";
}
function FT(e) {
  switch (e.tag) {
    case 5:
      return zf(e.type);
    case 16:
      return zf("Lazy");
    case 13:
      return zf("Suspense");
    case 19:
      return zf("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (e = bg(e.type, !1)), e;
    case 11:
      return (e = bg(e.type.render, !1)), e;
    case 1:
      return (e = bg(e.type, !0)), e;
    default:
      return "";
  }
}
function Yg(e) {
  if (e == null) return null;
  if (typeof e == "function") return e.displayName || e.name || null;
  if (typeof e == "string") return e;
  switch (e) {
    case Kl:
      return "Fragment";
    case ql:
      return "Portal";
    case Kg:
      return "Profiler";
    case Z_:
      return "StrictMode";
    case Qg:
      return "Suspense";
    case Xg:
      return "SuspenseList";
  }
  if (typeof e == "object")
    switch (e.$$typeof) {
      case sb:
        return (e.displayName || "Context") + ".Consumer";
      case ob:
        return (e._context.displayName || "Context") + ".Provider";
      case J_:
        var t = e.render;
        return (
          (e = e.displayName),
          e ||
            ((e = t.displayName || t.name || ""),
            (e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")),
          e
        );
      case e0:
        return (
          (t = e.displayName || null), t !== null ? t : Yg(e.type) || "Memo"
        );
      case ds:
        (t = e._payload), (e = e._init);
        try {
          return Yg(e(t));
        } catch {}
    }
  return null;
}
function zT(e) {
  var t = e.type;
  switch (e.tag) {
    case 24:
      return "Cache";
    case 9:
      return (t.displayName || "Context") + ".Consumer";
    case 10:
      return (t._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (e = t.render),
        (e = e.displayName || e.name || ""),
        t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return t;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Yg(t);
    case 8:
      return t === Z_ ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == "function") return t.displayName || t.name || null;
      if (typeof t == "string") return t;
  }
  return null;
}
function ks(e) {
  switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e;
    case "object":
      return e;
    default:
      return "";
  }
}
function lb(e) {
  var t = e.type;
  return (
    (e = e.nodeName) &&
    e.toLowerCase() === "input" &&
    (t === "checkbox" || t === "radio")
  );
}
function OT(e) {
  var t = lb(e) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    o = "" + e[t];
  if (
    !e.hasOwnProperty(t) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var a = n.get,
      l = n.set;
    return (
      Object.defineProperty(e, t, {
        configurable: !0,
        get: function () {
          return a.call(this);
        },
        set: function (f) {
          (o = "" + f), l.call(this, f);
        }
      }),
      Object.defineProperty(e, t, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return o;
        },
        setValue: function (f) {
          o = "" + f;
        },
        stopTracking: function () {
          (e._valueTracker = null), delete e[t];
        }
      }
    );
  }
}
function ph(e) {
  e._valueTracker || (e._valueTracker = OT(e));
}
function ub(e) {
  if (!e) return !1;
  var t = e._valueTracker;
  if (!t) return !0;
  var n = t.getValue(),
    o = "";
  return (
    e && (o = lb(e) ? (e.checked ? "true" : "false") : e.value),
    (e = o),
    e !== n ? (t.setValue(e), !0) : !1
  );
}
function Vh(e) {
  if (((e = e || (typeof document < "u" ? document : void 0)), typeof e > "u"))
    return null;
  try {
    return e.activeElement || e.body;
  } catch {
    return e.body;
  }
}
function Zg(e, t) {
  var n = t.checked;
  return pn({}, t, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? e._wrapperState.initialChecked
  });
}
function Ev(e, t) {
  var n = t.defaultValue == null ? "" : t.defaultValue,
    o = t.checked != null ? t.checked : t.defaultChecked;
  (n = ks(t.value != null ? t.value : n)),
    (e._wrapperState = {
      initialChecked: o,
      initialValue: n,
      controlled:
        t.type === "checkbox" || t.type === "radio"
          ? t.checked != null
          : t.value != null
    });
}
function cb(e, t) {
  (t = t.checked), t != null && Y_(e, "checked", t, !1);
}
function Jg(e, t) {
  cb(e, t);
  var n = ks(t.value),
    o = t.type;
  if (n != null)
    o === "number"
      ? ((n === 0 && e.value === "") || e.value != n) && (e.value = "" + n)
      : e.value !== "" + n && (e.value = "" + n);
  else if (o === "submit" || o === "reset") {
    e.removeAttribute("value");
    return;
  }
  t.hasOwnProperty("value")
    ? e_(e, t.type, n)
    : t.hasOwnProperty("defaultValue") && e_(e, t.type, ks(t.defaultValue)),
    t.checked == null &&
      t.defaultChecked != null &&
      (e.defaultChecked = !!t.defaultChecked);
}
function Cv(e, t, n) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
    var o = t.type;
    if (
      !(
        (o !== "submit" && o !== "reset") ||
        (t.value !== void 0 && t.value !== null)
      )
    )
      return;
    (t = "" + e._wrapperState.initialValue),
      n || t === e.value || (e.value = t),
      (e.defaultValue = t);
  }
  (n = e.name),
    n !== "" && (e.name = ""),
    (e.defaultChecked = !!e._wrapperState.initialChecked),
    n !== "" && (e.name = n);
}
function e_(e, t, n) {
  (t !== "number" || Vh(e.ownerDocument) !== e) &&
    (n == null
      ? (e.defaultValue = "" + e._wrapperState.initialValue)
      : e.defaultValue !== "" + n && (e.defaultValue = "" + n));
}
var Of = Array.isArray;
function ou(e, t, n, o) {
  if (((e = e.options), t)) {
    t = {};
    for (var a = 0; a < n.length; a++) t["$" + n[a]] = !0;
    for (n = 0; n < e.length; n++)
      (a = t.hasOwnProperty("$" + e[n].value)),
        e[n].selected !== a && (e[n].selected = a),
        a && o && (e[n].defaultSelected = !0);
  } else {
    for (n = "" + ks(n), t = null, a = 0; a < e.length; a++) {
      if (e[a].value === n) {
        (e[a].selected = !0), o && (e[a].defaultSelected = !0);
        return;
      }
      t !== null || e[a].disabled || (t = e[a]);
    }
    t !== null && (t.selected = !0);
  }
}
function t_(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(St(91));
  return pn({}, t, {
    value: void 0,
    defaultValue: void 0,
    children: "" + e._wrapperState.initialValue
  });
}
function Pv(e, t) {
  var n = t.value;
  if (n == null) {
    if (((n = t.children), (t = t.defaultValue), n != null)) {
      if (t != null) throw Error(St(92));
      if (Of(n)) {
        if (1 < n.length) throw Error(St(93));
        n = n[0];
      }
      t = n;
    }
    t == null && (t = ""), (n = t);
  }
  e._wrapperState = { initialValue: ks(n) };
}
function db(e, t) {
  var n = ks(t.value),
    o = ks(t.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== e.value && (e.value = n),
    t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
    o != null && (e.defaultValue = "" + o);
}
function $v(e) {
  var t = e.textContent;
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t);
}
function fb(e) {
  switch (e) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function r_(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml"
    ? fb(t)
    : e === "http://www.w3.org/2000/svg" && t === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : e;
}
var hh,
  pb = (function (e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (t, n, o, a) {
          MSApp.execUnsafeLocalFunction(function () {
            return e(t, n, o, a);
          });
        }
      : e;
  })(function (e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e)
      e.innerHTML = t;
    else {
      for (
        hh = hh || document.createElement("div"),
          hh.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
          t = hh.firstChild;
        e.firstChild;

      )
        e.removeChild(e.firstChild);
      for (; t.firstChild; ) e.appendChild(t.firstChild);
    }
  });
function Qf(e, t) {
  if (t) {
    var n = e.firstChild;
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t;
      return;
    }
  }
  e.textContent = t;
}
var Rf = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  },
  DT = ["Webkit", "ms", "Moz", "O"];
Object.keys(Rf).forEach(function (e) {
  DT.forEach(function (t) {
    (t = t + e.charAt(0).toUpperCase() + e.substring(1)), (Rf[t] = Rf[e]);
  });
});
function hb(e, t, n) {
  return t == null || typeof t == "boolean" || t === ""
    ? ""
    : n || typeof t != "number" || t === 0 || (Rf.hasOwnProperty(e) && Rf[e])
    ? ("" + t).trim()
    : t + "px";
}
function mb(e, t) {
  e = e.style;
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var o = n.indexOf("--") === 0,
        a = hb(n, t[n], o);
      n === "float" && (n = "cssFloat"), o ? e.setProperty(n, a) : (e[n] = a);
    }
}
var LT = pn(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  }
);
function n_(e, t) {
  if (t) {
    if (LT[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
      throw Error(St(137, e));
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(St(60));
      if (
        typeof t.dangerouslySetInnerHTML != "object" ||
        !("__html" in t.dangerouslySetInnerHTML)
      )
        throw Error(St(61));
    }
    if (t.style != null && typeof t.style != "object") throw Error(St(62));
  }
}
function i_(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string";
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var o_ = null;
function t0(e) {
  return (
    (e = e.target || e.srcElement || window),
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
  );
}
var s_ = null,
  su = null,
  au = null;
function Av(e) {
  if ((e = mp(e))) {
    if (typeof s_ != "function") throw Error(St(280));
    var t = e.stateNode;
    t && ((t = bm(t)), s_(e.stateNode, e.type, t));
  }
}
function gb(e) {
  su ? (au ? au.push(e) : (au = [e])) : (su = e);
}
function _b() {
  if (su) {
    var e = su,
      t = au;
    if (((au = su = null), Av(e), t)) for (e = 0; e < t.length; e++) Av(t[e]);
  }
}
function yb(e, t) {
  return e(t);
}
function wb() {}
var xg = !1;
function vb(e, t, n) {
  if (xg) return e(t, n);
  xg = !0;
  try {
    return yb(e, t, n);
  } finally {
    (xg = !1), (su !== null || au !== null) && (wb(), _b());
  }
}
function Xf(e, t) {
  var n = e.stateNode;
  if (n === null) return null;
  var o = bm(n);
  if (o === null) return null;
  n = o[t];
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (o = !o.disabled) ||
        ((e = e.type),
        (o = !(
          e === "button" ||
          e === "input" ||
          e === "select" ||
          e === "textarea"
        ))),
        (e = !o);
      break e;
    default:
      e = !1;
  }
  if (e) return null;
  if (n && typeof n != "function") throw Error(St(231, t, typeof n));
  return n;
}
var a_ = !1;
if (Lo)
  try {
    var Sf = {};
    Object.defineProperty(Sf, "passive", {
      get: function () {
        a_ = !0;
      }
    }),
      window.addEventListener("test", Sf, Sf),
      window.removeEventListener("test", Sf, Sf);
  } catch {
    a_ = !1;
  }
function BT(e, t, n, o, a, l, f, _, m) {
  var g = Array.prototype.slice.call(arguments, 3);
  try {
    t.apply(n, g);
  } catch (M) {
    this.onError(M);
  }
}
var Nf = !1,
  Wh = null,
  Gh = !1,
  l_ = null,
  RT = {
    onError: function (e) {
      (Nf = !0), (Wh = e);
    }
  };
function NT(e, t, n, o, a, l, f, _, m) {
  (Nf = !1), (Wh = null), BT.apply(RT, arguments);
}
function jT(e, t, n, o, a, l, f, _, m) {
  if ((NT.apply(this, arguments), Nf)) {
    if (Nf) {
      var g = Wh;
      (Nf = !1), (Wh = null);
    } else throw Error(St(198));
    Gh || ((Gh = !0), (l_ = g));
  }
}
function ga(e) {
  var t = e,
    n = e;
  if (e.alternate) for (; t.return; ) t = t.return;
  else {
    e = t;
    do (t = e), t.flags & 4098 && (n = t.return), (e = t.return);
    while (e);
  }
  return t.tag === 3 ? n : null;
}
function bb(e) {
  if (e.tag === 13) {
    var t = e.memoizedState;
    if (
      (t === null && ((e = e.alternate), e !== null && (t = e.memoizedState)),
      t !== null)
    )
      return t.dehydrated;
  }
  return null;
}
function Iv(e) {
  if (ga(e) !== e) throw Error(St(188));
}
function UT(e) {
  var t = e.alternate;
  if (!t) {
    if (((t = ga(e)), t === null)) throw Error(St(188));
    return t !== e ? null : e;
  }
  for (var n = e, o = t; ; ) {
    var a = n.return;
    if (a === null) break;
    var l = a.alternate;
    if (l === null) {
      if (((o = a.return), o !== null)) {
        n = o;
        continue;
      }
      break;
    }
    if (a.child === l.child) {
      for (l = a.child; l; ) {
        if (l === n) return Iv(a), e;
        if (l === o) return Iv(a), t;
        l = l.sibling;
      }
      throw Error(St(188));
    }
    if (n.return !== o.return) (n = a), (o = l);
    else {
      for (var f = !1, _ = a.child; _; ) {
        if (_ === n) {
          (f = !0), (n = a), (o = l);
          break;
        }
        if (_ === o) {
          (f = !0), (o = a), (n = l);
          break;
        }
        _ = _.sibling;
      }
      if (!f) {
        for (_ = l.child; _; ) {
          if (_ === n) {
            (f = !0), (n = l), (o = a);
            break;
          }
          if (_ === o) {
            (f = !0), (o = l), (n = a);
            break;
          }
          _ = _.sibling;
        }
        if (!f) throw Error(St(189));
      }
    }
    if (n.alternate !== o) throw Error(St(190));
  }
  if (n.tag !== 3) throw Error(St(188));
  return n.stateNode.current === n ? e : t;
}
function xb(e) {
  return (e = UT(e)), e !== null ? Mb(e) : null;
}
function Mb(e) {
  if (e.tag === 5 || e.tag === 6) return e;
  for (e = e.child; e !== null; ) {
    var t = Mb(e);
    if (t !== null) return t;
    e = e.sibling;
  }
  return null;
}
var Tb = Ci.unstable_scheduleCallback,
  Fv = Ci.unstable_cancelCallback,
  VT = Ci.unstable_shouldYield,
  WT = Ci.unstable_requestPaint,
  wn = Ci.unstable_now,
  GT = Ci.unstable_getCurrentPriorityLevel,
  r0 = Ci.unstable_ImmediatePriority,
  kb = Ci.unstable_UserBlockingPriority,
  Hh = Ci.unstable_NormalPriority,
  HT = Ci.unstable_LowPriority,
  Sb = Ci.unstable_IdlePriority,
  _m = null,
  mo = null;
function qT(e) {
  if (mo && typeof mo.onCommitFiberRoot == "function")
    try {
      mo.onCommitFiberRoot(_m, e, void 0, (e.current.flags & 128) === 128);
    } catch {}
}
var Ji = Math.clz32 ? Math.clz32 : XT,
  KT = Math.log,
  QT = Math.LN2;
function XT(e) {
  return (e >>>= 0), e === 0 ? 32 : (31 - ((KT(e) / QT) | 0)) | 0;
}
var mh = 64,
  gh = 4194304;
function Df(e) {
  switch (e & -e) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return e;
  }
}
function qh(e, t) {
  var n = e.pendingLanes;
  if (n === 0) return 0;
  var o = 0,
    a = e.suspendedLanes,
    l = e.pingedLanes,
    f = n & 268435455;
  if (f !== 0) {
    var _ = f & ~a;
    _ !== 0 ? (o = Df(_)) : ((l &= f), l !== 0 && (o = Df(l)));
  } else (f = n & ~a), f !== 0 ? (o = Df(f)) : l !== 0 && (o = Df(l));
  if (o === 0) return 0;
  if (
    t !== 0 &&
    t !== o &&
    !(t & a) &&
    ((a = o & -o), (l = t & -t), a >= l || (a === 16 && (l & 4194240) !== 0))
  )
    return t;
  if ((o & 4 && (o |= n & 16), (t = e.entangledLanes), t !== 0))
    for (e = e.entanglements, t &= o; 0 < t; )
      (n = 31 - Ji(t)), (a = 1 << n), (o |= e[n]), (t &= ~a);
  return o;
}
function YT(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function ZT(e, t) {
  for (
    var n = e.suspendedLanes,
      o = e.pingedLanes,
      a = e.expirationTimes,
      l = e.pendingLanes;
    0 < l;

  ) {
    var f = 31 - Ji(l),
      _ = 1 << f,
      m = a[f];
    m === -1
      ? (!(_ & n) || _ & o) && (a[f] = YT(_, t))
      : m <= t && (e.expiredLanes |= _),
      (l &= ~_);
  }
}
function u_(e) {
  return (
    (e = e.pendingLanes & -1073741825),
    e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
  );
}
function Eb() {
  var e = mh;
  return (mh <<= 1), !(mh & 4194240) && (mh = 64), e;
}
function Mg(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e);
  return t;
}
function pp(e, t, n) {
  (e.pendingLanes |= t),
    t !== 536870912 && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
    (e = e.eventTimes),
    (t = 31 - Ji(t)),
    (e[t] = n);
}
function JT(e, t) {
  var n = e.pendingLanes & ~t;
  (e.pendingLanes = t),
    (e.suspendedLanes = 0),
    (e.pingedLanes = 0),
    (e.expiredLanes &= t),
    (e.mutableReadLanes &= t),
    (e.entangledLanes &= t),
    (t = e.entanglements);
  var o = e.eventTimes;
  for (e = e.expirationTimes; 0 < n; ) {
    var a = 31 - Ji(n),
      l = 1 << a;
    (t[a] = 0), (o[a] = -1), (e[a] = -1), (n &= ~l);
  }
}
function n0(e, t) {
  var n = (e.entangledLanes |= t);
  for (e = e.entanglements; n; ) {
    var o = 31 - Ji(n),
      a = 1 << o;
    (a & t) | (e[o] & t) && (e[o] |= t), (n &= ~a);
  }
}
var qr = 0;
function Cb(e) {
  return (e &= -e), 1 < e ? (4 < e ? (e & 268435455 ? 16 : 536870912) : 4) : 1;
}
var Pb,
  i0,
  $b,
  Ab,
  Ib,
  c_ = !1,
  _h = [],
  _s = null,
  ys = null,
  ws = null,
  Yf = new Map(),
  Zf = new Map(),
  ps = [],
  ek =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function zv(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      _s = null;
      break;
    case "dragenter":
    case "dragleave":
      ys = null;
      break;
    case "mouseover":
    case "mouseout":
      ws = null;
      break;
    case "pointerover":
    case "pointerout":
      Yf.delete(t.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Zf.delete(t.pointerId);
  }
}
function Ef(e, t, n, o, a, l) {
  return e === null || e.nativeEvent !== l
    ? ((e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: o,
        nativeEvent: l,
        targetContainers: [a]
      }),
      t !== null && ((t = mp(t)), t !== null && i0(t)),
      e)
    : ((e.eventSystemFlags |= o),
      (t = e.targetContainers),
      a !== null && t.indexOf(a) === -1 && t.push(a),
      e);
}
function tk(e, t, n, o, a) {
  switch (t) {
    case "focusin":
      return (_s = Ef(_s, e, t, n, o, a)), !0;
    case "dragenter":
      return (ys = Ef(ys, e, t, n, o, a)), !0;
    case "mouseover":
      return (ws = Ef(ws, e, t, n, o, a)), !0;
    case "pointerover":
      var l = a.pointerId;
      return Yf.set(l, Ef(Yf.get(l) || null, e, t, n, o, a)), !0;
    case "gotpointercapture":
      return (
        (l = a.pointerId), Zf.set(l, Ef(Zf.get(l) || null, e, t, n, o, a)), !0
      );
  }
  return !1;
}
function Fb(e) {
  var t = oa(e.target);
  if (t !== null) {
    var n = ga(t);
    if (n !== null) {
      if (((t = n.tag), t === 13)) {
        if (((t = bb(n)), t !== null)) {
          (e.blockedOn = t),
            Ib(e.priority, function () {
              $b(n);
            });
          return;
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  e.blockedOn = null;
}
function Ih(e) {
  if (e.blockedOn !== null) return !1;
  for (var t = e.targetContainers; 0 < t.length; ) {
    var n = d_(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
    if (n === null) {
      n = e.nativeEvent;
      var o = new n.constructor(n.type, n);
      (o_ = o), n.target.dispatchEvent(o), (o_ = null);
    } else return (t = mp(n)), t !== null && i0(t), (e.blockedOn = n), !1;
    t.shift();
  }
  return !0;
}
function Ov(e, t, n) {
  Ih(e) && n.delete(t);
}
function rk() {
  (c_ = !1),
    _s !== null && Ih(_s) && (_s = null),
    ys !== null && Ih(ys) && (ys = null),
    ws !== null && Ih(ws) && (ws = null),
    Yf.forEach(Ov),
    Zf.forEach(Ov);
}
function Cf(e, t) {
  e.blockedOn === t &&
    ((e.blockedOn = null),
    c_ ||
      ((c_ = !0),
      Ci.unstable_scheduleCallback(Ci.unstable_NormalPriority, rk)));
}
function Jf(e) {
  function t(a) {
    return Cf(a, e);
  }
  if (0 < _h.length) {
    Cf(_h[0], e);
    for (var n = 1; n < _h.length; n++) {
      var o = _h[n];
      o.blockedOn === e && (o.blockedOn = null);
    }
  }
  for (
    _s !== null && Cf(_s, e),
      ys !== null && Cf(ys, e),
      ws !== null && Cf(ws, e),
      Yf.forEach(t),
      Zf.forEach(t),
      n = 0;
    n < ps.length;
    n++
  )
    (o = ps[n]), o.blockedOn === e && (o.blockedOn = null);
  for (; 0 < ps.length && ((n = ps[0]), n.blockedOn === null); )
    Fb(n), n.blockedOn === null && ps.shift();
}
var lu = jo.ReactCurrentBatchConfig,
  Kh = !0;
function nk(e, t, n, o) {
  var a = qr,
    l = lu.transition;
  lu.transition = null;
  try {
    (qr = 1), o0(e, t, n, o);
  } finally {
    (qr = a), (lu.transition = l);
  }
}
function ik(e, t, n, o) {
  var a = qr,
    l = lu.transition;
  lu.transition = null;
  try {
    (qr = 4), o0(e, t, n, o);
  } finally {
    (qr = a), (lu.transition = l);
  }
}
function o0(e, t, n, o) {
  if (Kh) {
    var a = d_(e, t, n, o);
    if (a === null) Fg(e, t, o, Qh, n), zv(e, o);
    else if (tk(a, e, t, n, o)) o.stopPropagation();
    else if ((zv(e, o), t & 4 && -1 < ek.indexOf(e))) {
      for (; a !== null; ) {
        var l = mp(a);
        if (
          (l !== null && Pb(l),
          (l = d_(e, t, n, o)),
          l === null && Fg(e, t, o, Qh, n),
          l === a)
        )
          break;
        a = l;
      }
      a !== null && o.stopPropagation();
    } else Fg(e, t, o, null, n);
  }
}
var Qh = null;
function d_(e, t, n, o) {
  if (((Qh = null), (e = t0(o)), (e = oa(e)), e !== null))
    if (((t = ga(e)), t === null)) e = null;
    else if (((n = t.tag), n === 13)) {
      if (((e = bb(t)), e !== null)) return e;
      e = null;
    } else if (n === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated)
        return t.tag === 3 ? t.stateNode.containerInfo : null;
      e = null;
    } else t !== e && (e = null);
  return (Qh = e), null;
}
function zb(e) {
  switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (GT()) {
        case r0:
          return 1;
        case kb:
          return 4;
        case Hh:
        case HT:
          return 16;
        case Sb:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var ms = null,
  s0 = null,
  Fh = null;
function Ob() {
  if (Fh) return Fh;
  var e,
    t = s0,
    n = t.length,
    o,
    a = "value" in ms ? ms.value : ms.textContent,
    l = a.length;
  for (e = 0; e < n && t[e] === a[e]; e++);
  var f = n - e;
  for (o = 1; o <= f && t[n - o] === a[l - o]; o++);
  return (Fh = a.slice(e, 1 < o ? 1 - o : void 0));
}
function zh(e) {
  var t = e.keyCode;
  return (
    "charCode" in e
      ? ((e = e.charCode), e === 0 && t === 13 && (e = 13))
      : (e = t),
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
  );
}
function yh() {
  return !0;
}
function Dv() {
  return !1;
}
function $i(e) {
  function t(n, o, a, l, f) {
    (this._reactName = n),
      (this._targetInst = a),
      (this.type = o),
      (this.nativeEvent = l),
      (this.target = f),
      (this.currentTarget = null);
    for (var _ in e)
      e.hasOwnProperty(_) && ((n = e[_]), (this[_] = n ? n(l) : l[_]));
    return (
      (this.isDefaultPrevented = (
        l.defaultPrevented != null ? l.defaultPrevented : l.returnValue === !1
      )
        ? yh
        : Dv),
      (this.isPropagationStopped = Dv),
      this
    );
  }
  return (
    pn(t.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = yh));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = yh));
      },
      persist: function () {},
      isPersistent: yh
    }),
    t
  );
}
var wu = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
      return e.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  a0 = $i(wu),
  hp = pn({}, wu, { view: 0, detail: 0 }),
  ok = $i(hp),
  Tg,
  kg,
  Pf,
  ym = pn({}, hp, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: l0,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
      return e.relatedTarget === void 0
        ? e.fromElement === e.srcElement
          ? e.toElement
          : e.fromElement
        : e.relatedTarget;
    },
    movementX: function (e) {
      return "movementX" in e
        ? e.movementX
        : (e !== Pf &&
            (Pf && e.type === "mousemove"
              ? ((Tg = e.screenX - Pf.screenX), (kg = e.screenY - Pf.screenY))
              : (kg = Tg = 0),
            (Pf = e)),
          Tg);
    },
    movementY: function (e) {
      return "movementY" in e ? e.movementY : kg;
    }
  }),
  Lv = $i(ym),
  sk = pn({}, ym, { dataTransfer: 0 }),
  ak = $i(sk),
  lk = pn({}, hp, { relatedTarget: 0 }),
  Sg = $i(lk),
  uk = pn({}, wu, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  ck = $i(uk),
  dk = pn({}, wu, {
    clipboardData: function (e) {
      return "clipboardData" in e ? e.clipboardData : window.clipboardData;
    }
  }),
  fk = $i(dk),
  pk = pn({}, wu, { data: 0 }),
  Bv = $i(pk),
  hk = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  mk = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  gk = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
function _k(e) {
  var t = this.nativeEvent;
  return t.getModifierState ? t.getModifierState(e) : (e = gk[e]) ? !!t[e] : !1;
}
function l0() {
  return _k;
}
var yk = pn({}, hp, {
    key: function (e) {
      if (e.key) {
        var t = hk[e.key] || e.key;
        if (t !== "Unidentified") return t;
      }
      return e.type === "keypress"
        ? ((e = zh(e)), e === 13 ? "Enter" : String.fromCharCode(e))
        : e.type === "keydown" || e.type === "keyup"
        ? mk[e.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: l0,
    charCode: function (e) {
      return e.type === "keypress" ? zh(e) : 0;
    },
    keyCode: function (e) {
      return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
    },
    which: function (e) {
      return e.type === "keypress"
        ? zh(e)
        : e.type === "keydown" || e.type === "keyup"
        ? e.keyCode
        : 0;
    }
  }),
  wk = $i(yk),
  vk = pn({}, ym, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  Rv = $i(vk),
  bk = pn({}, hp, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: l0
  }),
  xk = $i(bk),
  Mk = pn({}, wu, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Tk = $i(Mk),
  kk = pn({}, ym, {
    deltaX: function (e) {
      return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
    },
    deltaY: function (e) {
      return "deltaY" in e
        ? e.deltaY
        : "wheelDeltaY" in e
        ? -e.wheelDeltaY
        : "wheelDelta" in e
        ? -e.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  Sk = $i(kk),
  Ek = [9, 13, 27, 32],
  u0 = Lo && "CompositionEvent" in window,
  jf = null;
Lo && "documentMode" in document && (jf = document.documentMode);
var Ck = Lo && "TextEvent" in window && !jf,
  Db = Lo && (!u0 || (jf && 8 < jf && 11 >= jf)),
  Nv = " ",
  jv = !1;
function Lb(e, t) {
  switch (e) {
    case "keyup":
      return Ek.indexOf(t.keyCode) !== -1;
    case "keydown":
      return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function Bb(e) {
  return (e = e.detail), typeof e == "object" && "data" in e ? e.data : null;
}
var Ql = !1;
function Pk(e, t) {
  switch (e) {
    case "compositionend":
      return Bb(t);
    case "keypress":
      return t.which !== 32 ? null : ((jv = !0), Nv);
    case "textInput":
      return (e = t.data), e === Nv && jv ? null : e;
    default:
      return null;
  }
}
function $k(e, t) {
  if (Ql)
    return e === "compositionend" || (!u0 && Lb(e, t))
      ? ((e = Ob()), (Fh = s0 = ms = null), (Ql = !1), e)
      : null;
  switch (e) {
    case "paste":
      return null;
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || (t.ctrlKey && t.altKey)) {
        if (t.char && 1 < t.char.length) return t.char;
        if (t.which) return String.fromCharCode(t.which);
      }
      return null;
    case "compositionend":
      return Db && t.locale !== "ko" ? null : t.data;
    default:
      return null;
  }
}
var Ak = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function Uv(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!Ak[e.type] : t === "textarea";
}
function Rb(e, t, n, o) {
  gb(o),
    (t = Xh(t, "onChange")),
    0 < t.length &&
      ((n = new a0("onChange", "change", null, n, o)),
      e.push({ event: n, listeners: t }));
}
var Uf = null,
  ep = null;
function Ik(e) {
  Xb(e, 0);
}
function wm(e) {
  var t = Zl(e);
  if (ub(t)) return e;
}
function Fk(e, t) {
  if (e === "change") return t;
}
var Nb = !1;
if (Lo) {
  var Eg;
  if (Lo) {
    var Cg = "oninput" in document;
    if (!Cg) {
      var Vv = document.createElement("div");
      Vv.setAttribute("oninput", "return;"),
        (Cg = typeof Vv.oninput == "function");
    }
    Eg = Cg;
  } else Eg = !1;
  Nb = Eg && (!document.documentMode || 9 < document.documentMode);
}
function Wv() {
  Uf && (Uf.detachEvent("onpropertychange", jb), (ep = Uf = null));
}
function jb(e) {
  if (e.propertyName === "value" && wm(ep)) {
    var t = [];
    Rb(t, ep, e, t0(e)), vb(Ik, t);
  }
}
function zk(e, t, n) {
  e === "focusin"
    ? (Wv(), (Uf = t), (ep = n), Uf.attachEvent("onpropertychange", jb))
    : e === "focusout" && Wv();
}
function Ok(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown")
    return wm(ep);
}
function Dk(e, t) {
  if (e === "click") return wm(t);
}
function Lk(e, t) {
  if (e === "input" || e === "change") return wm(t);
}
function Bk(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t);
}
var to = typeof Object.is == "function" ? Object.is : Bk;
function tp(e, t) {
  if (to(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  var n = Object.keys(e),
    o = Object.keys(t);
  if (n.length !== o.length) return !1;
  for (o = 0; o < n.length; o++) {
    var a = n[o];
    if (!qg.call(t, a) || !to(e[a], t[a])) return !1;
  }
  return !0;
}
function Gv(e) {
  for (; e && e.firstChild; ) e = e.firstChild;
  return e;
}
function Hv(e, t) {
  var n = Gv(e);
  e = 0;
  for (var o; n; ) {
    if (n.nodeType === 3) {
      if (((o = e + n.textContent.length), e <= t && o >= t))
        return { node: n, offset: t - e };
      e = o;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = Gv(n);
  }
}
function Ub(e, t) {
  return e && t
    ? e === t
      ? !0
      : e && e.nodeType === 3
      ? !1
      : t && t.nodeType === 3
      ? Ub(e, t.parentNode)
      : "contains" in e
      ? e.contains(t)
      : e.compareDocumentPosition
      ? !!(e.compareDocumentPosition(t) & 16)
      : !1
    : !1;
}
function Vb() {
  for (var e = window, t = Vh(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var n = typeof t.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) e = t.contentWindow;
    else break;
    t = Vh(e.document);
  }
  return t;
}
function c0(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return (
    t &&
    ((t === "input" &&
      (e.type === "text" ||
        e.type === "search" ||
        e.type === "tel" ||
        e.type === "url" ||
        e.type === "password")) ||
      t === "textarea" ||
      e.contentEditable === "true")
  );
}
function Rk(e) {
  var t = Vb(),
    n = e.focusedElem,
    o = e.selectionRange;
  if (
    t !== n &&
    n &&
    n.ownerDocument &&
    Ub(n.ownerDocument.documentElement, n)
  ) {
    if (o !== null && c0(n)) {
      if (
        ((t = o.start),
        (e = o.end),
        e === void 0 && (e = t),
        "selectionStart" in n)
      )
        (n.selectionStart = t), (n.selectionEnd = Math.min(e, n.value.length));
      else if (
        ((e = ((t = n.ownerDocument || document) && t.defaultView) || window),
        e.getSelection)
      ) {
        e = e.getSelection();
        var a = n.textContent.length,
          l = Math.min(o.start, a);
        (o = o.end === void 0 ? l : Math.min(o.end, a)),
          !e.extend && l > o && ((a = o), (o = l), (l = a)),
          (a = Hv(n, l));
        var f = Hv(n, o);
        a &&
          f &&
          (e.rangeCount !== 1 ||
            e.anchorNode !== a.node ||
            e.anchorOffset !== a.offset ||
            e.focusNode !== f.node ||
            e.focusOffset !== f.offset) &&
          ((t = t.createRange()),
          t.setStart(a.node, a.offset),
          e.removeAllRanges(),
          l > o
            ? (e.addRange(t), e.extend(f.node, f.offset))
            : (t.setEnd(f.node, f.offset), e.addRange(t)));
      }
    }
    for (t = [], e = n; (e = e.parentNode); )
      e.nodeType === 1 &&
        t.push({ element: e, left: e.scrollLeft, top: e.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)
      (e = t[n]),
        (e.element.scrollLeft = e.left),
        (e.element.scrollTop = e.top);
  }
}
var Nk = Lo && "documentMode" in document && 11 >= document.documentMode,
  Xl = null,
  f_ = null,
  Vf = null,
  p_ = !1;
function qv(e, t, n) {
  var o = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  p_ ||
    Xl == null ||
    Xl !== Vh(o) ||
    ((o = Xl),
    "selectionStart" in o && c0(o)
      ? (o = { start: o.selectionStart, end: o.selectionEnd })
      : ((o = (
          (o.ownerDocument && o.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (o = {
          anchorNode: o.anchorNode,
          anchorOffset: o.anchorOffset,
          focusNode: o.focusNode,
          focusOffset: o.focusOffset
        })),
    (Vf && tp(Vf, o)) ||
      ((Vf = o),
      (o = Xh(f_, "onSelect")),
      0 < o.length &&
        ((t = new a0("onSelect", "select", null, t, n)),
        e.push({ event: t, listeners: o }),
        (t.target = Xl))));
}
function wh(e, t) {
  var n = {};
  return (
    (n[e.toLowerCase()] = t.toLowerCase()),
    (n["Webkit" + e] = "webkit" + t),
    (n["Moz" + e] = "moz" + t),
    n
  );
}
var Yl = {
    animationend: wh("Animation", "AnimationEnd"),
    animationiteration: wh("Animation", "AnimationIteration"),
    animationstart: wh("Animation", "AnimationStart"),
    transitionend: wh("Transition", "TransitionEnd")
  },
  Pg = {},
  Wb = {};
Lo &&
  ((Wb = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Yl.animationend.animation,
    delete Yl.animationiteration.animation,
    delete Yl.animationstart.animation),
  "TransitionEvent" in window || delete Yl.transitionend.transition);
function vm(e) {
  if (Pg[e]) return Pg[e];
  if (!Yl[e]) return e;
  var t = Yl[e],
    n;
  for (n in t) if (t.hasOwnProperty(n) && n in Wb) return (Pg[e] = t[n]);
  return e;
}
var Gb = vm("animationend"),
  Hb = vm("animationiteration"),
  qb = vm("animationstart"),
  Kb = vm("transitionend"),
  Qb = new Map(),
  Kv =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function Es(e, t) {
  Qb.set(e, t), ma(t, [e]);
}
for (var $g = 0; $g < Kv.length; $g++) {
  var Ag = Kv[$g],
    jk = Ag.toLowerCase(),
    Uk = Ag[0].toUpperCase() + Ag.slice(1);
  Es(jk, "on" + Uk);
}
Es(Gb, "onAnimationEnd");
Es(Hb, "onAnimationIteration");
Es(qb, "onAnimationStart");
Es("dblclick", "onDoubleClick");
Es("focusin", "onFocus");
Es("focusout", "onBlur");
Es(Kb, "onTransitionEnd");
du("onMouseEnter", ["mouseout", "mouseover"]);
du("onMouseLeave", ["mouseout", "mouseover"]);
du("onPointerEnter", ["pointerout", "pointerover"]);
du("onPointerLeave", ["pointerout", "pointerover"]);
ma(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
ma(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
ma("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
ma(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
ma(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
ma(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var Lf =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  Vk = new Set("cancel close invalid load scroll toggle".split(" ").concat(Lf));
function Qv(e, t, n) {
  var o = e.type || "unknown-event";
  (e.currentTarget = n), jT(o, t, void 0, e), (e.currentTarget = null);
}
function Xb(e, t) {
  t = (t & 4) !== 0;
  for (var n = 0; n < e.length; n++) {
    var o = e[n],
      a = o.event;
    o = o.listeners;
    e: {
      var l = void 0;
      if (t)
        for (var f = o.length - 1; 0 <= f; f--) {
          var _ = o[f],
            m = _.instance,
            g = _.currentTarget;
          if (((_ = _.listener), m !== l && a.isPropagationStopped())) break e;
          Qv(a, _, g), (l = m);
        }
      else
        for (f = 0; f < o.length; f++) {
          if (
            ((_ = o[f]),
            (m = _.instance),
            (g = _.currentTarget),
            (_ = _.listener),
            m !== l && a.isPropagationStopped())
          )
            break e;
          Qv(a, _, g), (l = m);
        }
    }
  }
  if (Gh) throw ((e = l_), (Gh = !1), (l_ = null), e);
}
function on(e, t) {
  var n = t[y_];
  n === void 0 && (n = t[y_] = new Set());
  var o = e + "__bubble";
  n.has(o) || (Yb(t, e, 2, !1), n.add(o));
}
function Ig(e, t, n) {
  var o = 0;
  t && (o |= 4), Yb(n, e, o, t);
}
var vh = "_reactListening" + Math.random().toString(36).slice(2);
function rp(e) {
  if (!e[vh]) {
    (e[vh] = !0),
      ib.forEach(function (n) {
        n !== "selectionchange" && (Vk.has(n) || Ig(n, !1, e), Ig(n, !0, e));
      });
    var t = e.nodeType === 9 ? e : e.ownerDocument;
    t === null || t[vh] || ((t[vh] = !0), Ig("selectionchange", !1, t));
  }
}
function Yb(e, t, n, o) {
  switch (zb(t)) {
    case 1:
      var a = nk;
      break;
    case 4:
      a = ik;
      break;
    default:
      a = o0;
  }
  (n = a.bind(null, t, n, e)),
    (a = void 0),
    !a_ ||
      (t !== "touchstart" && t !== "touchmove" && t !== "wheel") ||
      (a = !0),
    o
      ? a !== void 0
        ? e.addEventListener(t, n, { capture: !0, passive: a })
        : e.addEventListener(t, n, !0)
      : a !== void 0
      ? e.addEventListener(t, n, { passive: a })
      : e.addEventListener(t, n, !1);
}
function Fg(e, t, n, o, a) {
  var l = o;
  if (!(t & 1) && !(t & 2) && o !== null)
    e: for (;;) {
      if (o === null) return;
      var f = o.tag;
      if (f === 3 || f === 4) {
        var _ = o.stateNode.containerInfo;
        if (_ === a || (_.nodeType === 8 && _.parentNode === a)) break;
        if (f === 4)
          for (f = o.return; f !== null; ) {
            var m = f.tag;
            if (
              (m === 3 || m === 4) &&
              ((m = f.stateNode.containerInfo),
              m === a || (m.nodeType === 8 && m.parentNode === a))
            )
              return;
            f = f.return;
          }
        for (; _ !== null; ) {
          if (((f = oa(_)), f === null)) return;
          if (((m = f.tag), m === 5 || m === 6)) {
            o = l = f;
            continue e;
          }
          _ = _.parentNode;
        }
      }
      o = o.return;
    }
  vb(function () {
    var g = l,
      M = t0(n),
      v = [];
    e: {
      var C = Qb.get(e);
      if (C !== void 0) {
        var T = a0,
          z = e;
        switch (e) {
          case "keypress":
            if (zh(n) === 0) break e;
          case "keydown":
          case "keyup":
            T = wk;
            break;
          case "focusin":
            (z = "focus"), (T = Sg);
            break;
          case "focusout":
            (z = "blur"), (T = Sg);
            break;
          case "beforeblur":
          case "afterblur":
            T = Sg;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            T = Lv;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            T = ak;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            T = xk;
            break;
          case Gb:
          case Hb:
          case qb:
            T = ck;
            break;
          case Kb:
            T = Tk;
            break;
          case "scroll":
            T = ok;
            break;
          case "wheel":
            T = Sk;
            break;
          case "copy":
          case "cut":
          case "paste":
            T = fk;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            T = Rv;
        }
        var $ = (t & 4) !== 0,
          S = !$ && e === "scroll",
          y = $ ? (C !== null ? C + "Capture" : null) : C;
        $ = [];
        for (var x = g, I; x !== null; ) {
          I = x;
          var V = I.stateNode;
          if (
            (I.tag === 5 &&
              V !== null &&
              ((I = V),
              y !== null && ((V = Xf(x, y)), V != null && $.push(np(x, V, I)))),
            S)
          )
            break;
          x = x.return;
        }
        0 < $.length &&
          ((C = new T(C, z, null, n, M)), v.push({ event: C, listeners: $ }));
      }
    }
    if (!(t & 7)) {
      e: {
        if (
          ((C = e === "mouseover" || e === "pointerover"),
          (T = e === "mouseout" || e === "pointerout"),
          C &&
            n !== o_ &&
            (z = n.relatedTarget || n.fromElement) &&
            (oa(z) || z[Bo]))
        )
          break e;
        if (
          (T || C) &&
          ((C =
            M.window === M
              ? M
              : (C = M.ownerDocument)
              ? C.defaultView || C.parentWindow
              : window),
          T
            ? ((z = n.relatedTarget || n.toElement),
              (T = g),
              (z = z ? oa(z) : null),
              z !== null &&
                ((S = ga(z)), z !== S || (z.tag !== 5 && z.tag !== 6)) &&
                (z = null))
            : ((T = null), (z = g)),
          T !== z)
        ) {
          if (
            (($ = Lv),
            (V = "onMouseLeave"),
            (y = "onMouseEnter"),
            (x = "mouse"),
            (e === "pointerout" || e === "pointerover") &&
              (($ = Rv),
              (V = "onPointerLeave"),
              (y = "onPointerEnter"),
              (x = "pointer")),
            (S = T == null ? C : Zl(T)),
            (I = z == null ? C : Zl(z)),
            (C = new $(V, x + "leave", T, n, M)),
            (C.target = S),
            (C.relatedTarget = I),
            (V = null),
            oa(M) === g &&
              (($ = new $(y, x + "enter", z, n, M)),
              ($.target = I),
              ($.relatedTarget = S),
              (V = $)),
            (S = V),
            T && z)
          )
            t: {
              for ($ = T, y = z, x = 0, I = $; I; I = Gl(I)) x++;
              for (I = 0, V = y; V; V = Gl(V)) I++;
              for (; 0 < x - I; ) ($ = Gl($)), x--;
              for (; 0 < I - x; ) (y = Gl(y)), I--;
              for (; x--; ) {
                if ($ === y || (y !== null && $ === y.alternate)) break t;
                ($ = Gl($)), (y = Gl(y));
              }
              $ = null;
            }
          else $ = null;
          T !== null && Xv(v, C, T, $, !1),
            z !== null && S !== null && Xv(v, S, z, $, !0);
        }
      }
      e: {
        if (
          ((C = g ? Zl(g) : window),
          (T = C.nodeName && C.nodeName.toLowerCase()),
          T === "select" || (T === "input" && C.type === "file"))
        )
          var O = Fk;
        else if (Uv(C))
          if (Nb) O = Lk;
          else {
            O = Ok;
            var B = zk;
          }
        else
          (T = C.nodeName) &&
            T.toLowerCase() === "input" &&
            (C.type === "checkbox" || C.type === "radio") &&
            (O = Dk);
        if (O && (O = O(e, g))) {
          Rb(v, O, n, M);
          break e;
        }
        B && B(e, C, g),
          e === "focusout" &&
            (B = C._wrapperState) &&
            B.controlled &&
            C.type === "number" &&
            e_(C, "number", C.value);
      }
      switch (((B = g ? Zl(g) : window), e)) {
        case "focusin":
          (Uv(B) || B.contentEditable === "true") &&
            ((Xl = B), (f_ = g), (Vf = null));
          break;
        case "focusout":
          Vf = f_ = Xl = null;
          break;
        case "mousedown":
          p_ = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (p_ = !1), qv(v, n, M);
          break;
        case "selectionchange":
          if (Nk) break;
        case "keydown":
        case "keyup":
          qv(v, n, M);
      }
      var j;
      if (u0)
        e: {
          switch (e) {
            case "compositionstart":
              var N = "onCompositionStart";
              break e;
            case "compositionend":
              N = "onCompositionEnd";
              break e;
            case "compositionupdate":
              N = "onCompositionUpdate";
              break e;
          }
          N = void 0;
        }
      else
        Ql
          ? Lb(e, n) && (N = "onCompositionEnd")
          : e === "keydown" && n.keyCode === 229 && (N = "onCompositionStart");
      N &&
        (Db &&
          n.locale !== "ko" &&
          (Ql || N !== "onCompositionStart"
            ? N === "onCompositionEnd" && Ql && (j = Ob())
            : ((ms = M),
              (s0 = "value" in ms ? ms.value : ms.textContent),
              (Ql = !0))),
        (B = Xh(g, N)),
        0 < B.length &&
          ((N = new Bv(N, e, null, n, M)),
          v.push({ event: N, listeners: B }),
          j ? (N.data = j) : ((j = Bb(n)), j !== null && (N.data = j)))),
        (j = Ck ? Pk(e, n) : $k(e, n)) &&
          ((g = Xh(g, "onBeforeInput")),
          0 < g.length &&
            ((M = new Bv("onBeforeInput", "beforeinput", null, n, M)),
            v.push({ event: M, listeners: g }),
            (M.data = j)));
    }
    Xb(v, t);
  });
}
function np(e, t, n) {
  return { instance: e, listener: t, currentTarget: n };
}
function Xh(e, t) {
  for (var n = t + "Capture", o = []; e !== null; ) {
    var a = e,
      l = a.stateNode;
    a.tag === 5 &&
      l !== null &&
      ((a = l),
      (l = Xf(e, n)),
      l != null && o.unshift(np(e, l, a)),
      (l = Xf(e, t)),
      l != null && o.push(np(e, l, a))),
      (e = e.return);
  }
  return o;
}
function Gl(e) {
  if (e === null) return null;
  do e = e.return;
  while (e && e.tag !== 5);
  return e || null;
}
function Xv(e, t, n, o, a) {
  for (var l = t._reactName, f = []; n !== null && n !== o; ) {
    var _ = n,
      m = _.alternate,
      g = _.stateNode;
    if (m !== null && m === o) break;
    _.tag === 5 &&
      g !== null &&
      ((_ = g),
      a
        ? ((m = Xf(n, l)), m != null && f.unshift(np(n, m, _)))
        : a || ((m = Xf(n, l)), m != null && f.push(np(n, m, _)))),
      (n = n.return);
  }
  f.length !== 0 && e.push({ event: t, listeners: f });
}
var Wk = /\r\n?/g,
  Gk = /\u0000|\uFFFD/g;
function Yv(e) {
  return (typeof e == "string" ? e : "" + e)
    .replace(
      Wk,
      `
`
    )
    .replace(Gk, "");
}
function bh(e, t, n) {
  if (((t = Yv(t)), Yv(e) !== t && n)) throw Error(St(425));
}
function Yh() {}
var h_ = null,
  m_ = null;
function g_(e, t) {
  return (
    e === "textarea" ||
    e === "noscript" ||
    typeof t.children == "string" ||
    typeof t.children == "number" ||
    (typeof t.dangerouslySetInnerHTML == "object" &&
      t.dangerouslySetInnerHTML !== null &&
      t.dangerouslySetInnerHTML.__html != null)
  );
}
var __ = typeof setTimeout == "function" ? setTimeout : void 0,
  Hk = typeof clearTimeout == "function" ? clearTimeout : void 0,
  Zv = typeof Promise == "function" ? Promise : void 0,
  qk =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof Zv < "u"
      ? function (e) {
          return Zv.resolve(null).then(e).catch(Kk);
        }
      : __;
function Kk(e) {
  setTimeout(function () {
    throw e;
  });
}
function zg(e, t) {
  var n = t,
    o = 0;
  do {
    var a = n.nextSibling;
    if ((e.removeChild(n), a && a.nodeType === 8))
      if (((n = a.data), n === "/$")) {
        if (o === 0) {
          e.removeChild(a), Jf(t);
          return;
        }
        o--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || o++;
    n = a;
  } while (n);
  Jf(t);
}
function vs(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType;
    if (t === 1 || t === 3) break;
    if (t === 8) {
      if (((t = e.data), t === "$" || t === "$!" || t === "$?")) break;
      if (t === "/$") return null;
    }
  }
  return e;
}
function Jv(e) {
  e = e.previousSibling;
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (t === 0) return e;
        t--;
      } else n === "/$" && t++;
    }
    e = e.previousSibling;
  }
  return null;
}
var vu = Math.random().toString(36).slice(2),
  ho = "__reactFiber$" + vu,
  ip = "__reactProps$" + vu,
  Bo = "__reactContainer$" + vu,
  y_ = "__reactEvents$" + vu,
  Qk = "__reactListeners$" + vu,
  Xk = "__reactHandles$" + vu;
function oa(e) {
  var t = e[ho];
  if (t) return t;
  for (var n = e.parentNode; n; ) {
    if ((t = n[Bo] || n[ho])) {
      if (
        ((n = t.alternate),
        t.child !== null || (n !== null && n.child !== null))
      )
        for (e = Jv(e); e !== null; ) {
          if ((n = e[ho])) return n;
          e = Jv(e);
        }
      return t;
    }
    (e = n), (n = e.parentNode);
  }
  return null;
}
function mp(e) {
  return (
    (e = e[ho] || e[Bo]),
    !e || (e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3) ? null : e
  );
}
function Zl(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode;
  throw Error(St(33));
}
function bm(e) {
  return e[ip] || null;
}
var w_ = [],
  Jl = -1;
function Cs(e) {
  return { current: e };
}
function sn(e) {
  0 > Jl || ((e.current = w_[Jl]), (w_[Jl] = null), Jl--);
}
function tn(e, t) {
  Jl++, (w_[Jl] = e.current), (e.current = t);
}
var Ss = {},
  Jn = Cs(Ss),
  mi = Cs(!1),
  ca = Ss;
function fu(e, t) {
  var n = e.type.contextTypes;
  if (!n) return Ss;
  var o = e.stateNode;
  if (o && o.__reactInternalMemoizedUnmaskedChildContext === t)
    return o.__reactInternalMemoizedMaskedChildContext;
  var a = {},
    l;
  for (l in n) a[l] = t[l];
  return (
    o &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = t),
      (e.__reactInternalMemoizedMaskedChildContext = a)),
    a
  );
}
function gi(e) {
  return (e = e.childContextTypes), e != null;
}
function Zh() {
  sn(mi), sn(Jn);
}
function e1(e, t, n) {
  if (Jn.current !== Ss) throw Error(St(168));
  tn(Jn, t), tn(mi, n);
}
function Zb(e, t, n) {
  var o = e.stateNode;
  if (((t = t.childContextTypes), typeof o.getChildContext != "function"))
    return n;
  o = o.getChildContext();
  for (var a in o) if (!(a in t)) throw Error(St(108, zT(e) || "Unknown", a));
  return pn({}, n, o);
}
function Jh(e) {
  return (
    (e =
      ((e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext) || Ss),
    (ca = Jn.current),
    tn(Jn, e),
    tn(mi, mi.current),
    !0
  );
}
function t1(e, t, n) {
  var o = e.stateNode;
  if (!o) throw Error(St(169));
  n
    ? ((e = Zb(e, t, ca)),
      (o.__reactInternalMemoizedMergedChildContext = e),
      sn(mi),
      sn(Jn),
      tn(Jn, e))
    : sn(mi),
    tn(mi, n);
}
var Io = null,
  xm = !1,
  Og = !1;
function Jb(e) {
  Io === null ? (Io = [e]) : Io.push(e);
}
function Yk(e) {
  (xm = !0), Jb(e);
}
function Ps() {
  if (!Og && Io !== null) {
    Og = !0;
    var e = 0,
      t = qr;
    try {
      var n = Io;
      for (qr = 1; e < n.length; e++) {
        var o = n[e];
        do o = o(!0);
        while (o !== null);
      }
      (Io = null), (xm = !1);
    } catch (a) {
      throw (Io !== null && (Io = Io.slice(e + 1)), Tb(r0, Ps), a);
    } finally {
      (qr = t), (Og = !1);
    }
  }
  return null;
}
var eu = [],
  tu = 0,
  em = null,
  tm = 0,
  Bi = [],
  Ri = 0,
  da = null,
  zo = 1,
  Oo = "";
function ra(e, t) {
  (eu[tu++] = tm), (eu[tu++] = em), (em = e), (tm = t);
}
function e2(e, t, n) {
  (Bi[Ri++] = zo), (Bi[Ri++] = Oo), (Bi[Ri++] = da), (da = e);
  var o = zo;
  e = Oo;
  var a = 32 - Ji(o) - 1;
  (o &= ~(1 << a)), (n += 1);
  var l = 32 - Ji(t) + a;
  if (30 < l) {
    var f = a - (a % 5);
    (l = (o & ((1 << f) - 1)).toString(32)),
      (o >>= f),
      (a -= f),
      (zo = (1 << (32 - Ji(t) + a)) | (n << a) | o),
      (Oo = l + e);
  } else (zo = (1 << l) | (n << a) | o), (Oo = e);
}
function d0(e) {
  e.return !== null && (ra(e, 1), e2(e, 1, 0));
}
function f0(e) {
  for (; e === em; )
    (em = eu[--tu]), (eu[tu] = null), (tm = eu[--tu]), (eu[tu] = null);
  for (; e === da; )
    (da = Bi[--Ri]),
      (Bi[Ri] = null),
      (Oo = Bi[--Ri]),
      (Bi[Ri] = null),
      (zo = Bi[--Ri]),
      (Bi[Ri] = null);
}
var Ei = null,
  Si = null,
  ln = !1,
  Zi = null;
function t2(e, t) {
  var n = Ni(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = t),
    (n.return = e),
    (t = e.deletions),
    t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n);
}
function r1(e, t) {
  switch (e.tag) {
    case 5:
      var n = e.type;
      return (
        (t =
          t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase()
            ? null
            : t),
        t !== null
          ? ((e.stateNode = t), (Ei = e), (Si = vs(t.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (t = e.pendingProps === "" || t.nodeType !== 3 ? null : t),
        t !== null ? ((e.stateNode = t), (Ei = e), (Si = null), !0) : !1
      );
    case 13:
      return (
        (t = t.nodeType !== 8 ? null : t),
        t !== null
          ? ((n = da !== null ? { id: zo, overflow: Oo } : null),
            (e.memoizedState = {
              dehydrated: t,
              treeContext: n,
              retryLane: 1073741824
            }),
            (n = Ni(18, null, null, 0)),
            (n.stateNode = t),
            (n.return = e),
            (e.child = n),
            (Ei = e),
            (Si = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function v_(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0;
}
function b_(e) {
  if (ln) {
    var t = Si;
    if (t) {
      var n = t;
      if (!r1(e, t)) {
        if (v_(e)) throw Error(St(418));
        t = vs(n.nextSibling);
        var o = Ei;
        t && r1(e, t)
          ? t2(o, n)
          : ((e.flags = (e.flags & -4097) | 2), (ln = !1), (Ei = e));
      }
    } else {
      if (v_(e)) throw Error(St(418));
      (e.flags = (e.flags & -4097) | 2), (ln = !1), (Ei = e);
    }
  }
}
function n1(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
    e = e.return;
  Ei = e;
}
function xh(e) {
  if (e !== Ei) return !1;
  if (!ln) return n1(e), (ln = !0), !1;
  var t;
  if (
    ((t = e.tag !== 3) &&
      !(t = e.tag !== 5) &&
      ((t = e.type),
      (t = t !== "head" && t !== "body" && !g_(e.type, e.memoizedProps))),
    t && (t = Si))
  ) {
    if (v_(e)) throw (r2(), Error(St(418)));
    for (; t; ) t2(e, t), (t = vs(t.nextSibling));
  }
  if ((n1(e), e.tag === 13)) {
    if (((e = e.memoizedState), (e = e !== null ? e.dehydrated : null), !e))
      throw Error(St(317));
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var n = e.data;
          if (n === "/$") {
            if (t === 0) {
              Si = vs(e.nextSibling);
              break e;
            }
            t--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || t++;
        }
        e = e.nextSibling;
      }
      Si = null;
    }
  } else Si = Ei ? vs(e.stateNode.nextSibling) : null;
  return !0;
}
function r2() {
  for (var e = Si; e; ) e = vs(e.nextSibling);
}
function pu() {
  (Si = Ei = null), (ln = !1);
}
function p0(e) {
  Zi === null ? (Zi = [e]) : Zi.push(e);
}
var Zk = jo.ReactCurrentBatchConfig;
function $f(e, t, n) {
  if (
    ((e = n.ref), e !== null && typeof e != "function" && typeof e != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(St(309));
        var o = n.stateNode;
      }
      if (!o) throw Error(St(147, e));
      var a = o,
        l = "" + e;
      return t !== null &&
        t.ref !== null &&
        typeof t.ref == "function" &&
        t.ref._stringRef === l
        ? t.ref
        : ((t = function (f) {
            var _ = a.refs;
            f === null ? delete _[l] : (_[l] = f);
          }),
          (t._stringRef = l),
          t);
    }
    if (typeof e != "string") throw Error(St(284));
    if (!n._owner) throw Error(St(290, e));
  }
  return e;
}
function Mh(e, t) {
  throw (
    ((e = Object.prototype.toString.call(t)),
    Error(
      St(
        31,
        e === "[object Object]"
          ? "object with keys {" + Object.keys(t).join(", ") + "}"
          : e
      )
    ))
  );
}
function i1(e) {
  var t = e._init;
  return t(e._payload);
}
function n2(e) {
  function t(y, x) {
    if (e) {
      var I = y.deletions;
      I === null ? ((y.deletions = [x]), (y.flags |= 16)) : I.push(x);
    }
  }
  function n(y, x) {
    if (!e) return null;
    for (; x !== null; ) t(y, x), (x = x.sibling);
    return null;
  }
  function o(y, x) {
    for (y = new Map(); x !== null; )
      x.key !== null ? y.set(x.key, x) : y.set(x.index, x), (x = x.sibling);
    return y;
  }
  function a(y, x) {
    return (y = Ts(y, x)), (y.index = 0), (y.sibling = null), y;
  }
  function l(y, x, I) {
    return (
      (y.index = I),
      e
        ? ((I = y.alternate),
          I !== null
            ? ((I = I.index), I < x ? ((y.flags |= 2), x) : I)
            : ((y.flags |= 2), x))
        : ((y.flags |= 1048576), x)
    );
  }
  function f(y) {
    return e && y.alternate === null && (y.flags |= 2), y;
  }
  function _(y, x, I, V) {
    return x === null || x.tag !== 6
      ? ((x = Ug(I, y.mode, V)), (x.return = y), x)
      : ((x = a(x, I)), (x.return = y), x);
  }
  function m(y, x, I, V) {
    var O = I.type;
    return O === Kl
      ? M(y, x, I.props.children, V, I.key)
      : x !== null &&
        (x.elementType === O ||
          (typeof O == "object" &&
            O !== null &&
            O.$$typeof === ds &&
            i1(O) === x.type))
      ? ((V = a(x, I.props)), (V.ref = $f(y, x, I)), (V.return = y), V)
      : ((V = jh(I.type, I.key, I.props, null, y.mode, V)),
        (V.ref = $f(y, x, I)),
        (V.return = y),
        V);
  }
  function g(y, x, I, V) {
    return x === null ||
      x.tag !== 4 ||
      x.stateNode.containerInfo !== I.containerInfo ||
      x.stateNode.implementation !== I.implementation
      ? ((x = Vg(I, y.mode, V)), (x.return = y), x)
      : ((x = a(x, I.children || [])), (x.return = y), x);
  }
  function M(y, x, I, V, O) {
    return x === null || x.tag !== 7
      ? ((x = ua(I, y.mode, V, O)), (x.return = y), x)
      : ((x = a(x, I)), (x.return = y), x);
  }
  function v(y, x, I) {
    if ((typeof x == "string" && x !== "") || typeof x == "number")
      return (x = Ug("" + x, y.mode, I)), (x.return = y), x;
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case fh:
          return (
            (I = jh(x.type, x.key, x.props, null, y.mode, I)),
            (I.ref = $f(y, null, x)),
            (I.return = y),
            I
          );
        case ql:
          return (x = Vg(x, y.mode, I)), (x.return = y), x;
        case ds:
          var V = x._init;
          return v(y, V(x._payload), I);
      }
      if (Of(x) || kf(x))
        return (x = ua(x, y.mode, I, null)), (x.return = y), x;
      Mh(y, x);
    }
    return null;
  }
  function C(y, x, I, V) {
    var O = x !== null ? x.key : null;
    if ((typeof I == "string" && I !== "") || typeof I == "number")
      return O !== null ? null : _(y, x, "" + I, V);
    if (typeof I == "object" && I !== null) {
      switch (I.$$typeof) {
        case fh:
          return I.key === O ? m(y, x, I, V) : null;
        case ql:
          return I.key === O ? g(y, x, I, V) : null;
        case ds:
          return (O = I._init), C(y, x, O(I._payload), V);
      }
      if (Of(I) || kf(I)) return O !== null ? null : M(y, x, I, V, null);
      Mh(y, I);
    }
    return null;
  }
  function T(y, x, I, V, O) {
    if ((typeof V == "string" && V !== "") || typeof V == "number")
      return (y = y.get(I) || null), _(x, y, "" + V, O);
    if (typeof V == "object" && V !== null) {
      switch (V.$$typeof) {
        case fh:
          return (y = y.get(V.key === null ? I : V.key) || null), m(x, y, V, O);
        case ql:
          return (y = y.get(V.key === null ? I : V.key) || null), g(x, y, V, O);
        case ds:
          var B = V._init;
          return T(y, x, I, B(V._payload), O);
      }
      if (Of(V) || kf(V)) return (y = y.get(I) || null), M(x, y, V, O, null);
      Mh(x, V);
    }
    return null;
  }
  function z(y, x, I, V) {
    for (
      var O = null, B = null, j = x, N = (x = 0), se = null;
      j !== null && N < I.length;
      N++
    ) {
      j.index > N ? ((se = j), (j = null)) : (se = j.sibling);
      var de = C(y, j, I[N], V);
      if (de === null) {
        j === null && (j = se);
        break;
      }
      e && j && de.alternate === null && t(y, j),
        (x = l(de, x, N)),
        B === null ? (O = de) : (B.sibling = de),
        (B = de),
        (j = se);
    }
    if (N === I.length) return n(y, j), ln && ra(y, N), O;
    if (j === null) {
      for (; N < I.length; N++)
        (j = v(y, I[N], V)),
          j !== null &&
            ((x = l(j, x, N)), B === null ? (O = j) : (B.sibling = j), (B = j));
      return ln && ra(y, N), O;
    }
    for (j = o(y, j); N < I.length; N++)
      (se = T(j, y, N, I[N], V)),
        se !== null &&
          (e && se.alternate !== null && j.delete(se.key === null ? N : se.key),
          (x = l(se, x, N)),
          B === null ? (O = se) : (B.sibling = se),
          (B = se));
    return (
      e &&
        j.forEach(function (Me) {
          return t(y, Me);
        }),
      ln && ra(y, N),
      O
    );
  }
  function $(y, x, I, V) {
    var O = kf(I);
    if (typeof O != "function") throw Error(St(150));
    if (((I = O.call(I)), I == null)) throw Error(St(151));
    for (
      var B = (O = null), j = x, N = (x = 0), se = null, de = I.next();
      j !== null && !de.done;
      N++, de = I.next()
    ) {
      j.index > N ? ((se = j), (j = null)) : (se = j.sibling);
      var Me = C(y, j, de.value, V);
      if (Me === null) {
        j === null && (j = se);
        break;
      }
      e && j && Me.alternate === null && t(y, j),
        (x = l(Me, x, N)),
        B === null ? (O = Me) : (B.sibling = Me),
        (B = Me),
        (j = se);
    }
    if (de.done) return n(y, j), ln && ra(y, N), O;
    if (j === null) {
      for (; !de.done; N++, de = I.next())
        (de = v(y, de.value, V)),
          de !== null &&
            ((x = l(de, x, N)),
            B === null ? (O = de) : (B.sibling = de),
            (B = de));
      return ln && ra(y, N), O;
    }
    for (j = o(y, j); !de.done; N++, de = I.next())
      (de = T(j, y, N, de.value, V)),
        de !== null &&
          (e && de.alternate !== null && j.delete(de.key === null ? N : de.key),
          (x = l(de, x, N)),
          B === null ? (O = de) : (B.sibling = de),
          (B = de));
    return (
      e &&
        j.forEach(function (J) {
          return t(y, J);
        }),
      ln && ra(y, N),
      O
    );
  }
  function S(y, x, I, V) {
    if (
      (typeof I == "object" &&
        I !== null &&
        I.type === Kl &&
        I.key === null &&
        (I = I.props.children),
      typeof I == "object" && I !== null)
    ) {
      switch (I.$$typeof) {
        case fh:
          e: {
            for (var O = I.key, B = x; B !== null; ) {
              if (B.key === O) {
                if (((O = I.type), O === Kl)) {
                  if (B.tag === 7) {
                    n(y, B.sibling),
                      (x = a(B, I.props.children)),
                      (x.return = y),
                      (y = x);
                    break e;
                  }
                } else if (
                  B.elementType === O ||
                  (typeof O == "object" &&
                    O !== null &&
                    O.$$typeof === ds &&
                    i1(O) === B.type)
                ) {
                  n(y, B.sibling),
                    (x = a(B, I.props)),
                    (x.ref = $f(y, B, I)),
                    (x.return = y),
                    (y = x);
                  break e;
                }
                n(y, B);
                break;
              } else t(y, B);
              B = B.sibling;
            }
            I.type === Kl
              ? ((x = ua(I.props.children, y.mode, V, I.key)),
                (x.return = y),
                (y = x))
              : ((V = jh(I.type, I.key, I.props, null, y.mode, V)),
                (V.ref = $f(y, x, I)),
                (V.return = y),
                (y = V));
          }
          return f(y);
        case ql:
          e: {
            for (B = I.key; x !== null; ) {
              if (x.key === B)
                if (
                  x.tag === 4 &&
                  x.stateNode.containerInfo === I.containerInfo &&
                  x.stateNode.implementation === I.implementation
                ) {
                  n(y, x.sibling),
                    (x = a(x, I.children || [])),
                    (x.return = y),
                    (y = x);
                  break e;
                } else {
                  n(y, x);
                  break;
                }
              else t(y, x);
              x = x.sibling;
            }
            (x = Vg(I, y.mode, V)), (x.return = y), (y = x);
          }
          return f(y);
        case ds:
          return (B = I._init), S(y, x, B(I._payload), V);
      }
      if (Of(I)) return z(y, x, I, V);
      if (kf(I)) return $(y, x, I, V);
      Mh(y, I);
    }
    return (typeof I == "string" && I !== "") || typeof I == "number"
      ? ((I = "" + I),
        x !== null && x.tag === 6
          ? (n(y, x.sibling), (x = a(x, I)), (x.return = y), (y = x))
          : (n(y, x), (x = Ug(I, y.mode, V)), (x.return = y), (y = x)),
        f(y))
      : n(y, x);
  }
  return S;
}
var hu = n2(!0),
  i2 = n2(!1),
  rm = Cs(null),
  nm = null,
  ru = null,
  h0 = null;
function m0() {
  h0 = ru = nm = null;
}
function g0(e) {
  var t = rm.current;
  sn(rm), (e._currentValue = t);
}
function x_(e, t, n) {
  for (; e !== null; ) {
    var o = e.alternate;
    if (
      ((e.childLanes & t) !== t
        ? ((e.childLanes |= t), o !== null && (o.childLanes |= t))
        : o !== null && (o.childLanes & t) !== t && (o.childLanes |= t),
      e === n)
    )
      break;
    e = e.return;
  }
}
function uu(e, t) {
  (nm = e),
    (h0 = ru = null),
    (e = e.dependencies),
    e !== null &&
      e.firstContext !== null &&
      (e.lanes & t && (hi = !0), (e.firstContext = null));
}
function Ui(e) {
  var t = e._currentValue;
  if (h0 !== e)
    if (((e = { context: e, memoizedValue: t, next: null }), ru === null)) {
      if (nm === null) throw Error(St(308));
      (ru = e), (nm.dependencies = { lanes: 0, firstContext: e });
    } else ru = ru.next = e;
  return t;
}
var sa = null;
function _0(e) {
  sa === null ? (sa = [e]) : sa.push(e);
}
function o2(e, t, n, o) {
  var a = t.interleaved;
  return (
    a === null ? ((n.next = n), _0(t)) : ((n.next = a.next), (a.next = n)),
    (t.interleaved = n),
    Ro(e, o)
  );
}
function Ro(e, t) {
  e.lanes |= t;
  var n = e.alternate;
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null; )
    (e.childLanes |= t),
      (n = e.alternate),
      n !== null && (n.childLanes |= t),
      (n = e),
      (e = e.return);
  return n.tag === 3 ? n.stateNode : null;
}
var fs = !1;
function y0(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null
  };
}
function s2(e, t) {
  (e = e.updateQueue),
    t.updateQueue === e &&
      (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects
      });
}
function Do(e, t) {
  return {
    eventTime: e,
    lane: t,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  };
}
function bs(e, t, n) {
  var o = e.updateQueue;
  if (o === null) return null;
  if (((o = o.shared), Rr & 2)) {
    var a = o.pending;
    return (
      a === null ? (t.next = t) : ((t.next = a.next), (a.next = t)),
      (o.pending = t),
      Ro(e, n)
    );
  }
  return (
    (a = o.interleaved),
    a === null ? ((t.next = t), _0(o)) : ((t.next = a.next), (a.next = t)),
    (o.interleaved = t),
    Ro(e, n)
  );
}
function Oh(e, t, n) {
  if (
    ((t = t.updateQueue), t !== null && ((t = t.shared), (n & 4194240) !== 0))
  ) {
    var o = t.lanes;
    (o &= e.pendingLanes), (n |= o), (t.lanes = n), n0(e, n);
  }
}
function o1(e, t) {
  var n = e.updateQueue,
    o = e.alternate;
  if (o !== null && ((o = o.updateQueue), n === o)) {
    var a = null,
      l = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var f = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null
        };
        l === null ? (a = l = f) : (l = l.next = f), (n = n.next);
      } while (n !== null);
      l === null ? (a = l = t) : (l = l.next = t);
    } else a = l = t;
    (n = {
      baseState: o.baseState,
      firstBaseUpdate: a,
      lastBaseUpdate: l,
      shared: o.shared,
      effects: o.effects
    }),
      (e.updateQueue = n);
    return;
  }
  (e = n.lastBaseUpdate),
    e === null ? (n.firstBaseUpdate = t) : (e.next = t),
    (n.lastBaseUpdate = t);
}
function im(e, t, n, o) {
  var a = e.updateQueue;
  fs = !1;
  var l = a.firstBaseUpdate,
    f = a.lastBaseUpdate,
    _ = a.shared.pending;
  if (_ !== null) {
    a.shared.pending = null;
    var m = _,
      g = m.next;
    (m.next = null), f === null ? (l = g) : (f.next = g), (f = m);
    var M = e.alternate;
    M !== null &&
      ((M = M.updateQueue),
      (_ = M.lastBaseUpdate),
      _ !== f &&
        (_ === null ? (M.firstBaseUpdate = g) : (_.next = g),
        (M.lastBaseUpdate = m)));
  }
  if (l !== null) {
    var v = a.baseState;
    (f = 0), (M = g = m = null), (_ = l);
    do {
      var C = _.lane,
        T = _.eventTime;
      if ((o & C) === C) {
        M !== null &&
          (M = M.next =
            {
              eventTime: T,
              lane: 0,
              tag: _.tag,
              payload: _.payload,
              callback: _.callback,
              next: null
            });
        e: {
          var z = e,
            $ = _;
          switch (((C = t), (T = n), $.tag)) {
            case 1:
              if (((z = $.payload), typeof z == "function")) {
                v = z.call(T, v, C);
                break e;
              }
              v = z;
              break e;
            case 3:
              z.flags = (z.flags & -65537) | 128;
            case 0:
              if (
                ((z = $.payload),
                (C = typeof z == "function" ? z.call(T, v, C) : z),
                C == null)
              )
                break e;
              v = pn({}, v, C);
              break e;
            case 2:
              fs = !0;
          }
        }
        _.callback !== null &&
          _.lane !== 0 &&
          ((e.flags |= 64),
          (C = a.effects),
          C === null ? (a.effects = [_]) : C.push(_));
      } else
        (T = {
          eventTime: T,
          lane: C,
          tag: _.tag,
          payload: _.payload,
          callback: _.callback,
          next: null
        }),
          M === null ? ((g = M = T), (m = v)) : (M = M.next = T),
          (f |= C);
      if (((_ = _.next), _ === null)) {
        if (((_ = a.shared.pending), _ === null)) break;
        (C = _),
          (_ = C.next),
          (C.next = null),
          (a.lastBaseUpdate = C),
          (a.shared.pending = null);
      }
    } while (!0);
    if (
      (M === null && (m = v),
      (a.baseState = m),
      (a.firstBaseUpdate = g),
      (a.lastBaseUpdate = M),
      (t = a.shared.interleaved),
      t !== null)
    ) {
      a = t;
      do (f |= a.lane), (a = a.next);
      while (a !== t);
    } else l === null && (a.shared.lanes = 0);
    (pa |= f), (e.lanes = f), (e.memoizedState = v);
  }
}
function s1(e, t, n) {
  if (((e = t.effects), (t.effects = null), e !== null))
    for (t = 0; t < e.length; t++) {
      var o = e[t],
        a = o.callback;
      if (a !== null) {
        if (((o.callback = null), (o = n), typeof a != "function"))
          throw Error(St(191, a));
        a.call(o);
      }
    }
}
var gp = {},
  go = Cs(gp),
  op = Cs(gp),
  sp = Cs(gp);
function aa(e) {
  if (e === gp) throw Error(St(174));
  return e;
}
function w0(e, t) {
  switch ((tn(sp, t), tn(op, e), tn(go, gp), (e = t.nodeType), e)) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : r_(null, "");
      break;
    default:
      (e = e === 8 ? t.parentNode : t),
        (t = e.namespaceURI || null),
        (e = e.tagName),
        (t = r_(t, e));
  }
  sn(go), tn(go, t);
}
function mu() {
  sn(go), sn(op), sn(sp);
}
function a2(e) {
  aa(sp.current);
  var t = aa(go.current),
    n = r_(t, e.type);
  t !== n && (tn(op, e), tn(go, n));
}
function v0(e) {
  op.current === e && (sn(go), sn(op));
}
var dn = Cs(0);
function om(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var n = t.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return t;
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t;
    } else if (t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
  return null;
}
var Dg = [];
function b0() {
  for (var e = 0; e < Dg.length; e++)
    Dg[e]._workInProgressVersionPrimary = null;
  Dg.length = 0;
}
var Dh = jo.ReactCurrentDispatcher,
  Lg = jo.ReactCurrentBatchConfig,
  fa = 0,
  fn = null,
  Pn = null,
  Dn = null,
  sm = !1,
  Wf = !1,
  ap = 0,
  Jk = 0;
function Xn() {
  throw Error(St(321));
}
function x0(e, t) {
  if (t === null) return !1;
  for (var n = 0; n < t.length && n < e.length; n++)
    if (!to(e[n], t[n])) return !1;
  return !0;
}
function M0(e, t, n, o, a, l) {
  if (
    ((fa = l),
    (fn = t),
    (t.memoizedState = null),
    (t.updateQueue = null),
    (t.lanes = 0),
    (Dh.current = e === null || e.memoizedState === null ? nS : iS),
    (e = n(o, a)),
    Wf)
  ) {
    l = 0;
    do {
      if (((Wf = !1), (ap = 0), 25 <= l)) throw Error(St(301));
      (l += 1),
        (Dn = Pn = null),
        (t.updateQueue = null),
        (Dh.current = oS),
        (e = n(o, a));
    } while (Wf);
  }
  if (
    ((Dh.current = am),
    (t = Pn !== null && Pn.next !== null),
    (fa = 0),
    (Dn = Pn = fn = null),
    (sm = !1),
    t)
  )
    throw Error(St(300));
  return e;
}
function T0() {
  var e = ap !== 0;
  return (ap = 0), e;
}
function po() {
  var e = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  return Dn === null ? (fn.memoizedState = Dn = e) : (Dn = Dn.next = e), Dn;
}
function Vi() {
  if (Pn === null) {
    var e = fn.alternate;
    e = e !== null ? e.memoizedState : null;
  } else e = Pn.next;
  var t = Dn === null ? fn.memoizedState : Dn.next;
  if (t !== null) (Dn = t), (Pn = e);
  else {
    if (e === null) throw Error(St(310));
    (Pn = e),
      (e = {
        memoizedState: Pn.memoizedState,
        baseState: Pn.baseState,
        baseQueue: Pn.baseQueue,
        queue: Pn.queue,
        next: null
      }),
      Dn === null ? (fn.memoizedState = Dn = e) : (Dn = Dn.next = e);
  }
  return Dn;
}
function lp(e, t) {
  return typeof t == "function" ? t(e) : t;
}
function Bg(e) {
  var t = Vi(),
    n = t.queue;
  if (n === null) throw Error(St(311));
  n.lastRenderedReducer = e;
  var o = Pn,
    a = o.baseQueue,
    l = n.pending;
  if (l !== null) {
    if (a !== null) {
      var f = a.next;
      (a.next = l.next), (l.next = f);
    }
    (o.baseQueue = a = l), (n.pending = null);
  }
  if (a !== null) {
    (l = a.next), (o = o.baseState);
    var _ = (f = null),
      m = null,
      g = l;
    do {
      var M = g.lane;
      if ((fa & M) === M)
        m !== null &&
          (m = m.next =
            {
              lane: 0,
              action: g.action,
              hasEagerState: g.hasEagerState,
              eagerState: g.eagerState,
              next: null
            }),
          (o = g.hasEagerState ? g.eagerState : e(o, g.action));
      else {
        var v = {
          lane: M,
          action: g.action,
          hasEagerState: g.hasEagerState,
          eagerState: g.eagerState,
          next: null
        };
        m === null ? ((_ = m = v), (f = o)) : (m = m.next = v),
          (fn.lanes |= M),
          (pa |= M);
      }
      g = g.next;
    } while (g !== null && g !== l);
    m === null ? (f = o) : (m.next = _),
      to(o, t.memoizedState) || (hi = !0),
      (t.memoizedState = o),
      (t.baseState = f),
      (t.baseQueue = m),
      (n.lastRenderedState = o);
  }
  if (((e = n.interleaved), e !== null)) {
    a = e;
    do (l = a.lane), (fn.lanes |= l), (pa |= l), (a = a.next);
    while (a !== e);
  } else a === null && (n.lanes = 0);
  return [t.memoizedState, n.dispatch];
}
function Rg(e) {
  var t = Vi(),
    n = t.queue;
  if (n === null) throw Error(St(311));
  n.lastRenderedReducer = e;
  var o = n.dispatch,
    a = n.pending,
    l = t.memoizedState;
  if (a !== null) {
    n.pending = null;
    var f = (a = a.next);
    do (l = e(l, f.action)), (f = f.next);
    while (f !== a);
    to(l, t.memoizedState) || (hi = !0),
      (t.memoizedState = l),
      t.baseQueue === null && (t.baseState = l),
      (n.lastRenderedState = l);
  }
  return [l, o];
}
function l2() {}
function u2(e, t) {
  var n = fn,
    o = Vi(),
    a = t(),
    l = !to(o.memoizedState, a);
  if (
    (l && ((o.memoizedState = a), (hi = !0)),
    (o = o.queue),
    k0(f2.bind(null, n, o, e), [e]),
    o.getSnapshot !== t || l || (Dn !== null && Dn.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      up(9, d2.bind(null, n, o, a, t), void 0, null),
      Ln === null)
    )
      throw Error(St(349));
    fa & 30 || c2(n, t, a);
  }
  return a;
}
function c2(e, t, n) {
  (e.flags |= 16384),
    (e = { getSnapshot: t, value: n }),
    (t = fn.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (fn.updateQueue = t),
        (t.stores = [e]))
      : ((n = t.stores), n === null ? (t.stores = [e]) : n.push(e));
}
function d2(e, t, n, o) {
  (t.value = n), (t.getSnapshot = o), p2(t) && h2(e);
}
function f2(e, t, n) {
  return n(function () {
    p2(t) && h2(e);
  });
}
function p2(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var n = t();
    return !to(e, n);
  } catch {
    return !0;
  }
}
function h2(e) {
  var t = Ro(e, 1);
  t !== null && eo(t, e, 1, -1);
}
function a1(e) {
  var t = po();
  return (
    typeof e == "function" && (e = e()),
    (t.memoizedState = t.baseState = e),
    (e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: lp,
      lastRenderedState: e
    }),
    (t.queue = e),
    (e = e.dispatch = rS.bind(null, fn, e)),
    [t.memoizedState, e]
  );
}
function up(e, t, n, o) {
  return (
    (e = { tag: e, create: t, destroy: n, deps: o, next: null }),
    (t = fn.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (fn.updateQueue = t),
        (t.lastEffect = e.next = e))
      : ((n = t.lastEffect),
        n === null
          ? (t.lastEffect = e.next = e)
          : ((o = n.next), (n.next = e), (e.next = o), (t.lastEffect = e))),
    e
  );
}
function m2() {
  return Vi().memoizedState;
}
function Lh(e, t, n, o) {
  var a = po();
  (fn.flags |= e),
    (a.memoizedState = up(1 | t, n, void 0, o === void 0 ? null : o));
}
function Mm(e, t, n, o) {
  var a = Vi();
  o = o === void 0 ? null : o;
  var l = void 0;
  if (Pn !== null) {
    var f = Pn.memoizedState;
    if (((l = f.destroy), o !== null && x0(o, f.deps))) {
      a.memoizedState = up(t, n, l, o);
      return;
    }
  }
  (fn.flags |= e), (a.memoizedState = up(1 | t, n, l, o));
}
function l1(e, t) {
  return Lh(8390656, 8, e, t);
}
function k0(e, t) {
  return Mm(2048, 8, e, t);
}
function g2(e, t) {
  return Mm(4, 2, e, t);
}
function _2(e, t) {
  return Mm(4, 4, e, t);
}
function y2(e, t) {
  if (typeof t == "function")
    return (
      (e = e()),
      t(e),
      function () {
        t(null);
      }
    );
  if (t != null)
    return (
      (e = e()),
      (t.current = e),
      function () {
        t.current = null;
      }
    );
}
function w2(e, t, n) {
  return (
    (n = n != null ? n.concat([e]) : null), Mm(4, 4, y2.bind(null, t, e), n)
  );
}
function S0() {}
function v2(e, t) {
  var n = Vi();
  t = t === void 0 ? null : t;
  var o = n.memoizedState;
  return o !== null && t !== null && x0(t, o[1])
    ? o[0]
    : ((n.memoizedState = [e, t]), e);
}
function b2(e, t) {
  var n = Vi();
  t = t === void 0 ? null : t;
  var o = n.memoizedState;
  return o !== null && t !== null && x0(t, o[1])
    ? o[0]
    : ((e = e()), (n.memoizedState = [e, t]), e);
}
function x2(e, t, n) {
  return fa & 21
    ? (to(n, t) || ((n = Eb()), (fn.lanes |= n), (pa |= n), (e.baseState = !0)),
      t)
    : (e.baseState && ((e.baseState = !1), (hi = !0)), (e.memoizedState = n));
}
function eS(e, t) {
  var n = qr;
  (qr = n !== 0 && 4 > n ? n : 4), e(!0);
  var o = Lg.transition;
  Lg.transition = {};
  try {
    e(!1), t();
  } finally {
    (qr = n), (Lg.transition = o);
  }
}
function M2() {
  return Vi().memoizedState;
}
function tS(e, t, n) {
  var o = Ms(e);
  if (
    ((n = {
      lane: o,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }),
    T2(e))
  )
    k2(t, n);
  else if (((n = o2(e, t, n, o)), n !== null)) {
    var a = si();
    eo(n, e, o, a), S2(n, t, o);
  }
}
function rS(e, t, n) {
  var o = Ms(e),
    a = { lane: o, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (T2(e)) k2(t, a);
  else {
    var l = e.alternate;
    if (
      e.lanes === 0 &&
      (l === null || l.lanes === 0) &&
      ((l = t.lastRenderedReducer), l !== null)
    )
      try {
        var f = t.lastRenderedState,
          _ = l(f, n);
        if (((a.hasEagerState = !0), (a.eagerState = _), to(_, f))) {
          var m = t.interleaved;
          m === null
            ? ((a.next = a), _0(t))
            : ((a.next = m.next), (m.next = a)),
            (t.interleaved = a);
          return;
        }
      } catch {
      } finally {
      }
    (n = o2(e, t, a, o)),
      n !== null && ((a = si()), eo(n, e, o, a), S2(n, t, o));
  }
}
function T2(e) {
  var t = e.alternate;
  return e === fn || (t !== null && t === fn);
}
function k2(e, t) {
  Wf = sm = !0;
  var n = e.pending;
  n === null ? (t.next = t) : ((t.next = n.next), (n.next = t)),
    (e.pending = t);
}
function S2(e, t, n) {
  if (n & 4194240) {
    var o = t.lanes;
    (o &= e.pendingLanes), (n |= o), (t.lanes = n), n0(e, n);
  }
}
var am = {
    readContext: Ui,
    useCallback: Xn,
    useContext: Xn,
    useEffect: Xn,
    useImperativeHandle: Xn,
    useInsertionEffect: Xn,
    useLayoutEffect: Xn,
    useMemo: Xn,
    useReducer: Xn,
    useRef: Xn,
    useState: Xn,
    useDebugValue: Xn,
    useDeferredValue: Xn,
    useTransition: Xn,
    useMutableSource: Xn,
    useSyncExternalStore: Xn,
    useId: Xn,
    unstable_isNewReconciler: !1
  },
  nS = {
    readContext: Ui,
    useCallback: function (e, t) {
      return (po().memoizedState = [e, t === void 0 ? null : t]), e;
    },
    useContext: Ui,
    useEffect: l1,
    useImperativeHandle: function (e, t, n) {
      return (
        (n = n != null ? n.concat([e]) : null),
        Lh(4194308, 4, y2.bind(null, t, e), n)
      );
    },
    useLayoutEffect: function (e, t) {
      return Lh(4194308, 4, e, t);
    },
    useInsertionEffect: function (e, t) {
      return Lh(4, 2, e, t);
    },
    useMemo: function (e, t) {
      var n = po();
      return (
        (t = t === void 0 ? null : t), (e = e()), (n.memoizedState = [e, t]), e
      );
    },
    useReducer: function (e, t, n) {
      var o = po();
      return (
        (t = n !== void 0 ? n(t) : t),
        (o.memoizedState = o.baseState = t),
        (e = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: e,
          lastRenderedState: t
        }),
        (o.queue = e),
        (e = e.dispatch = tS.bind(null, fn, e)),
        [o.memoizedState, e]
      );
    },
    useRef: function (e) {
      var t = po();
      return (e = { current: e }), (t.memoizedState = e);
    },
    useState: a1,
    useDebugValue: S0,
    useDeferredValue: function (e) {
      return (po().memoizedState = e);
    },
    useTransition: function () {
      var e = a1(!1),
        t = e[0];
      return (e = eS.bind(null, e[1])), (po().memoizedState = e), [t, e];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (e, t, n) {
      var o = fn,
        a = po();
      if (ln) {
        if (n === void 0) throw Error(St(407));
        n = n();
      } else {
        if (((n = t()), Ln === null)) throw Error(St(349));
        fa & 30 || c2(o, t, n);
      }
      a.memoizedState = n;
      var l = { value: n, getSnapshot: t };
      return (
        (a.queue = l),
        l1(f2.bind(null, o, l, e), [e]),
        (o.flags |= 2048),
        up(9, d2.bind(null, o, l, n, t), void 0, null),
        n
      );
    },
    useId: function () {
      var e = po(),
        t = Ln.identifierPrefix;
      if (ln) {
        var n = Oo,
          o = zo;
        (n = (o & ~(1 << (32 - Ji(o) - 1))).toString(32) + n),
          (t = ":" + t + "R" + n),
          (n = ap++),
          0 < n && (t += "H" + n.toString(32)),
          (t += ":");
      } else (n = Jk++), (t = ":" + t + "r" + n.toString(32) + ":");
      return (e.memoizedState = t);
    },
    unstable_isNewReconciler: !1
  },
  iS = {
    readContext: Ui,
    useCallback: v2,
    useContext: Ui,
    useEffect: k0,
    useImperativeHandle: w2,
    useInsertionEffect: g2,
    useLayoutEffect: _2,
    useMemo: b2,
    useReducer: Bg,
    useRef: m2,
    useState: function () {
      return Bg(lp);
    },
    useDebugValue: S0,
    useDeferredValue: function (e) {
      var t = Vi();
      return x2(t, Pn.memoizedState, e);
    },
    useTransition: function () {
      var e = Bg(lp)[0],
        t = Vi().memoizedState;
      return [e, t];
    },
    useMutableSource: l2,
    useSyncExternalStore: u2,
    useId: M2,
    unstable_isNewReconciler: !1
  },
  oS = {
    readContext: Ui,
    useCallback: v2,
    useContext: Ui,
    useEffect: k0,
    useImperativeHandle: w2,
    useInsertionEffect: g2,
    useLayoutEffect: _2,
    useMemo: b2,
    useReducer: Rg,
    useRef: m2,
    useState: function () {
      return Rg(lp);
    },
    useDebugValue: S0,
    useDeferredValue: function (e) {
      var t = Vi();
      return Pn === null ? (t.memoizedState = e) : x2(t, Pn.memoizedState, e);
    },
    useTransition: function () {
      var e = Rg(lp)[0],
        t = Vi().memoizedState;
      return [e, t];
    },
    useMutableSource: l2,
    useSyncExternalStore: u2,
    useId: M2,
    unstable_isNewReconciler: !1
  };
function Xi(e, t) {
  if (e && e.defaultProps) {
    (t = pn({}, t)), (e = e.defaultProps);
    for (var n in e) t[n] === void 0 && (t[n] = e[n]);
    return t;
  }
  return t;
}
function M_(e, t, n, o) {
  (t = e.memoizedState),
    (n = n(o, t)),
    (n = n == null ? t : pn({}, t, n)),
    (e.memoizedState = n),
    e.lanes === 0 && (e.updateQueue.baseState = n);
}
var Tm = {
  isMounted: function (e) {
    return (e = e._reactInternals) ? ga(e) === e : !1;
  },
  enqueueSetState: function (e, t, n) {
    e = e._reactInternals;
    var o = si(),
      a = Ms(e),
      l = Do(o, a);
    (l.payload = t),
      n != null && (l.callback = n),
      (t = bs(e, l, a)),
      t !== null && (eo(t, e, a, o), Oh(t, e, a));
  },
  enqueueReplaceState: function (e, t, n) {
    e = e._reactInternals;
    var o = si(),
      a = Ms(e),
      l = Do(o, a);
    (l.tag = 1),
      (l.payload = t),
      n != null && (l.callback = n),
      (t = bs(e, l, a)),
      t !== null && (eo(t, e, a, o), Oh(t, e, a));
  },
  enqueueForceUpdate: function (e, t) {
    e = e._reactInternals;
    var n = si(),
      o = Ms(e),
      a = Do(n, o);
    (a.tag = 2),
      t != null && (a.callback = t),
      (t = bs(e, a, o)),
      t !== null && (eo(t, e, o, n), Oh(t, e, o));
  }
};
function u1(e, t, n, o, a, l, f) {
  return (
    (e = e.stateNode),
    typeof e.shouldComponentUpdate == "function"
      ? e.shouldComponentUpdate(o, l, f)
      : t.prototype && t.prototype.isPureReactComponent
      ? !tp(n, o) || !tp(a, l)
      : !0
  );
}
function E2(e, t, n) {
  var o = !1,
    a = Ss,
    l = t.contextType;
  return (
    typeof l == "object" && l !== null
      ? (l = Ui(l))
      : ((a = gi(t) ? ca : Jn.current),
        (o = t.contextTypes),
        (l = (o = o != null) ? fu(e, a) : Ss)),
    (t = new t(n, l)),
    (e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null),
    (t.updater = Tm),
    (e.stateNode = t),
    (t._reactInternals = e),
    o &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = a),
      (e.__reactInternalMemoizedMaskedChildContext = l)),
    t
  );
}
function c1(e, t, n, o) {
  (e = t.state),
    typeof t.componentWillReceiveProps == "function" &&
      t.componentWillReceiveProps(n, o),
    typeof t.UNSAFE_componentWillReceiveProps == "function" &&
      t.UNSAFE_componentWillReceiveProps(n, o),
    t.state !== e && Tm.enqueueReplaceState(t, t.state, null);
}
function T_(e, t, n, o) {
  var a = e.stateNode;
  (a.props = n), (a.state = e.memoizedState), (a.refs = {}), y0(e);
  var l = t.contextType;
  typeof l == "object" && l !== null
    ? (a.context = Ui(l))
    : ((l = gi(t) ? ca : Jn.current), (a.context = fu(e, l))),
    (a.state = e.memoizedState),
    (l = t.getDerivedStateFromProps),
    typeof l == "function" && (M_(e, t, l, n), (a.state = e.memoizedState)),
    typeof t.getDerivedStateFromProps == "function" ||
      typeof a.getSnapshotBeforeUpdate == "function" ||
      (typeof a.UNSAFE_componentWillMount != "function" &&
        typeof a.componentWillMount != "function") ||
      ((t = a.state),
      typeof a.componentWillMount == "function" && a.componentWillMount(),
      typeof a.UNSAFE_componentWillMount == "function" &&
        a.UNSAFE_componentWillMount(),
      t !== a.state && Tm.enqueueReplaceState(a, a.state, null),
      im(e, n, a, o),
      (a.state = e.memoizedState)),
    typeof a.componentDidMount == "function" && (e.flags |= 4194308);
}
function gu(e, t) {
  try {
    var n = "",
      o = t;
    do (n += FT(o)), (o = o.return);
    while (o);
    var a = n;
  } catch (l) {
    a =
      `
Error generating stack: ` +
      l.message +
      `
` +
      l.stack;
  }
  return { value: e, source: t, stack: a, digest: null };
}
function Ng(e, t, n) {
  return { value: e, source: null, stack: n ?? null, digest: t ?? null };
}
function k_(e, t) {
  try {
    console.error(t.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var sS = typeof WeakMap == "function" ? WeakMap : Map;
function C2(e, t, n) {
  (n = Do(-1, n)), (n.tag = 3), (n.payload = { element: null });
  var o = t.value;
  return (
    (n.callback = function () {
      um || ((um = !0), (O_ = o)), k_(e, t);
    }),
    n
  );
}
function P2(e, t, n) {
  (n = Do(-1, n)), (n.tag = 3);
  var o = e.type.getDerivedStateFromError;
  if (typeof o == "function") {
    var a = t.value;
    (n.payload = function () {
      return o(a);
    }),
      (n.callback = function () {
        k_(e, t);
      });
  }
  var l = e.stateNode;
  return (
    l !== null &&
      typeof l.componentDidCatch == "function" &&
      (n.callback = function () {
        k_(e, t),
          typeof o != "function" &&
            (xs === null ? (xs = new Set([this])) : xs.add(this));
        var f = t.stack;
        this.componentDidCatch(t.value, {
          componentStack: f !== null ? f : ""
        });
      }),
    n
  );
}
function d1(e, t, n) {
  var o = e.pingCache;
  if (o === null) {
    o = e.pingCache = new sS();
    var a = new Set();
    o.set(t, a);
  } else (a = o.get(t)), a === void 0 && ((a = new Set()), o.set(t, a));
  a.has(n) || (a.add(n), (e = vS.bind(null, e, t, n)), t.then(e, e));
}
function f1(e) {
  do {
    var t;
    if (
      ((t = e.tag === 13) &&
        ((t = e.memoizedState), (t = t !== null ? t.dehydrated !== null : !0)),
      t)
    )
      return e;
    e = e.return;
  } while (e !== null);
  return null;
}
function p1(e, t, n, o, a) {
  return e.mode & 1
    ? ((e.flags |= 65536), (e.lanes = a), e)
    : (e === t
        ? (e.flags |= 65536)
        : ((e.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((t = Do(-1, 1)), (t.tag = 2), bs(n, t, 1))),
          (n.lanes |= 1)),
      e);
}
var aS = jo.ReactCurrentOwner,
  hi = !1;
function oi(e, t, n, o) {
  t.child = e === null ? i2(t, null, n, o) : hu(t, e.child, n, o);
}
function h1(e, t, n, o, a) {
  n = n.render;
  var l = t.ref;
  return (
    uu(t, a),
    (o = M0(e, t, n, o, l, a)),
    (n = T0()),
    e !== null && !hi
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~a),
        No(e, t, a))
      : (ln && n && d0(t), (t.flags |= 1), oi(e, t, o, a), t.child)
  );
}
function m1(e, t, n, o, a) {
  if (e === null) {
    var l = n.type;
    return typeof l == "function" &&
      !z0(l) &&
      l.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((t.tag = 15), (t.type = l), $2(e, t, l, o, a))
      : ((e = jh(n.type, null, o, t, t.mode, a)),
        (e.ref = t.ref),
        (e.return = t),
        (t.child = e));
  }
  if (((l = e.child), !(e.lanes & a))) {
    var f = l.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : tp), n(f, o) && e.ref === t.ref)
    )
      return No(e, t, a);
  }
  return (
    (t.flags |= 1),
    (e = Ts(l, o)),
    (e.ref = t.ref),
    (e.return = t),
    (t.child = e)
  );
}
function $2(e, t, n, o, a) {
  if (e !== null) {
    var l = e.memoizedProps;
    if (tp(l, o) && e.ref === t.ref)
      if (((hi = !1), (t.pendingProps = o = l), (e.lanes & a) !== 0))
        e.flags & 131072 && (hi = !0);
      else return (t.lanes = e.lanes), No(e, t, a);
  }
  return S_(e, t, n, o, a);
}
function A2(e, t, n) {
  var o = t.pendingProps,
    a = o.children,
    l = e !== null ? e.memoizedState : null;
  if (o.mode === "hidden")
    if (!(t.mode & 1))
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        tn(iu, ki),
        (ki |= n);
    else {
      if (!(n & 1073741824))
        return (
          (e = l !== null ? l.baseLanes | n : n),
          (t.lanes = t.childLanes = 1073741824),
          (t.memoizedState = {
            baseLanes: e,
            cachePool: null,
            transitions: null
          }),
          (t.updateQueue = null),
          tn(iu, ki),
          (ki |= e),
          null
        );
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (o = l !== null ? l.baseLanes : n),
        tn(iu, ki),
        (ki |= o);
    }
  else
    l !== null ? ((o = l.baseLanes | n), (t.memoizedState = null)) : (o = n),
      tn(iu, ki),
      (ki |= o);
  return oi(e, t, a, n), t.child;
}
function I2(e, t) {
  var n = t.ref;
  ((e === null && n !== null) || (e !== null && e.ref !== n)) &&
    ((t.flags |= 512), (t.flags |= 2097152));
}
function S_(e, t, n, o, a) {
  var l = gi(n) ? ca : Jn.current;
  return (
    (l = fu(t, l)),
    uu(t, a),
    (n = M0(e, t, n, o, l, a)),
    (o = T0()),
    e !== null && !hi
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~a),
        No(e, t, a))
      : (ln && o && d0(t), (t.flags |= 1), oi(e, t, n, a), t.child)
  );
}
function g1(e, t, n, o, a) {
  if (gi(n)) {
    var l = !0;
    Jh(t);
  } else l = !1;
  if ((uu(t, a), t.stateNode === null))
    Bh(e, t), E2(t, n, o), T_(t, n, o, a), (o = !0);
  else if (e === null) {
    var f = t.stateNode,
      _ = t.memoizedProps;
    f.props = _;
    var m = f.context,
      g = n.contextType;
    typeof g == "object" && g !== null
      ? (g = Ui(g))
      : ((g = gi(n) ? ca : Jn.current), (g = fu(t, g)));
    var M = n.getDerivedStateFromProps,
      v =
        typeof M == "function" ||
        typeof f.getSnapshotBeforeUpdate == "function";
    v ||
      (typeof f.UNSAFE_componentWillReceiveProps != "function" &&
        typeof f.componentWillReceiveProps != "function") ||
      ((_ !== o || m !== g) && c1(t, f, o, g)),
      (fs = !1);
    var C = t.memoizedState;
    (f.state = C),
      im(t, o, f, a),
      (m = t.memoizedState),
      _ !== o || C !== m || mi.current || fs
        ? (typeof M == "function" && (M_(t, n, M, o), (m = t.memoizedState)),
          (_ = fs || u1(t, n, _, o, C, m, g))
            ? (v ||
                (typeof f.UNSAFE_componentWillMount != "function" &&
                  typeof f.componentWillMount != "function") ||
                (typeof f.componentWillMount == "function" &&
                  f.componentWillMount(),
                typeof f.UNSAFE_componentWillMount == "function" &&
                  f.UNSAFE_componentWillMount()),
              typeof f.componentDidMount == "function" && (t.flags |= 4194308))
            : (typeof f.componentDidMount == "function" && (t.flags |= 4194308),
              (t.memoizedProps = o),
              (t.memoizedState = m)),
          (f.props = o),
          (f.state = m),
          (f.context = g),
          (o = _))
        : (typeof f.componentDidMount == "function" && (t.flags |= 4194308),
          (o = !1));
  } else {
    (f = t.stateNode),
      s2(e, t),
      (_ = t.memoizedProps),
      (g = t.type === t.elementType ? _ : Xi(t.type, _)),
      (f.props = g),
      (v = t.pendingProps),
      (C = f.context),
      (m = n.contextType),
      typeof m == "object" && m !== null
        ? (m = Ui(m))
        : ((m = gi(n) ? ca : Jn.current), (m = fu(t, m)));
    var T = n.getDerivedStateFromProps;
    (M =
      typeof T == "function" ||
      typeof f.getSnapshotBeforeUpdate == "function") ||
      (typeof f.UNSAFE_componentWillReceiveProps != "function" &&
        typeof f.componentWillReceiveProps != "function") ||
      ((_ !== v || C !== m) && c1(t, f, o, m)),
      (fs = !1),
      (C = t.memoizedState),
      (f.state = C),
      im(t, o, f, a);
    var z = t.memoizedState;
    _ !== v || C !== z || mi.current || fs
      ? (typeof T == "function" && (M_(t, n, T, o), (z = t.memoizedState)),
        (g = fs || u1(t, n, g, o, C, z, m) || !1)
          ? (M ||
              (typeof f.UNSAFE_componentWillUpdate != "function" &&
                typeof f.componentWillUpdate != "function") ||
              (typeof f.componentWillUpdate == "function" &&
                f.componentWillUpdate(o, z, m),
              typeof f.UNSAFE_componentWillUpdate == "function" &&
                f.UNSAFE_componentWillUpdate(o, z, m)),
            typeof f.componentDidUpdate == "function" && (t.flags |= 4),
            typeof f.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024))
          : (typeof f.componentDidUpdate != "function" ||
              (_ === e.memoizedProps && C === e.memoizedState) ||
              (t.flags |= 4),
            typeof f.getSnapshotBeforeUpdate != "function" ||
              (_ === e.memoizedProps && C === e.memoizedState) ||
              (t.flags |= 1024),
            (t.memoizedProps = o),
            (t.memoizedState = z)),
        (f.props = o),
        (f.state = z),
        (f.context = m),
        (o = g))
      : (typeof f.componentDidUpdate != "function" ||
          (_ === e.memoizedProps && C === e.memoizedState) ||
          (t.flags |= 4),
        typeof f.getSnapshotBeforeUpdate != "function" ||
          (_ === e.memoizedProps && C === e.memoizedState) ||
          (t.flags |= 1024),
        (o = !1));
  }
  return E_(e, t, n, o, l, a);
}
function E_(e, t, n, o, a, l) {
  I2(e, t);
  var f = (t.flags & 128) !== 0;
  if (!o && !f) return a && t1(t, n, !1), No(e, t, l);
  (o = t.stateNode), (aS.current = t);
  var _ =
    f && typeof n.getDerivedStateFromError != "function" ? null : o.render();
  return (
    (t.flags |= 1),
    e !== null && f
      ? ((t.child = hu(t, e.child, null, l)), (t.child = hu(t, null, _, l)))
      : oi(e, t, _, l),
    (t.memoizedState = o.state),
    a && t1(t, n, !0),
    t.child
  );
}
function F2(e) {
  var t = e.stateNode;
  t.pendingContext
    ? e1(e, t.pendingContext, t.pendingContext !== t.context)
    : t.context && e1(e, t.context, !1),
    w0(e, t.containerInfo);
}
function _1(e, t, n, o, a) {
  return pu(), p0(a), (t.flags |= 256), oi(e, t, n, o), t.child;
}
var C_ = { dehydrated: null, treeContext: null, retryLane: 0 };
function P_(e) {
  return { baseLanes: e, cachePool: null, transitions: null };
}
function z2(e, t, n) {
  var o = t.pendingProps,
    a = dn.current,
    l = !1,
    f = (t.flags & 128) !== 0,
    _;
  if (
    ((_ = f) ||
      (_ = e !== null && e.memoizedState === null ? !1 : (a & 2) !== 0),
    _
      ? ((l = !0), (t.flags &= -129))
      : (e === null || e.memoizedState !== null) && (a |= 1),
    tn(dn, a & 1),
    e === null)
  )
    return (
      b_(t),
      (e = t.memoizedState),
      e !== null && ((e = e.dehydrated), e !== null)
        ? (t.mode & 1
            ? e.data === "$!"
              ? (t.lanes = 8)
              : (t.lanes = 1073741824)
            : (t.lanes = 1),
          null)
        : ((f = o.children),
          (e = o.fallback),
          l
            ? ((o = t.mode),
              (l = t.child),
              (f = { mode: "hidden", children: f }),
              !(o & 1) && l !== null
                ? ((l.childLanes = 0), (l.pendingProps = f))
                : (l = Em(f, o, 0, null)),
              (e = ua(e, o, n, null)),
              (l.return = t),
              (e.return = t),
              (l.sibling = e),
              (t.child = l),
              (t.child.memoizedState = P_(n)),
              (t.memoizedState = C_),
              e)
            : E0(t, f))
    );
  if (((a = e.memoizedState), a !== null && ((_ = a.dehydrated), _ !== null)))
    return lS(e, t, f, o, _, a, n);
  if (l) {
    (l = o.fallback), (f = t.mode), (a = e.child), (_ = a.sibling);
    var m = { mode: "hidden", children: o.children };
    return (
      !(f & 1) && t.child !== a
        ? ((o = t.child),
          (o.childLanes = 0),
          (o.pendingProps = m),
          (t.deletions = null))
        : ((o = Ts(a, m)), (o.subtreeFlags = a.subtreeFlags & 14680064)),
      _ !== null ? (l = Ts(_, l)) : ((l = ua(l, f, n, null)), (l.flags |= 2)),
      (l.return = t),
      (o.return = t),
      (o.sibling = l),
      (t.child = o),
      (o = l),
      (l = t.child),
      (f = e.child.memoizedState),
      (f =
        f === null
          ? P_(n)
          : {
              baseLanes: f.baseLanes | n,
              cachePool: null,
              transitions: f.transitions
            }),
      (l.memoizedState = f),
      (l.childLanes = e.childLanes & ~n),
      (t.memoizedState = C_),
      o
    );
  }
  return (
    (l = e.child),
    (e = l.sibling),
    (o = Ts(l, { mode: "visible", children: o.children })),
    !(t.mode & 1) && (o.lanes = n),
    (o.return = t),
    (o.sibling = null),
    e !== null &&
      ((n = t.deletions),
      n === null ? ((t.deletions = [e]), (t.flags |= 16)) : n.push(e)),
    (t.child = o),
    (t.memoizedState = null),
    o
  );
}
function E0(e, t) {
  return (
    (t = Em({ mode: "visible", children: t }, e.mode, 0, null)),
    (t.return = e),
    (e.child = t)
  );
}
function Th(e, t, n, o) {
  return (
    o !== null && p0(o),
    hu(t, e.child, null, n),
    (e = E0(t, t.pendingProps.children)),
    (e.flags |= 2),
    (t.memoizedState = null),
    e
  );
}
function lS(e, t, n, o, a, l, f) {
  if (n)
    return t.flags & 256
      ? ((t.flags &= -257), (o = Ng(Error(St(422)))), Th(e, t, f, o))
      : t.memoizedState !== null
      ? ((t.child = e.child), (t.flags |= 128), null)
      : ((l = o.fallback),
        (a = t.mode),
        (o = Em({ mode: "visible", children: o.children }, a, 0, null)),
        (l = ua(l, a, f, null)),
        (l.flags |= 2),
        (o.return = t),
        (l.return = t),
        (o.sibling = l),
        (t.child = o),
        t.mode & 1 && hu(t, e.child, null, f),
        (t.child.memoizedState = P_(f)),
        (t.memoizedState = C_),
        l);
  if (!(t.mode & 1)) return Th(e, t, f, null);
  if (a.data === "$!") {
    if (((o = a.nextSibling && a.nextSibling.dataset), o)) var _ = o.dgst;
    return (
      (o = _), (l = Error(St(419))), (o = Ng(l, o, void 0)), Th(e, t, f, o)
    );
  }
  if (((_ = (f & e.childLanes) !== 0), hi || _)) {
    if (((o = Ln), o !== null)) {
      switch (f & -f) {
        case 4:
          a = 2;
          break;
        case 16:
          a = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          a = 32;
          break;
        case 536870912:
          a = 268435456;
          break;
        default:
          a = 0;
      }
      (a = a & (o.suspendedLanes | f) ? 0 : a),
        a !== 0 &&
          a !== l.retryLane &&
          ((l.retryLane = a), Ro(e, a), eo(o, e, a, -1));
    }
    return F0(), (o = Ng(Error(St(421)))), Th(e, t, f, o);
  }
  return a.data === "$?"
    ? ((t.flags |= 128),
      (t.child = e.child),
      (t = bS.bind(null, e)),
      (a._reactRetry = t),
      null)
    : ((e = l.treeContext),
      (Si = vs(a.nextSibling)),
      (Ei = t),
      (ln = !0),
      (Zi = null),
      e !== null &&
        ((Bi[Ri++] = zo),
        (Bi[Ri++] = Oo),
        (Bi[Ri++] = da),
        (zo = e.id),
        (Oo = e.overflow),
        (da = t)),
      (t = E0(t, o.children)),
      (t.flags |= 4096),
      t);
}
function y1(e, t, n) {
  e.lanes |= t;
  var o = e.alternate;
  o !== null && (o.lanes |= t), x_(e.return, t, n);
}
function jg(e, t, n, o, a) {
  var l = e.memoizedState;
  l === null
    ? (e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: o,
        tail: n,
        tailMode: a
      })
    : ((l.isBackwards = t),
      (l.rendering = null),
      (l.renderingStartTime = 0),
      (l.last = o),
      (l.tail = n),
      (l.tailMode = a));
}
function O2(e, t, n) {
  var o = t.pendingProps,
    a = o.revealOrder,
    l = o.tail;
  if ((oi(e, t, o.children, n), (o = dn.current), o & 2))
    (o = (o & 1) | 2), (t.flags |= 128);
  else {
    if (e !== null && e.flags & 128)
      e: for (e = t.child; e !== null; ) {
        if (e.tag === 13) e.memoizedState !== null && y1(e, n, t);
        else if (e.tag === 19) y1(e, n, t);
        else if (e.child !== null) {
          (e.child.return = e), (e = e.child);
          continue;
        }
        if (e === t) break e;
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) break e;
          e = e.return;
        }
        (e.sibling.return = e.return), (e = e.sibling);
      }
    o &= 1;
  }
  if ((tn(dn, o), !(t.mode & 1))) t.memoizedState = null;
  else
    switch (a) {
      case "forwards":
        for (n = t.child, a = null; n !== null; )
          (e = n.alternate),
            e !== null && om(e) === null && (a = n),
            (n = n.sibling);
        (n = a),
          n === null
            ? ((a = t.child), (t.child = null))
            : ((a = n.sibling), (n.sibling = null)),
          jg(t, !1, a, n, l);
        break;
      case "backwards":
        for (n = null, a = t.child, t.child = null; a !== null; ) {
          if (((e = a.alternate), e !== null && om(e) === null)) {
            t.child = a;
            break;
          }
          (e = a.sibling), (a.sibling = n), (n = a), (a = e);
        }
        jg(t, !0, n, null, l);
        break;
      case "together":
        jg(t, !1, null, null, void 0);
        break;
      default:
        t.memoizedState = null;
    }
  return t.child;
}
function Bh(e, t) {
  !(t.mode & 1) &&
    e !== null &&
    ((e.alternate = null), (t.alternate = null), (t.flags |= 2));
}
function No(e, t, n) {
  if (
    (e !== null && (t.dependencies = e.dependencies),
    (pa |= t.lanes),
    !(n & t.childLanes))
  )
    return null;
  if (e !== null && t.child !== e.child) throw Error(St(153));
  if (t.child !== null) {
    for (
      e = t.child, n = Ts(e, e.pendingProps), t.child = n, n.return = t;
      e.sibling !== null;

    )
      (e = e.sibling), (n = n.sibling = Ts(e, e.pendingProps)), (n.return = t);
    n.sibling = null;
  }
  return t.child;
}
function uS(e, t, n) {
  switch (t.tag) {
    case 3:
      F2(t), pu();
      break;
    case 5:
      a2(t);
      break;
    case 1:
      gi(t.type) && Jh(t);
      break;
    case 4:
      w0(t, t.stateNode.containerInfo);
      break;
    case 10:
      var o = t.type._context,
        a = t.memoizedProps.value;
      tn(rm, o._currentValue), (o._currentValue = a);
      break;
    case 13:
      if (((o = t.memoizedState), o !== null))
        return o.dehydrated !== null
          ? (tn(dn, dn.current & 1), (t.flags |= 128), null)
          : n & t.child.childLanes
          ? z2(e, t, n)
          : (tn(dn, dn.current & 1),
            (e = No(e, t, n)),
            e !== null ? e.sibling : null);
      tn(dn, dn.current & 1);
      break;
    case 19:
      if (((o = (n & t.childLanes) !== 0), e.flags & 128)) {
        if (o) return O2(e, t, n);
        t.flags |= 128;
      }
      if (
        ((a = t.memoizedState),
        a !== null &&
          ((a.rendering = null), (a.tail = null), (a.lastEffect = null)),
        tn(dn, dn.current),
        o)
      )
        break;
      return null;
    case 22:
    case 23:
      return (t.lanes = 0), A2(e, t, n);
  }
  return No(e, t, n);
}
var D2, $_, L2, B2;
D2 = function (e, t) {
  for (var n = t.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === t) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === t) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
$_ = function () {};
L2 = function (e, t, n, o) {
  var a = e.memoizedProps;
  if (a !== o) {
    (e = t.stateNode), aa(go.current);
    var l = null;
    switch (n) {
      case "input":
        (a = Zg(e, a)), (o = Zg(e, o)), (l = []);
        break;
      case "select":
        (a = pn({}, a, { value: void 0 })),
          (o = pn({}, o, { value: void 0 })),
          (l = []);
        break;
      case "textarea":
        (a = t_(e, a)), (o = t_(e, o)), (l = []);
        break;
      default:
        typeof a.onClick != "function" &&
          typeof o.onClick == "function" &&
          (e.onclick = Yh);
    }
    n_(n, o);
    var f;
    n = null;
    for (g in a)
      if (!o.hasOwnProperty(g) && a.hasOwnProperty(g) && a[g] != null)
        if (g === "style") {
          var _ = a[g];
          for (f in _) _.hasOwnProperty(f) && (n || (n = {}), (n[f] = ""));
        } else
          g !== "dangerouslySetInnerHTML" &&
            g !== "children" &&
            g !== "suppressContentEditableWarning" &&
            g !== "suppressHydrationWarning" &&
            g !== "autoFocus" &&
            (Kf.hasOwnProperty(g)
              ? l || (l = [])
              : (l = l || []).push(g, null));
    for (g in o) {
      var m = o[g];
      if (
        ((_ = a != null ? a[g] : void 0),
        o.hasOwnProperty(g) && m !== _ && (m != null || _ != null))
      )
        if (g === "style")
          if (_) {
            for (f in _)
              !_.hasOwnProperty(f) ||
                (m && m.hasOwnProperty(f)) ||
                (n || (n = {}), (n[f] = ""));
            for (f in m)
              m.hasOwnProperty(f) &&
                _[f] !== m[f] &&
                (n || (n = {}), (n[f] = m[f]));
          } else n || (l || (l = []), l.push(g, n)), (n = m);
        else
          g === "dangerouslySetInnerHTML"
            ? ((m = m ? m.__html : void 0),
              (_ = _ ? _.__html : void 0),
              m != null && _ !== m && (l = l || []).push(g, m))
            : g === "children"
            ? (typeof m != "string" && typeof m != "number") ||
              (l = l || []).push(g, "" + m)
            : g !== "suppressContentEditableWarning" &&
              g !== "suppressHydrationWarning" &&
              (Kf.hasOwnProperty(g)
                ? (m != null && g === "onScroll" && on("scroll", e),
                  l || _ === m || (l = []))
                : (l = l || []).push(g, m));
    }
    n && (l = l || []).push("style", n);
    var g = l;
    (t.updateQueue = g) && (t.flags |= 4);
  }
};
B2 = function (e, t, n, o) {
  n !== o && (t.flags |= 4);
};
function Af(e, t) {
  if (!ln)
    switch (e.tailMode) {
      case "hidden":
        t = e.tail;
        for (var n = null; t !== null; )
          t.alternate !== null && (n = t), (t = t.sibling);
        n === null ? (e.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = e.tail;
        for (var o = null; n !== null; )
          n.alternate !== null && (o = n), (n = n.sibling);
        o === null
          ? t || e.tail === null
            ? (e.tail = null)
            : (e.tail.sibling = null)
          : (o.sibling = null);
    }
}
function Yn(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
    n = 0,
    o = 0;
  if (t)
    for (var a = e.child; a !== null; )
      (n |= a.lanes | a.childLanes),
        (o |= a.subtreeFlags & 14680064),
        (o |= a.flags & 14680064),
        (a.return = e),
        (a = a.sibling);
  else
    for (a = e.child; a !== null; )
      (n |= a.lanes | a.childLanes),
        (o |= a.subtreeFlags),
        (o |= a.flags),
        (a.return = e),
        (a = a.sibling);
  return (e.subtreeFlags |= o), (e.childLanes = n), t;
}
function cS(e, t, n) {
  var o = t.pendingProps;
  switch ((f0(t), t.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Yn(t), null;
    case 1:
      return gi(t.type) && Zh(), Yn(t), null;
    case 3:
      return (
        (o = t.stateNode),
        mu(),
        sn(mi),
        sn(Jn),
        b0(),
        o.pendingContext &&
          ((o.context = o.pendingContext), (o.pendingContext = null)),
        (e === null || e.child === null) &&
          (xh(t)
            ? (t.flags |= 4)
            : e === null ||
              (e.memoizedState.isDehydrated && !(t.flags & 256)) ||
              ((t.flags |= 1024), Zi !== null && (B_(Zi), (Zi = null)))),
        $_(e, t),
        Yn(t),
        null
      );
    case 5:
      v0(t);
      var a = aa(sp.current);
      if (((n = t.type), e !== null && t.stateNode != null))
        L2(e, t, n, o, a),
          e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152));
      else {
        if (!o) {
          if (t.stateNode === null) throw Error(St(166));
          return Yn(t), null;
        }
        if (((e = aa(go.current)), xh(t))) {
          (o = t.stateNode), (n = t.type);
          var l = t.memoizedProps;
          switch (((o[ho] = t), (o[ip] = l), (e = (t.mode & 1) !== 0), n)) {
            case "dialog":
              on("cancel", o), on("close", o);
              break;
            case "iframe":
            case "object":
            case "embed":
              on("load", o);
              break;
            case "video":
            case "audio":
              for (a = 0; a < Lf.length; a++) on(Lf[a], o);
              break;
            case "source":
              on("error", o);
              break;
            case "img":
            case "image":
            case "link":
              on("error", o), on("load", o);
              break;
            case "details":
              on("toggle", o);
              break;
            case "input":
              Ev(o, l), on("invalid", o);
              break;
            case "select":
              (o._wrapperState = { wasMultiple: !!l.multiple }),
                on("invalid", o);
              break;
            case "textarea":
              Pv(o, l), on("invalid", o);
          }
          n_(n, l), (a = null);
          for (var f in l)
            if (l.hasOwnProperty(f)) {
              var _ = l[f];
              f === "children"
                ? typeof _ == "string"
                  ? o.textContent !== _ &&
                    (l.suppressHydrationWarning !== !0 &&
                      bh(o.textContent, _, e),
                    (a = ["children", _]))
                  : typeof _ == "number" &&
                    o.textContent !== "" + _ &&
                    (l.suppressHydrationWarning !== !0 &&
                      bh(o.textContent, _, e),
                    (a = ["children", "" + _]))
                : Kf.hasOwnProperty(f) &&
                  _ != null &&
                  f === "onScroll" &&
                  on("scroll", o);
            }
          switch (n) {
            case "input":
              ph(o), Cv(o, l, !0);
              break;
            case "textarea":
              ph(o), $v(o);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof l.onClick == "function" && (o.onclick = Yh);
          }
          (o = a), (t.updateQueue = o), o !== null && (t.flags |= 4);
        } else {
          (f = a.nodeType === 9 ? a : a.ownerDocument),
            e === "http://www.w3.org/1999/xhtml" && (e = fb(n)),
            e === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((e = f.createElement("div")),
                  (e.innerHTML = "<script></script>"),
                  (e = e.removeChild(e.firstChild)))
                : typeof o.is == "string"
                ? (e = f.createElement(n, { is: o.is }))
                : ((e = f.createElement(n)),
                  n === "select" &&
                    ((f = e),
                    o.multiple
                      ? (f.multiple = !0)
                      : o.size && (f.size = o.size)))
              : (e = f.createElementNS(e, n)),
            (e[ho] = t),
            (e[ip] = o),
            D2(e, t, !1, !1),
            (t.stateNode = e);
          e: {
            switch (((f = i_(n, o)), n)) {
              case "dialog":
                on("cancel", e), on("close", e), (a = o);
                break;
              case "iframe":
              case "object":
              case "embed":
                on("load", e), (a = o);
                break;
              case "video":
              case "audio":
                for (a = 0; a < Lf.length; a++) on(Lf[a], e);
                a = o;
                break;
              case "source":
                on("error", e), (a = o);
                break;
              case "img":
              case "image":
              case "link":
                on("error", e), on("load", e), (a = o);
                break;
              case "details":
                on("toggle", e), (a = o);
                break;
              case "input":
                Ev(e, o), (a = Zg(e, o)), on("invalid", e);
                break;
              case "option":
                a = o;
                break;
              case "select":
                (e._wrapperState = { wasMultiple: !!o.multiple }),
                  (a = pn({}, o, { value: void 0 })),
                  on("invalid", e);
                break;
              case "textarea":
                Pv(e, o), (a = t_(e, o)), on("invalid", e);
                break;
              default:
                a = o;
            }
            n_(n, a), (_ = a);
            for (l in _)
              if (_.hasOwnProperty(l)) {
                var m = _[l];
                l === "style"
                  ? mb(e, m)
                  : l === "dangerouslySetInnerHTML"
                  ? ((m = m ? m.__html : void 0), m != null && pb(e, m))
                  : l === "children"
                  ? typeof m == "string"
                    ? (n !== "textarea" || m !== "") && Qf(e, m)
                    : typeof m == "number" && Qf(e, "" + m)
                  : l !== "suppressContentEditableWarning" &&
                    l !== "suppressHydrationWarning" &&
                    l !== "autoFocus" &&
                    (Kf.hasOwnProperty(l)
                      ? m != null && l === "onScroll" && on("scroll", e)
                      : m != null && Y_(e, l, m, f));
              }
            switch (n) {
              case "input":
                ph(e), Cv(e, o, !1);
                break;
              case "textarea":
                ph(e), $v(e);
                break;
              case "option":
                o.value != null && e.setAttribute("value", "" + ks(o.value));
                break;
              case "select":
                (e.multiple = !!o.multiple),
                  (l = o.value),
                  l != null
                    ? ou(e, !!o.multiple, l, !1)
                    : o.defaultValue != null &&
                      ou(e, !!o.multiple, o.defaultValue, !0);
                break;
              default:
                typeof a.onClick == "function" && (e.onclick = Yh);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                o = !!o.autoFocus;
                break e;
              case "img":
                o = !0;
                break e;
              default:
                o = !1;
            }
          }
          o && (t.flags |= 4);
        }
        t.ref !== null && ((t.flags |= 512), (t.flags |= 2097152));
      }
      return Yn(t), null;
    case 6:
      if (e && t.stateNode != null) B2(e, t, e.memoizedProps, o);
      else {
        if (typeof o != "string" && t.stateNode === null) throw Error(St(166));
        if (((n = aa(sp.current)), aa(go.current), xh(t))) {
          if (
            ((o = t.stateNode),
            (n = t.memoizedProps),
            (o[ho] = t),
            (l = o.nodeValue !== n) && ((e = Ei), e !== null))
          )
            switch (e.tag) {
              case 3:
                bh(o.nodeValue, n, (e.mode & 1) !== 0);
                break;
              case 5:
                e.memoizedProps.suppressHydrationWarning !== !0 &&
                  bh(o.nodeValue, n, (e.mode & 1) !== 0);
            }
          l && (t.flags |= 4);
        } else
          (o = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(o)),
            (o[ho] = t),
            (t.stateNode = o);
      }
      return Yn(t), null;
    case 13:
      if (
        (sn(dn),
        (o = t.memoizedState),
        e === null ||
          (e.memoizedState !== null && e.memoizedState.dehydrated !== null))
      ) {
        if (ln && Si !== null && t.mode & 1 && !(t.flags & 128))
          r2(), pu(), (t.flags |= 98560), (l = !1);
        else if (((l = xh(t)), o !== null && o.dehydrated !== null)) {
          if (e === null) {
            if (!l) throw Error(St(318));
            if (
              ((l = t.memoizedState),
              (l = l !== null ? l.dehydrated : null),
              !l)
            )
              throw Error(St(317));
            l[ho] = t;
          } else
            pu(), !(t.flags & 128) && (t.memoizedState = null), (t.flags |= 4);
          Yn(t), (l = !1);
        } else Zi !== null && (B_(Zi), (Zi = null)), (l = !0);
        if (!l) return t.flags & 65536 ? t : null;
      }
      return t.flags & 128
        ? ((t.lanes = n), t)
        : ((o = o !== null),
          o !== (e !== null && e.memoizedState !== null) &&
            o &&
            ((t.child.flags |= 8192),
            t.mode & 1 &&
              (e === null || dn.current & 1 ? $n === 0 && ($n = 3) : F0())),
          t.updateQueue !== null && (t.flags |= 4),
          Yn(t),
          null);
    case 4:
      return (
        mu(), $_(e, t), e === null && rp(t.stateNode.containerInfo), Yn(t), null
      );
    case 10:
      return g0(t.type._context), Yn(t), null;
    case 17:
      return gi(t.type) && Zh(), Yn(t), null;
    case 19:
      if ((sn(dn), (l = t.memoizedState), l === null)) return Yn(t), null;
      if (((o = (t.flags & 128) !== 0), (f = l.rendering), f === null))
        if (o) Af(l, !1);
        else {
          if ($n !== 0 || (e !== null && e.flags & 128))
            for (e = t.child; e !== null; ) {
              if (((f = om(e)), f !== null)) {
                for (
                  t.flags |= 128,
                    Af(l, !1),
                    o = f.updateQueue,
                    o !== null && ((t.updateQueue = o), (t.flags |= 4)),
                    t.subtreeFlags = 0,
                    o = n,
                    n = t.child;
                  n !== null;

                )
                  (l = n),
                    (e = o),
                    (l.flags &= 14680066),
                    (f = l.alternate),
                    f === null
                      ? ((l.childLanes = 0),
                        (l.lanes = e),
                        (l.child = null),
                        (l.subtreeFlags = 0),
                        (l.memoizedProps = null),
                        (l.memoizedState = null),
                        (l.updateQueue = null),
                        (l.dependencies = null),
                        (l.stateNode = null))
                      : ((l.childLanes = f.childLanes),
                        (l.lanes = f.lanes),
                        (l.child = f.child),
                        (l.subtreeFlags = 0),
                        (l.deletions = null),
                        (l.memoizedProps = f.memoizedProps),
                        (l.memoizedState = f.memoizedState),
                        (l.updateQueue = f.updateQueue),
                        (l.type = f.type),
                        (e = f.dependencies),
                        (l.dependencies =
                          e === null
                            ? null
                            : {
                                lanes: e.lanes,
                                firstContext: e.firstContext
                              })),
                    (n = n.sibling);
                return tn(dn, (dn.current & 1) | 2), t.child;
              }
              e = e.sibling;
            }
          l.tail !== null &&
            wn() > _u &&
            ((t.flags |= 128), (o = !0), Af(l, !1), (t.lanes = 4194304));
        }
      else {
        if (!o)
          if (((e = om(f)), e !== null)) {
            if (
              ((t.flags |= 128),
              (o = !0),
              (n = e.updateQueue),
              n !== null && ((t.updateQueue = n), (t.flags |= 4)),
              Af(l, !0),
              l.tail === null && l.tailMode === "hidden" && !f.alternate && !ln)
            )
              return Yn(t), null;
          } else
            2 * wn() - l.renderingStartTime > _u &&
              n !== 1073741824 &&
              ((t.flags |= 128), (o = !0), Af(l, !1), (t.lanes = 4194304));
        l.isBackwards
          ? ((f.sibling = t.child), (t.child = f))
          : ((n = l.last),
            n !== null ? (n.sibling = f) : (t.child = f),
            (l.last = f));
      }
      return l.tail !== null
        ? ((t = l.tail),
          (l.rendering = t),
          (l.tail = t.sibling),
          (l.renderingStartTime = wn()),
          (t.sibling = null),
          (n = dn.current),
          tn(dn, o ? (n & 1) | 2 : n & 1),
          t)
        : (Yn(t), null);
    case 22:
    case 23:
      return (
        I0(),
        (o = t.memoizedState !== null),
        e !== null && (e.memoizedState !== null) !== o && (t.flags |= 8192),
        o && t.mode & 1
          ? ki & 1073741824 && (Yn(t), t.subtreeFlags & 6 && (t.flags |= 8192))
          : Yn(t),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(St(156, t.tag));
}
function dS(e, t) {
  switch ((f0(t), t.tag)) {
    case 1:
      return (
        gi(t.type) && Zh(),
        (e = t.flags),
        e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      );
    case 3:
      return (
        mu(),
        sn(mi),
        sn(Jn),
        b0(),
        (e = t.flags),
        e & 65536 && !(e & 128) ? ((t.flags = (e & -65537) | 128), t) : null
      );
    case 5:
      return v0(t), null;
    case 13:
      if (
        (sn(dn), (e = t.memoizedState), e !== null && e.dehydrated !== null)
      ) {
        if (t.alternate === null) throw Error(St(340));
        pu();
      }
      return (
        (e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      );
    case 19:
      return sn(dn), null;
    case 4:
      return mu(), null;
    case 10:
      return g0(t.type._context), null;
    case 22:
    case 23:
      return I0(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var kh = !1,
  Zn = !1,
  fS = typeof WeakSet == "function" ? WeakSet : Set,
  Vt = null;
function nu(e, t) {
  var n = e.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (o) {
        _n(e, t, o);
      }
    else n.current = null;
}
function A_(e, t, n) {
  try {
    n();
  } catch (o) {
    _n(e, t, o);
  }
}
var w1 = !1;
function pS(e, t) {
  if (((h_ = Kh), (e = Vb()), c0(e))) {
    if ("selectionStart" in e)
      var n = { start: e.selectionStart, end: e.selectionEnd };
    else
      e: {
        n = ((n = e.ownerDocument) && n.defaultView) || window;
        var o = n.getSelection && n.getSelection();
        if (o && o.rangeCount !== 0) {
          n = o.anchorNode;
          var a = o.anchorOffset,
            l = o.focusNode;
          o = o.focusOffset;
          try {
            n.nodeType, l.nodeType;
          } catch {
            n = null;
            break e;
          }
          var f = 0,
            _ = -1,
            m = -1,
            g = 0,
            M = 0,
            v = e,
            C = null;
          t: for (;;) {
            for (
              var T;
              v !== n || (a !== 0 && v.nodeType !== 3) || (_ = f + a),
                v !== l || (o !== 0 && v.nodeType !== 3) || (m = f + o),
                v.nodeType === 3 && (f += v.nodeValue.length),
                (T = v.firstChild) !== null;

            )
              (C = v), (v = T);
            for (;;) {
              if (v === e) break t;
              if (
                (C === n && ++g === a && (_ = f),
                C === l && ++M === o && (m = f),
                (T = v.nextSibling) !== null)
              )
                break;
              (v = C), (C = v.parentNode);
            }
            v = T;
          }
          n = _ === -1 || m === -1 ? null : { start: _, end: m };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (
    m_ = { focusedElem: e, selectionRange: n }, Kh = !1, Vt = t;
    Vt !== null;

  )
    if (((t = Vt), (e = t.child), (t.subtreeFlags & 1028) !== 0 && e !== null))
      (e.return = t), (Vt = e);
    else
      for (; Vt !== null; ) {
        t = Vt;
        try {
          var z = t.alternate;
          if (t.flags & 1024)
            switch (t.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (z !== null) {
                  var $ = z.memoizedProps,
                    S = z.memoizedState,
                    y = t.stateNode,
                    x = y.getSnapshotBeforeUpdate(
                      t.elementType === t.type ? $ : Xi(t.type, $),
                      S
                    );
                  y.__reactInternalSnapshotBeforeUpdate = x;
                }
                break;
              case 3:
                var I = t.stateNode.containerInfo;
                I.nodeType === 1
                  ? (I.textContent = "")
                  : I.nodeType === 9 &&
                    I.documentElement &&
                    I.removeChild(I.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(St(163));
            }
        } catch (V) {
          _n(t, t.return, V);
        }
        if (((e = t.sibling), e !== null)) {
          (e.return = t.return), (Vt = e);
          break;
        }
        Vt = t.return;
      }
  return (z = w1), (w1 = !1), z;
}
function Gf(e, t, n) {
  var o = t.updateQueue;
  if (((o = o !== null ? o.lastEffect : null), o !== null)) {
    var a = (o = o.next);
    do {
      if ((a.tag & e) === e) {
        var l = a.destroy;
        (a.destroy = void 0), l !== void 0 && A_(t, n, l);
      }
      a = a.next;
    } while (a !== o);
  }
}
function km(e, t) {
  if (
    ((t = t.updateQueue), (t = t !== null ? t.lastEffect : null), t !== null)
  ) {
    var n = (t = t.next);
    do {
      if ((n.tag & e) === e) {
        var o = n.create;
        n.destroy = o();
      }
      n = n.next;
    } while (n !== t);
  }
}
function I_(e) {
  var t = e.ref;
  if (t !== null) {
    var n = e.stateNode;
    switch (e.tag) {
      case 5:
        e = n;
        break;
      default:
        e = n;
    }
    typeof t == "function" ? t(e) : (t.current = e);
  }
}
function R2(e) {
  var t = e.alternate;
  t !== null && ((e.alternate = null), R2(t)),
    (e.child = null),
    (e.deletions = null),
    (e.sibling = null),
    e.tag === 5 &&
      ((t = e.stateNode),
      t !== null &&
        (delete t[ho], delete t[ip], delete t[y_], delete t[Qk], delete t[Xk])),
    (e.stateNode = null),
    (e.return = null),
    (e.dependencies = null),
    (e.memoizedProps = null),
    (e.memoizedState = null),
    (e.pendingProps = null),
    (e.stateNode = null),
    (e.updateQueue = null);
}
function N2(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4;
}
function v1(e) {
  e: for (;;) {
    for (; e.sibling === null; ) {
      if (e.return === null || N2(e.return)) return null;
      e = e.return;
    }
    for (
      e.sibling.return = e.return, e = e.sibling;
      e.tag !== 5 && e.tag !== 6 && e.tag !== 18;

    ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
      (e.child.return = e), (e = e.child);
    }
    if (!(e.flags & 2)) return e.stateNode;
  }
}
function F_(e, t, n) {
  var o = e.tag;
  if (o === 5 || o === 6)
    (e = e.stateNode),
      t
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(e, t)
          : n.insertBefore(e, t)
        : (n.nodeType === 8
            ? ((t = n.parentNode), t.insertBefore(e, n))
            : ((t = n), t.appendChild(e)),
          (n = n._reactRootContainer),
          n != null || t.onclick !== null || (t.onclick = Yh));
  else if (o !== 4 && ((e = e.child), e !== null))
    for (F_(e, t, n), e = e.sibling; e !== null; ) F_(e, t, n), (e = e.sibling);
}
function z_(e, t, n) {
  var o = e.tag;
  if (o === 5 || o === 6)
    (e = e.stateNode), t ? n.insertBefore(e, t) : n.appendChild(e);
  else if (o !== 4 && ((e = e.child), e !== null))
    for (z_(e, t, n), e = e.sibling; e !== null; ) z_(e, t, n), (e = e.sibling);
}
var Wn = null,
  Yi = !1;
function cs(e, t, n) {
  for (n = n.child; n !== null; ) j2(e, t, n), (n = n.sibling);
}
function j2(e, t, n) {
  if (mo && typeof mo.onCommitFiberUnmount == "function")
    try {
      mo.onCommitFiberUnmount(_m, n);
    } catch {}
  switch (n.tag) {
    case 5:
      Zn || nu(n, t);
    case 6:
      var o = Wn,
        a = Yi;
      (Wn = null),
        cs(e, t, n),
        (Wn = o),
        (Yi = a),
        Wn !== null &&
          (Yi
            ? ((e = Wn),
              (n = n.stateNode),
              e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n))
            : Wn.removeChild(n.stateNode));
      break;
    case 18:
      Wn !== null &&
        (Yi
          ? ((e = Wn),
            (n = n.stateNode),
            e.nodeType === 8
              ? zg(e.parentNode, n)
              : e.nodeType === 1 && zg(e, n),
            Jf(e))
          : zg(Wn, n.stateNode));
      break;
    case 4:
      (o = Wn),
        (a = Yi),
        (Wn = n.stateNode.containerInfo),
        (Yi = !0),
        cs(e, t, n),
        (Wn = o),
        (Yi = a);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Zn &&
        ((o = n.updateQueue), o !== null && ((o = o.lastEffect), o !== null))
      ) {
        a = o = o.next;
        do {
          var l = a,
            f = l.destroy;
          (l = l.tag),
            f !== void 0 && (l & 2 || l & 4) && A_(n, t, f),
            (a = a.next);
        } while (a !== o);
      }
      cs(e, t, n);
      break;
    case 1:
      if (
        !Zn &&
        (nu(n, t),
        (o = n.stateNode),
        typeof o.componentWillUnmount == "function")
      )
        try {
          (o.props = n.memoizedProps),
            (o.state = n.memoizedState),
            o.componentWillUnmount();
        } catch (_) {
          _n(n, t, _);
        }
      cs(e, t, n);
      break;
    case 21:
      cs(e, t, n);
      break;
    case 22:
      n.mode & 1
        ? ((Zn = (o = Zn) || n.memoizedState !== null), cs(e, t, n), (Zn = o))
        : cs(e, t, n);
      break;
    default:
      cs(e, t, n);
  }
}
function b1(e) {
  var t = e.updateQueue;
  if (t !== null) {
    e.updateQueue = null;
    var n = e.stateNode;
    n === null && (n = e.stateNode = new fS()),
      t.forEach(function (o) {
        var a = xS.bind(null, e, o);
        n.has(o) || (n.add(o), o.then(a, a));
      });
  }
}
function Qi(e, t) {
  var n = t.deletions;
  if (n !== null)
    for (var o = 0; o < n.length; o++) {
      var a = n[o];
      try {
        var l = e,
          f = t,
          _ = f;
        e: for (; _ !== null; ) {
          switch (_.tag) {
            case 5:
              (Wn = _.stateNode), (Yi = !1);
              break e;
            case 3:
              (Wn = _.stateNode.containerInfo), (Yi = !0);
              break e;
            case 4:
              (Wn = _.stateNode.containerInfo), (Yi = !0);
              break e;
          }
          _ = _.return;
        }
        if (Wn === null) throw Error(St(160));
        j2(l, f, a), (Wn = null), (Yi = !1);
        var m = a.alternate;
        m !== null && (m.return = null), (a.return = null);
      } catch (g) {
        _n(a, t, g);
      }
    }
  if (t.subtreeFlags & 12854)
    for (t = t.child; t !== null; ) U2(t, e), (t = t.sibling);
}
function U2(e, t) {
  var n = e.alternate,
    o = e.flags;
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Qi(t, e), co(e), o & 4)) {
        try {
          Gf(3, e, e.return), km(3, e);
        } catch ($) {
          _n(e, e.return, $);
        }
        try {
          Gf(5, e, e.return);
        } catch ($) {
          _n(e, e.return, $);
        }
      }
      break;
    case 1:
      Qi(t, e), co(e), o & 512 && n !== null && nu(n, n.return);
      break;
    case 5:
      if (
        (Qi(t, e),
        co(e),
        o & 512 && n !== null && nu(n, n.return),
        e.flags & 32)
      ) {
        var a = e.stateNode;
        try {
          Qf(a, "");
        } catch ($) {
          _n(e, e.return, $);
        }
      }
      if (o & 4 && ((a = e.stateNode), a != null)) {
        var l = e.memoizedProps,
          f = n !== null ? n.memoizedProps : l,
          _ = e.type,
          m = e.updateQueue;
        if (((e.updateQueue = null), m !== null))
          try {
            _ === "input" && l.type === "radio" && l.name != null && cb(a, l),
              i_(_, f);
            var g = i_(_, l);
            for (f = 0; f < m.length; f += 2) {
              var M = m[f],
                v = m[f + 1];
              M === "style"
                ? mb(a, v)
                : M === "dangerouslySetInnerHTML"
                ? pb(a, v)
                : M === "children"
                ? Qf(a, v)
                : Y_(a, M, v, g);
            }
            switch (_) {
              case "input":
                Jg(a, l);
                break;
              case "textarea":
                db(a, l);
                break;
              case "select":
                var C = a._wrapperState.wasMultiple;
                a._wrapperState.wasMultiple = !!l.multiple;
                var T = l.value;
                T != null
                  ? ou(a, !!l.multiple, T, !1)
                  : C !== !!l.multiple &&
                    (l.defaultValue != null
                      ? ou(a, !!l.multiple, l.defaultValue, !0)
                      : ou(a, !!l.multiple, l.multiple ? [] : "", !1));
            }
            a[ip] = l;
          } catch ($) {
            _n(e, e.return, $);
          }
      }
      break;
    case 6:
      if ((Qi(t, e), co(e), o & 4)) {
        if (e.stateNode === null) throw Error(St(162));
        (a = e.stateNode), (l = e.memoizedProps);
        try {
          a.nodeValue = l;
        } catch ($) {
          _n(e, e.return, $);
        }
      }
      break;
    case 3:
      if (
        (Qi(t, e), co(e), o & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          Jf(t.containerInfo);
        } catch ($) {
          _n(e, e.return, $);
        }
      break;
    case 4:
      Qi(t, e), co(e);
      break;
    case 13:
      Qi(t, e),
        co(e),
        (a = e.child),
        a.flags & 8192 &&
          ((l = a.memoizedState !== null),
          (a.stateNode.isHidden = l),
          !l ||
            (a.alternate !== null && a.alternate.memoizedState !== null) ||
            ($0 = wn())),
        o & 4 && b1(e);
      break;
    case 22:
      if (
        ((M = n !== null && n.memoizedState !== null),
        e.mode & 1 ? ((Zn = (g = Zn) || M), Qi(t, e), (Zn = g)) : Qi(t, e),
        co(e),
        o & 8192)
      ) {
        if (
          ((g = e.memoizedState !== null),
          (e.stateNode.isHidden = g) && !M && e.mode & 1)
        )
          for (Vt = e, M = e.child; M !== null; ) {
            for (v = Vt = M; Vt !== null; ) {
              switch (((C = Vt), (T = C.child), C.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Gf(4, C, C.return);
                  break;
                case 1:
                  nu(C, C.return);
                  var z = C.stateNode;
                  if (typeof z.componentWillUnmount == "function") {
                    (o = C), (n = C.return);
                    try {
                      (t = o),
                        (z.props = t.memoizedProps),
                        (z.state = t.memoizedState),
                        z.componentWillUnmount();
                    } catch ($) {
                      _n(o, n, $);
                    }
                  }
                  break;
                case 5:
                  nu(C, C.return);
                  break;
                case 22:
                  if (C.memoizedState !== null) {
                    M1(v);
                    continue;
                  }
              }
              T !== null ? ((T.return = C), (Vt = T)) : M1(v);
            }
            M = M.sibling;
          }
        e: for (M = null, v = e; ; ) {
          if (v.tag === 5) {
            if (M === null) {
              M = v;
              try {
                (a = v.stateNode),
                  g
                    ? ((l = a.style),
                      typeof l.setProperty == "function"
                        ? l.setProperty("display", "none", "important")
                        : (l.display = "none"))
                    : ((_ = v.stateNode),
                      (m = v.memoizedProps.style),
                      (f =
                        m != null && m.hasOwnProperty("display")
                          ? m.display
                          : null),
                      (_.style.display = hb("display", f)));
              } catch ($) {
                _n(e, e.return, $);
              }
            }
          } else if (v.tag === 6) {
            if (M === null)
              try {
                v.stateNode.nodeValue = g ? "" : v.memoizedProps;
              } catch ($) {
                _n(e, e.return, $);
              }
          } else if (
            ((v.tag !== 22 && v.tag !== 23) ||
              v.memoizedState === null ||
              v === e) &&
            v.child !== null
          ) {
            (v.child.return = v), (v = v.child);
            continue;
          }
          if (v === e) break e;
          for (; v.sibling === null; ) {
            if (v.return === null || v.return === e) break e;
            M === v && (M = null), (v = v.return);
          }
          M === v && (M = null), (v.sibling.return = v.return), (v = v.sibling);
        }
      }
      break;
    case 19:
      Qi(t, e), co(e), o & 4 && b1(e);
      break;
    case 21:
      break;
    default:
      Qi(t, e), co(e);
  }
}
function co(e) {
  var t = e.flags;
  if (t & 2) {
    try {
      e: {
        for (var n = e.return; n !== null; ) {
          if (N2(n)) {
            var o = n;
            break e;
          }
          n = n.return;
        }
        throw Error(St(160));
      }
      switch (o.tag) {
        case 5:
          var a = o.stateNode;
          o.flags & 32 && (Qf(a, ""), (o.flags &= -33));
          var l = v1(e);
          z_(e, l, a);
          break;
        case 3:
        case 4:
          var f = o.stateNode.containerInfo,
            _ = v1(e);
          F_(e, _, f);
          break;
        default:
          throw Error(St(161));
      }
    } catch (m) {
      _n(e, e.return, m);
    }
    e.flags &= -3;
  }
  t & 4096 && (e.flags &= -4097);
}
function hS(e, t, n) {
  (Vt = e), V2(e);
}
function V2(e, t, n) {
  for (var o = (e.mode & 1) !== 0; Vt !== null; ) {
    var a = Vt,
      l = a.child;
    if (a.tag === 22 && o) {
      var f = a.memoizedState !== null || kh;
      if (!f) {
        var _ = a.alternate,
          m = (_ !== null && _.memoizedState !== null) || Zn;
        _ = kh;
        var g = Zn;
        if (((kh = f), (Zn = m) && !g))
          for (Vt = a; Vt !== null; )
            (f = Vt),
              (m = f.child),
              f.tag === 22 && f.memoizedState !== null
                ? T1(a)
                : m !== null
                ? ((m.return = f), (Vt = m))
                : T1(a);
        for (; l !== null; ) (Vt = l), V2(l), (l = l.sibling);
        (Vt = a), (kh = _), (Zn = g);
      }
      x1(e);
    } else
      a.subtreeFlags & 8772 && l !== null ? ((l.return = a), (Vt = l)) : x1(e);
  }
}
function x1(e) {
  for (; Vt !== null; ) {
    var t = Vt;
    if (t.flags & 8772) {
      var n = t.alternate;
      try {
        if (t.flags & 8772)
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              Zn || km(5, t);
              break;
            case 1:
              var o = t.stateNode;
              if (t.flags & 4 && !Zn)
                if (n === null) o.componentDidMount();
                else {
                  var a =
                    t.elementType === t.type
                      ? n.memoizedProps
                      : Xi(t.type, n.memoizedProps);
                  o.componentDidUpdate(
                    a,
                    n.memoizedState,
                    o.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var l = t.updateQueue;
              l !== null && s1(t, l, o);
              break;
            case 3:
              var f = t.updateQueue;
              if (f !== null) {
                if (((n = null), t.child !== null))
                  switch (t.child.tag) {
                    case 5:
                      n = t.child.stateNode;
                      break;
                    case 1:
                      n = t.child.stateNode;
                  }
                s1(t, f, n);
              }
              break;
            case 5:
              var _ = t.stateNode;
              if (n === null && t.flags & 4) {
                n = _;
                var m = t.memoizedProps;
                switch (t.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    m.autoFocus && n.focus();
                    break;
                  case "img":
                    m.src && (n.src = m.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (t.memoizedState === null) {
                var g = t.alternate;
                if (g !== null) {
                  var M = g.memoizedState;
                  if (M !== null) {
                    var v = M.dehydrated;
                    v !== null && Jf(v);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(St(163));
          }
        Zn || (t.flags & 512 && I_(t));
      } catch (C) {
        _n(t, t.return, C);
      }
    }
    if (t === e) {
      Vt = null;
      break;
    }
    if (((n = t.sibling), n !== null)) {
      (n.return = t.return), (Vt = n);
      break;
    }
    Vt = t.return;
  }
}
function M1(e) {
  for (; Vt !== null; ) {
    var t = Vt;
    if (t === e) {
      Vt = null;
      break;
    }
    var n = t.sibling;
    if (n !== null) {
      (n.return = t.return), (Vt = n);
      break;
    }
    Vt = t.return;
  }
}
function T1(e) {
  for (; Vt !== null; ) {
    var t = Vt;
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var n = t.return;
          try {
            km(4, t);
          } catch (m) {
            _n(t, n, m);
          }
          break;
        case 1:
          var o = t.stateNode;
          if (typeof o.componentDidMount == "function") {
            var a = t.return;
            try {
              o.componentDidMount();
            } catch (m) {
              _n(t, a, m);
            }
          }
          var l = t.return;
          try {
            I_(t);
          } catch (m) {
            _n(t, l, m);
          }
          break;
        case 5:
          var f = t.return;
          try {
            I_(t);
          } catch (m) {
            _n(t, f, m);
          }
      }
    } catch (m) {
      _n(t, t.return, m);
    }
    if (t === e) {
      Vt = null;
      break;
    }
    var _ = t.sibling;
    if (_ !== null) {
      (_.return = t.return), (Vt = _);
      break;
    }
    Vt = t.return;
  }
}
var mS = Math.ceil,
  lm = jo.ReactCurrentDispatcher,
  C0 = jo.ReactCurrentOwner,
  ji = jo.ReactCurrentBatchConfig,
  Rr = 0,
  Ln = null,
  Mn = null,
  Gn = 0,
  ki = 0,
  iu = Cs(0),
  $n = 0,
  cp = null,
  pa = 0,
  Sm = 0,
  P0 = 0,
  Hf = null,
  pi = null,
  $0 = 0,
  _u = 1 / 0,
  Ao = null,
  um = !1,
  O_ = null,
  xs = null,
  Sh = !1,
  gs = null,
  cm = 0,
  qf = 0,
  D_ = null,
  Rh = -1,
  Nh = 0;
function si() {
  return Rr & 6 ? wn() : Rh !== -1 ? Rh : (Rh = wn());
}
function Ms(e) {
  return e.mode & 1
    ? Rr & 2 && Gn !== 0
      ? Gn & -Gn
      : Zk.transition !== null
      ? (Nh === 0 && (Nh = Eb()), Nh)
      : ((e = qr),
        e !== 0 || ((e = window.event), (e = e === void 0 ? 16 : zb(e.type))),
        e)
    : 1;
}
function eo(e, t, n, o) {
  if (50 < qf) throw ((qf = 0), (D_ = null), Error(St(185)));
  pp(e, n, o),
    (!(Rr & 2) || e !== Ln) &&
      (e === Ln && (!(Rr & 2) && (Sm |= n), $n === 4 && hs(e, Gn)),
      _i(e, o),
      n === 1 && Rr === 0 && !(t.mode & 1) && ((_u = wn() + 500), xm && Ps()));
}
function _i(e, t) {
  var n = e.callbackNode;
  ZT(e, t);
  var o = qh(e, e === Ln ? Gn : 0);
  if (o === 0)
    n !== null && Fv(n), (e.callbackNode = null), (e.callbackPriority = 0);
  else if (((t = o & -o), e.callbackPriority !== t)) {
    if ((n != null && Fv(n), t === 1))
      e.tag === 0 ? Yk(k1.bind(null, e)) : Jb(k1.bind(null, e)),
        qk(function () {
          !(Rr & 6) && Ps();
        }),
        (n = null);
    else {
      switch (Cb(o)) {
        case 1:
          n = r0;
          break;
        case 4:
          n = kb;
          break;
        case 16:
          n = Hh;
          break;
        case 536870912:
          n = Sb;
          break;
        default:
          n = Hh;
      }
      n = Y2(n, W2.bind(null, e));
    }
    (e.callbackPriority = t), (e.callbackNode = n);
  }
}
function W2(e, t) {
  if (((Rh = -1), (Nh = 0), Rr & 6)) throw Error(St(327));
  var n = e.callbackNode;
  if (cu() && e.callbackNode !== n) return null;
  var o = qh(e, e === Ln ? Gn : 0);
  if (o === 0) return null;
  if (o & 30 || o & e.expiredLanes || t) t = dm(e, o);
  else {
    t = o;
    var a = Rr;
    Rr |= 2;
    var l = H2();
    (Ln !== e || Gn !== t) && ((Ao = null), (_u = wn() + 500), la(e, t));
    do
      try {
        yS();
        break;
      } catch (_) {
        G2(e, _);
      }
    while (!0);
    m0(),
      (lm.current = l),
      (Rr = a),
      Mn !== null ? (t = 0) : ((Ln = null), (Gn = 0), (t = $n));
  }
  if (t !== 0) {
    if (
      (t === 2 && ((a = u_(e)), a !== 0 && ((o = a), (t = L_(e, a)))), t === 1)
    )
      throw ((n = cp), la(e, 0), hs(e, o), _i(e, wn()), n);
    if (t === 6) hs(e, o);
    else {
      if (
        ((a = e.current.alternate),
        !(o & 30) &&
          !gS(a) &&
          ((t = dm(e, o)),
          t === 2 && ((l = u_(e)), l !== 0 && ((o = l), (t = L_(e, l)))),
          t === 1))
      )
        throw ((n = cp), la(e, 0), hs(e, o), _i(e, wn()), n);
      switch (((e.finishedWork = a), (e.finishedLanes = o), t)) {
        case 0:
        case 1:
          throw Error(St(345));
        case 2:
          na(e, pi, Ao);
          break;
        case 3:
          if (
            (hs(e, o), (o & 130023424) === o && ((t = $0 + 500 - wn()), 10 < t))
          ) {
            if (qh(e, 0) !== 0) break;
            if (((a = e.suspendedLanes), (a & o) !== o)) {
              si(), (e.pingedLanes |= e.suspendedLanes & a);
              break;
            }
            e.timeoutHandle = __(na.bind(null, e, pi, Ao), t);
            break;
          }
          na(e, pi, Ao);
          break;
        case 4:
          if ((hs(e, o), (o & 4194240) === o)) break;
          for (t = e.eventTimes, a = -1; 0 < o; ) {
            var f = 31 - Ji(o);
            (l = 1 << f), (f = t[f]), f > a && (a = f), (o &= ~l);
          }
          if (
            ((o = a),
            (o = wn() - o),
            (o =
              (120 > o
                ? 120
                : 480 > o
                ? 480
                : 1080 > o
                ? 1080
                : 1920 > o
                ? 1920
                : 3e3 > o
                ? 3e3
                : 4320 > o
                ? 4320
                : 1960 * mS(o / 1960)) - o),
            10 < o)
          ) {
            e.timeoutHandle = __(na.bind(null, e, pi, Ao), o);
            break;
          }
          na(e, pi, Ao);
          break;
        case 5:
          na(e, pi, Ao);
          break;
        default:
          throw Error(St(329));
      }
    }
  }
  return _i(e, wn()), e.callbackNode === n ? W2.bind(null, e) : null;
}
function L_(e, t) {
  var n = Hf;
  return (
    e.current.memoizedState.isDehydrated && (la(e, t).flags |= 256),
    (e = dm(e, t)),
    e !== 2 && ((t = pi), (pi = n), t !== null && B_(t)),
    e
  );
}
function B_(e) {
  pi === null ? (pi = e) : pi.push.apply(pi, e);
}
function gS(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var n = t.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var o = 0; o < n.length; o++) {
          var a = n[o],
            l = a.getSnapshot;
          a = a.value;
          try {
            if (!to(l(), a)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = t.child), t.subtreeFlags & 16384 && n !== null))
      (n.return = t), (t = n);
    else {
      if (t === e) break;
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0;
        t = t.return;
      }
      (t.sibling.return = t.return), (t = t.sibling);
    }
  }
  return !0;
}
function hs(e, t) {
  for (
    t &= ~P0,
      t &= ~Sm,
      e.suspendedLanes |= t,
      e.pingedLanes &= ~t,
      e = e.expirationTimes;
    0 < t;

  ) {
    var n = 31 - Ji(t),
      o = 1 << n;
    (e[n] = -1), (t &= ~o);
  }
}
function k1(e) {
  if (Rr & 6) throw Error(St(327));
  cu();
  var t = qh(e, 0);
  if (!(t & 1)) return _i(e, wn()), null;
  var n = dm(e, t);
  if (e.tag !== 0 && n === 2) {
    var o = u_(e);
    o !== 0 && ((t = o), (n = L_(e, o)));
  }
  if (n === 1) throw ((n = cp), la(e, 0), hs(e, t), _i(e, wn()), n);
  if (n === 6) throw Error(St(345));
  return (
    (e.finishedWork = e.current.alternate),
    (e.finishedLanes = t),
    na(e, pi, Ao),
    _i(e, wn()),
    null
  );
}
function A0(e, t) {
  var n = Rr;
  Rr |= 1;
  try {
    return e(t);
  } finally {
    (Rr = n), Rr === 0 && ((_u = wn() + 500), xm && Ps());
  }
}
function ha(e) {
  gs !== null && gs.tag === 0 && !(Rr & 6) && cu();
  var t = Rr;
  Rr |= 1;
  var n = ji.transition,
    o = qr;
  try {
    if (((ji.transition = null), (qr = 1), e)) return e();
  } finally {
    (qr = o), (ji.transition = n), (Rr = t), !(Rr & 6) && Ps();
  }
}
function I0() {
  (ki = iu.current), sn(iu);
}
function la(e, t) {
  (e.finishedWork = null), (e.finishedLanes = 0);
  var n = e.timeoutHandle;
  if ((n !== -1 && ((e.timeoutHandle = -1), Hk(n)), Mn !== null))
    for (n = Mn.return; n !== null; ) {
      var o = n;
      switch ((f0(o), o.tag)) {
        case 1:
          (o = o.type.childContextTypes), o != null && Zh();
          break;
        case 3:
          mu(), sn(mi), sn(Jn), b0();
          break;
        case 5:
          v0(o);
          break;
        case 4:
          mu();
          break;
        case 13:
          sn(dn);
          break;
        case 19:
          sn(dn);
          break;
        case 10:
          g0(o.type._context);
          break;
        case 22:
        case 23:
          I0();
      }
      n = n.return;
    }
  if (
    ((Ln = e),
    (Mn = e = Ts(e.current, null)),
    (Gn = ki = t),
    ($n = 0),
    (cp = null),
    (P0 = Sm = pa = 0),
    (pi = Hf = null),
    sa !== null)
  ) {
    for (t = 0; t < sa.length; t++)
      if (((n = sa[t]), (o = n.interleaved), o !== null)) {
        n.interleaved = null;
        var a = o.next,
          l = n.pending;
        if (l !== null) {
          var f = l.next;
          (l.next = a), (o.next = f);
        }
        n.pending = o;
      }
    sa = null;
  }
  return e;
}
function G2(e, t) {
  do {
    var n = Mn;
    try {
      if ((m0(), (Dh.current = am), sm)) {
        for (var o = fn.memoizedState; o !== null; ) {
          var a = o.queue;
          a !== null && (a.pending = null), (o = o.next);
        }
        sm = !1;
      }
      if (
        ((fa = 0),
        (Dn = Pn = fn = null),
        (Wf = !1),
        (ap = 0),
        (C0.current = null),
        n === null || n.return === null)
      ) {
        ($n = 1), (cp = t), (Mn = null);
        break;
      }
      e: {
        var l = e,
          f = n.return,
          _ = n,
          m = t;
        if (
          ((t = Gn),
          (_.flags |= 32768),
          m !== null && typeof m == "object" && typeof m.then == "function")
        ) {
          var g = m,
            M = _,
            v = M.tag;
          if (!(M.mode & 1) && (v === 0 || v === 11 || v === 15)) {
            var C = M.alternate;
            C
              ? ((M.updateQueue = C.updateQueue),
                (M.memoizedState = C.memoizedState),
                (M.lanes = C.lanes))
              : ((M.updateQueue = null), (M.memoizedState = null));
          }
          var T = f1(f);
          if (T !== null) {
            (T.flags &= -257),
              p1(T, f, _, l, t),
              T.mode & 1 && d1(l, g, t),
              (t = T),
              (m = g);
            var z = t.updateQueue;
            if (z === null) {
              var $ = new Set();
              $.add(m), (t.updateQueue = $);
            } else z.add(m);
            break e;
          } else {
            if (!(t & 1)) {
              d1(l, g, t), F0();
              break e;
            }
            m = Error(St(426));
          }
        } else if (ln && _.mode & 1) {
          var S = f1(f);
          if (S !== null) {
            !(S.flags & 65536) && (S.flags |= 256),
              p1(S, f, _, l, t),
              p0(gu(m, _));
            break e;
          }
        }
        (l = m = gu(m, _)),
          $n !== 4 && ($n = 2),
          Hf === null ? (Hf = [l]) : Hf.push(l),
          (l = f);
        do {
          switch (l.tag) {
            case 3:
              (l.flags |= 65536), (t &= -t), (l.lanes |= t);
              var y = C2(l, m, t);
              o1(l, y);
              break e;
            case 1:
              _ = m;
              var x = l.type,
                I = l.stateNode;
              if (
                !(l.flags & 128) &&
                (typeof x.getDerivedStateFromError == "function" ||
                  (I !== null &&
                    typeof I.componentDidCatch == "function" &&
                    (xs === null || !xs.has(I))))
              ) {
                (l.flags |= 65536), (t &= -t), (l.lanes |= t);
                var V = P2(l, _, t);
                o1(l, V);
                break e;
              }
          }
          l = l.return;
        } while (l !== null);
      }
      K2(n);
    } catch (O) {
      (t = O), Mn === n && n !== null && (Mn = n = n.return);
      continue;
    }
    break;
  } while (!0);
}
function H2() {
  var e = lm.current;
  return (lm.current = am), e === null ? am : e;
}
function F0() {
  ($n === 0 || $n === 3 || $n === 2) && ($n = 4),
    Ln === null || (!(pa & 268435455) && !(Sm & 268435455)) || hs(Ln, Gn);
}
function dm(e, t) {
  var n = Rr;
  Rr |= 2;
  var o = H2();
  (Ln !== e || Gn !== t) && ((Ao = null), la(e, t));
  do
    try {
      _S();
      break;
    } catch (a) {
      G2(e, a);
    }
  while (!0);
  if ((m0(), (Rr = n), (lm.current = o), Mn !== null)) throw Error(St(261));
  return (Ln = null), (Gn = 0), $n;
}
function _S() {
  for (; Mn !== null; ) q2(Mn);
}
function yS() {
  for (; Mn !== null && !VT(); ) q2(Mn);
}
function q2(e) {
  var t = X2(e.alternate, e, ki);
  (e.memoizedProps = e.pendingProps),
    t === null ? K2(e) : (Mn = t),
    (C0.current = null);
}
function K2(e) {
  var t = e;
  do {
    var n = t.alternate;
    if (((e = t.return), t.flags & 32768)) {
      if (((n = dS(n, t)), n !== null)) {
        (n.flags &= 32767), (Mn = n);
        return;
      }
      if (e !== null)
        (e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null);
      else {
        ($n = 6), (Mn = null);
        return;
      }
    } else if (((n = cS(n, t, ki)), n !== null)) {
      Mn = n;
      return;
    }
    if (((t = t.sibling), t !== null)) {
      Mn = t;
      return;
    }
    Mn = t = e;
  } while (t !== null);
  $n === 0 && ($n = 5);
}
function na(e, t, n) {
  var o = qr,
    a = ji.transition;
  try {
    (ji.transition = null), (qr = 1), wS(e, t, n, o);
  } finally {
    (ji.transition = a), (qr = o);
  }
  return null;
}
function wS(e, t, n, o) {
  do cu();
  while (gs !== null);
  if (Rr & 6) throw Error(St(327));
  n = e.finishedWork;
  var a = e.finishedLanes;
  if (n === null) return null;
  if (((e.finishedWork = null), (e.finishedLanes = 0), n === e.current))
    throw Error(St(177));
  (e.callbackNode = null), (e.callbackPriority = 0);
  var l = n.lanes | n.childLanes;
  if (
    (JT(e, l),
    e === Ln && ((Mn = Ln = null), (Gn = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      Sh ||
      ((Sh = !0),
      Y2(Hh, function () {
        return cu(), null;
      })),
    (l = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || l)
  ) {
    (l = ji.transition), (ji.transition = null);
    var f = qr;
    qr = 1;
    var _ = Rr;
    (Rr |= 4),
      (C0.current = null),
      pS(e, n),
      U2(n, e),
      Rk(m_),
      (Kh = !!h_),
      (m_ = h_ = null),
      (e.current = n),
      hS(n),
      WT(),
      (Rr = _),
      (qr = f),
      (ji.transition = l);
  } else e.current = n;
  if (
    (Sh && ((Sh = !1), (gs = e), (cm = a)),
    (l = e.pendingLanes),
    l === 0 && (xs = null),
    qT(n.stateNode),
    _i(e, wn()),
    t !== null)
  )
    for (o = e.onRecoverableError, n = 0; n < t.length; n++)
      (a = t[n]), o(a.value, { componentStack: a.stack, digest: a.digest });
  if (um) throw ((um = !1), (e = O_), (O_ = null), e);
  return (
    cm & 1 && e.tag !== 0 && cu(),
    (l = e.pendingLanes),
    l & 1 ? (e === D_ ? qf++ : ((qf = 0), (D_ = e))) : (qf = 0),
    Ps(),
    null
  );
}
function cu() {
  if (gs !== null) {
    var e = Cb(cm),
      t = ji.transition,
      n = qr;
    try {
      if (((ji.transition = null), (qr = 16 > e ? 16 : e), gs === null))
        var o = !1;
      else {
        if (((e = gs), (gs = null), (cm = 0), Rr & 6)) throw Error(St(331));
        var a = Rr;
        for (Rr |= 4, Vt = e.current; Vt !== null; ) {
          var l = Vt,
            f = l.child;
          if (Vt.flags & 16) {
            var _ = l.deletions;
            if (_ !== null) {
              for (var m = 0; m < _.length; m++) {
                var g = _[m];
                for (Vt = g; Vt !== null; ) {
                  var M = Vt;
                  switch (M.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Gf(8, M, l);
                  }
                  var v = M.child;
                  if (v !== null) (v.return = M), (Vt = v);
                  else
                    for (; Vt !== null; ) {
                      M = Vt;
                      var C = M.sibling,
                        T = M.return;
                      if ((R2(M), M === g)) {
                        Vt = null;
                        break;
                      }
                      if (C !== null) {
                        (C.return = T), (Vt = C);
                        break;
                      }
                      Vt = T;
                    }
                }
              }
              var z = l.alternate;
              if (z !== null) {
                var $ = z.child;
                if ($ !== null) {
                  z.child = null;
                  do {
                    var S = $.sibling;
                    ($.sibling = null), ($ = S);
                  } while ($ !== null);
                }
              }
              Vt = l;
            }
          }
          if (l.subtreeFlags & 2064 && f !== null) (f.return = l), (Vt = f);
          else
            e: for (; Vt !== null; ) {
              if (((l = Vt), l.flags & 2048))
                switch (l.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Gf(9, l, l.return);
                }
              var y = l.sibling;
              if (y !== null) {
                (y.return = l.return), (Vt = y);
                break e;
              }
              Vt = l.return;
            }
        }
        var x = e.current;
        for (Vt = x; Vt !== null; ) {
          f = Vt;
          var I = f.child;
          if (f.subtreeFlags & 2064 && I !== null) (I.return = f), (Vt = I);
          else
            e: for (f = x; Vt !== null; ) {
              if (((_ = Vt), _.flags & 2048))
                try {
                  switch (_.tag) {
                    case 0:
                    case 11:
                    case 15:
                      km(9, _);
                  }
                } catch (O) {
                  _n(_, _.return, O);
                }
              if (_ === f) {
                Vt = null;
                break e;
              }
              var V = _.sibling;
              if (V !== null) {
                (V.return = _.return), (Vt = V);
                break e;
              }
              Vt = _.return;
            }
        }
        if (
          ((Rr = a), Ps(), mo && typeof mo.onPostCommitFiberRoot == "function")
        )
          try {
            mo.onPostCommitFiberRoot(_m, e);
          } catch {}
        o = !0;
      }
      return o;
    } finally {
      (qr = n), (ji.transition = t);
    }
  }
  return !1;
}
function S1(e, t, n) {
  (t = gu(n, t)),
    (t = C2(e, t, 1)),
    (e = bs(e, t, 1)),
    (t = si()),
    e !== null && (pp(e, 1, t), _i(e, t));
}
function _n(e, t, n) {
  if (e.tag === 3) S1(e, e, n);
  else
    for (; t !== null; ) {
      if (t.tag === 3) {
        S1(t, e, n);
        break;
      } else if (t.tag === 1) {
        var o = t.stateNode;
        if (
          typeof t.type.getDerivedStateFromError == "function" ||
          (typeof o.componentDidCatch == "function" &&
            (xs === null || !xs.has(o)))
        ) {
          (e = gu(n, e)),
            (e = P2(t, e, 1)),
            (t = bs(t, e, 1)),
            (e = si()),
            t !== null && (pp(t, 1, e), _i(t, e));
          break;
        }
      }
      t = t.return;
    }
}
function vS(e, t, n) {
  var o = e.pingCache;
  o !== null && o.delete(t),
    (t = si()),
    (e.pingedLanes |= e.suspendedLanes & n),
    Ln === e &&
      (Gn & n) === n &&
      ($n === 4 || ($n === 3 && (Gn & 130023424) === Gn && 500 > wn() - $0)
        ? la(e, 0)
        : (P0 |= n)),
    _i(e, t);
}
function Q2(e, t) {
  t === 0 &&
    (e.mode & 1
      ? ((t = gh), (gh <<= 1), !(gh & 130023424) && (gh = 4194304))
      : (t = 1));
  var n = si();
  (e = Ro(e, t)), e !== null && (pp(e, t, n), _i(e, n));
}
function bS(e) {
  var t = e.memoizedState,
    n = 0;
  t !== null && (n = t.retryLane), Q2(e, n);
}
function xS(e, t) {
  var n = 0;
  switch (e.tag) {
    case 13:
      var o = e.stateNode,
        a = e.memoizedState;
      a !== null && (n = a.retryLane);
      break;
    case 19:
      o = e.stateNode;
      break;
    default:
      throw Error(St(314));
  }
  o !== null && o.delete(t), Q2(e, n);
}
var X2;
X2 = function (e, t, n) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps || mi.current) hi = !0;
    else {
      if (!(e.lanes & n) && !(t.flags & 128)) return (hi = !1), uS(e, t, n);
      hi = !!(e.flags & 131072);
    }
  else (hi = !1), ln && t.flags & 1048576 && e2(t, tm, t.index);
  switch (((t.lanes = 0), t.tag)) {
    case 2:
      var o = t.type;
      Bh(e, t), (e = t.pendingProps);
      var a = fu(t, Jn.current);
      uu(t, n), (a = M0(null, t, o, e, a, n));
      var l = T0();
      return (
        (t.flags |= 1),
        typeof a == "object" &&
        a !== null &&
        typeof a.render == "function" &&
        a.$$typeof === void 0
          ? ((t.tag = 1),
            (t.memoizedState = null),
            (t.updateQueue = null),
            gi(o) ? ((l = !0), Jh(t)) : (l = !1),
            (t.memoizedState =
              a.state !== null && a.state !== void 0 ? a.state : null),
            y0(t),
            (a.updater = Tm),
            (t.stateNode = a),
            (a._reactInternals = t),
            T_(t, o, e, n),
            (t = E_(null, t, o, !0, l, n)))
          : ((t.tag = 0), ln && l && d0(t), oi(null, t, a, n), (t = t.child)),
        t
      );
    case 16:
      o = t.elementType;
      e: {
        switch (
          (Bh(e, t),
          (e = t.pendingProps),
          (a = o._init),
          (o = a(o._payload)),
          (t.type = o),
          (a = t.tag = TS(o)),
          (e = Xi(o, e)),
          a)
        ) {
          case 0:
            t = S_(null, t, o, e, n);
            break e;
          case 1:
            t = g1(null, t, o, e, n);
            break e;
          case 11:
            t = h1(null, t, o, e, n);
            break e;
          case 14:
            t = m1(null, t, o, Xi(o.type, e), n);
            break e;
        }
        throw Error(St(306, o, ""));
      }
      return t;
    case 0:
      return (
        (o = t.type),
        (a = t.pendingProps),
        (a = t.elementType === o ? a : Xi(o, a)),
        S_(e, t, o, a, n)
      );
    case 1:
      return (
        (o = t.type),
        (a = t.pendingProps),
        (a = t.elementType === o ? a : Xi(o, a)),
        g1(e, t, o, a, n)
      );
    case 3:
      e: {
        if ((F2(t), e === null)) throw Error(St(387));
        (o = t.pendingProps),
          (l = t.memoizedState),
          (a = l.element),
          s2(e, t),
          im(t, o, null, n);
        var f = t.memoizedState;
        if (((o = f.element), l.isDehydrated))
          if (
            ((l = {
              element: o,
              isDehydrated: !1,
              cache: f.cache,
              pendingSuspenseBoundaries: f.pendingSuspenseBoundaries,
              transitions: f.transitions
            }),
            (t.updateQueue.baseState = l),
            (t.memoizedState = l),
            t.flags & 256)
          ) {
            (a = gu(Error(St(423)), t)), (t = _1(e, t, o, n, a));
            break e;
          } else if (o !== a) {
            (a = gu(Error(St(424)), t)), (t = _1(e, t, o, n, a));
            break e;
          } else
            for (
              Si = vs(t.stateNode.containerInfo.firstChild),
                Ei = t,
                ln = !0,
                Zi = null,
                n = i2(t, null, o, n),
                t.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((pu(), o === a)) {
            t = No(e, t, n);
            break e;
          }
          oi(e, t, o, n);
        }
        t = t.child;
      }
      return t;
    case 5:
      return (
        a2(t),
        e === null && b_(t),
        (o = t.type),
        (a = t.pendingProps),
        (l = e !== null ? e.memoizedProps : null),
        (f = a.children),
        g_(o, a) ? (f = null) : l !== null && g_(o, l) && (t.flags |= 32),
        I2(e, t),
        oi(e, t, f, n),
        t.child
      );
    case 6:
      return e === null && b_(t), null;
    case 13:
      return z2(e, t, n);
    case 4:
      return (
        w0(t, t.stateNode.containerInfo),
        (o = t.pendingProps),
        e === null ? (t.child = hu(t, null, o, n)) : oi(e, t, o, n),
        t.child
      );
    case 11:
      return (
        (o = t.type),
        (a = t.pendingProps),
        (a = t.elementType === o ? a : Xi(o, a)),
        h1(e, t, o, a, n)
      );
    case 7:
      return oi(e, t, t.pendingProps, n), t.child;
    case 8:
      return oi(e, t, t.pendingProps.children, n), t.child;
    case 12:
      return oi(e, t, t.pendingProps.children, n), t.child;
    case 10:
      e: {
        if (
          ((o = t.type._context),
          (a = t.pendingProps),
          (l = t.memoizedProps),
          (f = a.value),
          tn(rm, o._currentValue),
          (o._currentValue = f),
          l !== null)
        )
          if (to(l.value, f)) {
            if (l.children === a.children && !mi.current) {
              t = No(e, t, n);
              break e;
            }
          } else
            for (l = t.child, l !== null && (l.return = t); l !== null; ) {
              var _ = l.dependencies;
              if (_ !== null) {
                f = l.child;
                for (var m = _.firstContext; m !== null; ) {
                  if (m.context === o) {
                    if (l.tag === 1) {
                      (m = Do(-1, n & -n)), (m.tag = 2);
                      var g = l.updateQueue;
                      if (g !== null) {
                        g = g.shared;
                        var M = g.pending;
                        M === null
                          ? (m.next = m)
                          : ((m.next = M.next), (M.next = m)),
                          (g.pending = m);
                      }
                    }
                    (l.lanes |= n),
                      (m = l.alternate),
                      m !== null && (m.lanes |= n),
                      x_(l.return, n, t),
                      (_.lanes |= n);
                    break;
                  }
                  m = m.next;
                }
              } else if (l.tag === 10) f = l.type === t.type ? null : l.child;
              else if (l.tag === 18) {
                if (((f = l.return), f === null)) throw Error(St(341));
                (f.lanes |= n),
                  (_ = f.alternate),
                  _ !== null && (_.lanes |= n),
                  x_(f, n, t),
                  (f = l.sibling);
              } else f = l.child;
              if (f !== null) f.return = l;
              else
                for (f = l; f !== null; ) {
                  if (f === t) {
                    f = null;
                    break;
                  }
                  if (((l = f.sibling), l !== null)) {
                    (l.return = f.return), (f = l);
                    break;
                  }
                  f = f.return;
                }
              l = f;
            }
        oi(e, t, a.children, n), (t = t.child);
      }
      return t;
    case 9:
      return (
        (a = t.type),
        (o = t.pendingProps.children),
        uu(t, n),
        (a = Ui(a)),
        (o = o(a)),
        (t.flags |= 1),
        oi(e, t, o, n),
        t.child
      );
    case 14:
      return (
        (o = t.type),
        (a = Xi(o, t.pendingProps)),
        (a = Xi(o.type, a)),
        m1(e, t, o, a, n)
      );
    case 15:
      return $2(e, t, t.type, t.pendingProps, n);
    case 17:
      return (
        (o = t.type),
        (a = t.pendingProps),
        (a = t.elementType === o ? a : Xi(o, a)),
        Bh(e, t),
        (t.tag = 1),
        gi(o) ? ((e = !0), Jh(t)) : (e = !1),
        uu(t, n),
        E2(t, o, a),
        T_(t, o, a, n),
        E_(null, t, o, !0, e, n)
      );
    case 19:
      return O2(e, t, n);
    case 22:
      return A2(e, t, n);
  }
  throw Error(St(156, t.tag));
};
function Y2(e, t) {
  return Tb(e, t);
}
function MS(e, t, n, o) {
  (this.tag = e),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = t),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = o),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Ni(e, t, n, o) {
  return new MS(e, t, n, o);
}
function z0(e) {
  return (e = e.prototype), !(!e || !e.isReactComponent);
}
function TS(e) {
  if (typeof e == "function") return z0(e) ? 1 : 0;
  if (e != null) {
    if (((e = e.$$typeof), e === J_)) return 11;
    if (e === e0) return 14;
  }
  return 2;
}
function Ts(e, t) {
  var n = e.alternate;
  return (
    n === null
      ? ((n = Ni(e.tag, t, e.key, e.mode)),
        (n.elementType = e.elementType),
        (n.type = e.type),
        (n.stateNode = e.stateNode),
        (n.alternate = e),
        (e.alternate = n))
      : ((n.pendingProps = t),
        (n.type = e.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = e.flags & 14680064),
    (n.childLanes = e.childLanes),
    (n.lanes = e.lanes),
    (n.child = e.child),
    (n.memoizedProps = e.memoizedProps),
    (n.memoizedState = e.memoizedState),
    (n.updateQueue = e.updateQueue),
    (t = e.dependencies),
    (n.dependencies =
      t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }),
    (n.sibling = e.sibling),
    (n.index = e.index),
    (n.ref = e.ref),
    n
  );
}
function jh(e, t, n, o, a, l) {
  var f = 2;
  if (((o = e), typeof e == "function")) z0(e) && (f = 1);
  else if (typeof e == "string") f = 5;
  else
    e: switch (e) {
      case Kl:
        return ua(n.children, a, l, t);
      case Z_:
        (f = 8), (a |= 8);
        break;
      case Kg:
        return (
          (e = Ni(12, n, t, a | 2)), (e.elementType = Kg), (e.lanes = l), e
        );
      case Qg:
        return (e = Ni(13, n, t, a)), (e.elementType = Qg), (e.lanes = l), e;
      case Xg:
        return (e = Ni(19, n, t, a)), (e.elementType = Xg), (e.lanes = l), e;
      case ab:
        return Em(n, a, l, t);
      default:
        if (typeof e == "object" && e !== null)
          switch (e.$$typeof) {
            case ob:
              f = 10;
              break e;
            case sb:
              f = 9;
              break e;
            case J_:
              f = 11;
              break e;
            case e0:
              f = 14;
              break e;
            case ds:
              (f = 16), (o = null);
              break e;
          }
        throw Error(St(130, e == null ? e : typeof e, ""));
    }
  return (
    (t = Ni(f, n, t, a)), (t.elementType = e), (t.type = o), (t.lanes = l), t
  );
}
function ua(e, t, n, o) {
  return (e = Ni(7, e, o, t)), (e.lanes = n), e;
}
function Em(e, t, n, o) {
  return (
    (e = Ni(22, e, o, t)),
    (e.elementType = ab),
    (e.lanes = n),
    (e.stateNode = { isHidden: !1 }),
    e
  );
}
function Ug(e, t, n) {
  return (e = Ni(6, e, null, t)), (e.lanes = n), e;
}
function Vg(e, t, n) {
  return (
    (t = Ni(4, e.children !== null ? e.children : [], e.key, t)),
    (t.lanes = n),
    (t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation
    }),
    t
  );
}
function kS(e, t, n, o, a) {
  (this.tag = t),
    (this.containerInfo = e),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Mg(0)),
    (this.expirationTimes = Mg(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Mg(0)),
    (this.identifierPrefix = o),
    (this.onRecoverableError = a),
    (this.mutableSourceEagerHydrationData = null);
}
function O0(e, t, n, o, a, l, f, _, m) {
  return (
    (e = new kS(e, t, n, _, m)),
    t === 1 ? ((t = 1), l === !0 && (t |= 8)) : (t = 0),
    (l = Ni(3, null, null, t)),
    (e.current = l),
    (l.stateNode = e),
    (l.memoizedState = {
      element: o,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null
    }),
    y0(l),
    e
  );
}
function SS(e, t, n) {
  var o = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: ql,
    key: o == null ? null : "" + o,
    children: e,
    containerInfo: t,
    implementation: n
  };
}
function Z2(e) {
  if (!e) return Ss;
  e = e._reactInternals;
  e: {
    if (ga(e) !== e || e.tag !== 1) throw Error(St(170));
    var t = e;
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context;
          break e;
        case 1:
          if (gi(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      t = t.return;
    } while (t !== null);
    throw Error(St(171));
  }
  if (e.tag === 1) {
    var n = e.type;
    if (gi(n)) return Zb(e, n, t);
  }
  return t;
}
function J2(e, t, n, o, a, l, f, _, m) {
  return (
    (e = O0(n, o, !0, e, a, l, f, _, m)),
    (e.context = Z2(null)),
    (n = e.current),
    (o = si()),
    (a = Ms(n)),
    (l = Do(o, a)),
    (l.callback = t ?? null),
    bs(n, l, a),
    (e.current.lanes = a),
    pp(e, a, o),
    _i(e, o),
    e
  );
}
function Cm(e, t, n, o) {
  var a = t.current,
    l = si(),
    f = Ms(a);
  return (
    (n = Z2(n)),
    t.context === null ? (t.context = n) : (t.pendingContext = n),
    (t = Do(l, f)),
    (t.payload = { element: e }),
    (o = o === void 0 ? null : o),
    o !== null && (t.callback = o),
    (e = bs(a, t, f)),
    e !== null && (eo(e, a, f, l), Oh(e, a, f)),
    f
  );
}
function fm(e) {
  if (((e = e.current), !e.child)) return null;
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode;
    default:
      return e.child.stateNode;
  }
}
function E1(e, t) {
  if (((e = e.memoizedState), e !== null && e.dehydrated !== null)) {
    var n = e.retryLane;
    e.retryLane = n !== 0 && n < t ? n : t;
  }
}
function D0(e, t) {
  E1(e, t), (e = e.alternate) && E1(e, t);
}
function ES() {
  return null;
}
var ex =
  typeof reportError == "function"
    ? reportError
    : function (e) {
        console.error(e);
      };
function L0(e) {
  this._internalRoot = e;
}
Pm.prototype.render = L0.prototype.render = function (e) {
  var t = this._internalRoot;
  if (t === null) throw Error(St(409));
  Cm(e, t, null, null);
};
Pm.prototype.unmount = L0.prototype.unmount = function () {
  var e = this._internalRoot;
  if (e !== null) {
    this._internalRoot = null;
    var t = e.containerInfo;
    ha(function () {
      Cm(null, e, null, null);
    }),
      (t[Bo] = null);
  }
};
function Pm(e) {
  this._internalRoot = e;
}
Pm.prototype.unstable_scheduleHydration = function (e) {
  if (e) {
    var t = Ab();
    e = { blockedOn: null, target: e, priority: t };
    for (var n = 0; n < ps.length && t !== 0 && t < ps[n].priority; n++);
    ps.splice(n, 0, e), n === 0 && Fb(e);
  }
};
function B0(e) {
  return !(!e || (e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11));
}
function $m(e) {
  return !(
    !e ||
    (e.nodeType !== 1 &&
      e.nodeType !== 9 &&
      e.nodeType !== 11 &&
      (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
  );
}
function C1() {}
function CS(e, t, n, o, a) {
  if (a) {
    if (typeof o == "function") {
      var l = o;
      o = function () {
        var g = fm(f);
        l.call(g);
      };
    }
    var f = J2(t, o, e, 0, null, !1, !1, "", C1);
    return (
      (e._reactRootContainer = f),
      (e[Bo] = f.current),
      rp(e.nodeType === 8 ? e.parentNode : e),
      ha(),
      f
    );
  }
  for (; (a = e.lastChild); ) e.removeChild(a);
  if (typeof o == "function") {
    var _ = o;
    o = function () {
      var g = fm(m);
      _.call(g);
    };
  }
  var m = O0(e, 0, !1, null, null, !1, !1, "", C1);
  return (
    (e._reactRootContainer = m),
    (e[Bo] = m.current),
    rp(e.nodeType === 8 ? e.parentNode : e),
    ha(function () {
      Cm(t, m, n, o);
    }),
    m
  );
}
function Am(e, t, n, o, a) {
  var l = n._reactRootContainer;
  if (l) {
    var f = l;
    if (typeof a == "function") {
      var _ = a;
      a = function () {
        var m = fm(f);
        _.call(m);
      };
    }
    Cm(t, f, e, a);
  } else f = CS(n, t, e, a, o);
  return fm(f);
}
Pb = function (e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode;
      if (t.current.memoizedState.isDehydrated) {
        var n = Df(t.pendingLanes);
        n !== 0 &&
          (n0(t, n | 1), _i(t, wn()), !(Rr & 6) && ((_u = wn() + 500), Ps()));
      }
      break;
    case 13:
      ha(function () {
        var o = Ro(e, 1);
        if (o !== null) {
          var a = si();
          eo(o, e, 1, a);
        }
      }),
        D0(e, 1);
  }
};
i0 = function (e) {
  if (e.tag === 13) {
    var t = Ro(e, 134217728);
    if (t !== null) {
      var n = si();
      eo(t, e, 134217728, n);
    }
    D0(e, 134217728);
  }
};
$b = function (e) {
  if (e.tag === 13) {
    var t = Ms(e),
      n = Ro(e, t);
    if (n !== null) {
      var o = si();
      eo(n, e, t, o);
    }
    D0(e, t);
  }
};
Ab = function () {
  return qr;
};
Ib = function (e, t) {
  var n = qr;
  try {
    return (qr = e), t();
  } finally {
    qr = n;
  }
};
s_ = function (e, t, n) {
  switch (t) {
    case "input":
      if ((Jg(e, n), (t = n.name), n.type === "radio" && t != null)) {
        for (n = e; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + t) + '][type="radio"]'
          ),
            t = 0;
          t < n.length;
          t++
        ) {
          var o = n[t];
          if (o !== e && o.form === e.form) {
            var a = bm(o);
            if (!a) throw Error(St(90));
            ub(o), Jg(o, a);
          }
        }
      }
      break;
    case "textarea":
      db(e, n);
      break;
    case "select":
      (t = n.value), t != null && ou(e, !!n.multiple, t, !1);
  }
};
yb = A0;
wb = ha;
var PS = { usingClientEntryPoint: !1, Events: [mp, Zl, bm, gb, _b, A0] },
  If = {
    findFiberByHostInstance: oa,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
  },
  $S = {
    bundleType: If.bundleType,
    version: If.version,
    rendererPackageName: If.rendererPackageName,
    rendererConfig: If.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: jo.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (e) {
      return (e = xb(e)), e === null ? null : e.stateNode;
    },
    findFiberByHostInstance: If.findFiberByHostInstance || ES,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Eh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Eh.isDisabled && Eh.supportsFiber)
    try {
      (_m = Eh.inject($S)), (mo = Eh);
    } catch {}
}
Pi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = PS;
Pi.createPortal = function (e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!B0(t)) throw Error(St(200));
  return SS(e, t, null, n);
};
Pi.createRoot = function (e, t) {
  if (!B0(e)) throw Error(St(299));
  var n = !1,
    o = "",
    a = ex;
  return (
    t != null &&
      (t.unstable_strictMode === !0 && (n = !0),
      t.identifierPrefix !== void 0 && (o = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (a = t.onRecoverableError)),
    (t = O0(e, 1, !1, null, null, n, !1, o, a)),
    (e[Bo] = t.current),
    rp(e.nodeType === 8 ? e.parentNode : e),
    new L0(t)
  );
};
Pi.findDOMNode = function (e) {
  if (e == null) return null;
  if (e.nodeType === 1) return e;
  var t = e._reactInternals;
  if (t === void 0)
    throw typeof e.render == "function"
      ? Error(St(188))
      : ((e = Object.keys(e).join(",")), Error(St(268, e)));
  return (e = xb(t)), (e = e === null ? null : e.stateNode), e;
};
Pi.flushSync = function (e) {
  return ha(e);
};
Pi.hydrate = function (e, t, n) {
  if (!$m(t)) throw Error(St(200));
  return Am(null, e, t, !0, n);
};
Pi.hydrateRoot = function (e, t, n) {
  if (!B0(e)) throw Error(St(405));
  var o = (n != null && n.hydratedSources) || null,
    a = !1,
    l = "",
    f = ex;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (a = !0),
      n.identifierPrefix !== void 0 && (l = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (f = n.onRecoverableError)),
    (t = J2(t, null, e, 1, n ?? null, a, !1, l, f)),
    (e[Bo] = t.current),
    rp(e),
    o)
  )
    for (e = 0; e < o.length; e++)
      (n = o[e]),
        (a = n._getVersion),
        (a = a(n._source)),
        t.mutableSourceEagerHydrationData == null
          ? (t.mutableSourceEagerHydrationData = [n, a])
          : t.mutableSourceEagerHydrationData.push(n, a);
  return new Pm(t);
};
Pi.render = function (e, t, n) {
  if (!$m(t)) throw Error(St(200));
  return Am(null, e, t, !1, n);
};
Pi.unmountComponentAtNode = function (e) {
  if (!$m(e)) throw Error(St(40));
  return e._reactRootContainer
    ? (ha(function () {
        Am(null, null, e, !1, function () {
          (e._reactRootContainer = null), (e[Bo] = null);
        });
      }),
      !0)
    : !1;
};
Pi.unstable_batchedUpdates = A0;
Pi.unstable_renderSubtreeIntoContainer = function (e, t, n, o) {
  if (!$m(n)) throw Error(St(200));
  if (e == null || e._reactInternals === void 0) throw Error(St(38));
  return Am(e, t, n, !1, o);
};
Pi.version = "18.3.1-next-f1338f8080-20240426";
function tx() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(tx);
    } catch (e) {
      console.error(e);
    }
}
tx(), (tb.exports = Pi);
var AS = tb.exports,
  rx,
  P1 = AS;
(rx = P1.createRoot), P1.hydrateRoot;
var nx = { exports: {} },
  IS = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  FS = IS,
  zS = FS;
function ix() {}
function ox() {}
ox.resetWarningCache = ix;
var OS = function () {
  function e(o, a, l, f, _, m) {
    if (m !== zS) {
      var g = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((g.name = "Invariant Violation"), g);
    }
  }
  e.isRequired = e;
  function t() {
    return e;
  }
  var n = {
    array: e,
    bigint: e,
    bool: e,
    func: e,
    number: e,
    object: e,
    string: e,
    symbol: e,
    any: e,
    arrayOf: t,
    element: e,
    elementType: e,
    instanceOf: t,
    node: e,
    objectOf: t,
    oneOf: t,
    oneOfType: t,
    shape: t,
    exact: t,
    checkPropTypes: ox,
    resetWarningCache: ix
  };
  return (n.PropTypes = n), n;
};
nx.exports = OS();
var DS = nx.exports;
const Xr = W_(DS);
function bu(e, t, n, o) {
  function a(l) {
    return l instanceof n
      ? l
      : new n(function (f) {
          f(l);
        });
  }
  return new (n || (n = Promise))(function (l, f) {
    function _(M) {
      try {
        g(o.next(M));
      } catch (v) {
        f(v);
      }
    }
    function m(M) {
      try {
        g(o.throw(M));
      } catch (v) {
        f(v);
      }
    }
    function g(M) {
      M.done ? l(M.value) : a(M.value).then(_, m);
    }
    g((o = o.apply(e, t || [])).next());
  });
}
function xu(e, t) {
  var n = {
      label: 0,
      sent: function () {
        if (l[0] & 1) throw l[1];
        return l[1];
      },
      trys: [],
      ops: []
    },
    o,
    a,
    l,
    f = Object.create(
      (typeof Iterator == "function" ? Iterator : Object).prototype
    );
  return (
    (f.next = _(0)),
    (f.throw = _(1)),
    (f.return = _(2)),
    typeof Symbol == "function" &&
      (f[Symbol.iterator] = function () {
        return this;
      }),
    f
  );
  function _(g) {
    return function (M) {
      return m([g, M]);
    };
  }
  function m(g) {
    if (o) throw new TypeError("Generator is already executing.");
    for (; f && ((f = 0), g[0] && (n = 0)), n; )
      try {
        if (
          ((o = 1),
          a &&
            (l =
              g[0] & 2
                ? a.return
                : g[0]
                ? a.throw || ((l = a.return) && l.call(a), 0)
                : a.next) &&
            !(l = l.call(a, g[1])).done)
        )
          return l;
        switch (((a = 0), l && (g = [g[0] & 2, l.value]), g[0])) {
          case 0:
          case 1:
            l = g;
            break;
          case 4:
            return n.label++, { value: g[1], done: !1 };
          case 5:
            n.label++, (a = g[1]), (g = [0]);
            continue;
          case 7:
            (g = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (
              ((l = n.trys),
              !(l = l.length > 0 && l[l.length - 1]) &&
                (g[0] === 6 || g[0] === 2))
            ) {
              n = 0;
              continue;
            }
            if (g[0] === 3 && (!l || (g[1] > l[0] && g[1] < l[3]))) {
              n.label = g[1];
              break;
            }
            if (g[0] === 6 && n.label < l[1]) {
              (n.label = l[1]), (l = g);
              break;
            }
            if (l && n.label < l[2]) {
              (n.label = l[2]), n.ops.push(g);
              break;
            }
            l[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        g = t.call(e, n);
      } catch (M) {
        (g = [6, M]), (a = 0);
      } finally {
        o = l = 0;
      }
    if (g[0] & 5) throw g[1];
    return { value: g[0] ? g[1] : void 0, done: !0 };
  }
}
function $1(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var o = n.call(e),
    a,
    l = [],
    f;
  try {
    for (; (t === void 0 || t-- > 0) && !(a = o.next()).done; ) l.push(a.value);
  } catch (_) {
    f = { error: _ };
  } finally {
    try {
      a && !a.done && (n = o.return) && n.call(o);
    } finally {
      if (f) throw f.error;
    }
  }
  return l;
}
function A1(e, t, n) {
  if (n || arguments.length === 2)
    for (var o = 0, a = t.length, l; o < a; o++)
      (l || !(o in t)) &&
        (l || (l = Array.prototype.slice.call(t, 0, o)), (l[o] = t[o]));
  return e.concat(l || Array.prototype.slice.call(t));
}
var LS = new Map([
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  [
    "docx",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
  ],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  [
    "pptx",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation"
  ],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function _p(e, t) {
  var n = BS(e);
  if (typeof n.path != "string") {
    var o = e.webkitRelativePath;
    Object.defineProperty(n, "path", {
      value:
        typeof t == "string"
          ? t
          : typeof o == "string" && o.length > 0
          ? o
          : e.name,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return n;
}
function BS(e) {
  var t = e.name,
    n = t && t.lastIndexOf(".") !== -1;
  if (n && !e.type) {
    var o = t.split(".").pop().toLowerCase(),
      a = LS.get(o);
    a &&
      Object.defineProperty(e, "type", {
        value: a,
        writable: !1,
        configurable: !1,
        enumerable: !0
      });
  }
  return e;
}
var RS = [".DS_Store", "Thumbs.db"];
function NS(e) {
  return bu(this, void 0, void 0, function () {
    return xu(this, function (t) {
      return pm(e) && jS(e.dataTransfer)
        ? [2, GS(e.dataTransfer, e.type)]
        : US(e)
        ? [2, VS(e)]
        : Array.isArray(e) &&
          e.every(function (n) {
            return "getFile" in n && typeof n.getFile == "function";
          })
        ? [2, WS(e)]
        : [2, []];
    });
  });
}
function jS(e) {
  return pm(e);
}
function US(e) {
  return pm(e) && pm(e.target);
}
function pm(e) {
  return typeof e == "object" && e !== null;
}
function VS(e) {
  return R_(e.target.files).map(function (t) {
    return _p(t);
  });
}
function WS(e) {
  return bu(this, void 0, void 0, function () {
    var t;
    return xu(this, function (n) {
      switch (n.label) {
        case 0:
          return [
            4,
            Promise.all(
              e.map(function (o) {
                return o.getFile();
              })
            )
          ];
        case 1:
          return (
            (t = n.sent()),
            [
              2,
              t.map(function (o) {
                return _p(o);
              })
            ]
          );
      }
    });
  });
}
function GS(e, t) {
  return bu(this, void 0, void 0, function () {
    var n, o;
    return xu(this, function (a) {
      switch (a.label) {
        case 0:
          return e.items
            ? ((n = R_(e.items).filter(function (l) {
                return l.kind === "file";
              })),
              t !== "drop" ? [2, n] : [4, Promise.all(n.map(HS))])
            : [3, 2];
        case 1:
          return (o = a.sent()), [2, I1(sx(o))];
        case 2:
          return [
            2,
            I1(
              R_(e.files).map(function (l) {
                return _p(l);
              })
            )
          ];
      }
    });
  });
}
function I1(e) {
  return e.filter(function (t) {
    return RS.indexOf(t.name) === -1;
  });
}
function R_(e) {
  if (e === null) return [];
  for (var t = [], n = 0; n < e.length; n++) {
    var o = e[n];
    t.push(o);
  }
  return t;
}
function HS(e) {
  if (typeof e.webkitGetAsEntry != "function") return F1(e);
  var t = e.webkitGetAsEntry();
  return t && t.isDirectory ? ax(t) : F1(e);
}
function sx(e) {
  return e.reduce(function (t, n) {
    return A1(A1([], $1(t), !1), $1(Array.isArray(n) ? sx(n) : [n]), !1);
  }, []);
}
function F1(e) {
  var t = e.getAsFile();
  if (!t) return Promise.reject("".concat(e, " is not a File"));
  var n = _p(t);
  return Promise.resolve(n);
}
function qS(e) {
  return bu(this, void 0, void 0, function () {
    return xu(this, function (t) {
      return [2, e.isDirectory ? ax(e) : KS(e)];
    });
  });
}
function ax(e) {
  var t = e.createReader();
  return new Promise(function (n, o) {
    var a = [];
    function l() {
      var f = this;
      t.readEntries(
        function (_) {
          return bu(f, void 0, void 0, function () {
            var m, g, M;
            return xu(this, function (v) {
              switch (v.label) {
                case 0:
                  if (_.length) return [3, 5];
                  v.label = 1;
                case 1:
                  return v.trys.push([1, 3, , 4]), [4, Promise.all(a)];
                case 2:
                  return (m = v.sent()), n(m), [3, 4];
                case 3:
                  return (g = v.sent()), o(g), [3, 4];
                case 4:
                  return [3, 6];
                case 5:
                  (M = Promise.all(_.map(qS))), a.push(M), l(), (v.label = 6);
                case 6:
                  return [2];
              }
            });
          });
        },
        function (_) {
          o(_);
        }
      );
    }
    l();
  });
}
function KS(e) {
  return bu(this, void 0, void 0, function () {
    return xu(this, function (t) {
      return [
        2,
        new Promise(function (n, o) {
          e.file(
            function (a) {
              var l = _p(a, e.fullPath);
              n(l);
            },
            function (a) {
              o(a);
            }
          );
        })
      ];
    });
  });
}
var QS = function (e, t) {
  if (e && t) {
    var n = Array.isArray(t) ? t : t.split(","),
      o = e.name || "",
      a = (e.type || "").toLowerCase(),
      l = a.replace(/\/.*$/, "");
    return n.some(function (f) {
      var _ = f.trim().toLowerCase();
      return _.charAt(0) === "."
        ? o.toLowerCase().endsWith(_)
        : _.endsWith("/*")
        ? l === _.replace(/\/.*$/, "")
        : a === _;
    });
  }
  return !0;
};
function z1(e) {
  return ZS(e) || YS(e) || ux(e) || XS();
}
function XS() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function YS(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e);
}
function ZS(e) {
  if (Array.isArray(e)) return N_(e);
}
function O1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t &&
      (o = o.filter(function (a) {
        return Object.getOwnPropertyDescriptor(e, a).enumerable;
      })),
      n.push.apply(n, o);
  }
  return n;
}
function D1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? O1(Object(n), !0).forEach(function (o) {
          lx(e, o, n[o]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
      : O1(Object(n)).forEach(function (o) {
          Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
        });
  }
  return e;
}
function lx(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  );
}
function dp(e, t) {
  return tE(e) || eE(e, t) || ux(e, t) || JS();
}
function JS() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ux(e, t) {
  if (e) {
    if (typeof e == "string") return N_(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return N_(e, t);
  }
}
function N_(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, o = new Array(t); n < t; n++) o[n] = e[n];
  return o;
}
function eE(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"];
  if (n != null) {
    var o = [],
      a = !0,
      l = !1,
      f,
      _;
    try {
      for (
        n = n.call(e);
        !(a = (f = n.next()).done) && (o.push(f.value), !(t && o.length === t));
        a = !0
      );
    } catch (m) {
      (l = !0), (_ = m);
    } finally {
      try {
        !a && n.return != null && n.return();
      } finally {
        if (l) throw _;
      }
    }
    return o;
  }
}
function tE(e) {
  if (Array.isArray(e)) return e;
}
var rE = "file-invalid-type",
  nE = "file-too-large",
  iE = "file-too-small",
  oE = "too-many-files",
  sE = function (t) {
    t = Array.isArray(t) && t.length === 1 ? t[0] : t;
    var n = Array.isArray(t) ? "one of ".concat(t.join(", ")) : t;
    return { code: rE, message: "File type must be ".concat(n) };
  },
  L1 = function (t) {
    return {
      code: nE,
      message: "File is larger than "
        .concat(t, " ")
        .concat(t === 1 ? "byte" : "bytes")
    };
  },
  B1 = function (t) {
    return {
      code: iE,
      message: "File is smaller than "
        .concat(t, " ")
        .concat(t === 1 ? "byte" : "bytes")
    };
  },
  aE = { code: oE, message: "Too many files" };
function cx(e, t) {
  var n = e.type === "application/x-moz-file" || QS(e, t);
  return [n, n ? null : sE(t)];
}
function dx(e, t, n) {
  if (ia(e.size))
    if (ia(t) && ia(n)) {
      if (e.size > n) return [!1, L1(n)];
      if (e.size < t) return [!1, B1(t)];
    } else {
      if (ia(t) && e.size < t) return [!1, B1(t)];
      if (ia(n) && e.size > n) return [!1, L1(n)];
    }
  return [!0, null];
}
function ia(e) {
  return e != null;
}
function lE(e) {
  var t = e.files,
    n = e.accept,
    o = e.minSize,
    a = e.maxSize,
    l = e.multiple,
    f = e.maxFiles,
    _ = e.validator;
  return (!l && t.length > 1) || (l && f >= 1 && t.length > f)
    ? !1
    : t.every(function (m) {
        var g = cx(m, n),
          M = dp(g, 1),
          v = M[0],
          C = dx(m, o, a),
          T = dp(C, 1),
          z = T[0],
          $ = _ ? _(m) : null;
        return v && z && !$;
      });
}
function hm(e) {
  return typeof e.isPropagationStopped == "function"
    ? e.isPropagationStopped()
    : typeof e.cancelBubble < "u"
    ? e.cancelBubble
    : !1;
}
function Ch(e) {
  return e.dataTransfer
    ? Array.prototype.some.call(e.dataTransfer.types, function (t) {
        return t === "Files" || t === "application/x-moz-file";
      })
    : !!e.target && !!e.target.files;
}
function R1(e) {
  e.preventDefault();
}
function uE(e) {
  return e.indexOf("MSIE") !== -1 || e.indexOf("Trident/") !== -1;
}
function cE(e) {
  return e.indexOf("Edge/") !== -1;
}
function dE() {
  var e =
    arguments.length > 0 && arguments[0] !== void 0
      ? arguments[0]
      : window.navigator.userAgent;
  return uE(e) || cE(e);
}
function fo() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function (o) {
    for (
      var a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), f = 1;
      f < a;
      f++
    )
      l[f - 1] = arguments[f];
    return t.some(function (_) {
      return !hm(o) && _ && _.apply(void 0, [o].concat(l)), hm(o);
    });
  };
}
function fE() {
  return "showOpenFilePicker" in window;
}
function pE(e) {
  if (ia(e)) {
    var t = Object.entries(e)
      .filter(function (n) {
        var o = dp(n, 2),
          a = o[0],
          l = o[1],
          f = !0;
        return (
          fx(a) ||
            (console.warn(
              'Skipped "'.concat(
                a,
                '" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.'
              )
            ),
            (f = !1)),
          (!Array.isArray(l) || !l.every(px)) &&
            (console.warn(
              'Skipped "'.concat(
                a,
                '" because an invalid file extension was provided.'
              )
            ),
            (f = !1)),
          f
        );
      })
      .reduce(function (n, o) {
        var a = dp(o, 2),
          l = a[0],
          f = a[1];
        return D1(D1({}, n), {}, lx({}, l, f));
      }, {});
    return [{ description: "Files", accept: t }];
  }
  return e;
}
function hE(e) {
  if (ia(e))
    return Object.entries(e)
      .reduce(function (t, n) {
        var o = dp(n, 2),
          a = o[0],
          l = o[1];
        return [].concat(z1(t), [a], z1(l));
      }, [])
      .filter(function (t) {
        return fx(t) || px(t);
      })
      .join(",");
}
function mE(e) {
  return (
    e instanceof DOMException &&
    (e.name === "AbortError" || e.code === e.ABORT_ERR)
  );
}
function gE(e) {
  return (
    e instanceof DOMException &&
    (e.name === "SecurityError" || e.code === e.SECURITY_ERR)
  );
}
function fx(e) {
  return (
    e === "audio/*" ||
    e === "video/*" ||
    e === "image/*" ||
    e === "text/*" ||
    /\w+\/[-+.\w]+/g.test(e)
  );
}
function px(e) {
  return /^.*\.[\w]+$/.test(e);
}
var _E = ["children"],
  yE = ["open"],
  wE = [
    "refKey",
    "role",
    "onKeyDown",
    "onFocus",
    "onBlur",
    "onClick",
    "onDragEnter",
    "onDragOver",
    "onDragLeave",
    "onDrop"
  ],
  vE = ["refKey", "onChange", "onClick"];
function bE(e) {
  return TE(e) || ME(e) || hx(e) || xE();
}
function xE() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ME(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e);
}
function TE(e) {
  if (Array.isArray(e)) return j_(e);
}
function Wg(e, t) {
  return EE(e) || SE(e, t) || hx(e, t) || kE();
}
function kE() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function hx(e, t) {
  if (e) {
    if (typeof e == "string") return j_(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return j_(e, t);
  }
}
function j_(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, o = new Array(t); n < t; n++) o[n] = e[n];
  return o;
}
function SE(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"];
  if (n != null) {
    var o = [],
      a = !0,
      l = !1,
      f,
      _;
    try {
      for (
        n = n.call(e);
        !(a = (f = n.next()).done) && (o.push(f.value), !(t && o.length === t));
        a = !0
      );
    } catch (m) {
      (l = !0), (_ = m);
    } finally {
      try {
        !a && n.return != null && n.return();
      } finally {
        if (l) throw _;
      }
    }
    return o;
  }
}
function EE(e) {
  if (Array.isArray(e)) return e;
}
function N1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t &&
      (o = o.filter(function (a) {
        return Object.getOwnPropertyDescriptor(e, a).enumerable;
      })),
      n.push.apply(n, o);
  }
  return n;
}
function cn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2
      ? N1(Object(n), !0).forEach(function (o) {
          U_(e, o, n[o]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
      : N1(Object(n)).forEach(function (o) {
          Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
        });
  }
  return e;
}
function U_(e, t, n) {
  return (
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  );
}
function mm(e, t) {
  if (e == null) return {};
  var n = CE(e, t),
    o,
    a;
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (a = 0; a < l.length; a++)
      (o = l[a]),
        !(t.indexOf(o) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, o) &&
          (n[o] = e[o]);
  }
  return n;
}
function CE(e, t) {
  if (e == null) return {};
  var n = {},
    o = Object.keys(e),
    a,
    l;
  for (l = 0; l < o.length; l++)
    (a = o[l]), !(t.indexOf(a) >= 0) && (n[a] = e[a]);
  return n;
}
var R0 = yr.forwardRef(function (e, t) {
  var n = e.children,
    o = mm(e, _E),
    a = gx(o),
    l = a.open,
    f = mm(a, yE);
  return (
    yr.useImperativeHandle(
      t,
      function () {
        return { open: l };
      },
      [l]
    ),
    vT.createElement(yr.Fragment, null, n(cn(cn({}, f), {}, { open: l })))
  );
});
R0.displayName = "Dropzone";
var mx = {
  disabled: !1,
  getFilesFromEvent: NS,
  maxSize: 1 / 0,
  minSize: 0,
  multiple: !0,
  maxFiles: 0,
  preventDropOnDocument: !0,
  noClick: !1,
  noKeyboard: !1,
  noDrag: !1,
  noDragEventsBubbling: !1,
  validator: null,
  useFsAccessApi: !0,
  autoFocus: !1
};
R0.defaultProps = mx;
R0.propTypes = {
  children: Xr.func,
  accept: Xr.objectOf(Xr.arrayOf(Xr.string)),
  multiple: Xr.bool,
  preventDropOnDocument: Xr.bool,
  noClick: Xr.bool,
  noKeyboard: Xr.bool,
  noDrag: Xr.bool,
  noDragEventsBubbling: Xr.bool,
  minSize: Xr.number,
  maxSize: Xr.number,
  maxFiles: Xr.number,
  disabled: Xr.bool,
  getFilesFromEvent: Xr.func,
  onFileDialogCancel: Xr.func,
  onFileDialogOpen: Xr.func,
  useFsAccessApi: Xr.bool,
  autoFocus: Xr.bool,
  onDragEnter: Xr.func,
  onDragLeave: Xr.func,
  onDragOver: Xr.func,
  onDrop: Xr.func,
  onDropAccepted: Xr.func,
  onDropRejected: Xr.func,
  onError: Xr.func,
  validator: Xr.func
};
var V_ = {
  isFocused: !1,
  isFileDialogActive: !1,
  isDragActive: !1,
  isDragAccept: !1,
  isDragReject: !1,
  acceptedFiles: [],
  fileRejections: []
};
function gx() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    t = cn(cn({}, mx), e),
    n = t.accept,
    o = t.disabled,
    a = t.getFilesFromEvent,
    l = t.maxSize,
    f = t.minSize,
    _ = t.multiple,
    m = t.maxFiles,
    g = t.onDragEnter,
    M = t.onDragLeave,
    v = t.onDragOver,
    C = t.onDrop,
    T = t.onDropAccepted,
    z = t.onDropRejected,
    $ = t.onFileDialogCancel,
    S = t.onFileDialogOpen,
    y = t.useFsAccessApi,
    x = t.autoFocus,
    I = t.preventDropOnDocument,
    V = t.noClick,
    O = t.noKeyboard,
    B = t.noDrag,
    j = t.noDragEventsBubbling,
    N = t.onError,
    se = t.validator,
    de = yr.useMemo(
      function () {
        return hE(n);
      },
      [n]
    ),
    Me = yr.useMemo(
      function () {
        return pE(n);
      },
      [n]
    ),
    J = yr.useMemo(
      function () {
        return typeof S == "function" ? S : j1;
      },
      [S]
    ),
    ye = yr.useMemo(
      function () {
        return typeof $ == "function" ? $ : j1;
      },
      [$]
    ),
    L = yr.useRef(null),
    Ee = yr.useRef(null),
    Qe = yr.useReducer(PE, V_),
    _e = Wg(Qe, 2),
    X = _e[0],
    oe = _e[1],
    xe = X.isFocused,
    Y = X.isFileDialogActive,
    ge = yr.useRef(typeof window < "u" && window.isSecureContext && y && fE()),
    qe = function () {
      !ge.current &&
        Y &&
        setTimeout(function () {
          if (Ee.current) {
            var ke = Ee.current.files;
            ke.length || (oe({ type: "closeDialog" }), ye());
          }
        }, 300);
    };
  yr.useEffect(
    function () {
      return (
        window.addEventListener("focus", qe, !1),
        function () {
          window.removeEventListener("focus", qe, !1);
        }
      );
    },
    [Ee, Y, ye, ge]
  );
  var Be = yr.useRef([]),
    Ne = function (ke) {
      (L.current && L.current.contains(ke.target)) ||
        (ke.preventDefault(), (Be.current = []));
    };
  yr.useEffect(
    function () {
      return (
        I &&
          (document.addEventListener("dragover", R1, !1),
          document.addEventListener("drop", Ne, !1)),
        function () {
          I &&
            (document.removeEventListener("dragover", R1),
            document.removeEventListener("drop", Ne));
        }
      );
    },
    [L, I]
  ),
    yr.useEffect(
      function () {
        return !o && x && L.current && L.current.focus(), function () {};
      },
      [L, x, o]
    );
  var We = yr.useCallback(
      function (ue) {
        N ? N(ue) : console.error(ue);
      },
      [N]
    ),
    st = yr.useCallback(
      function (ue) {
        ue.preventDefault(),
          ue.persist(),
          R(ue),
          (Be.current = [].concat(bE(Be.current), [ue.target])),
          Ch(ue) &&
            Promise.resolve(a(ue))
              .then(function (ke) {
                if (!(hm(ue) && !j)) {
                  var Re = ke.length,
                    ht =
                      Re > 0 &&
                      lE({
                        files: ke,
                        accept: de,
                        minSize: f,
                        maxSize: l,
                        multiple: _,
                        maxFiles: m,
                        validator: se
                      }),
                    tt = Re > 0 && !ht;
                  oe({
                    isDragAccept: ht,
                    isDragReject: tt,
                    isDragActive: !0,
                    type: "setDraggedFiles"
                  }),
                    g && g(ue);
                }
              })
              .catch(function (ke) {
                return We(ke);
              });
      },
      [a, g, We, j, de, f, l, _, m, se]
    ),
    pt = yr.useCallback(
      function (ue) {
        ue.preventDefault(), ue.persist(), R(ue);
        var ke = Ch(ue);
        if (ke && ue.dataTransfer)
          try {
            ue.dataTransfer.dropEffect = "copy";
          } catch {}
        return ke && v && v(ue), !1;
      },
      [v, j]
    ),
    Ge = yr.useCallback(
      function (ue) {
        ue.preventDefault(), ue.persist(), R(ue);
        var ke = Be.current.filter(function (ht) {
            return L.current && L.current.contains(ht);
          }),
          Re = ke.indexOf(ue.target);
        Re !== -1 && ke.splice(Re, 1),
          (Be.current = ke),
          !(ke.length > 0) &&
            (oe({
              type: "setDraggedFiles",
              isDragActive: !1,
              isDragAccept: !1,
              isDragReject: !1
            }),
            Ch(ue) && M && M(ue));
      },
      [L, M, j]
    ),
    Te = yr.useCallback(
      function (ue, ke) {
        var Re = [],
          ht = [];
        ue.forEach(function (tt) {
          var wt = cx(tt, de),
            bt = Wg(wt, 2),
            Ke = bt[0],
            fe = bt[1],
            Ie = dx(tt, f, l),
            Ve = Wg(Ie, 2),
            ot = Ve[0],
            Xe = Ve[1],
            ft = se ? se(tt) : null;
          if (Ke && ot && !ft) Re.push(tt);
          else {
            var xt = [fe, Xe];
            ft && (xt = xt.concat(ft)),
              ht.push({
                file: tt,
                errors: xt.filter(function (vt) {
                  return vt;
                })
              });
          }
        }),
          ((!_ && Re.length > 1) || (_ && m >= 1 && Re.length > m)) &&
            (Re.forEach(function (tt) {
              ht.push({ file: tt, errors: [aE] });
            }),
            Re.splice(0)),
          oe({ acceptedFiles: Re, fileRejections: ht, type: "setFiles" }),
          C && C(Re, ht, ke),
          ht.length > 0 && z && z(ht, ke),
          Re.length > 0 && T && T(Re, ke);
      },
      [oe, _, de, f, l, m, C, T, z, se]
    ),
    je = yr.useCallback(
      function (ue) {
        ue.preventDefault(),
          ue.persist(),
          R(ue),
          (Be.current = []),
          Ch(ue) &&
            Promise.resolve(a(ue))
              .then(function (ke) {
                (hm(ue) && !j) || Te(ke, ue);
              })
              .catch(function (ke) {
                return We(ke);
              }),
          oe({ type: "reset" });
      },
      [a, Te, We, j]
    ),
    Ye = yr.useCallback(
      function () {
        if (ge.current) {
          oe({ type: "openDialog" }), J();
          var ue = { multiple: _, types: Me };
          window
            .showOpenFilePicker(ue)
            .then(function (ke) {
              return a(ke);
            })
            .then(function (ke) {
              Te(ke, null), oe({ type: "closeDialog" });
            })
            .catch(function (ke) {
              mE(ke)
                ? (ye(ke), oe({ type: "closeDialog" }))
                : gE(ke)
                ? ((ge.current = !1),
                  Ee.current
                    ? ((Ee.current.value = null), Ee.current.click())
                    : We(
                        new Error(
                          "Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."
                        )
                      ))
                : We(ke);
            });
          return;
        }
        Ee.current &&
          (oe({ type: "openDialog" }),
          J(),
          (Ee.current.value = null),
          Ee.current.click());
      },
      [oe, J, ye, y, Te, We, Me, _]
    ),
    et = yr.useCallback(
      function (ue) {
        !L.current ||
          !L.current.isEqualNode(ue.target) ||
          ((ue.key === " " ||
            ue.key === "Enter" ||
            ue.keyCode === 32 ||
            ue.keyCode === 13) &&
            (ue.preventDefault(), Ye()));
      },
      [L, Ye]
    ),
    A = yr.useCallback(function () {
      oe({ type: "focus" });
    }, []),
    Ae = yr.useCallback(function () {
      oe({ type: "blur" });
    }, []),
    $e = yr.useCallback(
      function () {
        V || (dE() ? setTimeout(Ye, 0) : Ye());
      },
      [V, Ye]
    ),
    ae = function (ke) {
      return o ? null : ke;
    },
    ne = function (ke) {
      return O ? null : ae(ke);
    },
    ve = function (ke) {
      return B ? null : ae(ke);
    },
    R = function (ke) {
      j && ke.stopPropagation();
    },
    te = yr.useMemo(
      function () {
        return function () {
          var ue =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {},
            ke = ue.refKey,
            Re = ke === void 0 ? "ref" : ke,
            ht = ue.role,
            tt = ue.onKeyDown,
            wt = ue.onFocus,
            bt = ue.onBlur,
            Ke = ue.onClick,
            fe = ue.onDragEnter,
            Ie = ue.onDragOver,
            Ve = ue.onDragLeave,
            ot = ue.onDrop,
            Xe = mm(ue, wE);
          return cn(
            cn(
              U_(
                {
                  onKeyDown: ne(fo(tt, et)),
                  onFocus: ne(fo(wt, A)),
                  onBlur: ne(fo(bt, Ae)),
                  onClick: ae(fo(Ke, $e)),
                  onDragEnter: ve(fo(fe, st)),
                  onDragOver: ve(fo(Ie, pt)),
                  onDragLeave: ve(fo(Ve, Ge)),
                  onDrop: ve(fo(ot, je)),
                  role: typeof ht == "string" && ht !== "" ? ht : "presentation"
                },
                Re,
                L
              ),
              !o && !O ? { tabIndex: 0 } : {}
            ),
            Xe
          );
        };
      },
      [L, et, A, Ae, $e, st, pt, Ge, je, O, B, o]
    ),
    D = yr.useCallback(function (ue) {
      ue.stopPropagation();
    }, []),
    ce = yr.useMemo(
      function () {
        return function () {
          var ue =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : {},
            ke = ue.refKey,
            Re = ke === void 0 ? "ref" : ke,
            ht = ue.onChange,
            tt = ue.onClick,
            wt = mm(ue, vE),
            bt = U_(
              {
                accept: de,
                multiple: _,
                type: "file",
                style: { display: "none" },
                onChange: ae(fo(ht, je)),
                onClick: ae(fo(tt, D)),
                tabIndex: -1
              },
              Re,
              Ee
            );
          return cn(cn({}, bt), wt);
        };
      },
      [Ee, n, _, je, o]
    );
  return cn(
    cn({}, X),
    {},
    {
      isFocused: xe && !o,
      getRootProps: te,
      getInputProps: ce,
      rootRef: L,
      inputRef: Ee,
      open: ae(Ye)
    }
  );
}
function PE(e, t) {
  switch (t.type) {
    case "focus":
      return cn(cn({}, e), {}, { isFocused: !0 });
    case "blur":
      return cn(cn({}, e), {}, { isFocused: !1 });
    case "openDialog":
      return cn(cn({}, V_), {}, { isFileDialogActive: !0 });
    case "closeDialog":
      return cn(cn({}, e), {}, { isFileDialogActive: !1 });
    case "setDraggedFiles":
      return cn(
        cn({}, e),
        {},
        {
          isDragActive: t.isDragActive,
          isDragAccept: t.isDragAccept,
          isDragReject: t.isDragReject
        }
      );
    case "setFiles":
      return cn(
        cn({}, e),
        {},
        { acceptedFiles: t.acceptedFiles, fileRejections: t.fileRejections }
      );
    case "reset":
      return cn({}, V_);
    default:
      return e;
  }
}
function j1() {}
var $o = {},
  _x = {
    "./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm": (
      e,
      t,
      n
    ) => {
      e.exports = n.p + "ort-wasm-simd-threaded.jsep.wasm";
    },
    "?2ce3": () => {},
    "?7a2c": () => {},
    "?a42a": () => {},
    "?2b25": () => {},
    "?569f": () => {},
    "?3f59": () => {},
    "?154a": () => {},
    "./node_modules/@huggingface/jinja/dist/index.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          Environment: () => Ae,
          Interpreter: () => $e,
          Template: () => ve,
          parse: () => xe,
          tokenize: () => v
        });
      var o = Object.freeze({
          Text: "Text",
          NumericLiteral: "NumericLiteral",
          BooleanLiteral: "BooleanLiteral",
          StringLiteral: "StringLiteral",
          Identifier: "Identifier",
          Equals: "Equals",
          OpenParen: "OpenParen",
          CloseParen: "CloseParen",
          OpenStatement: "OpenStatement",
          CloseStatement: "CloseStatement",
          OpenExpression: "OpenExpression",
          CloseExpression: "CloseExpression",
          OpenSquareBracket: "OpenSquareBracket",
          CloseSquareBracket: "CloseSquareBracket",
          OpenCurlyBracket: "OpenCurlyBracket",
          CloseCurlyBracket: "CloseCurlyBracket",
          Comma: "Comma",
          Dot: "Dot",
          Colon: "Colon",
          Pipe: "Pipe",
          CallOperator: "CallOperator",
          AdditiveBinaryOperator: "AdditiveBinaryOperator",
          MultiplicativeBinaryOperator: "MultiplicativeBinaryOperator",
          ComparisonBinaryOperator: "ComparisonBinaryOperator",
          UnaryOperator: "UnaryOperator",
          Set: "Set",
          If: "If",
          For: "For",
          In: "In",
          Is: "Is",
          NotIn: "NotIn",
          Else: "Else",
          EndIf: "EndIf",
          ElseIf: "ElseIf",
          EndFor: "EndFor",
          And: "And",
          Or: "Or",
          Not: "UnaryOperator",
          Macro: "Macro",
          EndMacro: "EndMacro"
        }),
        a = Object.freeze({
          set: o.Set,
          for: o.For,
          in: o.In,
          is: o.Is,
          if: o.If,
          else: o.Else,
          endif: o.EndIf,
          elif: o.ElseIf,
          endfor: o.EndFor,
          and: o.And,
          or: o.Or,
          not: o.Not,
          "not in": o.NotIn,
          macro: o.Macro,
          endmacro: o.EndMacro,
          true: o.BooleanLiteral,
          false: o.BooleanLiteral,
          True: o.BooleanLiteral,
          False: o.BooleanLiteral
        }),
        l = class {
          constructor(R, te) {
            (this.value = R), (this.type = te);
          }
        };
      function f(R) {
        return /\w/.test(R);
      }
      function _(R) {
        return /[0-9]/.test(R);
      }
      var m = [
          ["{%", o.OpenStatement],
          ["%}", o.CloseStatement],
          ["{{", o.OpenExpression],
          ["}}", o.CloseExpression],
          ["(", o.OpenParen],
          [")", o.CloseParen],
          ["{", o.OpenCurlyBracket],
          ["}", o.CloseCurlyBracket],
          ["[", o.OpenSquareBracket],
          ["]", o.CloseSquareBracket],
          [",", o.Comma],
          [".", o.Dot],
          [":", o.Colon],
          ["|", o.Pipe],
          ["<=", o.ComparisonBinaryOperator],
          [">=", o.ComparisonBinaryOperator],
          ["==", o.ComparisonBinaryOperator],
          ["!=", o.ComparisonBinaryOperator],
          ["<", o.ComparisonBinaryOperator],
          [">", o.ComparisonBinaryOperator],
          ["+", o.AdditiveBinaryOperator],
          ["-", o.AdditiveBinaryOperator],
          ["*", o.MultiplicativeBinaryOperator],
          ["/", o.MultiplicativeBinaryOperator],
          ["%", o.MultiplicativeBinaryOperator],
          ["=", o.Equals]
        ],
        g = new Map([
          [
            "n",
            `
`
          ],
          ["t", "	"],
          ["r", "\r"],
          ["b", "\b"],
          ["f", "\f"],
          ["v", "\v"],
          ["'", "'"],
          ['"', '"'],
          ["\\", "\\"]
        ]);
      function M(R, te = {}) {
        return (
          R.endsWith(`
`) && (R = R.slice(0, -1)),
          (R = R.replace(/{#.*?#}/gs, "{##}")),
          te.lstrip_blocks && (R = R.replace(/^[ \t]*({[#%])/gm, "$1")),
          te.trim_blocks && (R = R.replace(/([#%]})\n/g, "$1")),
          R.replace(/{##}/g, "")
            .replace(/-%}\s*/g, "%}")
            .replace(/\s*{%-/g, "{%")
            .replace(/-}}\s*/g, "}}")
            .replace(/\s*{{-/g, "{{")
        );
      }
      function v(R, te = {}) {
        var Re, ht, tt;
        const D = [],
          ce = M(R, te);
        let ue = 0;
        const ke = (wt) => {
          let bt = "";
          for (; wt(ce[ue]); ) {
            if (ce[ue] === "\\") {
              if ((++ue, ue >= ce.length))
                throw new SyntaxError("Unexpected end of input");
              const Ke = ce[ue++],
                fe = g.get(Ke);
              if (fe === void 0)
                throw new SyntaxError(`Unexpected escaped character: ${Ke}`);
              bt += fe;
              continue;
            }
            if (((bt += ce[ue++]), ue >= ce.length))
              throw new SyntaxError("Unexpected end of input");
          }
          return bt;
        };
        e: for (; ue < ce.length; ) {
          const wt = (Re = D.at(-1)) == null ? void 0 : Re.type;
          if (
            wt === void 0 ||
            wt === o.CloseStatement ||
            wt === o.CloseExpression
          ) {
            let Ke = "";
            for (
              ;
              ue < ce.length &&
              !(ce[ue] === "{" && (ce[ue + 1] === "%" || ce[ue + 1] === "{"));

            )
              Ke += ce[ue++];
            if (Ke.length > 0) {
              D.push(new l(Ke, o.Text));
              continue;
            }
          }
          ke((Ke) => /\s/.test(Ke));
          const bt = ce[ue];
          if (bt === "-" || bt === "+") {
            const Ke = (ht = D.at(-1)) == null ? void 0 : ht.type;
            if (Ke === o.Text || Ke === void 0)
              throw new SyntaxError(`Unexpected character: ${bt}`);
            switch (Ke) {
              case o.Identifier:
              case o.NumericLiteral:
              case o.BooleanLiteral:
              case o.StringLiteral:
              case o.CloseParen:
              case o.CloseSquareBracket:
                break;
              default: {
                ++ue;
                const fe = ke(_);
                D.push(
                  new l(
                    `${bt}${fe}`,
                    fe.length > 0 ? o.NumericLiteral : o.UnaryOperator
                  )
                );
                continue;
              }
            }
          }
          for (const [Ke, fe] of m)
            if (ce.slice(ue, ue + Ke.length) === Ke) {
              D.push(new l(Ke, fe)), (ue += Ke.length);
              continue e;
            }
          if (bt === "'" || bt === '"') {
            ++ue;
            const Ke = ke((fe) => fe !== bt);
            D.push(new l(Ke, o.StringLiteral)), ++ue;
            continue;
          }
          if (_(bt)) {
            const Ke = ke(_);
            D.push(new l(Ke, o.NumericLiteral));
            continue;
          }
          if (f(bt)) {
            const Ke = ke(f),
              fe = Object.hasOwn(a, Ke) ? a[Ke] : o.Identifier;
            fe === o.In &&
            ((tt = D.at(-1)) == null ? void 0 : tt.type) === o.Not
              ? (D.pop(), D.push(new l("not in", o.NotIn)))
              : D.push(new l(Ke, fe));
            continue;
          }
          throw new SyntaxError(`Unexpected character: ${bt}`);
        }
        return D;
      }
      var C = class {
          constructor() {
            He(this, "type", "Statement");
          }
        },
        T = class extends C {
          constructor(te) {
            super();
            He(this, "type", "Program");
            this.body = te;
          }
        },
        z = class extends C {
          constructor(te, D, ce) {
            super();
            He(this, "type", "If");
            (this.test = te), (this.body = D), (this.alternate = ce);
          }
        },
        $ = class extends C {
          constructor(te, D, ce, ue) {
            super();
            He(this, "type", "For");
            (this.loopvar = te),
              (this.iterable = D),
              (this.body = ce),
              (this.defaultBlock = ue);
          }
        },
        S = class extends C {
          constructor(te, D) {
            super();
            He(this, "type", "Set");
            (this.assignee = te), (this.value = D);
          }
        },
        y = class extends C {
          constructor(te, D, ce) {
            super();
            He(this, "type", "Macro");
            (this.name = te), (this.args = D), (this.body = ce);
          }
        },
        x = class extends C {
          constructor() {
            super(...arguments);
            He(this, "type", "Expression");
          }
        },
        I = class extends x {
          constructor(te, D, ce) {
            super();
            He(this, "type", "MemberExpression");
            (this.object = te), (this.property = D), (this.computed = ce);
          }
        },
        V = class extends x {
          constructor(te, D) {
            super();
            He(this, "type", "CallExpression");
            (this.callee = te), (this.args = D);
          }
        },
        O = class extends x {
          constructor(te) {
            super();
            He(this, "type", "Identifier");
            this.value = te;
          }
        },
        B = class extends x {
          constructor(te) {
            super();
            He(this, "type", "Literal");
            this.value = te;
          }
        },
        j = class extends B {
          constructor() {
            super(...arguments);
            He(this, "type", "NumericLiteral");
          }
        },
        N = class extends B {
          constructor() {
            super(...arguments);
            He(this, "type", "StringLiteral");
          }
        },
        se = class extends B {
          constructor() {
            super(...arguments);
            He(this, "type", "BooleanLiteral");
          }
        },
        de = class extends B {
          constructor() {
            super(...arguments);
            He(this, "type", "ArrayLiteral");
          }
        },
        Me = class extends B {
          constructor() {
            super(...arguments);
            He(this, "type", "TupleLiteral");
          }
        },
        J = class extends B {
          constructor() {
            super(...arguments);
            He(this, "type", "ObjectLiteral");
          }
        },
        ye = class extends x {
          constructor(te, D, ce) {
            super();
            He(this, "type", "BinaryExpression");
            (this.operator = te), (this.left = D), (this.right = ce);
          }
        },
        L = class extends x {
          constructor(te, D) {
            super();
            He(this, "type", "FilterExpression");
            (this.operand = te), (this.filter = D);
          }
        },
        Ee = class extends x {
          constructor(te, D) {
            super();
            He(this, "type", "SelectExpression");
            (this.iterable = te), (this.test = D);
          }
        },
        Qe = class extends x {
          constructor(te, D, ce) {
            super();
            He(this, "type", "TestExpression");
            (this.operand = te), (this.negate = D), (this.test = ce);
          }
        },
        _e = class extends x {
          constructor(te, D) {
            super();
            He(this, "type", "UnaryExpression");
            (this.operator = te), (this.argument = D);
          }
        },
        X = class extends x {
          constructor(te = void 0, D = void 0, ce = void 0) {
            super();
            He(this, "type", "SliceExpression");
            (this.start = te), (this.stop = D), (this.step = ce);
          }
        },
        oe = class extends x {
          constructor(te, D) {
            super();
            He(this, "type", "KeywordArgumentExpression");
            (this.key = te), (this.value = D);
          }
        };
      function xe(R) {
        const te = new T([]);
        let D = 0;
        function ce(mt, kt) {
          const Lt = R[D++];
          if (!Lt || Lt.type !== mt)
            throw new Error(`Parser Error: ${kt}. ${Lt.type} !== ${mt}.`);
          return Lt;
        }
        function ue() {
          switch (R[D].type) {
            case o.Text:
              return ht();
            case o.OpenStatement:
              return tt();
            case o.OpenExpression:
              return wt();
            default:
              throw new SyntaxError(`Unexpected token type: ${R[D].type}`);
          }
        }
        function ke(...mt) {
          return (
            D + mt.length <= R.length &&
            mt.some((kt, Lt) => kt !== R[D + Lt].type)
          );
        }
        function Re(...mt) {
          return (
            D + mt.length <= R.length &&
            mt.every((kt, Lt) => kt === R[D + Lt].type)
          );
        }
        function ht() {
          return new N(ce(o.Text, "Expected text token").value);
        }
        function tt() {
          ce(o.OpenStatement, "Expected opening statement token");
          let mt;
          switch (R[D].type) {
            case o.Set:
              ++D,
                (mt = bt()),
                ce(o.CloseStatement, "Expected closing statement token");
              break;
            case o.If:
              ++D,
                (mt = Ke()),
                ce(o.OpenStatement, "Expected {% token"),
                ce(o.EndIf, "Expected endif token"),
                ce(o.CloseStatement, "Expected %} token");
              break;
            case o.Macro:
              ++D,
                (mt = fe()),
                ce(o.OpenStatement, "Expected {% token"),
                ce(o.EndMacro, "Expected endmacro token"),
                ce(o.CloseStatement, "Expected %} token");
              break;
            case o.For:
              ++D,
                (mt = Ve()),
                ce(o.OpenStatement, "Expected {% token"),
                ce(o.EndFor, "Expected endfor token"),
                ce(o.CloseStatement, "Expected %} token");
              break;
            default:
              throw new SyntaxError(`Unknown statement type: ${R[D].type}`);
          }
          return mt;
        }
        function wt() {
          ce(o.OpenExpression, "Expected opening expression token");
          const mt = ot();
          return ce(o.CloseExpression, "Expected closing expression token"), mt;
        }
        function bt() {
          const mt = ot();
          if (Re(o.Equals)) {
            ++D;
            const kt = bt();
            return new S(mt, kt);
          }
          return mt;
        }
        function Ke() {
          var nn, yi, Ai, Qr, Tn, Yr, wi, Nr;
          const mt = ot();
          ce(o.CloseStatement, "Expected closing statement token");
          const kt = [],
            Lt = [];
          for (
            ;
            !(
              ((nn = R[D]) == null ? void 0 : nn.type) === o.OpenStatement &&
              (((yi = R[D + 1]) == null ? void 0 : yi.type) === o.ElseIf ||
                ((Ai = R[D + 1]) == null ? void 0 : Ai.type) === o.Else ||
                ((Qr = R[D + 1]) == null ? void 0 : Qr.type) === o.EndIf)
            );

          )
            kt.push(ue());
          if (
            ((Tn = R[D]) == null ? void 0 : Tn.type) === o.OpenStatement &&
            ((Yr = R[D + 1]) == null ? void 0 : Yr.type) !== o.EndIf
          )
            if ((++D, Re(o.ElseIf)))
              ce(o.ElseIf, "Expected elseif token"), Lt.push(Ke());
            else
              for (
                ce(o.Else, "Expected else token"),
                  ce(o.CloseStatement, "Expected closing statement token");
                !(
                  ((wi = R[D]) == null ? void 0 : wi.type) ===
                    o.OpenStatement &&
                  ((Nr = R[D + 1]) == null ? void 0 : Nr.type) === o.EndIf
                );

              )
                Lt.push(ue());
          return new z(mt, kt, Lt);
        }
        function fe() {
          const mt = Mr();
          if (mt.type !== "Identifier")
            throw new SyntaxError(
              "Expected identifier following macro statement"
            );
          const kt = Rt();
          ce(o.CloseStatement, "Expected closing statement token");
          const Lt = [];
          for (; ke(o.OpenStatement, o.EndMacro); ) Lt.push(ue());
          return new y(mt, kt, Lt);
        }
        function Ie(mt = !1) {
          const kt = mt ? Mr : ot,
            Lt = [kt()],
            nn = Re(o.Comma);
          for (; nn && (++D, Lt.push(kt()), !!Re(o.Comma)); );
          return nn ? new Me(Lt) : Lt[0];
        }
        function Ve() {
          const mt = Ie(!0);
          if (!(mt instanceof O || mt instanceof Me))
            throw new SyntaxError(
              `Expected identifier/tuple for the loop variable, got ${mt.type} instead`
            );
          ce(o.In, "Expected `in` keyword following loop variable");
          const kt = ot();
          ce(o.CloseStatement, "Expected closing statement token");
          const Lt = [];
          for (; ke(o.OpenStatement, o.EndFor) && ke(o.OpenStatement, o.Else); )
            Lt.push(ue());
          const nn = [];
          if (Re(o.OpenStatement, o.Else))
            for (
              ++D,
                ++D,
                ce(o.CloseStatement, "Expected closing statement token");
              ke(o.OpenStatement, o.EndFor);

            )
              nn.push(ue());
          return new $(mt, kt, Lt, nn);
        }
        function ot() {
          return Xe();
        }
        function Xe() {
          const mt = ft();
          if (Re(o.If)) {
            ++D;
            const kt = ft();
            if (Re(o.Else)) {
              ++D;
              const Lt = ft();
              return new z(kt, [mt], [Lt]);
            } else return new Ee(mt, kt);
          }
          return mt;
        }
        function ft() {
          let mt = xt();
          for (; Re(o.Or); ) {
            const kt = R[D];
            ++D;
            const Lt = xt();
            mt = new ye(kt, mt, Lt);
          }
          return mt;
        }
        function xt() {
          let mt = vt();
          for (; Re(o.And); ) {
            const kt = R[D];
            ++D;
            const Lt = vt();
            mt = new ye(kt, mt, Lt);
          }
          return mt;
        }
        function vt() {
          let mt;
          for (; Re(o.Not); ) {
            const kt = R[D];
            ++D;
            const Lt = vt();
            mt = new _e(kt, Lt);
          }
          return mt ?? $t();
        }
        function $t() {
          let mt = Tt();
          for (; Re(o.ComparisonBinaryOperator) || Re(o.In) || Re(o.NotIn); ) {
            const kt = R[D];
            ++D;
            const Lt = Tt();
            mt = new ye(kt, mt, Lt);
          }
          return mt;
        }
        function Tt() {
          let mt = er();
          for (; Re(o.AdditiveBinaryOperator); ) {
            const kt = R[D];
            ++D;
            const Lt = er();
            mt = new ye(kt, mt, Lt);
          }
          return mt;
        }
        function rt() {
          const mt = Wt();
          return Re(o.OpenParen) ? Nt(mt) : mt;
        }
        function Nt(mt) {
          let kt = new V(mt, Rt());
          return Re(o.OpenParen) && (kt = Nt(kt)), kt;
        }
        function Rt() {
          ce(o.OpenParen, "Expected opening parenthesis for arguments list");
          const mt = Kt();
          return (
            ce(o.CloseParen, "Expected closing parenthesis for arguments list"),
            mt
          );
        }
        function Kt() {
          const mt = [];
          for (; !Re(o.CloseParen); ) {
            let kt = ot();
            if (Re(o.Equals)) {
              if ((++D, !(kt instanceof O)))
                throw new SyntaxError(
                  "Expected identifier for keyword argument"
                );
              const Lt = ot();
              kt = new oe(kt, Lt);
            }
            mt.push(kt), Re(o.Comma) && ++D;
          }
          return mt;
        }
        function Gt() {
          const mt = [];
          let kt = !1;
          for (; !Re(o.CloseSquareBracket); )
            Re(o.Colon)
              ? (mt.push(void 0), ++D, (kt = !0))
              : (mt.push(ot()), Re(o.Colon) && (++D, (kt = !0)));
          if (mt.length === 0)
            throw new SyntaxError(
              "Expected at least one argument for member/slice expression"
            );
          if (kt) {
            if (mt.length > 3)
              throw new SyntaxError(
                "Expected 0-3 arguments for slice expression"
              );
            return new X(...mt);
          }
          return mt[0];
        }
        function Wt() {
          let mt = Mr();
          for (; Re(o.Dot) || Re(o.OpenSquareBracket); ) {
            const kt = R[D];
            ++D;
            let Lt;
            const nn = kt.type !== o.Dot;
            if (nn)
              (Lt = Gt()),
                ce(o.CloseSquareBracket, "Expected closing square bracket");
            else if (((Lt = Mr()), Lt.type !== "Identifier"))
              throw new SyntaxError(
                "Expected identifier following dot operator"
              );
            mt = new I(mt, Lt, nn);
          }
          return mt;
        }
        function er() {
          let mt = nr();
          for (; Re(o.MultiplicativeBinaryOperator); ) {
            const kt = R[D];
            ++D;
            const Lt = nr();
            mt = new ye(kt, mt, Lt);
          }
          return mt;
        }
        function nr() {
          let mt = ar();
          for (; Re(o.Is); ) {
            ++D;
            const kt = Re(o.Not);
            kt && ++D;
            let Lt = Mr();
            if (
              (Lt instanceof se && (Lt = new O(Lt.value.toString())),
              !(Lt instanceof O))
            )
              throw new SyntaxError("Expected identifier for the test");
            mt = new Qe(mt, kt, Lt);
          }
          return mt;
        }
        function ar() {
          let mt = rt();
          for (; Re(o.Pipe); ) {
            ++D;
            let kt = Mr();
            if (!(kt instanceof O))
              throw new SyntaxError("Expected identifier for the filter");
            Re(o.OpenParen) && (kt = Nt(kt)), (mt = new L(mt, kt));
          }
          return mt;
        }
        function Mr() {
          const mt = R[D];
          switch (mt.type) {
            case o.NumericLiteral:
              return ++D, new j(Number(mt.value));
            case o.StringLiteral:
              return ++D, new N(mt.value);
            case o.BooleanLiteral:
              return ++D, new se(mt.value.toLowerCase() === "true");
            case o.Identifier:
              return ++D, new O(mt.value);
            case o.OpenParen: {
              ++D;
              const kt = Ie();
              if (R[D].type !== o.CloseParen)
                throw new SyntaxError(
                  `Expected closing parenthesis, got ${R[D].type} instead`
                );
              return ++D, kt;
            }
            case o.OpenSquareBracket: {
              ++D;
              const kt = [];
              for (; !Re(o.CloseSquareBracket); )
                kt.push(ot()), Re(o.Comma) && ++D;
              return ++D, new de(kt);
            }
            case o.OpenCurlyBracket: {
              ++D;
              const kt = new Map();
              for (; !Re(o.CloseCurlyBracket); ) {
                const Lt = ot();
                ce(
                  o.Colon,
                  "Expected colon between key and value in object literal"
                );
                const nn = ot();
                kt.set(Lt, nn), Re(o.Comma) && ++D;
              }
              return ++D, new J(kt);
            }
            default:
              throw new SyntaxError(`Unexpected token: ${mt.type}`);
          }
        }
        for (; D < R.length; ) te.body.push(ue());
        return te;
      }
      function Y(R, te, D = 1) {
        te === void 0 && ((te = R), (R = 0));
        const ce = [];
        for (let ue = R; ue < te; ue += D) ce.push(ue);
        return ce;
      }
      function ge(R, te, D, ce = 1) {
        const ue = Math.sign(ce);
        ue >= 0
          ? ((te =
              (te ?? (te = 0)) < 0
                ? Math.max(R.length + te, 0)
                : Math.min(te, R.length)),
            (D =
              (D ?? (D = R.length)) < 0
                ? Math.max(R.length + D, 0)
                : Math.min(D, R.length)))
          : ((te =
              (te ?? (te = R.length - 1)) < 0
                ? Math.max(R.length + te, -1)
                : Math.min(te, R.length - 1)),
            (D =
              (D ?? (D = -1)) < -1
                ? Math.max(R.length + D, -1)
                : Math.min(D, R.length - 1)));
        const ke = [];
        for (let Re = te; ue * Re < ue * D; Re += ce) ke.push(R[Re]);
        return ke;
      }
      function qe(R) {
        return R.replace(/\b\w/g, (te) => te.toUpperCase());
      }
      var Be = class {
          constructor(R = void 0) {
            He(this, "type", "RuntimeValue");
            He(this, "value");
            He(this, "builtins", new Map());
            this.value = R;
          }
          __bool__() {
            return new st(!!this.value);
          }
        },
        Ne = class extends Be {
          constructor() {
            super(...arguments);
            He(this, "type", "NumericValue");
          }
        },
        We = class extends Be {
          constructor() {
            super(...arguments);
            He(this, "type", "StringValue");
            He(
              this,
              "builtins",
              new Map([
                ["upper", new Ye(() => new We(this.value.toUpperCase()))],
                ["lower", new Ye(() => new We(this.value.toLowerCase()))],
                ["strip", new Ye(() => new We(this.value.trim()))],
                ["title", new Ye(() => new We(qe(this.value)))],
                ["length", new Ne(this.value.length)]
              ])
            );
          }
        },
        st = class extends Be {
          constructor() {
            super(...arguments);
            He(this, "type", "BooleanValue");
          }
        },
        pt = class extends Be {
          constructor() {
            super(...arguments);
            He(this, "type", "ObjectValue");
            He(
              this,
              "builtins",
              new Map([
                [
                  "get",
                  new Ye(([te, D]) => {
                    if (!(te instanceof We))
                      throw new Error(
                        `Object key must be a string: got ${te.type}`
                      );
                    return this.value.get(te.value) ?? D ?? new et();
                  })
                ],
                [
                  "items",
                  new Ye(
                    () =>
                      new Te(
                        Array.from(this.value.entries()).map(
                          ([te, D]) => new Te([new We(te), D])
                        )
                      )
                  )
                ]
              ])
            );
          }
          __bool__() {
            return new st(this.value.size > 0);
          }
        },
        Ge = class extends pt {
          constructor() {
            super(...arguments);
            He(this, "type", "KeywordArgumentsValue");
          }
        },
        Te = class extends Be {
          constructor() {
            super(...arguments);
            He(this, "type", "ArrayValue");
            He(
              this,
              "builtins",
              new Map([["length", new Ne(this.value.length)]])
            );
          }
          __bool__() {
            return new st(this.value.length > 0);
          }
        },
        je = class extends Te {
          constructor() {
            super(...arguments);
            He(this, "type", "TupleValue");
          }
        },
        Ye = class extends Be {
          constructor() {
            super(...arguments);
            He(this, "type", "FunctionValue");
          }
        },
        et = class extends Be {
          constructor() {
            super(...arguments);
            He(this, "type", "NullValue");
          }
        },
        A = class extends Be {
          constructor() {
            super(...arguments);
            He(this, "type", "UndefinedValue");
          }
        },
        Ae = class {
          constructor(R) {
            He(
              this,
              "variables",
              new Map([
                [
                  "namespace",
                  new Ye((R) => {
                    if (R.length === 0) return new pt(new Map());
                    if (R.length !== 1 || !(R[0] instanceof pt))
                      throw new Error(
                        "`namespace` expects either zero arguments or a single object argument"
                      );
                    return R[0];
                  })
                ]
              ])
            );
            He(
              this,
              "tests",
              new Map([
                ["boolean", (R) => R.type === "BooleanValue"],
                ["callable", (R) => R instanceof Ye],
                [
                  "odd",
                  (R) => {
                    if (R.type !== "NumericValue")
                      throw new Error(
                        `Cannot apply test "odd" to type: ${R.type}`
                      );
                    return R.value % 2 !== 0;
                  }
                ],
                [
                  "even",
                  (R) => {
                    if (R.type !== "NumericValue")
                      throw new Error(
                        `Cannot apply test "even" to type: ${R.type}`
                      );
                    return R.value % 2 === 0;
                  }
                ],
                ["false", (R) => R.type === "BooleanValue" && !R.value],
                ["true", (R) => R.type === "BooleanValue" && R.value],
                ["string", (R) => R.type === "StringValue"],
                ["number", (R) => R.type === "NumericValue"],
                [
                  "integer",
                  (R) => R.type === "NumericValue" && Number.isInteger(R.value)
                ],
                ["iterable", (R) => R instanceof Te || R instanceof We],
                [
                  "lower",
                  (R) => {
                    const te = R.value;
                    return R.type === "StringValue" && te === te.toLowerCase();
                  }
                ],
                [
                  "upper",
                  (R) => {
                    const te = R.value;
                    return R.type === "StringValue" && te === te.toUpperCase();
                  }
                ],
                ["none", (R) => R.type === "NullValue"],
                ["defined", (R) => R.type !== "UndefinedValue"],
                ["undefined", (R) => R.type === "UndefinedValue"],
                ["equalto", (R, te) => R.value === te.value],
                ["eq", (R, te) => R.value === te.value]
              ])
            );
            this.parent = R;
          }
          set(R, te) {
            return this.declareVariable(R, ae(te));
          }
          declareVariable(R, te) {
            if (this.variables.has(R))
              throw new SyntaxError(`Variable already declared: ${R}`);
            return this.variables.set(R, te), te;
          }
          setVariable(R, te) {
            return this.variables.set(R, te), te;
          }
          resolve(R) {
            if (this.variables.has(R)) return this;
            if (this.parent) return this.parent.resolve(R);
            throw new Error(`Unknown variable: ${R}`);
          }
          lookupVariable(R) {
            try {
              return this.resolve(R).variables.get(R) ?? new A();
            } catch {
              return new A();
            }
          }
        },
        $e = class {
          constructor(R) {
            He(this, "global");
            this.global = R ?? new Ae();
          }
          run(R) {
            return this.evaluate(R, this.global);
          }
          evaluateBinaryExpression(R, te) {
            const D = this.evaluate(R.left, te);
            switch (R.operator.value) {
              case "and":
                return D.__bool__().value ? this.evaluate(R.right, te) : D;
              case "or":
                return D.__bool__().value ? D : this.evaluate(R.right, te);
            }
            const ce = this.evaluate(R.right, te);
            switch (R.operator.value) {
              case "==":
                return new st(D.value == ce.value);
              case "!=":
                return new st(D.value != ce.value);
            }
            if (D instanceof A || ce instanceof A)
              throw new Error("Cannot perform operation on undefined values");
            if (D instanceof et || ce instanceof et)
              throw new Error("Cannot perform operation on null values");
            if (D instanceof Ne && ce instanceof Ne)
              switch (R.operator.value) {
                case "+":
                  return new Ne(D.value + ce.value);
                case "-":
                  return new Ne(D.value - ce.value);
                case "*":
                  return new Ne(D.value * ce.value);
                case "/":
                  return new Ne(D.value / ce.value);
                case "%":
                  return new Ne(D.value % ce.value);
                case "<":
                  return new st(D.value < ce.value);
                case ">":
                  return new st(D.value > ce.value);
                case ">=":
                  return new st(D.value >= ce.value);
                case "<=":
                  return new st(D.value <= ce.value);
              }
            else if (D instanceof Te && ce instanceof Te)
              switch (R.operator.value) {
                case "+":
                  return new Te(D.value.concat(ce.value));
              }
            else if (ce instanceof Te) {
              const ue = ce.value.find((ke) => ke.value === D.value) !== void 0;
              switch (R.operator.value) {
                case "in":
                  return new st(ue);
                case "not in":
                  return new st(!ue);
              }
            }
            if (D instanceof We || ce instanceof We)
              switch (R.operator.value) {
                case "+":
                  return new We(D.value.toString() + ce.value.toString());
              }
            if (D instanceof We && ce instanceof We)
              switch (R.operator.value) {
                case "in":
                  return new st(ce.value.includes(D.value));
                case "not in":
                  return new st(!ce.value.includes(D.value));
              }
            if (D instanceof We && ce instanceof pt)
              switch (R.operator.value) {
                case "in":
                  return new st(ce.value.has(D.value));
                case "not in":
                  return new st(!ce.value.has(D.value));
              }
            throw new SyntaxError(
              `Unknown operator "${R.operator.value}" between ${D.type} and ${ce.type}`
            );
          }
          evaluateArguments(R, te) {
            const D = [],
              ce = new Map();
            for (const ue of R)
              if (ue.type === "KeywordArgumentExpression") {
                const ke = ue;
                ce.set(ke.key.value, this.evaluate(ke.value, te));
              } else {
                if (ce.size > 0)
                  throw new Error(
                    "Positional arguments must come before keyword arguments"
                  );
                D.push(this.evaluate(ue, te));
              }
            return [D, ce];
          }
          evaluateFilterExpression(R, te) {
            const D = this.evaluate(R.operand, te);
            if (R.filter.type === "Identifier") {
              const ce = R.filter;
              if (ce.value === "tojson") return new We(ne(D));
              if (D instanceof Te)
                switch (ce.value) {
                  case "list":
                    return D;
                  case "first":
                    return D.value[0];
                  case "last":
                    return D.value[D.value.length - 1];
                  case "length":
                    return new Ne(D.value.length);
                  case "reverse":
                    return new Te(D.value.reverse());
                  case "sort":
                    return new Te(
                      D.value.sort((ue, ke) => {
                        if (ue.type !== ke.type)
                          throw new Error(
                            `Cannot compare different types: ${ue.type} and ${ke.type}`
                          );
                        switch (ue.type) {
                          case "NumericValue":
                            return ue.value - ke.value;
                          case "StringValue":
                            return ue.value.localeCompare(ke.value);
                          default:
                            throw new Error(`Cannot compare type: ${ue.type}`);
                        }
                      })
                    );
                  default:
                    throw new Error(`Unknown ArrayValue filter: ${ce.value}`);
                }
              else if (D instanceof We)
                switch (ce.value) {
                  case "length":
                    return new Ne(D.value.length);
                  case "upper":
                    return new We(D.value.toUpperCase());
                  case "lower":
                    return new We(D.value.toLowerCase());
                  case "title":
                    return new We(qe(D.value));
                  case "capitalize":
                    return new We(
                      D.value.charAt(0).toUpperCase() + D.value.slice(1)
                    );
                  case "trim":
                    return new We(D.value.trim());
                  case "indent":
                    return new We(
                      D.value
                        .split(
                          `
`
                        )
                        .map((ue, ke) =>
                          ke === 0 || ue.length === 0 ? ue : "    " + ue
                        ).join(`
`)
                    );
                  case "string":
                    return D;
                  default:
                    throw new Error(`Unknown StringValue filter: ${ce.value}`);
                }
              else if (D instanceof Ne)
                switch (ce.value) {
                  case "abs":
                    return new Ne(Math.abs(D.value));
                  default:
                    throw new Error(`Unknown NumericValue filter: ${ce.value}`);
                }
              else if (D instanceof pt)
                switch (ce.value) {
                  case "items":
                    return new Te(
                      Array.from(D.value.entries()).map(
                        ([ue, ke]) => new Te([new We(ue), ke])
                      )
                    );
                  case "length":
                    return new Ne(D.value.size);
                  default:
                    throw new Error(`Unknown ObjectValue filter: ${ce.value}`);
                }
              throw new Error(
                `Cannot apply filter "${ce.value}" to type: ${D.type}`
              );
            } else if (R.filter.type === "CallExpression") {
              const ce = R.filter;
              if (ce.callee.type !== "Identifier")
                throw new Error(`Unknown filter: ${ce.callee.type}`);
              const ue = ce.callee.value;
              if (ue === "tojson") {
                const [, ke] = this.evaluateArguments(ce.args, te),
                  Re = ke.get("indent") ?? new et();
                if (!(Re instanceof Ne || Re instanceof et))
                  throw new Error("If set, indent must be a number");
                return new We(ne(D, Re.value));
              }
              if (D instanceof Te) {
                switch (ue) {
                  case "selectattr": {
                    if (D.value.some((bt) => !(bt instanceof pt)))
                      throw new Error(
                        "`selectattr` can only be applied to array of objects"
                      );
                    if (ce.args.some((bt) => bt.type !== "StringLiteral"))
                      throw new Error(
                        "arguments of `selectattr` must be strings"
                      );
                    const [ke, Re, ht] = ce.args.map((bt) =>
                      this.evaluate(bt, te)
                    );
                    let tt;
                    if (Re) {
                      const bt = te.tests.get(Re.value);
                      if (!bt) throw new Error(`Unknown test: ${Re.value}`);
                      tt = bt;
                    } else tt = (...bt) => bt[0].__bool__().value;
                    const wt = D.value.filter((bt) => {
                      const Ke = bt.value.get(ke.value);
                      return Ke ? tt(Ke, ht) : !1;
                    });
                    return new Te(wt);
                  }
                  case "map": {
                    const [, ke] = this.evaluateArguments(ce.args, te);
                    if (ke.has("attribute")) {
                      const Re = ke.get("attribute");
                      if (!(Re instanceof We))
                        throw new Error("attribute must be a string");
                      const ht = ke.get("default"),
                        tt = D.value.map((wt) => {
                          if (!(wt instanceof pt))
                            throw new Error("items in map must be an object");
                          return wt.value.get(Re.value) ?? ht ?? new A();
                        });
                      return new Te(tt);
                    } else
                      throw new Error(
                        "`map` expressions without `attribute` set are not currently supported."
                      );
                  }
                }
                throw new Error(`Unknown ArrayValue filter: ${ue}`);
              } else if (D instanceof We) {
                switch (ue) {
                  case "indent": {
                    const [ke, Re] = this.evaluateArguments(ce.args, te),
                      ht = ke.at(0) ?? Re.get("width") ?? new Ne(4);
                    if (!(ht instanceof Ne))
                      throw new Error("width must be a number");
                    const tt = ke.at(1) ?? Re.get("first") ?? new st(!1),
                      wt = ke.at(2) ?? Re.get("blank") ?? new st(!1),
                      bt = D.value.split(`
`),
                      Ke = " ".repeat(ht.value),
                      fe = bt.map((Ie, Ve) =>
                        (!tt.value && Ve === 0) ||
                        (!wt.value && Ie.length === 0)
                          ? Ie
                          : Ke + Ie
                      );
                    return new We(
                      fe.join(`
`)
                    );
                  }
                }
                throw new Error(`Unknown StringValue filter: ${ue}`);
              } else
                throw new Error(
                  `Cannot apply filter "${ue}" to type: ${D.type}`
                );
            }
            throw new Error(`Unknown filter: ${R.filter.type}`);
          }
          evaluateTestExpression(R, te) {
            const D = this.evaluate(R.operand, te),
              ce = te.tests.get(R.test.value);
            if (!ce) throw new Error(`Unknown test: ${R.test.value}`);
            const ue = ce(D);
            return new st(R.negate ? !ue : ue);
          }
          evaluateUnaryExpression(R, te) {
            const D = this.evaluate(R.argument, te);
            switch (R.operator.value) {
              case "not":
                return new st(!D.value);
              default:
                throw new SyntaxError(`Unknown operator: ${R.operator.value}`);
            }
          }
          evalProgram(R, te) {
            return this.evaluateBlock(R.body, te);
          }
          evaluateBlock(R, te) {
            let D = "";
            for (const ce of R) {
              const ue = this.evaluate(ce, te);
              ue.type !== "NullValue" &&
                ue.type !== "UndefinedValue" &&
                (D += ue.value);
            }
            return new We(D);
          }
          evaluateIdentifier(R, te) {
            return te.lookupVariable(R.value);
          }
          evaluateCallExpression(R, te) {
            const [D, ce] = this.evaluateArguments(R.args, te);
            ce.size > 0 && D.push(new Ge(ce));
            const ue = this.evaluate(R.callee, te);
            if (ue.type !== "FunctionValue")
              throw new Error(
                `Cannot call something that is not a function: got ${ue.type}`
              );
            return ue.value(D, te);
          }
          evaluateSliceExpression(R, te, D) {
            if (!(R instanceof Te || R instanceof We))
              throw new Error("Slice object must be an array or string");
            const ce = this.evaluate(te.start, D),
              ue = this.evaluate(te.stop, D),
              ke = this.evaluate(te.step, D);
            if (!(ce instanceof Ne || ce instanceof A))
              throw new Error("Slice start must be numeric or undefined");
            if (!(ue instanceof Ne || ue instanceof A))
              throw new Error("Slice stop must be numeric or undefined");
            if (!(ke instanceof Ne || ke instanceof A))
              throw new Error("Slice step must be numeric or undefined");
            return R instanceof Te
              ? new Te(ge(R.value, ce.value, ue.value, ke.value))
              : new We(
                  ge(Array.from(R.value), ce.value, ue.value, ke.value).join("")
                );
          }
          evaluateMemberExpression(R, te) {
            const D = this.evaluate(R.object, te);
            let ce;
            if (R.computed) {
              if (R.property.type === "SliceExpression")
                return this.evaluateSliceExpression(D, R.property, te);
              ce = this.evaluate(R.property, te);
            } else ce = new We(R.property.value);
            let ue;
            if (D instanceof pt) {
              if (!(ce instanceof We))
                throw new Error(
                  `Cannot access property with non-string: got ${ce.type}`
                );
              ue = D.value.get(ce.value) ?? D.builtins.get(ce.value);
            } else if (D instanceof Te || D instanceof We)
              if (ce instanceof Ne)
                (ue = D.value.at(ce.value)),
                  D instanceof We && (ue = new We(D.value.at(ce.value)));
              else if (ce instanceof We) ue = D.builtins.get(ce.value);
              else
                throw new Error(
                  `Cannot access property with non-string/non-number: got ${ce.type}`
                );
            else {
              if (!(ce instanceof We))
                throw new Error(
                  `Cannot access property with non-string: got ${ce.type}`
                );
              ue = D.builtins.get(ce.value);
            }
            return ue instanceof Be ? ue : new A();
          }
          evaluateSet(R, te) {
            const D = this.evaluate(R.value, te);
            if (R.assignee.type === "Identifier") {
              const ce = R.assignee.value;
              te.setVariable(ce, D);
            } else if (R.assignee.type === "MemberExpression") {
              const ce = R.assignee,
                ue = this.evaluate(ce.object, te);
              if (!(ue instanceof pt))
                throw new Error("Cannot assign to member of non-object");
              if (ce.property.type !== "Identifier")
                throw new Error(
                  "Cannot assign to member with non-identifier property"
                );
              ue.value.set(ce.property.value, D);
            } else
              throw new Error(
                `Invalid LHS inside assignment expression: ${JSON.stringify(
                  R.assignee
                )}`
              );
            return new et();
          }
          evaluateIf(R, te) {
            const D = this.evaluate(R.test, te);
            return this.evaluateBlock(
              D.__bool__().value ? R.body : R.alternate,
              te
            );
          }
          evaluateFor(R, te) {
            const D = new Ae(te);
            let ce, ue;
            if (R.iterable.type === "SelectExpression") {
              const wt = R.iterable;
              (ue = this.evaluate(wt.iterable, D)), (ce = wt.test);
            } else ue = this.evaluate(R.iterable, D);
            if (!(ue instanceof Te))
              throw new Error(
                `Expected iterable type in for loop: got ${ue.type}`
              );
            const ke = [],
              Re = [];
            for (let wt = 0; wt < ue.value.length; ++wt) {
              const bt = new Ae(D),
                Ke = ue.value[wt];
              let fe;
              if (R.loopvar.type === "Identifier")
                fe = (Ie) => Ie.setVariable(R.loopvar.value, Ke);
              else if (R.loopvar.type === "TupleLiteral") {
                const Ie = R.loopvar;
                if (Ke.type !== "ArrayValue")
                  throw new Error(
                    `Cannot unpack non-iterable type: ${Ke.type}`
                  );
                const Ve = Ke;
                if (Ie.value.length !== Ve.value.length)
                  throw new Error(
                    `Too ${
                      Ie.value.length > Ve.value.length ? "few" : "many"
                    } items to unpack`
                  );
                fe = (ot) => {
                  for (let Xe = 0; Xe < Ie.value.length; ++Xe) {
                    if (Ie.value[Xe].type !== "Identifier")
                      throw new Error(
                        `Cannot unpack non-identifier type: ${Ie.value[Xe].type}`
                      );
                    ot.setVariable(Ie.value[Xe].value, Ve.value[Xe]);
                  }
                };
              } else
                throw new Error(`Invalid loop variable(s): ${R.loopvar.type}`);
              (ce && (fe(bt), !this.evaluate(ce, bt).__bool__().value)) ||
                (ke.push(Ke), Re.push(fe));
            }
            let ht = "",
              tt = !0;
            for (let wt = 0; wt < ke.length; ++wt) {
              const bt = new Map([
                ["index", new Ne(wt + 1)],
                ["index0", new Ne(wt)],
                ["revindex", new Ne(ke.length - wt)],
                ["revindex0", new Ne(ke.length - wt - 1)],
                ["first", new st(wt === 0)],
                ["last", new st(wt === ke.length - 1)],
                ["length", new Ne(ke.length)],
                ["previtem", wt > 0 ? ke[wt - 1] : new A()],
                ["nextitem", wt < ke.length - 1 ? ke[wt + 1] : new A()]
              ]);
              D.setVariable("loop", new pt(bt)), Re[wt](D);
              const Ke = this.evaluateBlock(R.body, D);
              (ht += Ke.value), (tt = !1);
            }
            if (tt) {
              const wt = this.evaluateBlock(R.defaultBlock, D);
              ht += wt.value;
            }
            return new We(ht);
          }
          evaluateMacro(R, te) {
            return (
              te.setVariable(
                R.name.value,
                new Ye((D, ce) => {
                  var Re;
                  const ue = new Ae(ce);
                  D = D.slice();
                  let ke;
                  ((Re = D.at(-1)) == null ? void 0 : Re.type) ===
                    "KeywordArgumentsValue" && (ke = D.pop());
                  for (let ht = 0; ht < R.args.length; ++ht) {
                    const tt = R.args[ht],
                      wt = D[ht];
                    if (tt.type === "Identifier") {
                      const bt = tt;
                      if (!wt)
                        throw new Error(
                          `Missing positional argument: ${bt.value}`
                        );
                      ue.setVariable(bt.value, wt);
                    } else if (tt.type === "KeywordArgumentExpression") {
                      const bt = tt,
                        Ke =
                          wt ??
                          (ke == null ? void 0 : ke.value.get(bt.key.value)) ??
                          this.evaluate(bt.value, ue);
                      ue.setVariable(bt.key.value, Ke);
                    } else throw new Error(`Unknown argument type: ${tt.type}`);
                  }
                  return this.evaluateBlock(R.body, ue);
                })
              ),
              new et()
            );
          }
          evaluate(R, te) {
            if (R === void 0) return new A();
            switch (R.type) {
              case "Program":
                return this.evalProgram(R, te);
              case "Set":
                return this.evaluateSet(R, te);
              case "If":
                return this.evaluateIf(R, te);
              case "For":
                return this.evaluateFor(R, te);
              case "Macro":
                return this.evaluateMacro(R, te);
              case "NumericLiteral":
                return new Ne(Number(R.value));
              case "StringLiteral":
                return new We(R.value);
              case "BooleanLiteral":
                return new st(R.value);
              case "ArrayLiteral":
                return new Te(R.value.map((D) => this.evaluate(D, te)));
              case "TupleLiteral":
                return new je(R.value.map((D) => this.evaluate(D, te)));
              case "ObjectLiteral": {
                const D = new Map();
                for (const [ce, ue] of R.value) {
                  const ke = this.evaluate(ce, te);
                  if (!(ke instanceof We))
                    throw new Error(
                      `Object keys must be strings: got ${ke.type}`
                    );
                  D.set(ke.value, this.evaluate(ue, te));
                }
                return new pt(D);
              }
              case "Identifier":
                return this.evaluateIdentifier(R, te);
              case "CallExpression":
                return this.evaluateCallExpression(R, te);
              case "MemberExpression":
                return this.evaluateMemberExpression(R, te);
              case "UnaryExpression":
                return this.evaluateUnaryExpression(R, te);
              case "BinaryExpression":
                return this.evaluateBinaryExpression(R, te);
              case "FilterExpression":
                return this.evaluateFilterExpression(R, te);
              case "TestExpression":
                return this.evaluateTestExpression(R, te);
              default:
                throw new SyntaxError(`Unknown node type: ${R.type}`);
            }
          }
        };
      function ae(R) {
        switch (typeof R) {
          case "number":
            return new Ne(R);
          case "string":
            return new We(R);
          case "boolean":
            return new st(R);
          case "undefined":
            return new A();
          case "object":
            return R === null
              ? new et()
              : Array.isArray(R)
              ? new Te(R.map(ae))
              : new pt(
                  new Map(Object.entries(R).map(([te, D]) => [te, ae(D)]))
                );
          case "function":
            return new Ye((te, D) => {
              const ce = R(...te.map((ue) => ue.value)) ?? null;
              return ae(ce);
            });
          default:
            throw new Error(`Cannot convert to runtime value: ${R}`);
        }
      }
      function ne(R, te, D) {
        const ce = D ?? 0;
        switch (R.type) {
          case "NullValue":
          case "UndefinedValue":
            return "null";
          case "NumericValue":
          case "StringValue":
          case "BooleanValue":
            return JSON.stringify(R.value);
          case "ArrayValue":
          case "ObjectValue": {
            const ue = te ? " ".repeat(te) : "",
              ke =
                `
` + ue.repeat(ce),
              Re = ke + ue;
            if (R.type === "ArrayValue") {
              const ht = R.value.map((tt) => ne(tt, te, ce + 1));
              return te
                ? `[${Re}${ht.join(`,${Re}`)}${ke}]`
                : `[${ht.join(", ")}]`;
            } else {
              const ht = Array.from(R.value.entries()).map(([tt, wt]) => {
                const bt = `"${tt}": ${ne(wt, te, ce + 1)}`;
                return te ? `${Re}${bt}` : bt;
              });
              return te ? `{${ht.join(",")}${ke}}` : `{${ht.join(", ")}}`;
            }
          }
          default:
            throw new Error(`Cannot convert to JSON: ${R.type}`);
        }
      }
      var ve = class {
        constructor(R) {
          He(this, "parsed");
          const te = v(R, { lstrip_blocks: !0, trim_blocks: !0 });
          this.parsed = xe(te);
        }
        render(R) {
          const te = new Ae();
          te.set("false", !1),
            te.set("true", !0),
            te.set("raise_exception", (ue) => {
              throw new Error(ue);
            }),
            te.set("range", Y);
          for (const [ue, ke] of Object.entries(R)) te.set(ue, ke);
          return new $e(te).run(this.parsed).value;
        }
      };
    },
    "./node_modules/onnxruntime-common/dist/esm/backend-impl.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          registerBackend: () => l,
          resolveBackendAndExecutionProviders: () => _
        });
      const o = new Map(),
        a = [],
        l = (m, g, M) => {
          if (
            g &&
            typeof g.init == "function" &&
            typeof g.createInferenceSessionHandler == "function"
          ) {
            const v = o.get(m);
            if (v === void 0) o.set(m, { backend: g, priority: M });
            else {
              if (v.priority > M) return;
              if (v.priority === M && v.backend !== g)
                throw new Error(
                  `cannot register backend "${m}" using priority ${M}`
                );
            }
            if (M >= 0) {
              const C = a.indexOf(m);
              C !== -1 && a.splice(C, 1);
              for (let T = 0; T < a.length; T++)
                if (o.get(a[T]).priority <= M) {
                  a.splice(T, 0, m);
                  return;
                }
              a.push(m);
            }
            return;
          }
          throw new TypeError("not a valid backend");
        },
        f = async (m) => {
          const g = o.get(m);
          if (!g) return "backend not found.";
          if (g.initialized) return g.backend;
          if (g.aborted) return g.error;
          {
            const M = !!g.initPromise;
            try {
              return (
                M || (g.initPromise = g.backend.init(m)),
                await g.initPromise,
                (g.initialized = !0),
                g.backend
              );
            } catch (v) {
              return M || ((g.error = `${v}`), (g.aborted = !0)), g.error;
            } finally {
              delete g.initPromise;
            }
          }
        },
        _ = async (m) => {
          const g = m.executionProviders || [],
            M = g.map((S) => (typeof S == "string" ? S : S.name)),
            v = M.length === 0 ? a : M;
          let C;
          const T = [],
            z = new Set();
          for (const S of v) {
            const y = await f(S);
            typeof y == "string"
              ? T.push({ name: S, err: y })
              : (C || (C = y), C === y && z.add(S));
          }
          if (!C)
            throw new Error(
              `no available backend found. ERR: ${T.map(
                (S) => `[${S.name}] ${S.err}`
              ).join(", ")}`
            );
          for (const { name: S, err: y } of T)
            M.includes(S) &&
              console.warn(
                `removing requested execution provider "${S}" from session options because it is not available: ${y}`
              );
          const $ = g.filter((S) => z.has(typeof S == "string" ? S : S.name));
          return [
            C,
            new Proxy(m, {
              get: (S, y) =>
                y === "executionProviders" ? $ : Reflect.get(S, y)
            })
          ];
        };
    },
    "./node_modules/onnxruntime-common/dist/esm/backend.js": (e, t, n) => {
      n.r(t), n.d(t, { registerBackend: () => o.registerBackend });
      var o = n("./node_modules/onnxruntime-common/dist/esm/backend-impl.js");
    },
    "./node_modules/onnxruntime-common/dist/esm/env-impl.js": (e, t, n) => {
      n.r(t), n.d(t, { env: () => l });
      var o = n("./node_modules/onnxruntime-common/dist/esm/version.js");
      let a = "warning";
      const l = {
        wasm: {},
        webgl: {},
        webgpu: {},
        versions: { common: o.version },
        set logLevel(f) {
          if (f !== void 0) {
            if (
              typeof f != "string" ||
              ["verbose", "info", "warning", "error", "fatal"].indexOf(f) === -1
            )
              throw new Error(`Unsupported logging level: ${f}`);
            a = f;
          }
        },
        get logLevel() {
          return a;
        }
      };
      Object.defineProperty(l, "logLevel", { enumerable: !0 });
    },
    "./node_modules/onnxruntime-common/dist/esm/env.js": (e, t, n) => {
      n.r(t), n.d(t, { env: () => a });
      var o = n("./node_modules/onnxruntime-common/dist/esm/env-impl.js");
      const a = o.env;
    },
    "./node_modules/onnxruntime-common/dist/esm/index.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          InferenceSession: () => l.InferenceSession,
          TRACE: () => _.TRACE,
          TRACE_FUNC_BEGIN: () => _.TRACE_FUNC_BEGIN,
          TRACE_FUNC_END: () => _.TRACE_FUNC_END,
          Tensor: () => f.Tensor,
          TrainingSession: () => m.TrainingSession,
          env: () => a.env,
          registerBackend: () => o.registerBackend
        });
      var o = n("./node_modules/onnxruntime-common/dist/esm/backend.js"),
        a = n("./node_modules/onnxruntime-common/dist/esm/env.js"),
        l = n(
          "./node_modules/onnxruntime-common/dist/esm/inference-session.js"
        ),
        f = n("./node_modules/onnxruntime-common/dist/esm/tensor.js");
      n("./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js"),
        n("./node_modules/onnxruntime-common/dist/esm/tensor-factory.js");
      var _ = n("./node_modules/onnxruntime-common/dist/esm/trace.js");
      n("./node_modules/onnxruntime-common/dist/esm/onnx-model.js"),
        n("./node_modules/onnxruntime-common/dist/esm/onnx-value.js");
      var m = n(
        "./node_modules/onnxruntime-common/dist/esm/training-session.js"
      );
    },
    "./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js": (
      e,
      t,
      n
    ) => {
      n.r(t), n.d(t, { InferenceSession: () => f });
      var o = n("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),
        a = n("./node_modules/onnxruntime-common/dist/esm/tensor.js"),
        l = n("./node_modules/onnxruntime-common/dist/esm/trace.js");
      class f {
        constructor(m) {
          this.handler = m;
        }
        async run(m, g, M) {
          (0, l.TRACE_FUNC_BEGIN)();
          const v = {};
          let C = {};
          if (
            typeof m != "object" ||
            m === null ||
            m instanceof a.Tensor ||
            Array.isArray(m)
          )
            throw new TypeError(
              "'feeds' must be an object that use input names as keys and OnnxValue as corresponding values."
            );
          let T = !0;
          if (typeof g == "object") {
            if (g === null)
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            if (g instanceof a.Tensor)
              throw new TypeError("'fetches' cannot be a Tensor");
            if (Array.isArray(g)) {
              if (g.length === 0)
                throw new TypeError("'fetches' cannot be an empty array.");
              T = !1;
              for (const S of g) {
                if (typeof S != "string")
                  throw new TypeError(
                    "'fetches' must be a string array or an object."
                  );
                if (this.outputNames.indexOf(S) === -1)
                  throw new RangeError(
                    `'fetches' contains invalid output name: ${S}.`
                  );
                v[S] = null;
              }
              if (typeof M == "object" && M !== null) C = M;
              else if (typeof M < "u")
                throw new TypeError("'options' must be an object.");
            } else {
              let S = !1;
              const y = Object.getOwnPropertyNames(g);
              for (const x of this.outputNames)
                if (y.indexOf(x) !== -1) {
                  const I = g[x];
                  (I === null || I instanceof a.Tensor) &&
                    ((S = !0), (T = !1), (v[x] = I));
                }
              if (S) {
                if (typeof M == "object" && M !== null) C = M;
                else if (typeof M < "u")
                  throw new TypeError("'options' must be an object.");
              } else C = g;
            }
          } else if (typeof g < "u")
            throw new TypeError(
              "Unexpected argument[1]: must be 'fetches' or 'options'."
            );
          for (const S of this.inputNames)
            if (typeof m[S] > "u")
              throw new Error(`input '${S}' is missing in 'feeds'.`);
          if (T) for (const S of this.outputNames) v[S] = null;
          const z = await this.handler.run(m, v, C),
            $ = {};
          for (const S in z)
            if (Object.hasOwnProperty.call(z, S)) {
              const y = z[S];
              y instanceof a.Tensor
                ? ($[S] = y)
                : ($[S] = new a.Tensor(y.type, y.data, y.dims));
            }
          return (0, l.TRACE_FUNC_END)(), $;
        }
        async release() {
          return this.handler.dispose();
        }
        static async create(m, g, M, v) {
          (0, l.TRACE_FUNC_BEGIN)();
          let C,
            T = {};
          if (typeof m == "string") {
            if (((C = m), typeof g == "object" && g !== null)) T = g;
            else if (typeof g < "u")
              throw new TypeError("'options' must be an object.");
          } else if (m instanceof Uint8Array) {
            if (((C = m), typeof g == "object" && g !== null)) T = g;
            else if (typeof g < "u")
              throw new TypeError("'options' must be an object.");
          } else if (
            m instanceof ArrayBuffer ||
            (typeof SharedArrayBuffer < "u" && m instanceof SharedArrayBuffer)
          ) {
            const y = m;
            let x = 0,
              I = m.byteLength;
            if (typeof g == "object" && g !== null) T = g;
            else if (typeof g == "number") {
              if (((x = g), !Number.isSafeInteger(x)))
                throw new RangeError("'byteOffset' must be an integer.");
              if (x < 0 || x >= y.byteLength)
                throw new RangeError(
                  `'byteOffset' is out of range [0, ${y.byteLength}).`
                );
              if (((I = m.byteLength - x), typeof M == "number")) {
                if (((I = M), !Number.isSafeInteger(I)))
                  throw new RangeError("'byteLength' must be an integer.");
                if (I <= 0 || x + I > y.byteLength)
                  throw new RangeError(
                    `'byteLength' is out of range (0, ${y.byteLength - x}].`
                  );
                if (typeof v == "object" && v !== null) T = v;
                else if (typeof v < "u")
                  throw new TypeError("'options' must be an object.");
              } else if (typeof M < "u")
                throw new TypeError("'byteLength' must be a number.");
            } else if (typeof g < "u")
              throw new TypeError("'options' must be an object.");
            C = new Uint8Array(y, x, I);
          } else
            throw new TypeError(
              "Unexpected argument[0]: must be 'path' or 'buffer'."
            );
          const [z, $] = await (0, o.resolveBackendAndExecutionProviders)(T),
            S = await z.createInferenceSessionHandler(C, $);
          return (0, l.TRACE_FUNC_END)(), new f(S);
        }
        startProfiling() {
          this.handler.startProfiling();
        }
        endProfiling() {
          this.handler.endProfiling();
        }
        get inputNames() {
          return this.handler.inputNames;
        }
        get outputNames() {
          return this.handler.outputNames;
        }
      }
    },
    "./node_modules/onnxruntime-common/dist/esm/inference-session.js": (
      e,
      t,
      n
    ) => {
      n.r(t), n.d(t, { InferenceSession: () => a });
      var o = n(
        "./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js"
      );
      const a = o.InferenceSession;
    },
    "./node_modules/onnxruntime-common/dist/esm/onnx-model.js": (e, t, n) => {
      n.r(t);
    },
    "./node_modules/onnxruntime-common/dist/esm/onnx-value.js": (e, t, n) => {
      n.r(t);
    },
    "./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js": (
      e,
      t,
      n
    ) => {
      n.r(t), n.d(t, { tensorToDataURL: () => o, tensorToImageData: () => a });
      const o = (l, f) => {
          const _ =
            typeof document < "u"
              ? document.createElement("canvas")
              : new OffscreenCanvas(1, 1);
          (_.width = l.dims[3]), (_.height = l.dims[2]);
          const m = _.getContext("2d");
          if (m != null) {
            let g, M;
            (f == null ? void 0 : f.tensorLayout) !== void 0 &&
            f.tensorLayout === "NHWC"
              ? ((g = l.dims[2]), (M = l.dims[3]))
              : ((g = l.dims[3]), (M = l.dims[2]));
            const v =
                (f == null ? void 0 : f.format) !== void 0 ? f.format : "RGB",
              C = f == null ? void 0 : f.norm;
            let T, z;
            C === void 0 || C.mean === void 0
              ? (T = [255, 255, 255, 255])
              : typeof C.mean == "number"
              ? (T = [C.mean, C.mean, C.mean, C.mean])
              : ((T = [C.mean[0], C.mean[1], C.mean[2], 0]),
                C.mean[3] !== void 0 && (T[3] = C.mean[3])),
              C === void 0 || C.bias === void 0
                ? (z = [0, 0, 0, 0])
                : typeof C.bias == "number"
                ? (z = [C.bias, C.bias, C.bias, C.bias])
                : ((z = [C.bias[0], C.bias[1], C.bias[2], 0]),
                  C.bias[3] !== void 0 && (z[3] = C.bias[3]));
            const $ = M * g;
            let S = 0,
              y = $,
              x = $ * 2,
              I = -1;
            v === "RGBA"
              ? ((S = 0), (y = $), (x = $ * 2), (I = $ * 3))
              : v === "RGB"
              ? ((S = 0), (y = $), (x = $ * 2))
              : v === "RBG" && ((S = 0), (x = $), (y = $ * 2));
            for (let V = 0; V < M; V++)
              for (let O = 0; O < g; O++) {
                const B = (l.data[S++] - z[0]) * T[0],
                  j = (l.data[y++] - z[1]) * T[1],
                  N = (l.data[x++] - z[2]) * T[2],
                  se = I === -1 ? 255 : (l.data[I++] - z[3]) * T[3];
                (m.fillStyle =
                  "rgba(" + B + "," + j + "," + N + "," + se + ")"),
                  m.fillRect(O, V, 1, 1);
              }
            if ("toDataURL" in _) return _.toDataURL();
            throw new Error("toDataURL is not supported");
          } else throw new Error("Can not access image data");
        },
        a = (l, f) => {
          const _ =
            typeof document < "u"
              ? document.createElement("canvas").getContext("2d")
              : new OffscreenCanvas(1, 1).getContext("2d");
          let m;
          if (_ != null) {
            let g, M, v;
            (f == null ? void 0 : f.tensorLayout) !== void 0 &&
            f.tensorLayout === "NHWC"
              ? ((g = l.dims[2]), (M = l.dims[1]), (v = l.dims[3]))
              : ((g = l.dims[3]), (M = l.dims[2]), (v = l.dims[1]));
            const C = f !== void 0 && f.format !== void 0 ? f.format : "RGB",
              T = f == null ? void 0 : f.norm;
            let z, $;
            T === void 0 || T.mean === void 0
              ? (z = [255, 255, 255, 255])
              : typeof T.mean == "number"
              ? (z = [T.mean, T.mean, T.mean, T.mean])
              : ((z = [T.mean[0], T.mean[1], T.mean[2], 255]),
                T.mean[3] !== void 0 && (z[3] = T.mean[3])),
              T === void 0 || T.bias === void 0
                ? ($ = [0, 0, 0, 0])
                : typeof T.bias == "number"
                ? ($ = [T.bias, T.bias, T.bias, T.bias])
                : (($ = [T.bias[0], T.bias[1], T.bias[2], 0]),
                  T.bias[3] !== void 0 && ($[3] = T.bias[3]));
            const S = M * g;
            if (
              f !== void 0 &&
              ((f.format !== void 0 && v === 4 && f.format !== "RGBA") ||
                (v === 3 && f.format !== "RGB" && f.format !== "BGR"))
            )
              throw new Error("Tensor format doesn't match input tensor dims");
            const y = 4;
            let x = 0,
              I = 1,
              V = 2,
              O = 3,
              B = 0,
              j = S,
              N = S * 2,
              se = -1;
            C === "RGBA"
              ? ((B = 0), (j = S), (N = S * 2), (se = S * 3))
              : C === "RGB"
              ? ((B = 0), (j = S), (N = S * 2))
              : C === "RBG" && ((B = 0), (N = S), (j = S * 2)),
              (m = _.createImageData(g, M));
            for (let de = 0; de < M * g; x += y, I += y, V += y, O += y, de++)
              (m.data[x] = (l.data[B++] - $[0]) * z[0]),
                (m.data[I] = (l.data[j++] - $[1]) * z[1]),
                (m.data[V] = (l.data[N++] - $[2]) * z[2]),
                (m.data[O] = se === -1 ? 255 : (l.data[se++] - $[3]) * z[3]);
          } else throw new Error("Can not access image data");
          return m;
        };
    },
    "./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js": (
      e,
      t,
      n
    ) => {
      n.r(t);
    },
    "./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js": (
      e,
      t,
      n
    ) => {
      n.r(t),
        n.d(t, {
          bufferToTensor: () => a,
          tensorFromGpuBuffer: () => _,
          tensorFromImage: () => l,
          tensorFromPinnedBuffer: () => m,
          tensorFromTexture: () => f
        });
      var o = n("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");
      const a = (g, M) => {
          if (g === void 0) throw new Error("Image buffer must be defined");
          if (M.height === void 0 || M.width === void 0)
            throw new Error("Image height and width must be defined");
          if (M.tensorLayout === "NHWC")
            throw new Error("NHWC Tensor layout is not supported yet");
          const { height: v, width: C } = M,
            T = M.norm ?? { mean: 255, bias: 0 };
          let z, $;
          typeof T.mean == "number"
            ? (z = [T.mean, T.mean, T.mean, T.mean])
            : (z = [T.mean[0], T.mean[1], T.mean[2], T.mean[3] ?? 255]),
            typeof T.bias == "number"
              ? ($ = [T.bias, T.bias, T.bias, T.bias])
              : ($ = [T.bias[0], T.bias[1], T.bias[2], T.bias[3] ?? 0]);
          const S = M.format !== void 0 ? M.format : "RGBA",
            y =
              M.tensorFormat !== void 0 && M.tensorFormat !== void 0
                ? M.tensorFormat
                : "RGB",
            x = v * C,
            I =
              y === "RGBA" ? new Float32Array(x * 4) : new Float32Array(x * 3);
          let V = 4,
            O = 0,
            B = 1,
            j = 2,
            N = 3,
            se = 0,
            de = x,
            Me = x * 2,
            J = -1;
          S === "RGB" && ((V = 3), (O = 0), (B = 1), (j = 2), (N = -1)),
            y === "RGBA"
              ? (J = x * 3)
              : y === "RBG"
              ? ((se = 0), (Me = x), (de = x * 2))
              : y === "BGR" && ((Me = 0), (de = x), (se = x * 2));
          for (let L = 0; L < x; L++, O += V, j += V, B += V, N += V)
            (I[se++] = (g[O] + $[0]) / z[0]),
              (I[de++] = (g[B] + $[1]) / z[1]),
              (I[Me++] = (g[j] + $[2]) / z[2]),
              J !== -1 && N !== -1 && (I[J++] = (g[N] + $[3]) / z[3]);
          return y === "RGBA"
            ? new o.Tensor("float32", I, [1, 4, v, C])
            : new o.Tensor("float32", I, [1, 3, v, C]);
        },
        l = async (g, M) => {
          const v =
              typeof HTMLImageElement < "u" && g instanceof HTMLImageElement,
            C = typeof ImageData < "u" && g instanceof ImageData,
            T = typeof ImageBitmap < "u" && g instanceof ImageBitmap,
            z = typeof g == "string";
          let $,
            S = M ?? {};
          const y = () => {
              if (typeof document < "u")
                return document.createElement("canvas");
              if (typeof OffscreenCanvas < "u")
                return new OffscreenCanvas(1, 1);
              throw new Error("Canvas is not supported");
            },
            x = (I) =>
              I instanceof HTMLCanvasElement || I instanceof OffscreenCanvas
                ? I.getContext("2d")
                : null;
          if (v) {
            const I = y();
            (I.width = g.width), (I.height = g.height);
            const V = x(I);
            if (V != null) {
              let O = g.height,
                B = g.width;
              if (
                (M !== void 0 &&
                  M.resizedHeight !== void 0 &&
                  M.resizedWidth !== void 0 &&
                  ((O = M.resizedHeight), (B = M.resizedWidth)),
                M !== void 0)
              ) {
                if (((S = M), M.tensorFormat !== void 0))
                  throw new Error(
                    "Image input config format must be RGBA for HTMLImageElement"
                  );
                (S.tensorFormat = "RGBA"), (S.height = O), (S.width = B);
              } else (S.tensorFormat = "RGBA"), (S.height = O), (S.width = B);
              V.drawImage(g, 0, 0), ($ = V.getImageData(0, 0, B, O).data);
            } else throw new Error("Can not access image data");
          } else if (C) {
            let I, V;
            if (
              (M !== void 0 &&
              M.resizedWidth !== void 0 &&
              M.resizedHeight !== void 0
                ? ((I = M.resizedHeight), (V = M.resizedWidth))
                : ((I = g.height), (V = g.width)),
              M !== void 0 && (S = M),
              (S.format = "RGBA"),
              (S.height = I),
              (S.width = V),
              M !== void 0)
            ) {
              const O = y();
              (O.width = V), (O.height = I);
              const B = x(O);
              if (B != null)
                B.putImageData(g, 0, 0), ($ = B.getImageData(0, 0, V, I).data);
              else throw new Error("Can not access image data");
            } else $ = g.data;
          } else if (T) {
            if (M === void 0)
              throw new Error(
                "Please provide image config with format for Imagebitmap"
              );
            const I = y();
            (I.width = g.width), (I.height = g.height);
            const V = x(I);
            if (V != null) {
              const O = g.height,
                B = g.width;
              return (
                V.drawImage(g, 0, 0, B, O),
                ($ = V.getImageData(0, 0, B, O).data),
                (S.height = O),
                (S.width = B),
                a($, S)
              );
            } else throw new Error("Can not access image data");
          } else {
            if (z)
              return new Promise((I, V) => {
                const O = y(),
                  B = x(O);
                if (!g || !B) return V();
                const j = new Image();
                (j.crossOrigin = "Anonymous"),
                  (j.src = g),
                  (j.onload = () => {
                    (O.width = j.width),
                      (O.height = j.height),
                      B.drawImage(j, 0, 0, O.width, O.height);
                    const N = B.getImageData(0, 0, O.width, O.height);
                    (S.height = O.height), (S.width = O.width), I(a(N.data, S));
                  });
              });
            throw new Error(
              "Input data provided is not supported - aborted tensor creation"
            );
          }
          if ($ !== void 0) return a($, S);
          throw new Error(
            "Input data provided is not supported - aborted tensor creation"
          );
        },
        f = (g, M) => {
          const { width: v, height: C, download: T, dispose: z } = M,
            $ = [1, C, v, 4];
          return new o.Tensor({
            location: "texture",
            type: "float32",
            texture: g,
            dims: $,
            download: T,
            dispose: z
          });
        },
        _ = (g, M) => {
          const { dataType: v, dims: C, download: T, dispose: z } = M;
          return new o.Tensor({
            location: "gpu-buffer",
            type: v ?? "float32",
            gpuBuffer: g,
            dims: C,
            download: T,
            dispose: z
          });
        },
        m = (g, M, v) =>
          new o.Tensor({
            location: "cpu-pinned",
            type: g,
            data: M,
            dims: v ?? [M.length]
          });
    },
    "./node_modules/onnxruntime-common/dist/esm/tensor-factory.js": (
      e,
      t,
      n
    ) => {
      n.r(t);
    },
    "./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js": (
      e,
      t,
      n
    ) => {
      n.r(t),
        n.d(t, {
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP: () => a,
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP: () => o,
          checkTypedArray: () => f
        });
      const o = new Map([
          ["float32", Float32Array],
          ["uint8", Uint8Array],
          ["int8", Int8Array],
          ["uint16", Uint16Array],
          ["int16", Int16Array],
          ["int32", Int32Array],
          ["bool", Uint8Array],
          ["float64", Float64Array],
          ["uint32", Uint32Array]
        ]),
        a = new Map([
          [Float32Array, "float32"],
          [Uint8Array, "uint8"],
          [Int8Array, "int8"],
          [Uint16Array, "uint16"],
          [Int16Array, "int16"],
          [Int32Array, "int32"],
          [Float64Array, "float64"],
          [Uint32Array, "uint32"]
        ]);
      let l = !1;
      const f = () => {
        if (!l) {
          l = !0;
          const _ = typeof BigInt64Array < "u" && BigInt64Array.from,
            m = typeof BigUint64Array < "u" && BigUint64Array.from,
            g = typeof Float16Array < "u" && Float16Array.from;
          _ && (o.set("int64", BigInt64Array), a.set(BigInt64Array, "int64")),
            m &&
              (o.set("uint64", BigUint64Array),
              a.set(BigUint64Array, "uint64")),
            g
              ? (o.set("float16", Float16Array), a.set(Float16Array, "float16"))
              : o.set("float16", Uint16Array);
        }
      };
    },
    "./node_modules/onnxruntime-common/dist/esm/tensor-impl.js": (e, t, n) => {
      n.r(t), n.d(t, { Tensor: () => _ });
      var o = n(
          "./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js"
        ),
        a = n(
          "./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js"
        ),
        l = n(
          "./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js"
        ),
        f = n(
          "./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js"
        );
      class _ {
        constructor(g, M, v) {
          (0, l.checkTypedArray)();
          let C, T;
          if (typeof g == "object" && "location" in g)
            switch (
              ((this.dataLocation = g.location),
              (C = g.type),
              (T = g.dims),
              g.location)
            ) {
              case "cpu-pinned": {
                const $ = l.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(C);
                if (!$)
                  throw new TypeError(
                    `unsupported type "${C}" to create tensor from pinned buffer`
                  );
                if (!(g.data instanceof $))
                  throw new TypeError(`buffer should be of type ${$.name}`);
                this.cpuData = g.data;
                break;
              }
              case "texture": {
                if (C !== "float32")
                  throw new TypeError(
                    `unsupported type "${C}" to create tensor from texture`
                  );
                (this.gpuTextureData = g.texture),
                  (this.downloader = g.download),
                  (this.disposer = g.dispose);
                break;
              }
              case "gpu-buffer": {
                if (
                  C !== "float32" &&
                  C !== "float16" &&
                  C !== "int32" &&
                  C !== "int64" &&
                  C !== "uint32" &&
                  C !== "uint8" &&
                  C !== "bool"
                )
                  throw new TypeError(
                    `unsupported type "${C}" to create tensor from gpu buffer`
                  );
                (this.gpuBufferData = g.gpuBuffer),
                  (this.downloader = g.download),
                  (this.disposer = g.dispose);
                break;
              }
              default:
                throw new Error(
                  `Tensor constructor: unsupported location '${this.dataLocation}'`
                );
            }
          else {
            let $, S;
            if (typeof g == "string")
              if (((C = g), (S = v), g === "string")) {
                if (!Array.isArray(M))
                  throw new TypeError(
                    "A string tensor's data must be a string array."
                  );
                $ = M;
              } else {
                const y = l.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(g);
                if (y === void 0)
                  throw new TypeError(`Unsupported tensor type: ${g}.`);
                if (Array.isArray(M)) {
                  if (g === "float16" && y === Uint16Array)
                    throw new TypeError(
                      "Creating a float16 tensor from number array is not supported. Please use Uint16Array as data."
                    );
                  g === "uint64" || g === "int64"
                    ? ($ = y.from(M, BigInt))
                    : ($ = y.from(M));
                } else if (M instanceof y) $ = M;
                else
                  throw new TypeError(
                    `A ${C} tensor's data must be type of ${y}`
                  );
              }
            else if (((S = M), Array.isArray(g))) {
              if (g.length === 0)
                throw new TypeError(
                  "Tensor type cannot be inferred from an empty array."
                );
              const y = typeof g[0];
              if (y === "string") (C = "string"), ($ = g);
              else if (y === "boolean") (C = "bool"), ($ = Uint8Array.from(g));
              else
                throw new TypeError(
                  `Invalid element type of data array: ${y}.`
                );
            } else {
              const y = l.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(
                g.constructor
              );
              if (y === void 0)
                throw new TypeError(
                  `Unsupported type for tensor data: ${g.constructor}.`
                );
              (C = y), ($ = g);
            }
            if (S === void 0) S = [$.length];
            else if (!Array.isArray(S))
              throw new TypeError("A tensor's dims must be a number array");
            (T = S), (this.cpuData = $), (this.dataLocation = "cpu");
          }
          const z = (0, f.calculateSize)(T);
          if (this.cpuData && z !== this.cpuData.length)
            throw new Error(
              `Tensor's size(${z}) does not match data length(${this.cpuData.length}).`
            );
          (this.type = C), (this.dims = T), (this.size = z);
        }
        static async fromImage(g, M) {
          return (0, a.tensorFromImage)(g, M);
        }
        static fromTexture(g, M) {
          return (0, a.tensorFromTexture)(g, M);
        }
        static fromGpuBuffer(g, M) {
          return (0, a.tensorFromGpuBuffer)(g, M);
        }
        static fromPinnedBuffer(g, M, v) {
          return (0, a.tensorFromPinnedBuffer)(g, M, v);
        }
        toDataURL(g) {
          return (0, o.tensorToDataURL)(this, g);
        }
        toImageData(g) {
          return (0, o.tensorToImageData)(this, g);
        }
        get data() {
          if ((this.ensureValid(), !this.cpuData))
            throw new Error(
              "The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly."
            );
          return this.cpuData;
        }
        get location() {
          return this.dataLocation;
        }
        get texture() {
          if ((this.ensureValid(), !this.gpuTextureData))
            throw new Error("The data is not stored as a WebGL texture.");
          return this.gpuTextureData;
        }
        get gpuBuffer() {
          if ((this.ensureValid(), !this.gpuBufferData))
            throw new Error("The data is not stored as a WebGPU buffer.");
          return this.gpuBufferData;
        }
        async getData(g) {
          switch ((this.ensureValid(), this.dataLocation)) {
            case "cpu":
            case "cpu-pinned":
              return this.data;
            case "texture":
            case "gpu-buffer": {
              if (!this.downloader)
                throw new Error(
                  "The current tensor is not created with a specified data downloader."
                );
              if (this.isDownloading)
                throw new Error("The current tensor is being downloaded.");
              try {
                this.isDownloading = !0;
                const M = await this.downloader();
                return (
                  (this.downloader = void 0),
                  (this.dataLocation = "cpu"),
                  (this.cpuData = M),
                  g &&
                    this.disposer &&
                    (this.disposer(), (this.disposer = void 0)),
                  M
                );
              } finally {
                this.isDownloading = !1;
              }
            }
            default:
              throw new Error(
                `cannot get data from location: ${this.dataLocation}`
              );
          }
        }
        dispose() {
          if (this.isDownloading)
            throw new Error("The current tensor is being downloaded.");
          this.disposer && (this.disposer(), (this.disposer = void 0)),
            (this.cpuData = void 0),
            (this.gpuTextureData = void 0),
            (this.gpuBufferData = void 0),
            (this.downloader = void 0),
            (this.isDownloading = void 0),
            (this.dataLocation = "none");
        }
        ensureValid() {
          if (this.dataLocation === "none")
            throw new Error("The tensor is disposed.");
        }
        reshape(g) {
          if ((this.ensureValid(), this.downloader || this.disposer))
            throw new Error("Cannot reshape a tensor that owns GPU resource.");
          return (0, f.tensorReshape)(this, g);
        }
      }
    },
    "./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js": (
      e,
      t,
      n
    ) => {
      n.r(t), n.d(t, { calculateSize: () => a, tensorReshape: () => l });
      var o = n("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");
      const a = (f) => {
          let _ = 1;
          for (let m = 0; m < f.length; m++) {
            const g = f[m];
            if (typeof g != "number" || !Number.isSafeInteger(g))
              throw new TypeError(`dims[${m}] must be an integer, got: ${g}`);
            if (g < 0)
              throw new RangeError(
                `dims[${m}] must be a non-negative integer, got: ${g}`
              );
            _ *= g;
          }
          return _;
        },
        l = (f, _) => {
          switch (f.location) {
            case "cpu":
              return new o.Tensor(f.type, f.data, _);
            case "cpu-pinned":
              return new o.Tensor({
                location: "cpu-pinned",
                data: f.data,
                type: f.type,
                dims: _
              });
            case "texture":
              return new o.Tensor({
                location: "texture",
                texture: f.texture,
                type: f.type,
                dims: _
              });
            case "gpu-buffer":
              return new o.Tensor({
                location: "gpu-buffer",
                gpuBuffer: f.gpuBuffer,
                type: f.type,
                dims: _
              });
            default:
              throw new Error(
                `tensorReshape: tensor location ${f.location} is not supported`
              );
          }
        };
    },
    "./node_modules/onnxruntime-common/dist/esm/tensor.js": (e, t, n) => {
      n.r(t), n.d(t, { Tensor: () => a });
      var o = n("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");
      const a = o.Tensor;
    },
    "./node_modules/onnxruntime-common/dist/esm/trace.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          TRACE: () => a,
          TRACE_FUNC_BEGIN: () => f,
          TRACE_FUNC_END: () => _
        });
      var o = n("./node_modules/onnxruntime-common/dist/esm/env-impl.js");
      const a = (m, g) => {
          (typeof o.env.trace > "u" ? !o.env.wasm.trace : !o.env.trace) ||
            console.timeStamp(`${m}::ORT::${g}`);
        },
        l = (m, g) => {
          var C;
          const M =
            ((C = new Error().stack) == null
              ? void 0
              : C.split(/\r\n|\r|\n/g)) || [];
          let v = !1;
          for (let T = 0; T < M.length; T++) {
            if (v && !M[T].includes("TRACE_FUNC")) {
              let z = `FUNC_${m}::${M[T].trim().split(" ")[1]}`;
              g && (z += `::${g}`), a("CPU", z);
              return;
            }
            M[T].includes("TRACE_FUNC") && (v = !0);
          }
        },
        f = (m) => {
          (typeof o.env.trace > "u" ? !o.env.wasm.trace : !o.env.trace) ||
            l("BEGIN", m);
        },
        _ = (m) => {
          (typeof o.env.trace > "u" ? !o.env.wasm.trace : !o.env.trace) ||
            l("END", m);
        };
    },
    "./node_modules/onnxruntime-common/dist/esm/training-session-impl.js": (
      e,
      t,
      n
    ) => {
      n.r(t), n.d(t, { TrainingSession: () => f });
      var o = n("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),
        a = n("./node_modules/onnxruntime-common/dist/esm/tensor.js");
      const l =
        "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";
      class f {
        constructor(m, g, M) {
          (this.handler = m),
            (this.hasOptimizerModel = g),
            (this.hasEvalModel = M);
        }
        get trainingInputNames() {
          return this.handler.inputNames;
        }
        get trainingOutputNames() {
          return this.handler.outputNames;
        }
        get evalInputNames() {
          if (this.hasEvalModel) return this.handler.evalInputNames;
          throw new Error("This training session has no evalModel loaded.");
        }
        get evalOutputNames() {
          if (this.hasEvalModel) return this.handler.evalOutputNames;
          throw new Error("This training session has no evalModel loaded.");
        }
        static async create(m, g) {
          const M = m.evalModel || "",
            v = m.optimizerModel || "",
            C = g || {},
            [T, z] = await (0, o.resolveBackendAndExecutionProviders)(C);
          if (T.createTrainingSessionHandler) {
            const $ = await T.createTrainingSessionHandler(
              m.checkpointState,
              m.trainModel,
              M,
              v,
              z
            );
            return new f($, !!m.optimizerModel, !!m.evalModel);
          } else throw new Error(l);
        }
        typeNarrowingForRunStep(m, g, M, v, C) {
          const T = {};
          let z = {};
          if (
            typeof M != "object" ||
            M === null ||
            M instanceof a.Tensor ||
            Array.isArray(M)
          )
            throw new TypeError(
              "'feeds' must be an object that use input names as keys and OnnxValue as corresponding values."
            );
          let $ = !0;
          if (typeof v == "object") {
            if (v === null)
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            if (v instanceof a.Tensor)
              throw new TypeError("'fetches' cannot be a Tensor");
            if (Array.isArray(v)) {
              if (v.length === 0)
                throw new TypeError("'fetches' cannot be an empty array.");
              $ = !1;
              for (const S of v) {
                if (typeof S != "string")
                  throw new TypeError(
                    "'fetches' must be a string array or an object."
                  );
                if (g.indexOf(S) === -1)
                  throw new RangeError(
                    `'fetches' contains invalid output name: ${S}.`
                  );
                T[S] = null;
              }
              if (typeof C == "object" && C !== null) z = C;
              else if (typeof C < "u")
                throw new TypeError("'options' must be an object.");
            } else {
              let S = !1;
              const y = Object.getOwnPropertyNames(v);
              for (const x of g)
                if (y.indexOf(x) !== -1) {
                  const I = v[x];
                  (I === null || I instanceof a.Tensor) &&
                    ((S = !0), ($ = !1), (T[x] = I));
                }
              if (S) {
                if (typeof C == "object" && C !== null) z = C;
                else if (typeof C < "u")
                  throw new TypeError("'options' must be an object.");
              } else z = v;
            }
          } else if (typeof v < "u")
            throw new TypeError(
              "Unexpected argument[1]: must be 'fetches' or 'options'."
            );
          for (const S of m)
            if (typeof M[S] > "u")
              throw new Error(`input '${S}' is missing in 'feeds'.`);
          if ($) for (const S of g) T[S] = null;
          return [T, z];
        }
        convertHandlerReturnTypeToMapOfTensors(m) {
          const g = {};
          for (const M in m)
            if (Object.hasOwnProperty.call(m, M)) {
              const v = m[M];
              v instanceof a.Tensor
                ? (g[M] = v)
                : (g[M] = new a.Tensor(v.type, v.data, v.dims));
            }
          return g;
        }
        async lazyResetGrad() {
          await this.handler.lazyResetGrad();
        }
        async runTrainStep(m, g, M) {
          const [v, C] = this.typeNarrowingForRunStep(
              this.trainingInputNames,
              this.trainingOutputNames,
              m,
              g,
              M
            ),
            T = await this.handler.runTrainStep(m, v, C);
          return this.convertHandlerReturnTypeToMapOfTensors(T);
        }
        async runOptimizerStep(m) {
          if (this.hasOptimizerModel)
            await this.handler.runOptimizerStep(m || {});
          else
            throw new Error(
              "This TrainingSession has no OptimizerModel loaded."
            );
        }
        async runEvalStep(m, g, M) {
          if (this.hasEvalModel) {
            const [v, C] = this.typeNarrowingForRunStep(
                this.evalInputNames,
                this.evalOutputNames,
                m,
                g,
                M
              ),
              T = await this.handler.runEvalStep(m, v, C);
            return this.convertHandlerReturnTypeToMapOfTensors(T);
          } else
            throw new Error("This TrainingSession has no EvalModel loaded.");
        }
        async getParametersSize(m = !0) {
          return this.handler.getParametersSize(m);
        }
        async loadParametersBuffer(m, g = !0) {
          const M = await this.getParametersSize(g);
          if (m.length !== 4 * M)
            throw new Error(
              "Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check."
            );
          return this.handler.loadParametersBuffer(m, g);
        }
        async getContiguousParameters(m = !0) {
          return this.handler.getContiguousParameters(m);
        }
        async release() {
          return this.handler.dispose();
        }
      }
    },
    "./node_modules/onnxruntime-common/dist/esm/training-session.js": (
      e,
      t,
      n
    ) => {
      n.r(t), n.d(t, { TrainingSession: () => a });
      var o = n(
        "./node_modules/onnxruntime-common/dist/esm/training-session-impl.js"
      );
      const a = o.TrainingSession;
    },
    "./node_modules/onnxruntime-common/dist/esm/version.js": (e, t, n) => {
      n.r(t), n.d(t, { version: () => o });
      const o = "1.19.0";
    },
    "./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs": (
      e,
      t,
      n
    ) => {
      n.r(t),
        n.d(t, {
          InferenceSession: () => ne,
          TRACE: () => je,
          TRACE_FUNC_BEGIN: () => et,
          TRACE_FUNC_END: () => A,
          Tensor: () => Ge,
          TrainingSession: () => ht,
          default: () => Rx,
          env: () => N,
          registerBackend: () => z
        });
      /*!
       * ONNX Runtime Web v1.20.0-dev.20240827-1d059b8702
       * Copyright (c) Microsoft Corporation. All rights reserved.
       * Licensed under the MIT License.
       */ var o = Object.defineProperty,
        a = Object.getOwnPropertyDescriptor,
        l = Object.getOwnPropertyNames,
        f = Object.prototype.hasOwnProperty,
        _ = ((r) =>
          typeof require < "u"
            ? require
            : typeof Proxy < "u"
            ? new Proxy(r, {
                get: (i, s) => (typeof require < "u" ? require : i)[s]
              })
            : r)(function (r) {
          if (typeof require < "u") return require.apply(this, arguments);
          throw Error('Dynamic require of "' + r + '" is not supported');
        }),
        m = (r, i) => () => (r && (i = r((r = 0))), i),
        g = (r, i) => {
          for (var s in i) o(r, s, { get: i[s], enumerable: !0 });
        },
        M = (r, i, s, u) => {
          if ((i && typeof i == "object") || typeof i == "function")
            for (let d of l(i))
              !f.call(r, d) &&
                d !== s &&
                o(r, d, {
                  get: () => i[d],
                  enumerable: !(u = a(i, d)) || u.enumerable
                });
          return r;
        },
        v = (r) => M(o({}, "__esModule", { value: !0 }), r),
        C,
        T,
        z,
        $,
        S,
        y = m(() => {
          (C = new Map()),
            (T = []),
            (z = (r, i, s) => {
              if (
                i &&
                typeof i.init == "function" &&
                typeof i.createInferenceSessionHandler == "function"
              ) {
                let u = C.get(r);
                if (u === void 0) C.set(r, { backend: i, priority: s });
                else {
                  if (u.priority > s) return;
                  if (u.priority === s && u.backend !== i)
                    throw new Error(
                      `cannot register backend "${r}" using priority ${s}`
                    );
                }
                if (s >= 0) {
                  let d = T.indexOf(r);
                  d !== -1 && T.splice(d, 1);
                  for (let p = 0; p < T.length; p++)
                    if (C.get(T[p]).priority <= s) {
                      T.splice(p, 0, r);
                      return;
                    }
                  T.push(r);
                }
                return;
              }
              throw new TypeError("not a valid backend");
            }),
            ($ = async (r) => {
              let i = C.get(r);
              if (!i) return "backend not found.";
              if (i.initialized) return i.backend;
              if (i.aborted) return i.error;
              {
                let s = !!i.initPromise;
                try {
                  return (
                    s || (i.initPromise = i.backend.init(r)),
                    await i.initPromise,
                    (i.initialized = !0),
                    i.backend
                  );
                } catch (u) {
                  return s || ((i.error = `${u}`), (i.aborted = !0)), i.error;
                } finally {
                  delete i.initPromise;
                }
              }
            }),
            (S = async (r) => {
              let i = r.executionProviders || [],
                s = i.map((k) => (typeof k == "string" ? k : k.name)),
                u = s.length === 0 ? T : s,
                d,
                p = [],
                c = new Set();
              for (let k of u) {
                let E = await $(k);
                typeof E == "string"
                  ? p.push({ name: k, err: E })
                  : (d || (d = E), d === E && c.add(k));
              }
              if (!d)
                throw new Error(
                  `no available backend found. ERR: ${p
                    .map((k) => `[${k.name}] ${k.err}`)
                    .join(", ")}`
                );
              for (let { name: k, err: E } of p)
                s.includes(k) &&
                  console.warn(
                    `removing requested execution provider "${k}" from session options because it is not available: ${E}`
                  );
              let b = i.filter((k) => c.has(typeof k == "string" ? k : k.name));
              return [
                d,
                new Proxy(r, {
                  get: (k, E) =>
                    E === "executionProviders" ? b : Reflect.get(k, E)
                })
              ];
            });
        }),
        x = m(() => {
          y();
        }),
        I,
        V = m(() => {
          I = "1.20.0-dev.20240827-5d54dc1462";
        }),
        O,
        B,
        j = m(() => {
          V(),
            (O = "warning"),
            (B = {
              wasm: {},
              webgl: {},
              webgpu: {},
              versions: { common: I },
              set logLevel(r) {
                if (r !== void 0) {
                  if (
                    typeof r != "string" ||
                    ["verbose", "info", "warning", "error", "fatal"].indexOf(
                      r
                    ) === -1
                  )
                    throw new Error(`Unsupported logging level: ${r}`);
                  O = r;
                }
              },
              get logLevel() {
                return O;
              }
            }),
            Object.defineProperty(B, "logLevel", { enumerable: !0 });
        }),
        N,
        se = m(() => {
          j(), (N = B);
        }),
        de,
        Me,
        J = m(() => {
          (de = (r, i) => {
            let s =
              typeof document < "u"
                ? document.createElement("canvas")
                : new OffscreenCanvas(1, 1);
            (s.width = r.dims[3]), (s.height = r.dims[2]);
            let u = s.getContext("2d");
            if (u != null) {
              let d, p;
              (i == null ? void 0 : i.tensorLayout) !== void 0 &&
              i.tensorLayout === "NHWC"
                ? ((d = r.dims[2]), (p = r.dims[3]))
                : ((d = r.dims[3]), (p = r.dims[2]));
              let c =
                  (i == null ? void 0 : i.format) !== void 0 ? i.format : "RGB",
                b = i == null ? void 0 : i.norm,
                k,
                E;
              b === void 0 || b.mean === void 0
                ? (k = [255, 255, 255, 255])
                : typeof b.mean == "number"
                ? (k = [b.mean, b.mean, b.mean, b.mean])
                : ((k = [b.mean[0], b.mean[1], b.mean[2], 0]),
                  b.mean[3] !== void 0 && (k[3] = b.mean[3])),
                b === void 0 || b.bias === void 0
                  ? (E = [0, 0, 0, 0])
                  : typeof b.bias == "number"
                  ? (E = [b.bias, b.bias, b.bias, b.bias])
                  : ((E = [b.bias[0], b.bias[1], b.bias[2], 0]),
                    b.bias[3] !== void 0 && (E[3] = b.bias[3]));
              let q = p * d,
                H = 0,
                w = q,
                Z = q * 2,
                re = -1;
              c === "RGBA"
                ? ((H = 0), (w = q), (Z = q * 2), (re = q * 3))
                : c === "RGB"
                ? ((H = 0), (w = q), (Z = q * 2))
                : c === "RBG" && ((H = 0), (Z = q), (w = q * 2));
              for (let le = 0; le < p; le++)
                for (let we = 0; we < d; we++) {
                  let be = (r.data[H++] - E[0]) * k[0],
                    me = (r.data[w++] - E[1]) * k[1],
                    Fe = (r.data[Z++] - E[2]) * k[2],
                    Ce = re === -1 ? 255 : (r.data[re++] - E[3]) * k[3];
                  (u.fillStyle =
                    "rgba(" + be + "," + me + "," + Fe + "," + Ce + ")"),
                    u.fillRect(we, le, 1, 1);
                }
              if ("toDataURL" in s) return s.toDataURL();
              throw new Error("toDataURL is not supported");
            } else throw new Error("Can not access image data");
          }),
            (Me = (r, i) => {
              let s =
                  typeof document < "u"
                    ? document.createElement("canvas").getContext("2d")
                    : new OffscreenCanvas(1, 1).getContext("2d"),
                u;
              if (s != null) {
                let d, p, c;
                (i == null ? void 0 : i.tensorLayout) !== void 0 &&
                i.tensorLayout === "NHWC"
                  ? ((d = r.dims[2]), (p = r.dims[1]), (c = r.dims[3]))
                  : ((d = r.dims[3]), (p = r.dims[2]), (c = r.dims[1]));
                let b = i !== void 0 && i.format !== void 0 ? i.format : "RGB",
                  k = i == null ? void 0 : i.norm,
                  E,
                  q;
                k === void 0 || k.mean === void 0
                  ? (E = [255, 255, 255, 255])
                  : typeof k.mean == "number"
                  ? (E = [k.mean, k.mean, k.mean, k.mean])
                  : ((E = [k.mean[0], k.mean[1], k.mean[2], 255]),
                    k.mean[3] !== void 0 && (E[3] = k.mean[3])),
                  k === void 0 || k.bias === void 0
                    ? (q = [0, 0, 0, 0])
                    : typeof k.bias == "number"
                    ? (q = [k.bias, k.bias, k.bias, k.bias])
                    : ((q = [k.bias[0], k.bias[1], k.bias[2], 0]),
                      k.bias[3] !== void 0 && (q[3] = k.bias[3]));
                let H = p * d;
                if (
                  i !== void 0 &&
                  ((i.format !== void 0 && c === 4 && i.format !== "RGBA") ||
                    (c === 3 && i.format !== "RGB" && i.format !== "BGR"))
                )
                  throw new Error(
                    "Tensor format doesn't match input tensor dims"
                  );
                let w = 4,
                  Z = 0,
                  re = 1,
                  le = 2,
                  we = 3,
                  be = 0,
                  me = H,
                  Fe = H * 2,
                  Ce = -1;
                b === "RGBA"
                  ? ((be = 0), (me = H), (Fe = H * 2), (Ce = H * 3))
                  : b === "RGB"
                  ? ((be = 0), (me = H), (Fe = H * 2))
                  : b === "RBG" && ((be = 0), (Fe = H), (me = H * 2)),
                  (u = s.createImageData(d, p));
                for (
                  let ze = 0;
                  ze < p * d;
                  Z += w, re += w, le += w, we += w, ze++
                )
                  (u.data[Z] = (r.data[be++] - q[0]) * E[0]),
                    (u.data[re] = (r.data[me++] - q[1]) * E[1]),
                    (u.data[le] = (r.data[Fe++] - q[2]) * E[2]),
                    (u.data[we] =
                      Ce === -1 ? 255 : (r.data[Ce++] - q[3]) * E[3]);
              } else throw new Error("Can not access image data");
              return u;
            });
        }),
        ye,
        L,
        Ee,
        Qe,
        _e,
        X = m(() => {
          pt(),
            (ye = (r, i) => {
              if (r === void 0) throw new Error("Image buffer must be defined");
              if (i.height === void 0 || i.width === void 0)
                throw new Error("Image height and width must be defined");
              if (i.tensorLayout === "NHWC")
                throw new Error("NHWC Tensor layout is not supported yet");
              let { height: s, width: u } = i,
                d = i.norm ?? { mean: 255, bias: 0 },
                p,
                c;
              typeof d.mean == "number"
                ? (p = [d.mean, d.mean, d.mean, d.mean])
                : (p = [d.mean[0], d.mean[1], d.mean[2], d.mean[3] ?? 255]),
                typeof d.bias == "number"
                  ? (c = [d.bias, d.bias, d.bias, d.bias])
                  : (c = [d.bias[0], d.bias[1], d.bias[2], d.bias[3] ?? 0]);
              let b = i.format !== void 0 ? i.format : "RGBA",
                k =
                  i.tensorFormat !== void 0 && i.tensorFormat !== void 0
                    ? i.tensorFormat
                    : "RGB",
                E = s * u,
                q =
                  k === "RGBA"
                    ? new Float32Array(E * 4)
                    : new Float32Array(E * 3),
                H = 4,
                w = 0,
                Z = 1,
                re = 2,
                le = 3,
                we = 0,
                be = E,
                me = E * 2,
                Fe = -1;
              b === "RGB" && ((H = 3), (w = 0), (Z = 1), (re = 2), (le = -1)),
                k === "RGBA"
                  ? (Fe = E * 3)
                  : k === "RBG"
                  ? ((we = 0), (me = E), (be = E * 2))
                  : k === "BGR" && ((me = 0), (be = E), (we = E * 2));
              for (let Ce = 0; Ce < E; Ce++, w += H, re += H, Z += H, le += H)
                (q[we++] = (r[w] + c[0]) / p[0]),
                  (q[be++] = (r[Z] + c[1]) / p[1]),
                  (q[me++] = (r[re] + c[2]) / p[2]),
                  Fe !== -1 && le !== -1 && (q[Fe++] = (r[le] + c[3]) / p[3]);
              return k === "RGBA"
                ? new st("float32", q, [1, 4, s, u])
                : new st("float32", q, [1, 3, s, u]);
            }),
            (L = async (r, i) => {
              let s =
                  typeof HTMLImageElement < "u" &&
                  r instanceof HTMLImageElement,
                u = typeof ImageData < "u" && r instanceof ImageData,
                d = typeof ImageBitmap < "u" && r instanceof ImageBitmap,
                p = typeof r == "string",
                c,
                b = i ?? {},
                k = () => {
                  if (typeof document < "u")
                    return document.createElement("canvas");
                  if (typeof OffscreenCanvas < "u")
                    return new OffscreenCanvas(1, 1);
                  throw new Error("Canvas is not supported");
                },
                E = (q) =>
                  q instanceof HTMLCanvasElement || q instanceof OffscreenCanvas
                    ? q.getContext("2d")
                    : null;
              if (s) {
                let q = k();
                (q.width = r.width), (q.height = r.height);
                let H = E(q);
                if (H != null) {
                  let w = r.height,
                    Z = r.width;
                  if (
                    (i !== void 0 &&
                      i.resizedHeight !== void 0 &&
                      i.resizedWidth !== void 0 &&
                      ((w = i.resizedHeight), (Z = i.resizedWidth)),
                    i !== void 0)
                  ) {
                    if (((b = i), i.tensorFormat !== void 0))
                      throw new Error(
                        "Image input config format must be RGBA for HTMLImageElement"
                      );
                    (b.tensorFormat = "RGBA"), (b.height = w), (b.width = Z);
                  } else
                    (b.tensorFormat = "RGBA"), (b.height = w), (b.width = Z);
                  H.drawImage(r, 0, 0), (c = H.getImageData(0, 0, Z, w).data);
                } else throw new Error("Can not access image data");
              } else if (u) {
                let q, H;
                if (
                  (i !== void 0 &&
                  i.resizedWidth !== void 0 &&
                  i.resizedHeight !== void 0
                    ? ((q = i.resizedHeight), (H = i.resizedWidth))
                    : ((q = r.height), (H = r.width)),
                  i !== void 0 && (b = i),
                  (b.format = "RGBA"),
                  (b.height = q),
                  (b.width = H),
                  i !== void 0)
                ) {
                  let w = k();
                  (w.width = H), (w.height = q);
                  let Z = E(w);
                  if (Z != null)
                    Z.putImageData(r, 0, 0),
                      (c = Z.getImageData(0, 0, H, q).data);
                  else throw new Error("Can not access image data");
                } else c = r.data;
              } else if (d) {
                if (i === void 0)
                  throw new Error(
                    "Please provide image config with format for Imagebitmap"
                  );
                let q = k();
                (q.width = r.width), (q.height = r.height);
                let H = E(q);
                if (H != null) {
                  let w = r.height,
                    Z = r.width;
                  return (
                    H.drawImage(r, 0, 0, Z, w),
                    (c = H.getImageData(0, 0, Z, w).data),
                    (b.height = w),
                    (b.width = Z),
                    ye(c, b)
                  );
                } else throw new Error("Can not access image data");
              } else {
                if (p)
                  return new Promise((q, H) => {
                    let w = k(),
                      Z = E(w);
                    if (!r || !Z) return H();
                    let re = new Image();
                    (re.crossOrigin = "Anonymous"),
                      (re.src = r),
                      (re.onload = () => {
                        (w.width = re.width),
                          (w.height = re.height),
                          Z.drawImage(re, 0, 0, w.width, w.height);
                        let le = Z.getImageData(0, 0, w.width, w.height);
                        (b.height = w.height),
                          (b.width = w.width),
                          q(ye(le.data, b));
                      });
                  });
                throw new Error(
                  "Input data provided is not supported - aborted tensor creation"
                );
              }
              if (c !== void 0) return ye(c, b);
              throw new Error(
                "Input data provided is not supported - aborted tensor creation"
              );
            }),
            (Ee = (r, i) => {
              let { width: s, height: u, download: d, dispose: p } = i,
                c = [1, u, s, 4];
              return new st({
                location: "texture",
                type: "float32",
                texture: r,
                dims: c,
                download: d,
                dispose: p
              });
            }),
            (Qe = (r, i) => {
              let { dataType: s, dims: u, download: d, dispose: p } = i;
              return new st({
                location: "gpu-buffer",
                type: s ?? "float32",
                gpuBuffer: r,
                dims: u,
                download: d,
                dispose: p
              });
            }),
            (_e = (r, i, s) =>
              new st({
                location: "cpu-pinned",
                type: r,
                data: i,
                dims: s ?? [i.length]
              }));
        }),
        oe,
        xe,
        Y,
        ge,
        qe = m(() => {
          (oe = new Map([
            ["float32", Float32Array],
            ["uint8", Uint8Array],
            ["int8", Int8Array],
            ["uint16", Uint16Array],
            ["int16", Int16Array],
            ["int32", Int32Array],
            ["bool", Uint8Array],
            ["float64", Float64Array],
            ["uint32", Uint32Array],
            ["int4", Uint8Array],
            ["uint4", Uint8Array]
          ])),
            (xe = new Map([
              [Float32Array, "float32"],
              [Uint8Array, "uint8"],
              [Int8Array, "int8"],
              [Uint16Array, "uint16"],
              [Int16Array, "int16"],
              [Int32Array, "int32"],
              [Float64Array, "float64"],
              [Uint32Array, "uint32"]
            ])),
            (Y = !1),
            (ge = () => {
              if (!Y) {
                Y = !0;
                let r = typeof BigInt64Array < "u" && BigInt64Array.from,
                  i = typeof BigUint64Array < "u" && BigUint64Array.from,
                  s = typeof Float16Array < "u" && Float16Array.from;
                r &&
                  (oe.set("int64", BigInt64Array),
                  xe.set(BigInt64Array, "int64")),
                  i &&
                    (oe.set("uint64", BigUint64Array),
                    xe.set(BigUint64Array, "uint64")),
                  s
                    ? (oe.set("float16", Float16Array),
                      xe.set(Float16Array, "float16"))
                    : oe.set("float16", Uint16Array);
              }
            });
        }),
        Be,
        Ne,
        We = m(() => {
          pt(),
            (Be = (r) => {
              let i = 1;
              for (let s = 0; s < r.length; s++) {
                let u = r[s];
                if (typeof u != "number" || !Number.isSafeInteger(u))
                  throw new TypeError(
                    `dims[${s}] must be an integer, got: ${u}`
                  );
                if (u < 0)
                  throw new RangeError(
                    `dims[${s}] must be a non-negative integer, got: ${u}`
                  );
                i *= u;
              }
              return i;
            }),
            (Ne = (r, i) => {
              switch (r.location) {
                case "cpu":
                  return new st(r.type, r.data, i);
                case "cpu-pinned":
                  return new st({
                    location: "cpu-pinned",
                    data: r.data,
                    type: r.type,
                    dims: i
                  });
                case "texture":
                  return new st({
                    location: "texture",
                    texture: r.texture,
                    type: r.type,
                    dims: i
                  });
                case "gpu-buffer":
                  return new st({
                    location: "gpu-buffer",
                    gpuBuffer: r.gpuBuffer,
                    type: r.type,
                    dims: i
                  });
                default:
                  throw new Error(
                    `tensorReshape: tensor location ${r.location} is not supported`
                  );
              }
            });
        }),
        st,
        pt = m(() => {
          J(),
            X(),
            qe(),
            We(),
            (st = class {
              constructor(r, i, s) {
                ge();
                let u, d;
                if (typeof r == "object" && "location" in r)
                  switch (
                    ((this.dataLocation = r.location),
                    (u = r.type),
                    (d = r.dims),
                    r.location)
                  ) {
                    case "cpu-pinned": {
                      let c = oe.get(u);
                      if (!c)
                        throw new TypeError(
                          `unsupported type "${u}" to create tensor from pinned buffer`
                        );
                      if (!(r.data instanceof c))
                        throw new TypeError(
                          `buffer should be of type ${c.name}`
                        );
                      this.cpuData = r.data;
                      break;
                    }
                    case "texture": {
                      if (u !== "float32")
                        throw new TypeError(
                          `unsupported type "${u}" to create tensor from texture`
                        );
                      (this.gpuTextureData = r.texture),
                        (this.downloader = r.download),
                        (this.disposer = r.dispose);
                      break;
                    }
                    case "gpu-buffer": {
                      if (
                        u !== "float32" &&
                        u !== "float16" &&
                        u !== "int32" &&
                        u !== "int64" &&
                        u !== "uint32" &&
                        u !== "uint8" &&
                        u !== "bool" &&
                        u !== "uint4" &&
                        u !== "int4"
                      )
                        throw new TypeError(
                          `unsupported type "${u}" to create tensor from gpu buffer`
                        );
                      (this.gpuBufferData = r.gpuBuffer),
                        (this.downloader = r.download),
                        (this.disposer = r.dispose);
                      break;
                    }
                    default:
                      throw new Error(
                        `Tensor constructor: unsupported location '${this.dataLocation}'`
                      );
                  }
                else {
                  let c, b;
                  if (typeof r == "string")
                    if (((u = r), (b = s), r === "string")) {
                      if (!Array.isArray(i))
                        throw new TypeError(
                          "A string tensor's data must be a string array."
                        );
                      c = i;
                    } else {
                      let k = oe.get(r);
                      if (k === void 0)
                        throw new TypeError(`Unsupported tensor type: ${r}.`);
                      if (Array.isArray(i)) {
                        if (
                          (r === "float16" && k === Uint16Array) ||
                          r === "uint4" ||
                          r === "int4"
                        )
                          throw new TypeError(
                            `Creating a ${r} tensor from number array is not supported. Please use ${k.name} as data.`
                          );
                        r === "uint64" || r === "int64"
                          ? (c = k.from(i, BigInt))
                          : (c = k.from(i));
                      } else if (i instanceof k) c = i;
                      else
                        throw new TypeError(
                          `A ${u} tensor's data must be type of ${k}`
                        );
                    }
                  else if (((b = i), Array.isArray(r))) {
                    if (r.length === 0)
                      throw new TypeError(
                        "Tensor type cannot be inferred from an empty array."
                      );
                    let k = typeof r[0];
                    if (k === "string") (u = "string"), (c = r);
                    else if (k === "boolean")
                      (u = "bool"), (c = Uint8Array.from(r));
                    else
                      throw new TypeError(
                        `Invalid element type of data array: ${k}.`
                      );
                  } else {
                    let k = xe.get(r.constructor);
                    if (k === void 0)
                      throw new TypeError(
                        `Unsupported type for tensor data: ${r.constructor}.`
                      );
                    (u = k), (c = r);
                  }
                  if (b === void 0) b = [c.length];
                  else if (!Array.isArray(b))
                    throw new TypeError(
                      "A tensor's dims must be a number array"
                    );
                  (d = b), (this.cpuData = c), (this.dataLocation = "cpu");
                }
                let p = Be(d);
                if (
                  this.cpuData &&
                  p !== this.cpuData.length &&
                  !(
                    (u === "uint4" || u === "int4") &&
                    Math.ceil(p / 2) === this.cpuData.length
                  )
                )
                  throw new Error(
                    `Tensor's size(${p}) does not match data length(${this.cpuData.length}).`
                  );
                (this.type = u), (this.dims = d), (this.size = p);
              }
              static async fromImage(r, i) {
                return L(r, i);
              }
              static fromTexture(r, i) {
                return Ee(r, i);
              }
              static fromGpuBuffer(r, i) {
                return Qe(r, i);
              }
              static fromPinnedBuffer(r, i, s) {
                return _e(r, i, s);
              }
              toDataURL(r) {
                return de(this, r);
              }
              toImageData(r) {
                return Me(this, r);
              }
              get data() {
                if ((this.ensureValid(), !this.cpuData))
                  throw new Error(
                    "The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly."
                  );
                return this.cpuData;
              }
              get location() {
                return this.dataLocation;
              }
              get texture() {
                if ((this.ensureValid(), !this.gpuTextureData))
                  throw new Error("The data is not stored as a WebGL texture.");
                return this.gpuTextureData;
              }
              get gpuBuffer() {
                if ((this.ensureValid(), !this.gpuBufferData))
                  throw new Error("The data is not stored as a WebGPU buffer.");
                return this.gpuBufferData;
              }
              async getData(r) {
                switch ((this.ensureValid(), this.dataLocation)) {
                  case "cpu":
                  case "cpu-pinned":
                    return this.data;
                  case "texture":
                  case "gpu-buffer": {
                    if (!this.downloader)
                      throw new Error(
                        "The current tensor is not created with a specified data downloader."
                      );
                    if (this.isDownloading)
                      throw new Error(
                        "The current tensor is being downloaded."
                      );
                    try {
                      this.isDownloading = !0;
                      let i = await this.downloader();
                      return (
                        (this.downloader = void 0),
                        (this.dataLocation = "cpu"),
                        (this.cpuData = i),
                        r &&
                          this.disposer &&
                          (this.disposer(), (this.disposer = void 0)),
                        i
                      );
                    } finally {
                      this.isDownloading = !1;
                    }
                  }
                  default:
                    throw new Error(
                      `cannot get data from location: ${this.dataLocation}`
                    );
                }
              }
              dispose() {
                if (this.isDownloading)
                  throw new Error("The current tensor is being downloaded.");
                this.disposer && (this.disposer(), (this.disposer = void 0)),
                  (this.cpuData = void 0),
                  (this.gpuTextureData = void 0),
                  (this.gpuBufferData = void 0),
                  (this.downloader = void 0),
                  (this.isDownloading = void 0),
                  (this.dataLocation = "none");
              }
              ensureValid() {
                if (this.dataLocation === "none")
                  throw new Error("The tensor is disposed.");
              }
              reshape(r) {
                if ((this.ensureValid(), this.downloader || this.disposer))
                  throw new Error(
                    "Cannot reshape a tensor that owns GPU resource."
                  );
                return Ne(this, r);
              }
            });
        }),
        Ge,
        Te = m(() => {
          pt(), (Ge = st);
        }),
        je,
        Ye,
        et,
        A,
        Ae = m(() => {
          j(),
            (je = (r, i) => {
              (typeof B.trace > "u" ? !B.wasm.trace : !B.trace) ||
                console.timeStamp(`${r}::ORT::${i}`);
            }),
            (Ye = (r, i) => {
              var d;
              let s =
                  ((d = new Error().stack) == null
                    ? void 0
                    : d.split(/\r\n|\r|\n/g)) || [],
                u = !1;
              for (let p = 0; p < s.length; p++) {
                if (u && !s[p].includes("TRACE_FUNC")) {
                  let c = `FUNC_${r}::${s[p].trim().split(" ")[1]}`;
                  i && (c += `::${i}`), je("CPU", c);
                  return;
                }
                s[p].includes("TRACE_FUNC") && (u = !0);
              }
            }),
            (et = (r) => {
              (typeof B.trace > "u" ? !B.wasm.trace : !B.trace) ||
                Ye("BEGIN", r);
            }),
            (A = (r) => {
              (typeof B.trace > "u" ? !B.wasm.trace : !B.trace) || Ye("END", r);
            });
        }),
        $e,
        ae = m(() => {
          y(),
            Te(),
            Ae(),
            ($e = class yx {
              constructor(i) {
                this.handler = i;
              }
              async run(i, s, u) {
                et();
                let d = {},
                  p = {};
                if (
                  typeof i != "object" ||
                  i === null ||
                  i instanceof Ge ||
                  Array.isArray(i)
                )
                  throw new TypeError(
                    "'feeds' must be an object that use input names as keys and OnnxValue as corresponding values."
                  );
                let c = !0;
                if (typeof s == "object") {
                  if (s === null)
                    throw new TypeError(
                      "Unexpected argument[1]: cannot be null."
                    );
                  if (s instanceof Ge)
                    throw new TypeError("'fetches' cannot be a Tensor");
                  if (Array.isArray(s)) {
                    if (s.length === 0)
                      throw new TypeError(
                        "'fetches' cannot be an empty array."
                      );
                    c = !1;
                    for (let E of s) {
                      if (typeof E != "string")
                        throw new TypeError(
                          "'fetches' must be a string array or an object."
                        );
                      if (this.outputNames.indexOf(E) === -1)
                        throw new RangeError(
                          `'fetches' contains invalid output name: ${E}.`
                        );
                      d[E] = null;
                    }
                    if (typeof u == "object" && u !== null) p = u;
                    else if (typeof u < "u")
                      throw new TypeError("'options' must be an object.");
                  } else {
                    let E = !1,
                      q = Object.getOwnPropertyNames(s);
                    for (let H of this.outputNames)
                      if (q.indexOf(H) !== -1) {
                        let w = s[H];
                        (w === null || w instanceof Ge) &&
                          ((E = !0), (c = !1), (d[H] = w));
                      }
                    if (E) {
                      if (typeof u == "object" && u !== null) p = u;
                      else if (typeof u < "u")
                        throw new TypeError("'options' must be an object.");
                    } else p = s;
                  }
                } else if (typeof s < "u")
                  throw new TypeError(
                    "Unexpected argument[1]: must be 'fetches' or 'options'."
                  );
                for (let E of this.inputNames)
                  if (typeof i[E] > "u")
                    throw new Error(`input '${E}' is missing in 'feeds'.`);
                if (c) for (let E of this.outputNames) d[E] = null;
                let b = await this.handler.run(i, d, p),
                  k = {};
                for (let E in b)
                  if (Object.hasOwnProperty.call(b, E)) {
                    let q = b[E];
                    q instanceof Ge
                      ? (k[E] = q)
                      : (k[E] = new Ge(q.type, q.data, q.dims));
                  }
                return A(), k;
              }
              async release() {
                return this.handler.dispose();
              }
              static async create(i, s, u, d) {
                et();
                let p,
                  c = {};
                if (typeof i == "string") {
                  if (((p = i), typeof s == "object" && s !== null)) c = s;
                  else if (typeof s < "u")
                    throw new TypeError("'options' must be an object.");
                } else if (i instanceof Uint8Array) {
                  if (((p = i), typeof s == "object" && s !== null)) c = s;
                  else if (typeof s < "u")
                    throw new TypeError("'options' must be an object.");
                } else if (
                  i instanceof ArrayBuffer ||
                  (typeof SharedArrayBuffer < "u" &&
                    i instanceof SharedArrayBuffer)
                ) {
                  let q = i,
                    H = 0,
                    w = i.byteLength;
                  if (typeof s == "object" && s !== null) c = s;
                  else if (typeof s == "number") {
                    if (((H = s), !Number.isSafeInteger(H)))
                      throw new RangeError("'byteOffset' must be an integer.");
                    if (H < 0 || H >= q.byteLength)
                      throw new RangeError(
                        `'byteOffset' is out of range [0, ${q.byteLength}).`
                      );
                    if (((w = i.byteLength - H), typeof u == "number")) {
                      if (((w = u), !Number.isSafeInteger(w)))
                        throw new RangeError(
                          "'byteLength' must be an integer."
                        );
                      if (w <= 0 || H + w > q.byteLength)
                        throw new RangeError(
                          `'byteLength' is out of range (0, ${
                            q.byteLength - H
                          }].`
                        );
                      if (typeof d == "object" && d !== null) c = d;
                      else if (typeof d < "u")
                        throw new TypeError("'options' must be an object.");
                    } else if (typeof u < "u")
                      throw new TypeError("'byteLength' must be a number.");
                  } else if (typeof s < "u")
                    throw new TypeError("'options' must be an object.");
                  p = new Uint8Array(q, H, w);
                } else
                  throw new TypeError(
                    "Unexpected argument[0]: must be 'path' or 'buffer'."
                  );
                let [b, k] = await S(c),
                  E = await b.createInferenceSessionHandler(p, k);
                return A(), new yx(E);
              }
              startProfiling() {
                this.handler.startProfiling();
              }
              endProfiling() {
                this.handler.endProfiling();
              }
              get inputNames() {
                return this.handler.inputNames;
              }
              get outputNames() {
                return this.handler.outputNames;
              }
            });
        }),
        ne,
        ve = m(() => {
          ae(), (ne = $e);
        }),
        R = m(() => {}),
        te = m(() => {}),
        D = m(() => {}),
        ce = m(() => {}),
        ue,
        ke,
        Re = m(() => {
          y(),
            Te(),
            (ue =
              "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files."),
            (ke = class wx {
              constructor(i, s, u) {
                (this.handler = i),
                  (this.hasOptimizerModel = s),
                  (this.hasEvalModel = u);
              }
              get trainingInputNames() {
                return this.handler.inputNames;
              }
              get trainingOutputNames() {
                return this.handler.outputNames;
              }
              get evalInputNames() {
                if (this.hasEvalModel) return this.handler.evalInputNames;
                throw new Error(
                  "This training session has no evalModel loaded."
                );
              }
              get evalOutputNames() {
                if (this.hasEvalModel) return this.handler.evalOutputNames;
                throw new Error(
                  "This training session has no evalModel loaded."
                );
              }
              static async create(i, s) {
                let u = i.evalModel || "",
                  d = i.optimizerModel || "",
                  p = s || {},
                  [c, b] = await S(p);
                if (c.createTrainingSessionHandler) {
                  let k = await c.createTrainingSessionHandler(
                    i.checkpointState,
                    i.trainModel,
                    u,
                    d,
                    b
                  );
                  return new wx(k, !!i.optimizerModel, !!i.evalModel);
                } else throw new Error(ue);
              }
              typeNarrowingForRunStep(i, s, u, d, p) {
                let c = {},
                  b = {};
                if (
                  typeof u != "object" ||
                  u === null ||
                  u instanceof Ge ||
                  Array.isArray(u)
                )
                  throw new TypeError(
                    "'feeds' must be an object that use input names as keys and OnnxValue as corresponding values."
                  );
                let k = !0;
                if (typeof d == "object") {
                  if (d === null)
                    throw new TypeError(
                      "Unexpected argument[1]: cannot be null."
                    );
                  if (d instanceof Ge)
                    throw new TypeError("'fetches' cannot be a Tensor");
                  if (Array.isArray(d)) {
                    if (d.length === 0)
                      throw new TypeError(
                        "'fetches' cannot be an empty array."
                      );
                    k = !1;
                    for (let E of d) {
                      if (typeof E != "string")
                        throw new TypeError(
                          "'fetches' must be a string array or an object."
                        );
                      if (s.indexOf(E) === -1)
                        throw new RangeError(
                          `'fetches' contains invalid output name: ${E}.`
                        );
                      c[E] = null;
                    }
                    if (typeof p == "object" && p !== null) b = p;
                    else if (typeof p < "u")
                      throw new TypeError("'options' must be an object.");
                  } else {
                    let E = !1,
                      q = Object.getOwnPropertyNames(d);
                    for (let H of s)
                      if (q.indexOf(H) !== -1) {
                        let w = d[H];
                        (w === null || w instanceof Ge) &&
                          ((E = !0), (k = !1), (c[H] = w));
                      }
                    if (E) {
                      if (typeof p == "object" && p !== null) b = p;
                      else if (typeof p < "u")
                        throw new TypeError("'options' must be an object.");
                    } else b = d;
                  }
                } else if (typeof d < "u")
                  throw new TypeError(
                    "Unexpected argument[1]: must be 'fetches' or 'options'."
                  );
                for (let E of i)
                  if (typeof u[E] > "u")
                    throw new Error(`input '${E}' is missing in 'feeds'.`);
                if (k) for (let E of s) c[E] = null;
                return [c, b];
              }
              convertHandlerReturnTypeToMapOfTensors(i) {
                let s = {};
                for (let u in i)
                  if (Object.hasOwnProperty.call(i, u)) {
                    let d = i[u];
                    d instanceof Ge
                      ? (s[u] = d)
                      : (s[u] = new Ge(d.type, d.data, d.dims));
                  }
                return s;
              }
              async lazyResetGrad() {
                await this.handler.lazyResetGrad();
              }
              async runTrainStep(i, s, u) {
                let [d, p] = this.typeNarrowingForRunStep(
                    this.trainingInputNames,
                    this.trainingOutputNames,
                    i,
                    s,
                    u
                  ),
                  c = await this.handler.runTrainStep(i, d, p);
                return this.convertHandlerReturnTypeToMapOfTensors(c);
              }
              async runOptimizerStep(i) {
                if (this.hasOptimizerModel)
                  await this.handler.runOptimizerStep(i || {});
                else
                  throw new Error(
                    "This TrainingSession has no OptimizerModel loaded."
                  );
              }
              async runEvalStep(i, s, u) {
                if (this.hasEvalModel) {
                  let [d, p] = this.typeNarrowingForRunStep(
                      this.evalInputNames,
                      this.evalOutputNames,
                      i,
                      s,
                      u
                    ),
                    c = await this.handler.runEvalStep(i, d, p);
                  return this.convertHandlerReturnTypeToMapOfTensors(c);
                } else
                  throw new Error(
                    "This TrainingSession has no EvalModel loaded."
                  );
              }
              async getParametersSize(i = !0) {
                return this.handler.getParametersSize(i);
              }
              async loadParametersBuffer(i, s = !0) {
                let u = await this.getParametersSize(s);
                if (i.length !== 4 * u)
                  throw new Error(
                    "Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check."
                  );
                return this.handler.loadParametersBuffer(i, s);
              }
              async getContiguousParameters(i = !0) {
                return this.handler.getContiguousParameters(i);
              }
              async release() {
                return this.handler.dispose();
              }
            });
        }),
        ht,
        tt = m(() => {
          Re(), (ht = ke);
        }),
        wt = {};
      g(wt, {
        InferenceSession: () => ne,
        TRACE: () => je,
        TRACE_FUNC_BEGIN: () => et,
        TRACE_FUNC_END: () => A,
        Tensor: () => Ge,
        TrainingSession: () => ht,
        env: () => N,
        registerBackend: () => z
      });
      var bt = m(() => {
          x(), se(), ve(), Te(), R(), te(), Ae(), D(), ce(), tt();
        }),
        Ke = m(() => {}),
        fe = {};
      g(fe, { default: () => ot });
      var Ie,
        Ve,
        ot,
        Xe = m(() => {
          var r;
          jy(),
            Tn(),
            ar(),
            (Ie = "ort-wasm-proxy-worker"),
            (Ve = ((r = globalThis.self) == null ? void 0 : r.name) === Ie),
            Ve &&
              (self.onmessage = (i) => {
                let { type: s, in: u } = i.data;
                try {
                  switch (s) {
                    case "init-wasm":
                      Ai(u.wasm).then(
                        () => {
                          Rm(u).then(
                            () => {
                              postMessage({ type: s });
                            },
                            (d) => {
                              postMessage({ type: s, err: d });
                            }
                          );
                        },
                        (d) => {
                          postMessage({ type: s, err: d });
                        }
                      );
                      break;
                    case "init-ep": {
                      let { epName: d, env: p } = u;
                      Nm(p, d).then(
                        () => {
                          postMessage({ type: s });
                        },
                        (c) => {
                          postMessage({ type: s, err: c });
                        }
                      );
                      break;
                    }
                    case "copy-from": {
                      let { buffer: d } = u,
                        p = Kp(d);
                      postMessage({ type: s, out: p });
                      break;
                    }
                    case "create": {
                      let { model: d, options: p } = u;
                      jm(d, p).then(
                        (c) => {
                          postMessage({ type: s, out: c });
                        },
                        (c) => {
                          postMessage({ type: s, err: c });
                        }
                      );
                      break;
                    }
                    case "release":
                      Um(u), postMessage({ type: s });
                      break;
                    case "run": {
                      let {
                        sessionId: d,
                        inputIndices: p,
                        inputs: c,
                        outputIndices: b,
                        options: k
                      } = u;
                      Wm(d, p, c, b, new Array(b.length).fill(null), k).then(
                        (E) => {
                          E.some((q) => q[3] !== "cpu")
                            ? postMessage({
                                type: s,
                                err: "Proxy does not support non-cpu tensor location."
                              })
                            : postMessage(
                                { type: s, out: E },
                                Hm([...c, ...E])
                              );
                        },
                        (E) => {
                          postMessage({ type: s, err: E });
                        }
                      );
                      break;
                    }
                    case "end-profiling":
                      Gm(u), postMessage({ type: s });
                      break;
                    default:
                  }
                } catch (d) {
                  postMessage({ type: s, err: d });
                }
              }),
            (ot = Ve
              ? null
              : (i) => new Worker(i ?? rt, { type: "module", name: Ie }));
        }),
        ft = {};
      g(ft, { default: () => $t });
      var xt,
        vt,
        $t,
        Tt = m(() => {
          var r;
          (vt =
            ((xt = import.meta.url),
            async function (i = {}) {
              function s() {
                return Sr.buffer != _r.buffer && Un(), _r;
              }
              function u() {
                return Sr.buffer != _r.buffer && Un(), zr;
              }
              function d() {
                return Sr.buffer != _r.buffer && Un(), ut;
              }
              function p() {
                return Sr.buffer != _r.buffer && Un(), At;
              }
              function c() {
                return Sr.buffer != _r.buffer && Un(), sr;
              }
              function b() {
                return Sr.buffer != _r.buffer && Un(), Gr;
              }
              function k() {
                return Sr.buffer != _r.buffer && Un(), gn;
              }
              function E() {
                return Sr.buffer != _r.buffer && Un(), Yp;
              }
              var q,
                H,
                w = Object.assign({}, i),
                Z = new Promise((h, F) => {
                  (q = h), (H = F);
                }),
                re = typeof window == "object",
                le = typeof importScripts == "function",
                we = le && self.name == "em-pthread";
              (w.mountExternalData = (h, F) => {
                h.startsWith("./") && (h = h.substring(2)),
                  (w.Fb || (w.Fb = new Map())).set(h, F);
              }),
                (w.unmountExternalData = () => {
                  delete w.Fb;
                });
              var be =
                globalThis.SharedArrayBuffer ??
                new WebAssembly.Memory({ initial: 0, maximum: 0, shared: !0 })
                  .buffer.constructor;
              let me = () => {
                let h =
                    (K, ee, he) =>
                    (...De) => {
                      let ct = lo,
                        yt = ee == null ? void 0 : ee();
                      De = K(...De);
                      let Ft = ee == null ? void 0 : ee();
                      return (
                        yt !== Ft && ((K = Ft), he(yt), (ee = he = null)),
                        lo != ct
                          ? new Promise((Bt, Jt) => {
                              cg = { resolve: Bt, reject: Jt };
                            })
                          : De
                      );
                    },
                  F =
                    (K) =>
                    async (...ee) => {
                      var he;
                      try {
                        if (w.Eb) throw Error("Session already started");
                        let De = (w.Eb = { bc: ee[0], errors: [] }),
                          ct = await K(...ee);
                        if (w.Eb !== De) throw Error("Session mismatch");
                        (he = w.Mb) == null || he.flush();
                        let yt = De.errors;
                        if (0 < yt.length) {
                          let Ft = await Promise.all(yt);
                          if (((Ft = Ft.filter((Bt) => Bt)), 0 < Ft.length))
                            throw Error(
                              Ft.join(`
`)
                            );
                        }
                        return ct;
                      } finally {
                        w.Eb = null;
                      }
                    };
                (w._OrtCreateSession = h(
                  w._OrtCreateSession,
                  () => w._OrtCreateSession,
                  (K) => (w._OrtCreateSession = K)
                )),
                  (w._OrtRun = F(
                    h(
                      w._OrtRun,
                      () => w._OrtRun,
                      (K) => (w._OrtRun = K)
                    )
                  )),
                  (w._OrtRunWithBinding = F(
                    h(
                      w._OrtRunWithBinding,
                      () => w._OrtRunWithBinding,
                      (K) => (w._OrtRunWithBinding = K)
                    )
                  )),
                  (w._OrtBindInput = h(
                    w._OrtBindInput,
                    () => w._OrtBindInput,
                    (K) => (w._OrtBindInput = K)
                  )),
                  (me = void 0);
              };
              w.jsepInit = (h, F) => {
                if ((me == null || me(), h === "webgpu")) {
                  [
                    w.Mb,
                    w.Tb,
                    w.Xb,
                    w.Nb,
                    w.Wb,
                    w.jb,
                    w.Yb,
                    w.$b,
                    w.Ub,
                    w.Vb,
                    w.Zb
                  ] = F;
                  let K = w.Mb;
                  (w.jsepRegisterBuffer = (ee, he, De, ct) =>
                    K.registerBuffer(ee, he, De, ct)),
                    (w.jsepGetBuffer = (ee) => K.getBuffer(ee)),
                    (w.jsepCreateDownloader = (ee, he, De) =>
                      K.createDownloader(ee, he, De)),
                    (w.jsepOnReleaseSession = (ee) => {
                      K.onReleaseSession(ee);
                    }),
                    (w.jsepOnRunStart = (ee) => K.onRunStart(ee));
                }
              };
              var Fe,
                Ce,
                ze = Object.assign({}, w),
                dt = "./this.program",
                lt = (h, F) => {
                  throw F;
                },
                Mt = "";
              (re || le) &&
                (le
                  ? (Mt = self.location.href)
                  : typeof document < "u" &&
                    document.currentScript &&
                    (Mt = document.currentScript.src),
                xt && (Mt = xt),
                (Mt = Mt.startsWith("blob:")
                  ? ""
                  : Mt.substr(
                      0,
                      Mt.replace(/[?#].*/, "").lastIndexOf("/") + 1
                    )),
                le &&
                  (Ce = (h) => {
                    var F = new XMLHttpRequest();
                    return (
                      F.open("GET", h, !1),
                      (F.responseType = "arraybuffer"),
                      F.send(null),
                      new Uint8Array(F.response)
                    );
                  }),
                (Fe = (h, F, K) => {
                  var ee = new XMLHttpRequest();
                  ee.open("GET", h, !0),
                    (ee.responseType = "arraybuffer"),
                    (ee.onload = () => {
                      ee.status == 200 || (ee.status == 0 && ee.response)
                        ? F(ee.response)
                        : K();
                    }),
                    (ee.onerror = K),
                    ee.send(null);
                }));
              var Dt,
                Ut = console.log.bind(console),
                fr = console.error.bind(console),
                br = Ut,
                rr = fr;
              if ((Object.assign(w, ze), (ze = null), we)) {
                let h = function (F) {
                  try {
                    var K = F.data,
                      ee = K.cmd;
                    if (ee === "load") {
                      let he = [];
                      (self.onmessage = (De) => he.push(De)),
                        (self.startWorker = () => {
                          postMessage({ cmd: "loaded" });
                          for (let De of he) h(De);
                          self.onmessage = h;
                        });
                      for (let De of K.handlers)
                        (w[De] && !w[De].proxy) ||
                          ((w[De] = (...ct) => {
                            postMessage({
                              Lb: "callHandler",
                              kc: De,
                              args: ct
                            });
                          }),
                          De == "print" && (br = w[De]),
                          De == "printErr" && (rr = w[De]));
                      (Sr = K.wasmMemory), Un(), Wr(K.wasmModule);
                    } else if (ee === "run") {
                      hg(K.pthread_ptr, 0, 0, 1, 0, 0),
                        ag(K.pthread_ptr),
                        Ux(),
                        fw(),
                        Jr || (uv(), (Jr = !0));
                      try {
                        Vx(K.start_routine, K.arg);
                      } catch (he) {
                        if (he != "unwind") throw he;
                      }
                    } else
                      ee === "cancel"
                        ? Wl() && uh(-1)
                        : K.target !== "setimmediate" &&
                          (ee === "checkMailbox"
                            ? Jr && eh()
                            : ee &&
                              (rr(`worker: received unknown command ${ee}`),
                              rr(K)));
                  } catch (he) {
                    throw (cv(), he);
                  }
                };
                var Wr,
                  Jr = !1;
                (rr = function (...F) {
                  (F = F.join(" ")), console.error(F);
                }),
                  (self.alert = function (...F) {
                    postMessage({ Lb: "alert", text: F.join(" "), mc: Wl() });
                  }),
                  (w.instantiateWasm = (F, K) =>
                    new Promise((ee) => {
                      Wr = (he) => {
                        (he = new WebAssembly.Instance(he, aw())), K(he), ee();
                      };
                    })),
                  (self.onunhandledrejection = (F) => {
                    throw F.reason || F;
                  }),
                  (self.onmessage = h);
              }
              w.wasmBinary && (Dt = w.wasmBinary);
              var Sr,
                Hr,
                tr,
                _r,
                zr,
                ut,
                At,
                sr,
                Gr,
                gn,
                Cn,
                is,
                Yp,
                Ti = !1;
              function Un() {
                var h = Sr.buffer;
                (w.HEAP8 = _r = new Int8Array(h)),
                  (w.HEAP16 = ut = new Int16Array(h)),
                  (w.HEAPU8 = zr = new Uint8Array(h)),
                  (w.HEAPU16 = At = new Uint16Array(h)),
                  (w.HEAP32 = sr = new Int32Array(h)),
                  (w.HEAPU32 = Gr = new Uint32Array(h)),
                  (w.HEAPF32 = gn = new Float32Array(h)),
                  (w.HEAPF64 = Yp = new Float64Array(h)),
                  (w.HEAP64 = Cn = new BigInt64Array(h)),
                  (w.HEAPU64 = is = new BigUint64Array(h));
              }
              if (!we) {
                if (
                  !(
                    (Sr = new WebAssembly.Memory({
                      initial: 256,
                      maximum: 65536,
                      shared: !0
                    })).buffer instanceof be
                  )
                )
                  throw (
                    (rr(
                      "requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"
                    ),
                    Error("bad memory"))
                  );
                Un();
              }
              var Mf = [],
                Vn = [],
                ii = [],
                Oi = 0,
                os = null;
              function Zp() {
                if (--Oi == 0 && os) {
                  var h = os;
                  (os = null), h();
                }
              }
              function jl(h) {
                throw (
                  (rr((h = "Aborted(" + h + ")")),
                  (Ti = !0),
                  (tr = 1),
                  (h = new WebAssembly.RuntimeError(
                    h + ". Build with -sASSERTIONS for more info."
                  )),
                  H(h),
                  h)
                );
              }
              var Qm,
                nw = (h) =>
                  h.startsWith("data:application/octet-stream;base64,"),
                iw = (h) => h.startsWith("file://");
              function ow(h) {
                if (h == Qm && Dt) return new Uint8Array(Dt);
                if (Ce) return Ce(h);
                throw "both async and sync fetching of the wasm failed";
              }
              function sw(h, F, K) {
                return (function (ee) {
                  if (!Dt && (re || le)) {
                    if (typeof fetch == "function" && !iw(ee))
                      return fetch(ee, { credentials: "same-origin" })
                        .then((he) => {
                          if (!he.ok)
                            throw `failed to load wasm binary file at '${ee}'`;
                          return he.arrayBuffer();
                        })
                        .catch(() => ow(ee));
                    if (Fe)
                      return new Promise((he, De) => {
                        Fe(ee, (ct) => he(new Uint8Array(ct)), De);
                      });
                  }
                  return Promise.resolve().then(() => ow(ee));
                })(h)
                  .then((ee) => WebAssembly.instantiate(ee, F))
                  .then(K, (ee) => {
                    rr(`failed to asynchronously prepare wasm: ${ee}`), jl(ee);
                  });
              }
              function aw() {
                return {
                  a: {
                    M: jx,
                    za: Nx,
                    b: Gx,
                    $: gw,
                    z: ww,
                    pa: vw,
                    X: xw,
                    Z: Mw,
                    qa: Tw,
                    na: kw,
                    ga: Sw,
                    ma: Ew,
                    J: Cw,
                    Y: Pw,
                    V: $w,
                    oa: Aw,
                    W: Iw,
                    va: Hx,
                    D: qx,
                    P: Kx,
                    O: Xx,
                    C: Zx,
                    s: Jx,
                    p: eM,
                    E: tM,
                    y: lM,
                    Q: uM,
                    ta: cM,
                    ja: dM,
                    T: fM,
                    aa: pM,
                    F: hM,
                    ia: ag,
                    sa: mM,
                    u: gM,
                    B: wM,
                    o: vM,
                    m: xM,
                    c: og,
                    n: MM,
                    k: SM,
                    Aa: EM,
                    r: CM,
                    g: PM,
                    v: $M,
                    l: AM,
                    f: IM,
                    i: FM,
                    j: zM,
                    h: OM,
                    e: DM,
                    da: LM,
                    ea: BM,
                    fa: RM,
                    ba: Hw,
                    ca: qw,
                    S: NM,
                    d: jM,
                    N: UM,
                    G: VM,
                    K: WM,
                    w: GM,
                    ra: HM,
                    U: qM,
                    t: Qw,
                    x: KM,
                    L: QM,
                    R: XM,
                    ya: YM,
                    xa: ZM,
                    ka: Zw,
                    la: Jw,
                    _: eg,
                    A: ev,
                    I: tv,
                    ha: rv,
                    H: nv,
                    a: Sr,
                    wa: Jm,
                    ua: sv,
                    q: tT
                  }
                };
              }
              var Xm = {
                858916: (h, F, K, ee) => {
                  if (w === void 0 || !w.Fb) return 1;
                  if (
                    ((h = On(h >>> 0)).startsWith("./") && (h = h.substring(2)),
                    !(h = w.Fb.get(h)))
                  )
                    return 2;
                  if (((ee >>>= 0), (F >>>= 0) + (K >>>= 0) > h.byteLength))
                    return 3;
                  try {
                    return u().set(h.subarray(F, F + K), ee >>> 0), 0;
                  } catch {
                    return 4;
                  }
                },
                859417: () => {
                  w.Ub();
                },
                859448: () => {
                  w.Vb();
                },
                859477: () => {
                  w.Zb();
                },
                859502: (h) => w.Tb(h),
                859535: (h) => w.Xb(h),
                859567: (h, F, K) => {
                  w.Nb(h, F, K, !0);
                },
                859606: (h, F, K) => {
                  w.Nb(h, F, K);
                },
                859639: () => typeof wasmOffsetConverter < "u",
                859696: (h) => {
                  w.jb("Abs", h, void 0);
                },
                859747: (h) => {
                  w.jb("Neg", h, void 0);
                },
                859798: (h) => {
                  w.jb("Floor", h, void 0);
                },
                859851: (h) => {
                  w.jb("Ceil", h, void 0);
                },
                859903: (h) => {
                  w.jb("Reciprocal", h, void 0);
                },
                859961: (h) => {
                  w.jb("Sqrt", h, void 0);
                },
                860013: (h) => {
                  w.jb("Exp", h, void 0);
                },
                860064: (h) => {
                  w.jb("Erf", h, void 0);
                },
                860115: (h) => {
                  w.jb("Sigmoid", h, void 0);
                },
                860170: (h, F, K) => {
                  w.jb("HardSigmoid", h, { alpha: F, beta: K });
                },
                860249: (h) => {
                  w.jb("Log", h, void 0);
                },
                860300: (h) => {
                  w.jb("Sin", h, void 0);
                },
                860351: (h) => {
                  w.jb("Cos", h, void 0);
                },
                860402: (h) => {
                  w.jb("Tan", h, void 0);
                },
                860453: (h) => {
                  w.jb("Asin", h, void 0);
                },
                860505: (h) => {
                  w.jb("Acos", h, void 0);
                },
                860557: (h) => {
                  w.jb("Atan", h, void 0);
                },
                860609: (h) => {
                  w.jb("Sinh", h, void 0);
                },
                860661: (h) => {
                  w.jb("Cosh", h, void 0);
                },
                860713: (h) => {
                  w.jb("Asinh", h, void 0);
                },
                860766: (h) => {
                  w.jb("Acosh", h, void 0);
                },
                860819: (h) => {
                  w.jb("Atanh", h, void 0);
                },
                860872: (h) => {
                  w.jb("Tanh", h, void 0);
                },
                860924: (h) => {
                  w.jb("Not", h, void 0);
                },
                860975: (h, F, K) => {
                  w.jb("Clip", h, { min: F, max: K });
                },
                861044: (h) => {
                  w.jb("Clip", h, void 0);
                },
                861096: (h, F) => {
                  w.jb("Elu", h, { alpha: F });
                },
                861154: (h) => {
                  w.jb("Gelu", h, void 0);
                },
                861206: (h) => {
                  w.jb("Relu", h, void 0);
                },
                861258: (h, F) => {
                  w.jb("LeakyRelu", h, { alpha: F });
                },
                861322: (h, F) => {
                  w.jb("ThresholdedRelu", h, { alpha: F });
                },
                861392: (h, F) => {
                  w.jb("Cast", h, { to: F });
                },
                861450: (h) => {
                  w.jb("Add", h, void 0);
                },
                861501: (h) => {
                  w.jb("Sub", h, void 0);
                },
                861552: (h) => {
                  w.jb("Mul", h, void 0);
                },
                861603: (h) => {
                  w.jb("Div", h, void 0);
                },
                861654: (h) => {
                  w.jb("Pow", h, void 0);
                },
                861705: (h) => {
                  w.jb("Equal", h, void 0);
                },
                861758: (h) => {
                  w.jb("Greater", h, void 0);
                },
                861813: (h) => {
                  w.jb("GreaterOrEqual", h, void 0);
                },
                861875: (h) => {
                  w.jb("Less", h, void 0);
                },
                861927: (h) => {
                  w.jb("LessOrEqual", h, void 0);
                },
                861986: (h, F, K, ee, he) => {
                  w.jb("ReduceMean", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                862145: (h, F, K, ee, he) => {
                  w.jb("ReduceMax", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                862303: (h, F, K, ee, he) => {
                  w.jb("ReduceMin", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                862461: (h, F, K, ee, he) => {
                  w.jb("ReduceProd", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                862620: (h, F, K, ee, he) => {
                  w.jb("ReduceSum", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                862778: (h, F, K, ee, he) => {
                  w.jb("ReduceL1", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                862935: (h, F, K, ee, he) => {
                  w.jb("ReduceL2", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                863092: (h, F, K, ee, he) => {
                  w.jb("ReduceLogSum", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                863253: (h, F, K, ee, he) => {
                  w.jb("ReduceSumSquare", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                863417: (h, F, K, ee, he) => {
                  w.jb("ReduceLogSumExp", h, {
                    keepDims: !!F,
                    noopWithEmptyAxes: !!K,
                    axes: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                863581: (h) => {
                  w.jb("Where", h, void 0);
                },
                863634: (h, F, K) => {
                  w.jb("Transpose", h, {
                    perm: F ? Array.from(c().subarray(F >>> 0, K >>> 0)) : []
                  });
                },
                863742: (h, F, K, ee) => {
                  w.jb("DepthToSpace", h, {
                    blocksize: F,
                    mode: On(K),
                    format: ee ? "NHWC" : "NCHW"
                  });
                },
                863875: (h, F, K, ee) => {
                  w.jb("DepthToSpace", h, {
                    blocksize: F,
                    mode: On(K),
                    format: ee ? "NHWC" : "NCHW"
                  });
                },
                864008: (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt,
                  Jt,
                  Ar,
                  Ur,
                  it,
                  Er
                ) => {
                  w.jb("ConvTranspose", h, {
                    format: Ft ? "NHWC" : "NCHW",
                    autoPad: F,
                    dilations: [K],
                    group: ee,
                    kernelShape: [he],
                    pads: [De, ct],
                    strides: [yt],
                    wIsConst: () => !!s()[Bt >>> 0],
                    outputPadding: Jt
                      ? Array.from(c().subarray(Jt >>> 0, Ar >>> 0))
                      : [],
                    outputShape: Ur
                      ? Array.from(c().subarray(Ur >>> 0, it >>> 0))
                      : [],
                    activation: On(Er)
                  });
                },
                864409: (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt,
                  Jt,
                  Ar,
                  Ur,
                  it
                ) => {
                  w.jb("ConvTranspose", h, {
                    format: yt ? "NHWC" : "NCHW",
                    autoPad: F,
                    dilations: Array.from(
                      c().subarray(K >>> 0, (2 + (K >>> 0)) >>> 0)
                    ),
                    group: ee,
                    kernelShape: Array.from(
                      c().subarray(he >>> 0, (2 + (he >>> 0)) >>> 0)
                    ),
                    pads: Array.from(
                      c().subarray(De >>> 0, (4 + (De >>> 0)) >>> 0)
                    ),
                    strides: Array.from(
                      c().subarray(ct >>> 0, (2 + (ct >>> 0)) >>> 0)
                    ),
                    wIsConst: () => !!s()[Ft >>> 0],
                    outputPadding: Bt
                      ? Array.from(c().subarray(Bt >>> 0, Jt >>> 0))
                      : [],
                    outputShape: Ar
                      ? Array.from(c().subarray(Ar >>> 0, Ur >>> 0))
                      : [],
                    activation: On(it)
                  });
                },
                864974: (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt,
                  Jt,
                  Ar,
                  Ur,
                  it,
                  Er
                ) => {
                  w.jb("ConvTranspose", h, {
                    format: Ft ? "NHWC" : "NCHW",
                    autoPad: F,
                    dilations: [K],
                    group: ee,
                    kernelShape: [he],
                    pads: [De, ct],
                    strides: [yt],
                    wIsConst: () => !!s()[Bt >>> 0],
                    outputPadding: Jt
                      ? Array.from(c().subarray(Jt >>> 0, Ar >>> 0))
                      : [],
                    outputShape: Ur
                      ? Array.from(c().subarray(Ur >>> 0, it >>> 0))
                      : [],
                    activation: On(Er)
                  });
                },
                865375: (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt,
                  Jt,
                  Ar,
                  Ur,
                  it
                ) => {
                  w.jb("ConvTranspose", h, {
                    format: yt ? "NHWC" : "NCHW",
                    autoPad: F,
                    dilations: Array.from(
                      c().subarray(K >>> 0, (2 + (K >>> 0)) >>> 0)
                    ),
                    group: ee,
                    kernelShape: Array.from(
                      c().subarray(he >>> 0, (2 + (he >>> 0)) >>> 0)
                    ),
                    pads: Array.from(
                      c().subarray(De >>> 0, (4 + (De >>> 0)) >>> 0)
                    ),
                    strides: Array.from(
                      c().subarray(ct >>> 0, (2 + (ct >>> 0)) >>> 0)
                    ),
                    wIsConst: () => !!s()[Ft >>> 0],
                    outputPadding: Bt
                      ? Array.from(c().subarray(Bt >>> 0, Jt >>> 0))
                      : [],
                    outputShape: Ar
                      ? Array.from(c().subarray(Ar >>> 0, Ur >>> 0))
                      : [],
                    activation: On(it)
                  });
                },
                865940: (h, F) => {
                  w.jb("GlobalAveragePool", h, { format: F ? "NHWC" : "NCHW" });
                },
                866031: (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt,
                  Jt,
                  Ar,
                  Ur,
                  it
                ) => {
                  w.jb("AveragePool", h, {
                    format: it ? "NHWC" : "NCHW",
                    auto_pad: F,
                    ceil_mode: K,
                    count_include_pad: ee,
                    storage_order: he,
                    dilations: De
                      ? Array.from(c().subarray(De >>> 0, ct >>> 0))
                      : [],
                    kernel_shape: yt
                      ? Array.from(c().subarray(yt >>> 0, Ft >>> 0))
                      : [],
                    pads: Bt
                      ? Array.from(c().subarray(Bt >>> 0, Jt >>> 0))
                      : [],
                    strides: Ar
                      ? Array.from(c().subarray(Ar >>> 0, Ur >>> 0))
                      : []
                  });
                },
                866446: (h, F) => {
                  w.jb("GlobalAveragePool", h, { format: F ? "NHWC" : "NCHW" });
                },
                866537: (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt,
                  Jt,
                  Ar,
                  Ur,
                  it
                ) => {
                  w.jb("AveragePool", h, {
                    format: it ? "NHWC" : "NCHW",
                    auto_pad: F,
                    ceil_mode: K,
                    count_include_pad: ee,
                    storage_order: he,
                    dilations: De
                      ? Array.from(c().subarray(De >>> 0, ct >>> 0))
                      : [],
                    kernel_shape: yt
                      ? Array.from(c().subarray(yt >>> 0, Ft >>> 0))
                      : [],
                    pads: Bt
                      ? Array.from(c().subarray(Bt >>> 0, Jt >>> 0))
                      : [],
                    strides: Ar
                      ? Array.from(c().subarray(Ar >>> 0, Ur >>> 0))
                      : []
                  });
                },
                866952: (h, F) => {
                  w.jb("GlobalMaxPool", h, { format: F ? "NHWC" : "NCHW" });
                },
                867039: (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt,
                  Jt,
                  Ar,
                  Ur,
                  it
                ) => {
                  w.jb("MaxPool", h, {
                    format: it ? "NHWC" : "NCHW",
                    auto_pad: F,
                    ceil_mode: K,
                    count_include_pad: ee,
                    storage_order: he,
                    dilations: De
                      ? Array.from(c().subarray(De >>> 0, ct >>> 0))
                      : [],
                    kernel_shape: yt
                      ? Array.from(c().subarray(yt >>> 0, Ft >>> 0))
                      : [],
                    pads: Bt
                      ? Array.from(c().subarray(Bt >>> 0, Jt >>> 0))
                      : [],
                    strides: Ar
                      ? Array.from(c().subarray(Ar >>> 0, Ur >>> 0))
                      : []
                  });
                },
                867450: (h, F) => {
                  w.jb("GlobalMaxPool", h, { format: F ? "NHWC" : "NCHW" });
                },
                867537: (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt,
                  Jt,
                  Ar,
                  Ur,
                  it
                ) => {
                  w.jb("MaxPool", h, {
                    format: it ? "NHWC" : "NCHW",
                    auto_pad: F,
                    ceil_mode: K,
                    count_include_pad: ee,
                    storage_order: he,
                    dilations: De
                      ? Array.from(c().subarray(De >>> 0, ct >>> 0))
                      : [],
                    kernel_shape: yt
                      ? Array.from(c().subarray(yt >>> 0, Ft >>> 0))
                      : [],
                    pads: Bt
                      ? Array.from(c().subarray(Bt >>> 0, Jt >>> 0))
                      : [],
                    strides: Ar
                      ? Array.from(c().subarray(Ar >>> 0, Ur >>> 0))
                      : []
                  });
                },
                867948: (h, F, K, ee, he) => {
                  w.jb("Gemm", h, {
                    alpha: F,
                    beta: K,
                    transA: ee,
                    transB: he
                  });
                },
                868052: (h) => {
                  w.jb("MatMul", h, void 0);
                },
                868106: (h, F, K, ee) => {
                  w.jb("ArgMax", h, {
                    keepDims: !!F,
                    selectLastIndex: !!K,
                    axis: ee
                  });
                },
                868214: (h, F, K, ee) => {
                  w.jb("ArgMin", h, {
                    keepDims: !!F,
                    selectLastIndex: !!K,
                    axis: ee
                  });
                },
                868322: (h, F) => {
                  w.jb("Softmax", h, { axis: F });
                },
                868385: (h, F) => {
                  w.jb("Concat", h, { axis: F });
                },
                868445: (h, F, K, ee, he) => {
                  w.jb("Split", h, {
                    axis: F,
                    numOutputs: K,
                    splitSizes: ee
                      ? Array.from(c().subarray(ee >>> 0, he >>> 0))
                      : []
                  });
                },
                868585: (h) => {
                  w.jb("Expand", h, void 0);
                },
                868639: (h, F) => {
                  w.jb("Gather", h, { axis: Number(F) });
                },
                868710: (h, F) => {
                  w.jb("GatherElements", h, { axis: Number(F) });
                },
                868789: (h, F, K, ee, he, De, ct, yt, Ft, Bt, Jt) => {
                  w.jb("Resize", h, {
                    antialias: F,
                    axes: K ? Array.from(c().subarray(K >>> 0, ee >>> 0)) : [],
                    coordinateTransformMode: On(he),
                    cubicCoeffA: De,
                    excludeOutside: ct,
                    extrapolationValue: yt,
                    keepAspectRatioPolicy: On(Ft),
                    mode: On(Bt),
                    nearestMode: On(Jt)
                  });
                },
                869135: (h, F, K, ee, he, De, ct) => {
                  w.jb("Slice", h, {
                    starts: F ? Array.from(c().subarray(F >>> 0, K >>> 0)) : [],
                    ends: ee
                      ? Array.from(c().subarray(ee >>> 0, he >>> 0))
                      : [],
                    axes: De ? Array.from(c().subarray(De >>> 0, ct >>> 0)) : []
                  });
                },
                869351: (h) => {
                  w.jb("Tile", h, void 0);
                },
                869403: (h, F, K) => {
                  w.jb("InstanceNormalization", h, {
                    epsilon: F,
                    format: K ? "NHWC" : "NCHW"
                  });
                },
                869517: (h, F, K) => {
                  w.jb("InstanceNormalization", h, {
                    epsilon: F,
                    format: K ? "NHWC" : "NCHW"
                  });
                },
                869631: (h) => {
                  w.jb("Range", h, void 0);
                },
                869684: (h, F) => {
                  w.jb("Einsum", h, { equation: On(F) });
                },
                869765: (h, F, K, ee, he) => {
                  w.jb("Pad", h, {
                    mode: F,
                    value: K,
                    pads: ee ? Array.from(c().subarray(ee >>> 0, he >>> 0)) : []
                  });
                },
                869892: (h, F, K, ee, he, De) => {
                  w.jb("BatchNormalization", h, {
                    epsilon: F,
                    momentum: K,
                    spatial: !!he,
                    trainingMode: !!ee,
                    format: De ? "NHWC" : "NCHW"
                  });
                },
                870061: (h, F, K, ee, he, De) => {
                  w.jb("BatchNormalization", h, {
                    epsilon: F,
                    momentum: K,
                    spatial: !!he,
                    trainingMode: !!ee,
                    format: De ? "NHWC" : "NCHW"
                  });
                },
                870230: (h, F, K) => {
                  w.jb("CumSum", h, {
                    exclusive: Number(F),
                    reverse: Number(K)
                  });
                },
                870327: (h, F, K) => {
                  w.jb("DequantizeLinear", h, { axis: F, blockSize: K });
                },
                870417: (h, F, K, ee, he, De, ct, yt, Ft) => {
                  w.jb("Attention", h, {
                    numHeads: F,
                    isUnidirectional: K,
                    maskFilterValue: ee,
                    scale: he,
                    doRotary: De,
                    qkvHiddenSizes: ct
                      ? Array.from(
                          c().subarray(
                            Number(yt) >>> 0,
                            (Number(yt) + ct) >>> 0
                          )
                        )
                      : [],
                    pastPresentShareBuffer: !!Ft
                  });
                },
                870689: (h) => {
                  w.jb("BiasAdd", h, void 0);
                },
                870744: (h) => {
                  w.jb("BiasSplitGelu", h, void 0);
                },
                870805: (h) => {
                  w.jb("FastGelu", h, void 0);
                },
                870861: (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt,
                  Jt,
                  Ar,
                  Ur,
                  it,
                  Er,
                  un
                ) => {
                  w.jb("Conv", h, {
                    format: Ar ? "NHWC" : "NCHW",
                    auto_pad: F,
                    dilations: K
                      ? Array.from(c().subarray(K >>> 0, ee >>> 0))
                      : [],
                    group: he,
                    kernel_shape: De
                      ? Array.from(c().subarray(De >>> 0, ct >>> 0))
                      : [],
                    pads: yt
                      ? Array.from(c().subarray(yt >>> 0, Ft >>> 0))
                      : [],
                    strides: Bt
                      ? Array.from(c().subarray(Bt >>> 0, Jt >>> 0))
                      : [],
                    w_is_const: () => !!s()[Ur >>> 0],
                    activation: On(it),
                    activation_params: Er
                      ? Array.from(k().subarray(Er >>> 0, un >>> 0))
                      : []
                  });
                },
                871357: (h) => {
                  w.jb("Gelu", h, void 0);
                },
                871409: (h, F, K, ee) => {
                  w.jb("GroupQueryAttention", h, {
                    numHeads: F,
                    kvNumHeads: K,
                    scale: ee
                  });
                },
                871522: (h, F, K, ee) => {
                  w.jb("LayerNormalization", h, {
                    axis: F,
                    epsilon: K,
                    simplified: !!ee
                  });
                },
                871633: (h, F, K, ee) => {
                  w.jb("LayerNormalization", h, {
                    axis: F,
                    epsilon: K,
                    simplified: !!ee
                  });
                },
                871744: (h, F, K, ee, he, De) => {
                  w.jb("MatMulNBits", h, {
                    k: F,
                    n: K,
                    accuracyLevel: ee,
                    bits: he,
                    blockSize: De
                  });
                },
                871871: (h, F, K, ee, he, De) => {
                  w.jb("MultiHeadAttention", h, {
                    numHeads: F,
                    isUnidirectional: K,
                    maskFilterValue: ee,
                    scale: he,
                    doRotary: De
                  });
                },
                872030: (h, F) => {
                  w.jb("QuickGelu", h, { alpha: F });
                },
                872094: (h, F, K, ee, he) => {
                  w.jb("RotaryEmbedding", h, {
                    interleaved: !!F,
                    numHeads: K,
                    rotaryEmbeddingDim: ee,
                    scale: he
                  });
                },
                872233: (h, F, K) => {
                  w.jb("SkipLayerNormalization", h, {
                    epsilon: F,
                    simplified: !!K
                  });
                },
                872335: (h, F, K) => {
                  w.jb("SkipLayerNormalization", h, {
                    epsilon: F,
                    simplified: !!K
                  });
                },
                872437: (h, F, K, ee) => {
                  w.jb("GatherBlockQuantized", h, {
                    gatherAxis: F,
                    quantizeAxis: K,
                    blockSize: ee
                  });
                },
                872558: (h) => {
                  w.Yb(h);
                },
                872592: (h, F) => w.$b(h, F, w.Eb.bc, w.Eb.errors)
              };
              function Nx(h, F, K) {
                return jw(async () => {
                  await w.Wb(h, F, K);
                });
              }
              function jx() {
                return typeof wasmOffsetConverter < "u";
              }
              function Ym(h) {
                (this.name = "ExitStatus"),
                  (this.message = `Program terminated with exit(${h})`),
                  (this.status = h);
              }
              var Zm = (h) => {
                  h.terminate(), (h.onmessage = () => {});
                },
                lw = (h) => {
                  ss.length == 0 && (hw(), pw(ss[0]));
                  var F = ss.pop();
                  if (!F) return 6;
                  ea.push(F), (so[h.Ab] = F), (F.Ab = h.Ab);
                  var K = {
                    cmd: "run",
                    start_routine: h.cc,
                    arg: h.Pb,
                    pthread_ptr: h.Ab
                  };
                  return F.postMessage(K, h.ic), 0;
                },
                Js = 0,
                an = (h, F, ...K) => {
                  for (
                    var ee = 2 * K.length,
                      he = _g(),
                      De = gg(8 * ee),
                      ct = De >>> 3,
                      yt = 0;
                    yt < K.length;
                    yt++
                  ) {
                    var Ft = K[yt];
                    typeof Ft == "bigint"
                      ? ((Cn[ct + 2 * yt] = 1n), (Cn[ct + 2 * yt + 1] = Ft))
                      : ((Cn[ct + 2 * yt] = 0n),
                        (E()[(ct + 2 * yt + 1) >>> 0] = Ft));
                  }
                  return (h = dv(h, 0, ee, De, F)), ch(he), h;
                };
              function Jm(h) {
                if (we) return an(0, 1, h);
                if (((tr = h), !(0 < Js))) {
                  for (var F of ea) Zm(F);
                  for (F of ss) Zm(F);
                  (ss = []), (ea = []), (so = []), (Ti = !0);
                }
                lt(h, new Ym(h));
              }
              function uw(h) {
                if (we) return an(1, 0, h);
                eg(h);
              }
              var eg = (h) => {
                  if (((tr = h), we)) throw (uw(h), "unwind");
                  Jm(h);
                },
                ss = [],
                ea = [],
                cw = [],
                so = {},
                dw = (h) => {
                  var F = h.Ab;
                  delete so[F],
                    ss.push(h),
                    ea.splice(ea.indexOf(h), 1),
                    (h.Ab = 0),
                    mg(F);
                };
              function fw() {
                cw.forEach((h) => h());
              }
              var pw = (h) =>
                new Promise((F) => {
                  (h.onmessage = (he) => {
                    var De = (he = he.data).cmd;
                    if (he.targetThread && he.targetThread != Wl()) {
                      var ct = so[he.targetThread];
                      ct
                        ? ct.postMessage(he, he.transferList)
                        : rr(
                            `Internal error! Worker sent a message "${De}" to target pthread ${he.targetThread}, but that thread no longer exists!`
                          );
                    } else
                      De === "checkMailbox"
                        ? eh()
                        : De === "spawnThread"
                        ? lw(he)
                        : De === "cleanupThread"
                        ? dw(so[he.thread])
                        : De === "killThread"
                        ? ((he = he.thread),
                          (De = so[he]),
                          delete so[he],
                          Zm(De),
                          mg(he),
                          ea.splice(ea.indexOf(De), 1),
                          (De.Ab = 0))
                        : De === "cancelThread"
                        ? so[he.thread].postMessage({ cmd: "cancel" })
                        : De === "loaded"
                        ? ((h.loaded = !0), F(h))
                        : De === "alert"
                        ? alert(`Thread ${he.threadId}: ${he.text}`)
                        : he.target === "setimmediate"
                        ? h.postMessage(he)
                        : De === "callHandler"
                        ? w[he.handler](...he.args)
                        : De && rr(`worker sent an unknown command ${De}`);
                  }),
                    (h.onerror = (he) => {
                      throw (
                        (rr(
                          `worker sent an error! ${he.filename}:${he.lineno}: ${he.message}`
                        ),
                        he)
                      );
                    });
                  var K,
                    ee = [];
                  for (K of []) w.hasOwnProperty(K) && ee.push(K);
                  h.postMessage({
                    cmd: "load",
                    handlers: ee,
                    wasmMemory: Sr,
                    wasmModule: Hr
                  });
                });
              function hw() {
                var h = new Worker(new URL(import.meta.url), {
                  type: "module",
                  workerData: "em-pthread",
                  name: "em-pthread"
                });
                ss.push(h);
              }
              var Jp = (h) => {
                  for (; 0 < h.length; ) h.shift()(w);
                },
                Ux = () => {
                  var h = Wl(),
                    F = b()[((h + 52) >>> 2) >>> 0];
                  (h = b()[((h + 56) >>> 2) >>> 0]), pv(F, F - h), ch(F);
                },
                Vx = (h, F) => {
                  (Js = 0), (h = hv(h, F)), 0 < Js ? (tr = h) : uh(h);
                };
              class Wx {
                constructor(F) {
                  this.Ib = F - 24;
                }
              }
              function Gx(h, F, K) {
                var ee = new Wx((h >>>= 0));
                throw (
                  ((F >>>= 0),
                  (K >>>= 0),
                  (b()[((ee.Ib + 16) >>> 2) >>> 0] = 0),
                  (b()[((ee.Ib + 4) >>> 2) >>> 0] = F),
                  (b()[((ee.Ib + 8) >>> 2) >>> 0] = K),
                  h)
                );
              }
              function mw(h, F, K, ee) {
                return we ? an(2, 1, h, F, K, ee) : gw(h, F, K, ee);
              }
              function gw(h, F, K, ee) {
                if (
                  ((h >>>= 0),
                  (F >>>= 0),
                  (K >>>= 0),
                  (ee >>>= 0),
                  be === void 0)
                )
                  return (
                    rr(
                      "Current environment does not support SharedArrayBuffer, pthreads are not available!"
                    ),
                    6
                  );
                var he = [];
                return we && he.length === 0
                  ? mw(h, F, K, ee)
                  : ((h = { cc: K, Ab: h, Pb: ee, ic: he }),
                    we
                      ? ((h.Lb = "spawnThread"), postMessage(h, he), 0)
                      : lw(h));
              }
              var _w =
                  typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0,
                yw = (h, F, K) => {
                  var ee = (F >>>= 0) + K;
                  for (K = F; h[K] && !(K >= ee); ) ++K;
                  if (16 < K - F && h.buffer && _w)
                    return _w.decode(
                      h.buffer instanceof be ? h.slice(F, K) : h.subarray(F, K)
                    );
                  for (ee = ""; F < K; ) {
                    var he = h[F++];
                    if (128 & he) {
                      var De = 63 & h[F++];
                      if ((224 & he) == 192)
                        ee += String.fromCharCode(((31 & he) << 6) | De);
                      else {
                        var ct = 63 & h[F++];
                        65536 >
                        (he =
                          (240 & he) == 224
                            ? ((15 & he) << 12) | (De << 6) | ct
                            : ((7 & he) << 18) |
                              (De << 12) |
                              (ct << 6) |
                              (63 & h[F++]))
                          ? (ee += String.fromCharCode(he))
                          : ((he -= 65536),
                            (ee += String.fromCharCode(
                              55296 | (he >> 10),
                              56320 | (1023 & he)
                            )));
                      }
                    } else ee += String.fromCharCode(he);
                  }
                  return ee;
                },
                On = (h, F) => ((h >>>= 0) ? yw(u(), h, F) : "");
              function ww(h, F, K) {
                return we ? an(3, 1, h, F, K) : 0;
              }
              function vw(h, F) {
                if (we) return an(4, 1, h, F);
              }
              var tg = (h) => {
                  for (var F = 0, K = 0; K < h.length; ++K) {
                    var ee = h.charCodeAt(K);
                    127 >= ee
                      ? F++
                      : 2047 >= ee
                      ? (F += 2)
                      : 55296 <= ee && 57343 >= ee
                      ? ((F += 4), ++K)
                      : (F += 3);
                  }
                  return F;
                },
                bw = (h, F, K, ee) => {
                  if (!(0 < ee)) return 0;
                  var he = (K >>>= 0);
                  ee = K + ee - 1;
                  for (var De = 0; De < h.length; ++De) {
                    var ct = h.charCodeAt(De);
                    if (
                      (55296 <= ct &&
                        57343 >= ct &&
                        (ct =
                          (65536 + ((1023 & ct) << 10)) |
                          (1023 & h.charCodeAt(++De))),
                      127 >= ct)
                    ) {
                      if (K >= ee) break;
                      F[K++ >>> 0] = ct;
                    } else {
                      if (2047 >= ct) {
                        if (K + 1 >= ee) break;
                        F[K++ >>> 0] = 192 | (ct >> 6);
                      } else {
                        if (65535 >= ct) {
                          if (K + 2 >= ee) break;
                          F[K++ >>> 0] = 224 | (ct >> 12);
                        } else {
                          if (K + 3 >= ee) break;
                          (F[K++ >>> 0] = 240 | (ct >> 18)),
                            (F[K++ >>> 0] = 128 | ((ct >> 12) & 63));
                        }
                        F[K++ >>> 0] = 128 | ((ct >> 6) & 63);
                      }
                      F[K++ >>> 0] = 128 | (63 & ct);
                    }
                  }
                  return (F[K >>> 0] = 0), K - he;
                },
                Ul = (h, F, K) => bw(h, u(), F, K);
              function xw(h, F) {
                if (we) return an(5, 1, h, F);
              }
              function Mw(h, F, K) {
                if (we) return an(6, 1, h, F, K);
              }
              function Tw(h, F, K) {
                return we ? an(7, 1, h, F, K) : 0;
              }
              function kw(h, F) {
                if (we) return an(8, 1, h, F);
              }
              function Sw(h, F, K) {
                if (we) return an(9, 1, h, F, K);
              }
              function Ew(h, F, K, ee) {
                if (we) return an(10, 1, h, F, K, ee);
              }
              function Cw(h, F, K, ee) {
                if (we) return an(11, 1, h, F, K, ee);
              }
              function Pw(h, F, K, ee) {
                if (we) return an(12, 1, h, F, K, ee);
              }
              function $w(h) {
                if (we) return an(13, 1, h);
              }
              function Aw(h, F) {
                if (we) return an(14, 1, h, F);
              }
              function Iw(h, F, K) {
                if (we) return an(15, 1, h, F, K);
              }
              var Fw,
                as,
                Hx = () => {
                  jl("");
                },
                ao = (h) => {
                  for (var F = ""; u()[h >>> 0]; ) F += Fw[u()[h++ >>> 0]];
                  return F;
                },
                rg = {},
                ng = {};
              function Co(h, F, K = {}) {
                if (!("argPackAdvance" in F))
                  throw new TypeError(
                    "registerType registeredInstance requires argPackAdvance"
                  );
                return (function (ee, he, De = {}) {
                  var ct = he.name;
                  if (!ee)
                    throw new as(
                      `type "${ct}" must have a positive integer typeid pointer`
                    );
                  if (ng.hasOwnProperty(ee)) {
                    if (De.Rb) return;
                    throw new as(`Cannot register type '${ct}' twice`);
                  }
                  (ng[ee] = he),
                    rg.hasOwnProperty(ee) &&
                      ((he = rg[ee]), delete rg[ee], he.forEach((yt) => yt()));
                })(h, F, K);
              }
              var zw = (h, F, K) => {
                switch (F) {
                  case 1:
                    return K ? (ee) => s()[ee >>> 0] : (ee) => u()[ee >>> 0];
                  case 2:
                    return K
                      ? (ee) => d()[(ee >>> 1) >>> 0]
                      : (ee) => p()[(ee >>> 1) >>> 0];
                  case 4:
                    return K
                      ? (ee) => c()[(ee >>> 2) >>> 0]
                      : (ee) => b()[(ee >>> 2) >>> 0];
                  case 8:
                    return K ? (ee) => Cn[ee >>> 3] : (ee) => is[ee >>> 3];
                  default:
                    throw new TypeError(`invalid integer width (${F}): ${h}`);
                }
              };
              function qx(h, F, K) {
                (K >>>= 0),
                  Co((h >>>= 0), {
                    name: (F = ao(F >>> 0)),
                    fromWireType: (ee) => ee,
                    toWireType: function (ee, he) {
                      if (typeof he != "bigint" && typeof he != "number")
                        throw (
                          ((he =
                            he === null
                              ? "null"
                              : (ee = typeof he) == "object" ||
                                ee === "array" ||
                                ee === "function"
                              ? he.toString()
                              : "" + he),
                          new TypeError(
                            `Cannot convert "${he}" to ${this.name}`
                          ))
                        );
                      return typeof he == "number" && (he = BigInt(he)), he;
                    },
                    argPackAdvance: ls,
                    readValueFromPointer: zw(F, K, F.indexOf("u") == -1),
                    Db: null
                  });
              }
              var ls = 8;
              function Kx(h, F, K, ee) {
                Co((h >>>= 0), {
                  name: (F = ao(F >>> 0)),
                  fromWireType: function (he) {
                    return !!he;
                  },
                  toWireType: function (he, De) {
                    return De ? K : ee;
                  },
                  argPackAdvance: ls,
                  readValueFromPointer: function (he) {
                    return this.fromWireType(u()[he >>> 0]);
                  },
                  Db: null
                });
              }
              var ig = [],
                Po = [];
              function og(h) {
                9 < (h >>>= 0) &&
                  --Po[h + 1] == 0 &&
                  ((Po[h] = void 0), ig.push(h));
              }
              var Di = (h) => {
                  if (!h) throw new as("Cannot use deleted val. handle = " + h);
                  return Po[h];
                },
                Li = (h) => {
                  switch (h) {
                    case void 0:
                      return 2;
                    case null:
                      return 4;
                    case !0:
                      return 6;
                    case !1:
                      return 8;
                    default:
                      let F = ig.pop() || Po.length;
                      return (Po[F] = h), (Po[F + 1] = 1), F;
                  }
                };
              function sg(h) {
                return this.fromWireType(b()[(h >>> 2) >>> 0]);
              }
              var Qx = {
                name: "emscripten::val",
                fromWireType: (h) => {
                  var F = Di(h);
                  return og(h), F;
                },
                toWireType: (h, F) => Li(F),
                argPackAdvance: ls,
                readValueFromPointer: sg,
                Db: null
              };
              function Xx(h) {
                return Co(h >>> 0, Qx);
              }
              var Yx = (h, F) => {
                switch (F) {
                  case 4:
                    return function (K) {
                      return this.fromWireType(k()[(K >>> 2) >>> 0]);
                    };
                  case 8:
                    return function (K) {
                      return this.fromWireType(E()[(K >>> 3) >>> 0]);
                    };
                  default:
                    throw new TypeError(`invalid float width (${F}): ${h}`);
                }
              };
              function Zx(h, F, K) {
                (K >>>= 0),
                  Co((h >>>= 0), {
                    name: (F = ao(F >>> 0)),
                    fromWireType: (ee) => ee,
                    toWireType: (ee, he) => he,
                    argPackAdvance: ls,
                    readValueFromPointer: Yx(F, K),
                    Db: null
                  });
              }
              function Jx(h, F, K, ee, he) {
                if (
                  ((h >>>= 0),
                  (K >>>= 0),
                  (F = ao(F >>> 0)),
                  he === -1 && (he = 4294967295),
                  (he = (yt) => yt),
                  ee === 0)
                ) {
                  var De = 32 - 8 * K;
                  he = (yt) => (yt << De) >>> De;
                }
                var ct = F.includes("unsigned")
                  ? function (yt, Ft) {
                      return Ft >>> 0;
                    }
                  : function (yt, Ft) {
                      return Ft;
                    };
                Co(h, {
                  name: F,
                  fromWireType: he,
                  toWireType: ct,
                  argPackAdvance: ls,
                  readValueFromPointer: zw(F, K, ee !== 0),
                  Db: null
                });
              }
              function eM(h, F, K) {
                function ee(De) {
                  var ct = b()[(De >>> 2) >>> 0];
                  return (
                    (De = b()[((De + 4) >>> 2) >>> 0]),
                    new he(s().buffer, De, ct)
                  );
                }
                var he = [
                  Int8Array,
                  Uint8Array,
                  Int16Array,
                  Uint16Array,
                  Int32Array,
                  Uint32Array,
                  Float32Array,
                  Float64Array,
                  BigInt64Array,
                  BigUint64Array
                ][F];
                Co(
                  (h >>>= 0),
                  {
                    name: (K = ao(K >>> 0)),
                    fromWireType: ee,
                    argPackAdvance: ls,
                    readValueFromPointer: ee
                  },
                  { Rb: !0 }
                );
              }
              function tM(h, F) {
                h >>>= 0;
                var K = (F = ao(F >>> 0)) === "std::string";
                Co(h, {
                  name: F,
                  fromWireType: function (ee) {
                    var he = b()[(ee >>> 2) >>> 0],
                      De = ee + 4;
                    if (K)
                      for (var ct = De, yt = 0; yt <= he; ++yt) {
                        var Ft = De + yt;
                        if (yt == he || u()[Ft >>> 0] == 0) {
                          if (((ct = On(ct, Ft - ct)), Bt === void 0))
                            var Bt = ct;
                          else (Bt += "\0"), (Bt += ct);
                          ct = Ft + 1;
                        }
                      }
                    else {
                      for (Bt = Array(he), yt = 0; yt < he; ++yt)
                        Bt[yt] = String.fromCharCode(u()[(De + yt) >>> 0]);
                      Bt = Bt.join("");
                    }
                    return uo(ee), Bt;
                  },
                  toWireType: function (ee, he) {
                    he instanceof ArrayBuffer && (he = new Uint8Array(he));
                    var De = typeof he == "string";
                    if (
                      !(
                        De ||
                        he instanceof Uint8Array ||
                        he instanceof Uint8ClampedArray ||
                        he instanceof Int8Array
                      )
                    )
                      throw new as("Cannot pass non-string to std::string");
                    var ct = K && De ? tg(he) : he.length,
                      yt = lh(4 + ct + 1),
                      Ft = yt + 4;
                    if (((b()[(yt >>> 2) >>> 0] = ct), K && De))
                      Ul(he, Ft, ct + 1);
                    else if (De)
                      for (De = 0; De < ct; ++De) {
                        var Bt = he.charCodeAt(De);
                        if (255 < Bt)
                          throw (
                            (uo(Ft),
                            new as(
                              "String has UTF-16 code units that do not fit in 8 bits"
                            ))
                          );
                        u()[(Ft + De) >>> 0] = Bt;
                      }
                    else
                      for (De = 0; De < ct; ++De) u()[(Ft + De) >>> 0] = he[De];
                    return ee !== null && ee.push(uo, yt), yt;
                  },
                  argPackAdvance: ls,
                  readValueFromPointer: sg,
                  Db(ee) {
                    uo(ee);
                  }
                });
              }
              var Ow =
                  typeof TextDecoder < "u"
                    ? new TextDecoder("utf-16le")
                    : void 0,
                rM = (h, F) => {
                  for (
                    var K = h >> 1, ee = K + F / 2;
                    !(K >= ee) && p()[K >>> 0];

                  )
                    ++K;
                  if (32 < (K <<= 1) - h && Ow)
                    return Ow.decode(u().slice(h, K));
                  for (K = "", ee = 0; !(ee >= F / 2); ++ee) {
                    var he = d()[((h + 2 * ee) >>> 1) >>> 0];
                    if (he == 0) break;
                    K += String.fromCharCode(he);
                  }
                  return K;
                },
                nM = (h, F, K) => {
                  if ((K ?? (K = 2147483647), 2 > K)) return 0;
                  var ee = F;
                  K = (K -= 2) < 2 * h.length ? K / 2 : h.length;
                  for (var he = 0; he < K; ++he) {
                    var De = h.charCodeAt(he);
                    (d()[(F >>> 1) >>> 0] = De), (F += 2);
                  }
                  return (d()[(F >>> 1) >>> 0] = 0), F - ee;
                },
                iM = (h) => 2 * h.length,
                oM = (h, F) => {
                  for (var K = 0, ee = ""; !(K >= F / 4); ) {
                    var he = c()[((h + 4 * K) >>> 2) >>> 0];
                    if (he == 0) break;
                    ++K,
                      65536 <= he
                        ? ((he -= 65536),
                          (ee += String.fromCharCode(
                            55296 | (he >> 10),
                            56320 | (1023 & he)
                          )))
                        : (ee += String.fromCharCode(he));
                  }
                  return ee;
                },
                sM = (h, F, K) => {
                  if (((F >>>= 0), K ?? (K = 2147483647), 4 > K)) return 0;
                  var ee = F;
                  K = ee + K - 4;
                  for (var he = 0; he < h.length; ++he) {
                    var De = h.charCodeAt(he);
                    if (
                      (55296 <= De &&
                        57343 >= De &&
                        (De =
                          (65536 + ((1023 & De) << 10)) |
                          (1023 & h.charCodeAt(++he))),
                      (c()[(F >>> 2) >>> 0] = De),
                      (F += 4) + 4 > K)
                    )
                      break;
                  }
                  return (c()[(F >>> 2) >>> 0] = 0), F - ee;
                },
                aM = (h) => {
                  for (var F = 0, K = 0; K < h.length; ++K) {
                    var ee = h.charCodeAt(K);
                    55296 <= ee && 57343 >= ee && ++K, (F += 4);
                  }
                  return F;
                };
              function lM(h, F, K) {
                if (((h >>>= 0), (F >>>= 0), (K = ao((K >>>= 0))), F === 2))
                  var ee = rM,
                    he = nM,
                    De = iM,
                    ct = (yt) => p()[(yt >>> 1) >>> 0];
                else
                  F === 4 &&
                    ((ee = oM),
                    (he = sM),
                    (De = aM),
                    (ct = (yt) => b()[(yt >>> 2) >>> 0]));
                Co(h, {
                  name: K,
                  fromWireType: (yt) => {
                    for (
                      var Ft, Bt = b()[(yt >>> 2) >>> 0], Jt = yt + 4, Ar = 0;
                      Ar <= Bt;
                      ++Ar
                    ) {
                      var Ur = yt + 4 + Ar * F;
                      (Ar != Bt && ct(Ur) != 0) ||
                        ((Jt = ee(Jt, Ur - Jt)),
                        Ft === void 0 ? (Ft = Jt) : ((Ft += "\0"), (Ft += Jt)),
                        (Jt = Ur + F));
                    }
                    return uo(yt), Ft;
                  },
                  toWireType: (yt, Ft) => {
                    if (typeof Ft != "string")
                      throw new as(
                        `Cannot pass non-string to C++ string type ${K}`
                      );
                    var Bt = De(Ft),
                      Jt = lh(4 + Bt + F);
                    return (
                      (b()[(Jt >>> 2) >>> 0] = Bt / F),
                      he(Ft, Jt + 4, Bt + F),
                      yt !== null && yt.push(uo, Jt),
                      Jt
                    );
                  },
                  argPackAdvance: ls,
                  readValueFromPointer: sg,
                  Db(yt) {
                    uo(yt);
                  }
                });
              }
              function uM(h, F) {
                Co((h >>>= 0), {
                  Sb: !0,
                  name: (F = ao(F >>> 0)),
                  argPackAdvance: 0,
                  fromWireType: () => {},
                  toWireType: () => {}
                });
              }
              var cM = () => 1;
              function dM(h) {
                hg(h >>> 0, !le, 1, !re, 131072, !1), fw();
              }
              var Dw = (h) => {
                if (!Ti)
                  try {
                    if ((h(), !(0 < Js)))
                      try {
                        we ? uh(tr) : eg(tr);
                      } catch (F) {
                        F instanceof Ym || F == "unwind" || lt(1, F);
                      }
                  } catch (F) {
                    F instanceof Ym || F == "unwind" || lt(1, F);
                  }
              };
              function ag(h) {
                (h >>>= 0),
                  typeof Atomics.jc == "function" &&
                    (Atomics.jc(c(), h >>> 2, h).value.then(eh),
                    (h += 128),
                    Atomics.store(c(), h >>> 2, 1));
              }
              var eh = () => {
                var h = Wl();
                h && (ag(h), Dw(fv));
              };
              function fM(h, F) {
                (h >>>= 0) == F >>> 0
                  ? setTimeout(eh)
                  : we
                  ? postMessage({ targetThread: h, cmd: "checkMailbox" })
                  : (h = so[h]) && h.postMessage({ cmd: "checkMailbox" });
              }
              var lg = [];
              function pM(h, F, K, ee, he) {
                for (
                  F >>>= 0,
                    ee /= 2,
                    lg.length = ee,
                    K = (he >>> 0) >>> 3,
                    he = 0;
                  he < ee;
                  he++
                )
                  lg[he] = Cn[K + 2 * he]
                    ? Cn[K + 2 * he + 1]
                    : E()[(K + 2 * he + 1) >>> 0];
                return (F ? Xm[F] : rT[h])(...lg);
              }
              function hM(h) {
                (h >>>= 0),
                  we
                    ? postMessage({ cmd: "cleanupThread", thread: h })
                    : dw(so[h]);
              }
              function mM(h) {}
              var ug = (h, F) => {
                  var K = ng[h];
                  if (K === void 0)
                    throw (
                      ((h = lv(h)),
                      (K = ao(h)),
                      uo(h),
                      new as(`${F} has unknown type ${K}`))
                    );
                  return K;
                },
                Lw = (h, F, K) => {
                  var ee = [];
                  return (
                    (h = h.toWireType(ee, K)),
                    ee.length && (b()[(F >>> 2) >>> 0] = Li(ee)),
                    h
                  );
                };
              function gM(h, F, K) {
                return (
                  (F >>>= 0),
                  (K >>>= 0),
                  (h = Di(h >>> 0)),
                  (F = ug(F, "emval::as")),
                  Lw(F, K, h)
                );
              }
              var th = (h) => {
                  try {
                    h();
                  } catch (F) {
                    jl(F);
                  }
                },
                us = 0,
                lo = null,
                Bw = 0,
                rh = [],
                Rw = {},
                Nw = {},
                _M = 0,
                cg = null,
                yM = [];
              function jw(h) {
                return (function (F) {
                  if (!Ti) {
                    if (us === 0) {
                      var K = !1,
                        ee = !1;
                      F((he = 0) => {
                        if (!Ti && ((Bw = he), (K = !0), ee)) {
                          (us = 2),
                            th(() => _v(lo)),
                            typeof Browser < "u" &&
                              Browser.Jb.Qb &&
                              Browser.Jb.resume(),
                            (he = !1);
                          try {
                            var De = (function () {
                              var Ft = c()[((lo + 8) >>> 2) >>> 0];
                              return (Ft = Xt[Nw[Ft]]), --Js, Ft();
                            })();
                          } catch (Ft) {
                            (De = Ft), (he = !0);
                          }
                          var ct = !1;
                          if (!lo) {
                            var yt = cg;
                            yt &&
                              ((cg = null),
                              (he ? yt.reject : yt.resolve)(De),
                              (ct = !0));
                          }
                          if (he && !ct) throw De;
                        }
                      }),
                        (ee = !0),
                        K ||
                          ((us = 1),
                          (lo = (function () {
                            var he = lh(65548),
                              De = he + 12;
                            (b()[(he >>> 2) >>> 0] = De),
                              (b()[((he + 4) >>> 2) >>> 0] = De + 65536),
                              (De = rh[0]);
                            var ct = Rw[De];
                            return (
                              ct === void 0 &&
                                ((ct = _M++), (Rw[De] = ct), (Nw[ct] = De)),
                              (De = ct),
                              (c()[((he + 8) >>> 2) >>> 0] = De),
                              he
                            );
                          })()),
                          typeof Browser < "u" &&
                            Browser.Jb.Qb &&
                            Browser.Jb.pause(),
                          th(() => mv(lo)));
                    } else
                      us === 2
                        ? ((us = 0),
                          th(yv),
                          uo(lo),
                          (lo = null),
                          yM.forEach(Dw))
                        : jl(`invalid state: ${us}`);
                    return Bw;
                  }
                })((F) => {
                  h().then(F);
                });
              }
              function wM(h) {
                return (h >>>= 0), jw(() => (h = Di(h)).then(Li));
              }
              var nh = [];
              function vM(h, F, K, ee) {
                return (
                  (K >>>= 0),
                  (ee >>>= 0),
                  (h = nh[h >>> 0])(null, (F = Di(F >>> 0)), K, ee)
                );
              }
              var bM = {},
                ih = (h) => {
                  var F = bM[h];
                  return F === void 0 ? ao(h) : F;
                };
              function xM(h, F, K, ee, he) {
                return (
                  (K >>>= 0),
                  (ee >>>= 0),
                  (he >>>= 0),
                  (h = nh[h >>> 0])((F = Di(F >>> 0)), F[(K = ih(K))], ee, he)
                );
              }
              var Uw = () =>
                typeof globalThis == "object"
                  ? globalThis
                  : Function("return this")();
              function MM(h) {
                return (h >>>= 0) == 0 ? Li(Uw()) : ((h = ih(h)), Li(Uw()[h]));
              }
              var TM = (h) => {
                  var F = nh.length;
                  return nh.push(h), F;
                },
                kM = (h, F) => {
                  for (var K = Array(h), ee = 0; ee < h; ++ee)
                    K[ee] = ug(
                      b()[((F + 4 * ee) >>> 2) >>> 0],
                      "parameter " + ee
                    );
                  return K;
                },
                Vw = (h, F) => Object.defineProperty(F, "name", { value: h });
              function SM(h, F, K) {
                var ee = (F = kM(h, F >>> 0)).shift();
                h--;
                var he = `return function (obj, func, destructorsRef, args) {
`,
                  De = 0,
                  ct = [];
                K === 0 && ct.push("obj");
                for (var yt = ["retType"], Ft = [ee], Bt = 0; Bt < h; ++Bt)
                  ct.push("arg" + Bt),
                    yt.push("argType" + Bt),
                    Ft.push(F[Bt]),
                    (he += `  var arg${Bt} = argType${Bt}.readValueFromPointer(args${
                      De ? "+" + De : ""
                    });
`),
                    (De += F[Bt].argPackAdvance);
                return (
                  (he += `  var rv = ${
                    K === 1 ? "new func" : "func.call"
                  }(${ct.join(", ")});
`),
                  ee.Sb ||
                    (yt.push("emval_returnValue"),
                    Ft.push(Lw),
                    (he += `  return emval_returnValue(retType, destructorsRef, rv);
`)),
                  yt.push(
                    he +
                      `};
`
                  ),
                  (h = (function (Jt) {
                    var Ar = Function;
                    if (!(Ar instanceof Function))
                      throw new TypeError(
                        `new_ called with constructor type ${typeof Ar} which is not a function`
                      );
                    var Ur = Vw(
                      Ar.name || "unknownFunctionName",
                      function () {}
                    );
                    return (
                      (Ur.prototype = Ar.prototype),
                      (Ur = new Ur()),
                      (Jt = Ar.apply(Ur, Jt)) instanceof Object ? Jt : Ur
                    );
                  })(yt)(...Ft)),
                  (K = `methodCaller<(${F.map((Jt) => Jt.name).join(
                    ", "
                  )}) => ${ee.name}>`),
                  TM(Vw(K, h))
                );
              }
              function EM(h) {
                return (h = ih(h >>> 0)), Li(w[h]);
              }
              function CM(h, F) {
                return (F >>>= 0), (h = Di(h >>> 0)), (F = Di(F)), Li(h[F]);
              }
              function PM(h) {
                9 < (h >>>= 0) && (Po[h + 1] += 1);
              }
              function $M() {
                return Li([]);
              }
              function AM(h) {
                h = Di(h >>> 0);
                for (var F = Array(h.length), K = 0; K < h.length; K++)
                  F[K] = h[K];
                return Li(F);
              }
              function IM(h) {
                return Li(ih(h >>> 0));
              }
              function FM() {
                return Li({});
              }
              function zM(h) {
                for (var F = Di((h >>>= 0)); F.length; ) {
                  var K = F.pop();
                  F.pop()(K);
                }
                og(h);
              }
              function OM(h, F, K) {
                (F >>>= 0),
                  (K >>>= 0),
                  (h = Di(h >>> 0)),
                  (F = Di(F)),
                  (K = Di(K)),
                  (h[F] = K);
              }
              function DM(h, F) {
                return (
                  (F >>>= 0),
                  (h = (h = ug(
                    h >>> 0,
                    "_emval_take_value"
                  )).readValueFromPointer(F)),
                  Li(h)
                );
              }
              function LM(h, F) {
                (h =
                  -9007199254740992 > h || 9007199254740992 < h
                    ? NaN
                    : Number(h)),
                  (F >>>= 0),
                  (h = new Date(1e3 * h)),
                  (c()[(F >>> 2) >>> 0] = h.getUTCSeconds()),
                  (c()[((F + 4) >>> 2) >>> 0] = h.getUTCMinutes()),
                  (c()[((F + 8) >>> 2) >>> 0] = h.getUTCHours()),
                  (c()[((F + 12) >>> 2) >>> 0] = h.getUTCDate()),
                  (c()[((F + 16) >>> 2) >>> 0] = h.getUTCMonth()),
                  (c()[((F + 20) >>> 2) >>> 0] = h.getUTCFullYear() - 1900),
                  (c()[((F + 24) >>> 2) >>> 0] = h.getUTCDay()),
                  (h =
                    ((h.getTime() -
                      Date.UTC(h.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) /
                      864e5) |
                    0),
                  (c()[((F + 28) >>> 2) >>> 0] = h);
              }
              var Vl = (h) => h % 4 == 0 && (h % 100 != 0 || h % 400 == 0),
                Ww = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],
                Gw = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
              function BM(h, F) {
                (h =
                  -9007199254740992 > h || 9007199254740992 < h
                    ? NaN
                    : Number(h)),
                  (F >>>= 0),
                  (h = new Date(1e3 * h)),
                  (c()[(F >>> 2) >>> 0] = h.getSeconds()),
                  (c()[((F + 4) >>> 2) >>> 0] = h.getMinutes()),
                  (c()[((F + 8) >>> 2) >>> 0] = h.getHours()),
                  (c()[((F + 12) >>> 2) >>> 0] = h.getDate()),
                  (c()[((F + 16) >>> 2) >>> 0] = h.getMonth()),
                  (c()[((F + 20) >>> 2) >>> 0] = h.getFullYear() - 1900),
                  (c()[((F + 24) >>> 2) >>> 0] = h.getDay());
                var K =
                  ((Vl(h.getFullYear()) ? Ww : Gw)[h.getMonth()] +
                    h.getDate() -
                    1) |
                  0;
                (c()[((F + 28) >>> 2) >>> 0] = K),
                  (c()[((F + 36) >>> 2) >>> 0] = -60 * h.getTimezoneOffset()),
                  (K = new Date(h.getFullYear(), 6, 1).getTimezoneOffset());
                var ee = new Date(h.getFullYear(), 0, 1).getTimezoneOffset();
                (h = 0 | (K != ee && h.getTimezoneOffset() == Math.min(ee, K))),
                  (c()[((F + 32) >>> 2) >>> 0] = h);
              }
              function RM(h) {
                h >>>= 0;
                var F = new Date(
                    c()[((h + 20) >>> 2) >>> 0] + 1900,
                    c()[((h + 16) >>> 2) >>> 0],
                    c()[((h + 12) >>> 2) >>> 0],
                    c()[((h + 8) >>> 2) >>> 0],
                    c()[((h + 4) >>> 2) >>> 0],
                    c()[(h >>> 2) >>> 0],
                    0
                  ),
                  K = c()[((h + 32) >>> 2) >>> 0],
                  ee = F.getTimezoneOffset(),
                  he = new Date(F.getFullYear(), 6, 1).getTimezoneOffset(),
                  De = new Date(F.getFullYear(), 0, 1).getTimezoneOffset(),
                  ct = Math.min(De, he);
                return (
                  0 > K
                    ? (c()[((h + 32) >>> 2) >>> 0] = +(he != De && ct == ee))
                    : 0 < K != (ct == ee) &&
                      ((he = Math.max(De, he)),
                      F.setTime(F.getTime() + 6e4 * ((0 < K ? ct : he) - ee))),
                  (c()[((h + 24) >>> 2) >>> 0] = F.getDay()),
                  (K =
                    ((Vl(F.getFullYear()) ? Ww : Gw)[F.getMonth()] +
                      F.getDate() -
                      1) |
                    0),
                  (c()[((h + 28) >>> 2) >>> 0] = K),
                  (c()[(h >>> 2) >>> 0] = F.getSeconds()),
                  (c()[((h + 4) >>> 2) >>> 0] = F.getMinutes()),
                  (c()[((h + 8) >>> 2) >>> 0] = F.getHours()),
                  (c()[((h + 12) >>> 2) >>> 0] = F.getDate()),
                  (c()[((h + 16) >>> 2) >>> 0] = F.getMonth()),
                  (c()[((h + 20) >>> 2) >>> 0] = F.getYear()),
                  (h = F.getTime()),
                  BigInt(isNaN(h) ? -1 : h / 1e3)
                );
              }
              function Hw(h, F, K, ee, he, De, ct) {
                return we ? an(16, 1, h, F, K, ee, he, De, ct) : -52;
              }
              function qw(h, F, K, ee, he, De) {
                if (we) return an(17, 1, h, F, K, ee, he, De);
              }
              function NM(h, F, K, ee) {
                (h >>>= 0), (F >>>= 0), (K >>>= 0), (ee >>>= 0);
                var he = new Date().getFullYear(),
                  De = new Date(he, 0, 1),
                  ct = new Date(he, 6, 1);
                he = De.getTimezoneOffset();
                var yt = ct.getTimezoneOffset(),
                  Ft = Math.max(he, yt);
                (b()[(h >>> 2) >>> 0] = 60 * Ft),
                  (c()[(F >>> 2) >>> 0] = +(he != yt)),
                  (De = (h = (Bt) =>
                    Bt.toLocaleTimeString(void 0, {
                      hour12: !1,
                      timeZoneName: "short"
                    }).split(" ")[1])(De)),
                  (ct = h(ct)),
                  yt < he
                    ? (Ul(De, K, 17), Ul(ct, ee, 17))
                    : (Ul(De, ee, 17), Ul(ct, K, 17));
              }
              var dg = [],
                Kw = (h, F) => {
                  dg.length = 0;
                  for (var K; (K = u()[h++ >>> 0]); ) {
                    var ee = K != 105;
                    (F += (ee &= K != 112) && F % 8 ? 4 : 0),
                      dg.push(
                        K == 112
                          ? b()[(F >>> 2) >>> 0]
                          : K == 106
                          ? Cn[F >>> 3]
                          : K == 105
                          ? c()[(F >>> 2) >>> 0]
                          : E()[(F >>> 3) >>> 0]
                      ),
                      (F += ee ? 8 : 4);
                  }
                  return dg;
                };
              function jM(h, F, K) {
                return (h >>>= 0), (F = Kw(F >>> 0, K >>> 0)), Xm[h](...F);
              }
              function UM(h, F, K) {
                return (h >>>= 0), (F = Kw(F >>> 0, K >>> 0)), Xm[h](...F);
              }
              var VM = () => {},
                WM = () => Date.now();
              function GM(h, F) {
                return rr(On(h >>> 0, F >>> 0));
              }
              var Qw,
                HM = () => {
                  throw ((Js += 1), "unwind");
                };
              function qM() {
                return 4294901760;
              }
              Qw = () => performance.timeOrigin + performance.now();
              var KM = () => navigator.hardwareConcurrency;
              function QM() {
                return (
                  jl(
                    "Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"
                  ),
                  0
                );
              }
              function XM(h) {
                h >>>= 0;
                var F = u().length;
                if (h <= F || 4294901760 < h) return !1;
                for (var K = 1; 4 >= K; K *= 2) {
                  var ee = F * (1 + 0.2 / K);
                  ee = Math.min(ee, h + 100663296);
                  var he = Math;
                  ee = Math.max(h, ee);
                  e: {
                    he =
                      (he.min.call(
                        he,
                        4294901760,
                        ee + ((65536 - (ee % 65536)) % 65536)
                      ) -
                        Sr.buffer.byteLength +
                        65535) /
                      65536;
                    try {
                      Sr.grow(he), Un();
                      var De = 1;
                      break e;
                    } catch {}
                    De = void 0;
                  }
                  if (De) return !0;
                }
                return !1;
              }
              var oh = () => (
                  jl(
                    "Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"
                  ),
                  0
                ),
                Tf = {},
                Xw = (h) => {
                  h.forEach((F) => {
                    oh();
                  });
                };
              function YM() {
                var h = Error().stack.toString().split(`
`);
                return (
                  h[0] == "Error" && h.shift(),
                  Xw(h),
                  (Tf.Ob = oh()),
                  (Tf.ac = h),
                  Tf.Ob
                );
              }
              function ZM(h, F, K) {
                if (((h >>>= 0), (F >>>= 0), Tf.Ob == h)) var ee = Tf.ac;
                else
                  (ee = Error().stack.toString().split(`
`))[0] == "Error" && ee.shift(),
                    Xw(ee);
                for (var he = 3; ee[he] && oh() != h; ) ++he;
                for (h = 0; h < K && ee[h + he]; ++h)
                  c()[((F + 4 * h) >>> 2) >>> 0] = oh();
                return h;
              }
              var fg,
                pg = {},
                Yw = () => {
                  if (!fg) {
                    var h,
                      F = {
                        USER: "web_user",
                        LOGNAME: "web_user",
                        PATH: "/",
                        PWD: "/",
                        HOME: "/home/web_user",
                        LANG:
                          (
                            (typeof navigator == "object" &&
                              navigator.languages &&
                              navigator.languages[0]) ||
                            "C"
                          ).replace("-", "_") + ".UTF-8",
                        _: dt
                      };
                    for (h in pg)
                      pg[h] === void 0 ? delete F[h] : (F[h] = pg[h]);
                    var K = [];
                    for (h in F) K.push(`${h}=${F[h]}`);
                    fg = K;
                  }
                  return fg;
                };
              function Zw(h, F) {
                if (we) return an(18, 1, h, F);
                (h >>>= 0), (F >>>= 0);
                var K = 0;
                return (
                  Yw().forEach((ee, he) => {
                    var De = F + K;
                    for (
                      he = b()[((h + 4 * he) >>> 2) >>> 0] = De, De = 0;
                      De < ee.length;
                      ++De
                    )
                      s()[he++ >>> 0] = ee.charCodeAt(De);
                    (s()[he >>> 0] = 0), (K += ee.length + 1);
                  }),
                  0
                );
              }
              function Jw(h, F) {
                if (we) return an(19, 1, h, F);
                (h >>>= 0), (F >>>= 0);
                var K = Yw();
                b()[(h >>> 2) >>> 0] = K.length;
                var ee = 0;
                return (
                  K.forEach((he) => (ee += he.length + 1)),
                  (b()[(F >>> 2) >>> 0] = ee),
                  0
                );
              }
              function ev(h) {
                return we ? an(20, 1, h) : 52;
              }
              function tv(h, F, K, ee) {
                return we ? an(21, 1, h, F, K, ee) : 52;
              }
              function rv(h, F, K, ee) {
                return we ? an(22, 1, h, F, K, ee) : 70;
              }
              var JM = [null, [], []];
              function nv(h, F, K, ee) {
                if (we) return an(23, 1, h, F, K, ee);
                (F >>>= 0), (K >>>= 0), (ee >>>= 0);
                for (var he = 0, De = 0; De < K; De++) {
                  var ct = b()[(F >>> 2) >>> 0],
                    yt = b()[((F + 4) >>> 2) >>> 0];
                  F += 8;
                  for (var Ft = 0; Ft < yt; Ft++) {
                    var Bt = u()[(ct + Ft) >>> 0],
                      Jt = JM[h];
                    Bt === 0 || Bt === 10
                      ? ((h === 1 ? br : rr)(yw(Jt, 0)), (Jt.length = 0))
                      : Jt.push(Bt);
                  }
                  he += yt;
                }
                return (b()[(ee >>> 2) >>> 0] = he), 0;
              }
              var iv = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                ov = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                eT = (h, F) => {
                  s().set(h, F >>> 0);
                };
              function sv(h, F, K, ee) {
                function he(it, Er, un) {
                  for (
                    it = typeof it == "number" ? it.toString() : it || "";
                    it.length < Er;

                  )
                    it = un[0] + it;
                  return it;
                }
                function De(it, Er) {
                  return he(it, Er, "0");
                }
                function ct(it, Er) {
                  function un(vv) {
                    return 0 > vv ? -1 : 0 < vv ? 1 : 0;
                  }
                  var ta;
                  return (
                    (ta = un(it.getFullYear() - Er.getFullYear())) === 0 &&
                      (ta = un(it.getMonth() - Er.getMonth())) === 0 &&
                      (ta = un(it.getDate() - Er.getDate())),
                    ta
                  );
                }
                function yt(it) {
                  switch (it.getDay()) {
                    case 0:
                      return new Date(it.getFullYear() - 1, 11, 29);
                    case 1:
                      return it;
                    case 2:
                      return new Date(it.getFullYear(), 0, 3);
                    case 3:
                      return new Date(it.getFullYear(), 0, 2);
                    case 4:
                      return new Date(it.getFullYear(), 0, 1);
                    case 5:
                      return new Date(it.getFullYear() - 1, 11, 31);
                    case 6:
                      return new Date(it.getFullYear() - 1, 11, 30);
                  }
                }
                function Ft(it) {
                  var Er = it.Bb;
                  for (
                    it = new Date(new Date(it.Cb + 1900, 0, 1).getTime());
                    0 < Er;

                  ) {
                    var un = it.getMonth(),
                      ta = (Vl(it.getFullYear()) ? iv : ov)[un];
                    if (!(Er > ta - it.getDate())) {
                      it.setDate(it.getDate() + Er);
                      break;
                    }
                    (Er -= ta - it.getDate() + 1),
                      it.setDate(1),
                      11 > un
                        ? it.setMonth(un + 1)
                        : (it.setMonth(0),
                          it.setFullYear(it.getFullYear() + 1));
                  }
                  return (
                    (un = new Date(it.getFullYear() + 1, 0, 4)),
                    (Er = yt(new Date(it.getFullYear(), 0, 4))),
                    (un = yt(un)),
                    0 >= ct(Er, it)
                      ? 0 >= ct(un, it)
                        ? it.getFullYear() + 1
                        : it.getFullYear()
                      : it.getFullYear() - 1
                  );
                }
                (h >>>= 0), (F >>>= 0), (K >>>= 0), (ee >>>= 0);
                var Bt = b()[((ee + 40) >>> 2) >>> 0];
                for (var Jt in ((ee = {
                  fc: c()[(ee >>> 2) >>> 0],
                  ec: c()[((ee + 4) >>> 2) >>> 0],
                  Gb: c()[((ee + 8) >>> 2) >>> 0],
                  Kb: c()[((ee + 12) >>> 2) >>> 0],
                  Hb: c()[((ee + 16) >>> 2) >>> 0],
                  Cb: c()[((ee + 20) >>> 2) >>> 0],
                  ub: c()[((ee + 24) >>> 2) >>> 0],
                  Bb: c()[((ee + 28) >>> 2) >>> 0],
                  nc: c()[((ee + 32) >>> 2) >>> 0],
                  dc: c()[((ee + 36) >>> 2) >>> 0],
                  hc: Bt ? On(Bt) : ""
                }),
                (K = On(K)),
                (Bt = {
                  "%c": "%a %b %d %H:%M:%S %Y",
                  "%D": "%m/%d/%y",
                  "%F": "%Y-%m-%d",
                  "%h": "%b",
                  "%r": "%I:%M:%S %p",
                  "%R": "%H:%M",
                  "%T": "%H:%M:%S",
                  "%x": "%m/%d/%y",
                  "%X": "%H:%M:%S",
                  "%Ec": "%c",
                  "%EC": "%C",
                  "%Ex": "%m/%d/%y",
                  "%EX": "%H:%M:%S",
                  "%Ey": "%y",
                  "%EY": "%Y",
                  "%Od": "%d",
                  "%Oe": "%e",
                  "%OH": "%H",
                  "%OI": "%I",
                  "%Om": "%m",
                  "%OM": "%M",
                  "%OS": "%S",
                  "%Ou": "%u",
                  "%OU": "%U",
                  "%OV": "%V",
                  "%Ow": "%w",
                  "%OW": "%W",
                  "%Oy": "%y"
                })))
                  K = K.replace(new RegExp(Jt, "g"), Bt[Jt]);
                var Ar =
                    "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
                      " "
                    ),
                  Ur =
                    "January February March April May June July August September October November December".split(
                      " "
                    );
                for (Jt in ((Bt = {
                  "%a": (it) => Ar[it.ub].substring(0, 3),
                  "%A": (it) => Ar[it.ub],
                  "%b": (it) => Ur[it.Hb].substring(0, 3),
                  "%B": (it) => Ur[it.Hb],
                  "%C": (it) => De(((it.Cb + 1900) / 100) | 0, 2),
                  "%d": (it) => De(it.Kb, 2),
                  "%e": (it) => he(it.Kb, 2, " "),
                  "%g": (it) => Ft(it).toString().substring(2),
                  "%G": Ft,
                  "%H": (it) => De(it.Gb, 2),
                  "%I": (it) => (
                    (it = it.Gb) == 0 ? (it = 12) : 12 < it && (it -= 12),
                    De(it, 2)
                  ),
                  "%j": (it) => {
                    for (
                      var Er = 0, un = 0;
                      un <= it.Hb - 1;
                      Er += (Vl(it.Cb + 1900) ? iv : ov)[un++]
                    );
                    return De(it.Kb + Er, 3);
                  },
                  "%m": (it) => De(it.Hb + 1, 2),
                  "%M": (it) => De(it.ec, 2),
                  "%n": () => `
`,
                  "%p": (it) => (0 <= it.Gb && 12 > it.Gb ? "AM" : "PM"),
                  "%S": (it) => De(it.fc, 2),
                  "%t": () => "	",
                  "%u": (it) => it.ub || 7,
                  "%U": (it) => De(Math.floor((it.Bb + 7 - it.ub) / 7), 2),
                  "%V": (it) => {
                    var Er = Math.floor((it.Bb + 7 - ((it.ub + 6) % 7)) / 7);
                    if ((2 >= (it.ub + 371 - it.Bb - 2) % 7 && Er++, Er))
                      Er == 53 &&
                        ((un = (it.ub + 371 - it.Bb) % 7) == 4 ||
                          (un == 3 && Vl(it.Cb)) ||
                          (Er = 1));
                    else {
                      Er = 52;
                      var un = (it.ub + 7 - it.Bb - 1) % 7;
                      (un == 4 || (un == 5 && Vl((it.Cb % 400) - 1))) && Er++;
                    }
                    return De(Er, 2);
                  },
                  "%w": (it) => it.ub,
                  "%W": (it) =>
                    De(Math.floor((it.Bb + 7 - ((it.ub + 6) % 7)) / 7), 2),
                  "%y": (it) => (it.Cb + 1900).toString().substring(2),
                  "%Y": (it) => it.Cb + 1900,
                  "%z": (it) => {
                    var Er = 0 <= (it = it.dc);
                    return (
                      (it = Math.abs(it) / 60),
                      (Er ? "+" : "-") +
                        ("0000" + ((it / 60) * 100 + (it % 60))).slice(-4)
                    );
                  },
                  "%Z": (it) => it.hc,
                  "%%": () => "%"
                }),
                (K = K.replace(/%%/g, "\0\0")),
                Bt))
                  K.includes(Jt) &&
                    (K = K.replace(new RegExp(Jt, "g"), Bt[Jt](ee)));
                return (
                  (Jt = (function (it) {
                    var Er = Array(tg(it) + 1);
                    return bw(it, Er, 0, Er.length), Er;
                  })((K = K.replace(/\0\0/g, "%")))),
                  Jt.length > F ? 0 : (eT(Jt, h), Jt.length - 1)
                );
              }
              function tT(h, F, K, ee) {
                return sv(h >>> 0, F >>> 0, K >>> 0, ee >>> 0);
              }
              we ||
                (function () {
                  for (var h = w.numThreads - 1; h--; ) hw();
                  Mf.unshift(() => {
                    Oi++,
                      (function (F) {
                        we ? F() : Promise.all(ss.map(pw)).then(F);
                      })(() => Zp());
                  });
                })();
              for (var av = Array(256), sh = 0; 256 > sh; ++sh)
                av[sh] = String.fromCharCode(sh);
              (Fw = av),
                (as = w.BindingError =
                  class extends Error {
                    constructor(h) {
                      super(h), (this.name = "BindingError");
                    }
                  }),
                (w.InternalError = class extends Error {
                  constructor(h) {
                    super(h), (this.name = "InternalError");
                  }
                }),
                Po.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1),
                (w.count_emval_handles = () => Po.length / 2 - 5 - ig.length);
              var rT = [
                  Jm,
                  uw,
                  mw,
                  ww,
                  vw,
                  xw,
                  Mw,
                  Tw,
                  kw,
                  Sw,
                  Ew,
                  Cw,
                  Pw,
                  $w,
                  Aw,
                  Iw,
                  Hw,
                  qw,
                  Zw,
                  Jw,
                  ev,
                  tv,
                  rv,
                  nv
                ],
                Xt = (function () {
                  function h(K, ee) {
                    return (
                      (Xt = K.exports),
                      (Xt = (function () {
                        var he = Xt,
                          De = {};
                        for (let [ct, yt] of Object.entries(he))
                          De[ct] =
                            typeof yt == "function"
                              ? (...Ft) => {
                                  rh.push(ct);
                                  try {
                                    return yt(...Ft);
                                  } finally {
                                    Ti ||
                                      (rh.pop(),
                                      lo &&
                                        us === 1 &&
                                        rh.length === 0 &&
                                        ((us = 0),
                                        (Js += 1),
                                        th(gv),
                                        typeof Fibers < "u" && Fibers.oc()));
                                  }
                                }
                              : yt;
                        return De;
                      })()),
                      (Xt = (function () {
                        var he = Xt,
                          De = (yt) => (Ft) => yt(Ft) >>> 0,
                          ct = (yt) => () => yt() >>> 0;
                        return (
                          ((he = Object.assign({}, he)).Ca = De(he.Ca)),
                          (he.fb = ct(he.fb)),
                          (he.gb = De(he.gb)),
                          (he.emscripten_main_runtime_thread_id = ct(
                            he.emscripten_main_runtime_thread_id
                          )),
                          (he.sb = De(he.sb)),
                          (he.tb = ct(he.tb)),
                          he
                        );
                      })()),
                      cw.push(Xt.ib),
                      Vn.unshift(Xt.Ba),
                      (Hr = ee),
                      Zp(),
                      Xt
                    );
                  }
                  var F = aw();
                  if ((Oi++, w.instantiateWasm))
                    try {
                      return w.instantiateWasm(F, h);
                    } catch (K) {
                      rr(
                        `Module.instantiateWasm callback failed with error: ${K}`
                      ),
                        H(K);
                    }
                  return (
                    Qm ||
                      (Qm = w.locateFile
                        ? nw("ort-wasm-simd-threaded.jsep.wasm")
                          ? "ort-wasm-simd-threaded.jsep.wasm"
                          : w.locateFile
                          ? w.locateFile("ort-wasm-simd-threaded.jsep.wasm", Mt)
                          : Mt + "ort-wasm-simd-threaded.jsep.wasm"
                        : new URL(
                            n(
                              "./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm"
                            ),
                            n.b
                          ).href),
                    (function (K, ee) {
                      var he = Qm;
                      return Dt ||
                        typeof WebAssembly.instantiateStreaming != "function" ||
                        nw(he) ||
                        iw(he) ||
                        typeof fetch != "function"
                        ? sw(he, K, ee)
                        : fetch(he, { credentials: "same-origin" }).then((De) =>
                            WebAssembly.instantiateStreaming(De, K).then(
                              ee,
                              function (ct) {
                                return (
                                  rr(`wasm streaming compile failed: ${ct}`),
                                  rr(
                                    "falling back to ArrayBuffer instantiation"
                                  ),
                                  sw(he, K, ee)
                                );
                              }
                            )
                          );
                    })(F, function (K) {
                      h(K.instance, K.module);
                    }).catch(H),
                    {}
                  );
                })(),
                lv = (h) => (lv = Xt.Ca)(h),
                uv = () => (uv = Xt.Da)();
              (w._OrtInit = (h, F) => (w._OrtInit = Xt.Ea)(h, F)),
                (w._OrtGetLastError = (h, F) =>
                  (w._OrtGetLastError = Xt.Fa)(h, F)),
                (w._OrtCreateSessionOptions = (
                  h,
                  F,
                  K,
                  ee,
                  he,
                  De,
                  ct,
                  yt,
                  Ft,
                  Bt
                ) =>
                  (w._OrtCreateSessionOptions = Xt.Ga)(
                    h,
                    F,
                    K,
                    ee,
                    he,
                    De,
                    ct,
                    yt,
                    Ft,
                    Bt
                  )),
                (w._OrtAppendExecutionProvider = (h, F) =>
                  (w._OrtAppendExecutionProvider = Xt.Ha)(h, F)),
                (w._OrtAddFreeDimensionOverride = (h, F, K) =>
                  (w._OrtAddFreeDimensionOverride = Xt.Ia)(h, F, K)),
                (w._OrtAddSessionConfigEntry = (h, F, K) =>
                  (w._OrtAddSessionConfigEntry = Xt.Ja)(h, F, K)),
                (w._OrtReleaseSessionOptions = (h) =>
                  (w._OrtReleaseSessionOptions = Xt.Ka)(h)),
                (w._OrtCreateSession = (h, F, K) =>
                  (w._OrtCreateSession = Xt.La)(h, F, K)),
                (w._OrtReleaseSession = (h) =>
                  (w._OrtReleaseSession = Xt.Ma)(h)),
                (w._OrtGetInputOutputCount = (h, F, K) =>
                  (w._OrtGetInputOutputCount = Xt.Na)(h, F, K)),
                (w._OrtGetInputName = (h, F) =>
                  (w._OrtGetInputName = Xt.Oa)(h, F)),
                (w._OrtGetOutputName = (h, F) =>
                  (w._OrtGetOutputName = Xt.Pa)(h, F)),
                (w._OrtFree = (h) => (w._OrtFree = Xt.Qa)(h)),
                (w._OrtCreateTensor = (h, F, K, ee, he, De) =>
                  (w._OrtCreateTensor = Xt.Ra)(h, F, K, ee, he, De)),
                (w._OrtGetTensorData = (h, F, K, ee, he) =>
                  (w._OrtGetTensorData = Xt.Sa)(h, F, K, ee, he)),
                (w._OrtReleaseTensor = (h) => (w._OrtReleaseTensor = Xt.Ta)(h)),
                (w._OrtCreateRunOptions = (h, F, K, ee) =>
                  (w._OrtCreateRunOptions = Xt.Ua)(h, F, K, ee)),
                (w._OrtAddRunConfigEntry = (h, F, K) =>
                  (w._OrtAddRunConfigEntry = Xt.Va)(h, F, K)),
                (w._OrtReleaseRunOptions = (h) =>
                  (w._OrtReleaseRunOptions = Xt.Wa)(h)),
                (w._OrtCreateBinding = (h) => (w._OrtCreateBinding = Xt.Xa)(h)),
                (w._OrtBindInput = (h, F, K) =>
                  (w._OrtBindInput = Xt.Ya)(h, F, K)),
                (w._OrtBindOutput = (h, F, K, ee) =>
                  (w._OrtBindOutput = Xt.Za)(h, F, K, ee)),
                (w._OrtClearBoundOutputs = (h) =>
                  (w._OrtClearBoundOutputs = Xt._a)(h)),
                (w._OrtReleaseBinding = (h) =>
                  (w._OrtReleaseBinding = Xt.$a)(h)),
                (w._OrtRunWithBinding = (h, F, K, ee, he) =>
                  (w._OrtRunWithBinding = Xt.ab)(h, F, K, ee, he)),
                (w._OrtRun = (h, F, K, ee, he, De, ct, yt) =>
                  (w._OrtRun = Xt.bb)(h, F, K, ee, he, De, ct, yt)),
                (w._OrtEndProfiling = (h) => (w._OrtEndProfiling = Xt.cb)(h)),
                (w._JsepOutput = (h, F, K) => (w._JsepOutput = Xt.db)(h, F, K)),
                (w._JsepGetNodeName = (h) => (w._JsepGetNodeName = Xt.eb)(h));
              var ah,
                Wl = () => (Wl = Xt.fb)(),
                lh = (w._malloc = (h) => (lh = w._malloc = Xt.gb)(h)),
                uo = (w._free = (h) => (uo = w._free = Xt.hb)(h)),
                hg = (h, F, K, ee, he, De) => (hg = Xt.kb)(h, F, K, ee, he, De),
                cv = () => (cv = Xt.lb)(),
                dv = (h, F, K, ee, he) => (dv = Xt.mb)(h, F, K, ee, he),
                mg = (h) => (mg = Xt.nb)(h),
                uh = (h) => (uh = Xt.ob)(h),
                fv = () => (fv = Xt.pb)(),
                pv = (h, F) => (pv = Xt.qb)(h, F),
                ch = (h) => (ch = Xt.rb)(h),
                gg = (h) => (gg = Xt.sb)(h),
                _g = () => (_g = Xt.tb)(),
                hv = (w.dynCall_ii = (h, F) =>
                  (hv = w.dynCall_ii = Xt.vb)(h, F)),
                mv = (h) => (mv = Xt.wb)(h),
                gv = () => (gv = Xt.xb)(),
                _v = (h) => (_v = Xt.yb)(h),
                yv = () => (yv = Xt.zb)();
              function wv() {
                0 < Oi ||
                  (we
                    ? (q(w), we || Jp(Vn), startWorker(w))
                    : (Jp(Mf),
                      0 < Oi ||
                        ah ||
                        ((ah = !0),
                        (w.calledRun = !0),
                        Ti || (we || Jp(Vn), q(w), we || Jp(ii)))));
              }
              return (
                (w.___start_em_js = 872704),
                (w.___stop_em_js = 872926),
                (w.stackSave = () => _g()),
                (w.stackRestore = (h) => ch(h)),
                (w.stackAlloc = (h) => gg(h)),
                (w.UTF8ToString = On),
                (w.stringToUTF8 = Ul),
                (w.lengthBytesUTF8 = tg),
                (os = function h() {
                  ah || wv(), ah || (os = h);
                }),
                wv(),
                Z
              );
            })),
            ($t = vt),
            ((r = globalThis.self) == null ? void 0 : r.name) ===
              "em-pthread" && vt();
        }),
        rt,
        Nt,
        Rt,
        Kt,
        Gt,
        Wt,
        er,
        nr,
        ar = m(() => {
          var r, i;
          Ke(),
            (rt =
              import.meta.url ??
              (typeof document < "u"
                ? (r = document.currentScript) == null
                  ? void 0
                  : r.src
                : typeof self < "u"
                ? (i = self.location) == null
                  ? void 0
                  : i.href
                : void 0)),
            (Nt = typeof location > "u" ? void 0 : location.origin),
            (Rt = (s, u) => {
              try {
                let d = u ?? rt;
                return (d ? new URL(s, d) : new URL(s)).origin === Nt;
              } catch {
                return !1;
              }
            }),
            (Kt = async (s) => {
              let u = await (
                await fetch(s, { credentials: "same-origin" })
              ).blob();
              return URL.createObjectURL(u);
            }),
            (Gt = (Xe(), v(fe)).default),
            (Wt = async () => {
              if (!rt)
                throw new Error(
                  "Failed to load proxy worker: cannot determine the script source URL."
                );
              if (Rt(rt)) return [void 0, Gt()];
              let s = await Kt(rt);
              return [s, Gt(s)];
            }),
            (er = (Tt(), v(ft)).default),
            (nr = async (s, u, d) => [void 0, er]);
        }),
        Mr,
        mt,
        kt,
        Lt,
        nn,
        yi,
        Ai,
        Qr,
        Tn = m(() => {
          ar(),
            (mt = !1),
            (kt = !1),
            (Lt = !1),
            (nn = () => {
              if (typeof SharedArrayBuffer > "u") return !1;
              try {
                return (
                  typeof MessageChannel < "u" &&
                    new MessageChannel().port1.postMessage(
                      new SharedArrayBuffer(1)
                    ),
                  WebAssembly.validate(
                    new Uint8Array([
                      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1,
                      0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2,
                      0, 26, 11
                    ])
                  )
                );
              } catch {
                return !1;
              }
            }),
            (yi = () => {
              try {
                return WebAssembly.validate(
                  new Uint8Array([
                    0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0,
                    10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11
                  ])
                );
              } catch {
                return !1;
              }
            }),
            (Ai = async (r) => {
              if (mt) return Promise.resolve();
              if (kt)
                throw new Error(
                  "multiple calls to 'initializeWebAssembly()' detected."
                );
              if (Lt)
                throw new Error(
                  "previous call to 'initializeWebAssembly()' failed."
                );
              kt = !0;
              let i = r.initTimeout,
                s = r.numThreads;
              if (!yi())
                throw new Error(
                  "WebAssembly SIMD is not supported in the current environment."
                );
              let u = nn();
              s > 1 &&
                !u &&
                (typeof self < "u" &&
                  !self.crossOriginIsolated &&
                  console.warn(
                    "env.wasm.numThreads is set to " +
                      s +
                      ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
                  ),
                console.warn(
                  "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
                ),
                (r.numThreads = s = 1));
              let d = r.wasmPaths,
                p = typeof d == "string" ? d : void 0,
                c = d == null ? void 0 : d.mjs,
                b = (c == null ? void 0 : c.href) ?? c,
                k = d == null ? void 0 : d.wasm,
                E = (k == null ? void 0 : k.href) ?? k,
                q = r.wasmBinary,
                [H, w] = await nr(b, p, s > 1),
                Z = !1,
                re = [];
              if (
                (i > 0 &&
                  re.push(
                    new Promise((le) => {
                      setTimeout(() => {
                        (Z = !0), le();
                      }, i);
                    })
                  ),
                re.push(
                  new Promise((le, we) => {
                    let be = { numThreads: s };
                    q
                      ? (be.wasmBinary = q)
                      : (E || p) &&
                        (be.locateFile = (me, Fe) => E ?? (p ?? Fe) + me),
                      w(be).then(
                        (me) => {
                          (kt = !1),
                            (mt = !0),
                            (Mr = me),
                            le(),
                            H && URL.revokeObjectURL(H);
                        },
                        (me) => {
                          (kt = !1), (Lt = !0), we(me);
                        }
                      );
                  })
                ),
                await Promise.race(re),
                Z)
              )
                throw new Error(
                  `WebAssembly backend initializing failed due to timeout: ${i}ms`
                );
            }),
            (Qr = () => {
              if (mt && Mr) return Mr;
              throw new Error("WebAssembly is not initialized yet.");
            });
        }),
        Yr,
        wi,
        Nr,
        Wi = m(() => {
          Tn(),
            (Yr = (r, i) => {
              let s = Qr(),
                u = s.lengthBytesUTF8(r) + 1,
                d = s._malloc(u);
              return s.stringToUTF8(r, d, u), i.push(d), d;
            }),
            (wi = (r, i, s, u) => {
              if (typeof r == "object" && r !== null) {
                if (s.has(r)) throw new Error("Circular reference in options");
                s.add(r);
              }
              Object.entries(r).forEach(([d, p]) => {
                let c = i ? i + d : d;
                if (typeof p == "object") wi(p, c + ".", s, u);
                else if (typeof p == "string" || typeof p == "number")
                  u(c, p.toString());
                else if (typeof p == "boolean") u(c, p ? "1" : "0");
                else
                  throw new Error(
                    `Can't handle extra config type: ${typeof p}`
                  );
              });
            }),
            (Nr = (r) => {
              let i = Qr(),
                s = i.stackSave();
              try {
                let u = i.stackAlloc(8);
                i._OrtGetLastError(u, u + 4);
                let d = i.HEAP32[u / 4],
                  p = i.HEAPU32[u / 4 + 1],
                  c = p ? i.UTF8ToString(p) : "";
                throw new Error(`${r} ERROR_CODE: ${d}, ERROR_MESSAGE: ${c}`);
              } finally {
                i.stackRestore(s);
              }
            });
        }),
        Ii,
        $s = m(() => {
          Tn(),
            Wi(),
            (Ii = (r) => {
              let i = Qr(),
                s = 0,
                u = [],
                d = r || {};
              try {
                if ((r == null ? void 0 : r.logSeverityLevel) === void 0)
                  d.logSeverityLevel = 2;
                else if (
                  typeof r.logSeverityLevel != "number" ||
                  !Number.isInteger(r.logSeverityLevel) ||
                  r.logSeverityLevel < 0 ||
                  r.logSeverityLevel > 4
                )
                  throw new Error(
                    `log serverity level is not valid: ${r.logSeverityLevel}`
                  );
                if ((r == null ? void 0 : r.logVerbosityLevel) === void 0)
                  d.logVerbosityLevel = 0;
                else if (
                  typeof r.logVerbosityLevel != "number" ||
                  !Number.isInteger(r.logVerbosityLevel)
                )
                  throw new Error(
                    `log verbosity level is not valid: ${r.logVerbosityLevel}`
                  );
                (r == null ? void 0 : r.terminate) === void 0 &&
                  (d.terminate = !1);
                let p = 0;
                return (
                  (r == null ? void 0 : r.tag) !== void 0 && (p = Yr(r.tag, u)),
                  (s = i._OrtCreateRunOptions(
                    d.logSeverityLevel,
                    d.logVerbosityLevel,
                    !!d.terminate,
                    p
                  )),
                  s === 0 && Nr("Can't create run options."),
                  (r == null ? void 0 : r.extra) !== void 0 &&
                    wi(r.extra, "", new WeakSet(), (c, b) => {
                      let k = Yr(c, u),
                        E = Yr(b, u);
                      i._OrtAddRunConfigEntry(s, k, E) !== 0 &&
                        Nr(`Can't set a run config entry: ${c} - ${b}.`);
                    }),
                  [s, u]
                );
              } catch (p) {
                throw (
                  (s !== 0 && i._OrtReleaseRunOptions(s),
                  u.forEach((c) => i._free(c)),
                  p)
                );
              }
            });
        }),
        Uo,
        Vo,
        Wo,
        Go,
        Gi,
        As = m(() => {
          Tn(),
            Wi(),
            (Uo = (r) => {
              switch (r) {
                case "disabled":
                  return 0;
                case "basic":
                  return 1;
                case "extended":
                  return 2;
                case "all":
                  return 99;
                default:
                  throw new Error(`unsupported graph optimization level: ${r}`);
              }
            }),
            (Vo = (r) => {
              switch (r) {
                case "sequential":
                  return 0;
                case "parallel":
                  return 1;
                default:
                  throw new Error(`unsupported execution mode: ${r}`);
              }
            }),
            (Wo = (r) => {
              r.extra || (r.extra = {}),
                r.extra.session || (r.extra.session = {});
              let i = r.extra.session;
              i.use_ort_model_bytes_directly ||
                (i.use_ort_model_bytes_directly = "1"),
                r.executionProviders &&
                  r.executionProviders.some(
                    (s) => (typeof s == "string" ? s : s.name) === "webgpu"
                  ) &&
                  (r.enableMemPattern = !1);
            }),
            (Go = (r, i, s) => {
              for (let u of i) {
                let d = typeof u == "string" ? u : u.name;
                switch (d) {
                  case "webnn":
                    if (((d = "WEBNN"), typeof u != "string")) {
                      let c = u == null ? void 0 : u.deviceType;
                      if (c) {
                        let b = Yr("deviceType", s),
                          k = Yr(c, s);
                        Qr()._OrtAddSessionConfigEntry(r, b, k) !== 0 &&
                          Nr(
                            `Can't set a session config entry: 'deviceType' - ${c}.`
                          );
                      }
                    }
                    break;
                  case "webgpu":
                    if (((d = "JS"), typeof u != "string")) {
                      let c = u;
                      if (c != null && c.preferredLayout) {
                        if (
                          c.preferredLayout !== "NCHW" &&
                          c.preferredLayout !== "NHWC"
                        )
                          throw new Error(
                            `preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`
                          );
                        let b = Yr("preferredLayout", s),
                          k = Yr(c.preferredLayout, s);
                        Qr()._OrtAddSessionConfigEntry(r, b, k) !== 0 &&
                          Nr(
                            `Can't set a session config entry: 'preferredLayout' - ${c.preferredLayout}.`
                          );
                      }
                    }
                    break;
                  case "wasm":
                  case "cpu":
                    continue;
                  default:
                    throw new Error(`not supported execution provider: ${d}`);
                }
                let p = Yr(d, s);
                Qr()._OrtAppendExecutionProvider(r, p) !== 0 &&
                  Nr(`Can't append execution provider: ${d}.`);
              }
            }),
            (Gi = (r) => {
              let i = Qr(),
                s = 0,
                u = [],
                d = r || {};
              Wo(d);
              try {
                let p = Uo(d.graphOptimizationLevel ?? "all"),
                  c = Vo(d.executionMode ?? "sequential"),
                  b = typeof d.logId == "string" ? Yr(d.logId, u) : 0,
                  k = d.logSeverityLevel ?? 2;
                if (!Number.isInteger(k) || k < 0 || k > 4)
                  throw new Error(`log serverity level is not valid: ${k}`);
                let E = d.logVerbosityLevel ?? 0;
                if (!Number.isInteger(E) || E < 0 || E > 4)
                  throw new Error(`log verbosity level is not valid: ${E}`);
                let q =
                  typeof d.optimizedModelFilePath == "string"
                    ? Yr(d.optimizedModelFilePath, u)
                    : 0;
                if (
                  ((s = i._OrtCreateSessionOptions(
                    p,
                    !!d.enableCpuMemArena,
                    !!d.enableMemPattern,
                    c,
                    !!d.enableProfiling,
                    0,
                    b,
                    k,
                    E,
                    q
                  )),
                  s === 0 && Nr("Can't create session options."),
                  d.executionProviders && Go(s, d.executionProviders, u),
                  d.enableGraphCapture !== void 0)
                ) {
                  if (typeof d.enableGraphCapture != "boolean")
                    throw new Error(
                      `enableGraphCapture must be a boolean value: ${d.enableGraphCapture}`
                    );
                  let H = Yr("enableGraphCapture", u),
                    w = Yr(d.enableGraphCapture.toString(), u);
                  i._OrtAddSessionConfigEntry(s, H, w) !== 0 &&
                    Nr(
                      `Can't set a session config entry: 'enableGraphCapture' - ${d.enableGraphCapture}.`
                    );
                }
                if (d.freeDimensionOverrides)
                  for (let [H, w] of Object.entries(d.freeDimensionOverrides)) {
                    if (typeof H != "string")
                      throw new Error(
                        `free dimension override name must be a string: ${H}`
                      );
                    if (typeof w != "number" || !Number.isInteger(w) || w < 0)
                      throw new Error(
                        `free dimension override value must be a non-negative integer: ${w}`
                      );
                    let Z = Yr(H, u);
                    i._OrtAddFreeDimensionOverride(s, Z, w) !== 0 &&
                      Nr(`Can't set a free dimension override: ${H} - ${w}.`);
                  }
                return (
                  d.extra !== void 0 &&
                    wi(d.extra, "", new WeakSet(), (H, w) => {
                      let Z = Yr(H, u),
                        re = Yr(w, u);
                      i._OrtAddSessionConfigEntry(s, Z, re) !== 0 &&
                        Nr(`Can't set a session config entry: ${H} - ${w}.`);
                    }),
                  [s, u]
                );
              } catch (p) {
                throw (
                  (s !== 0 && i._OrtReleaseSessionOptions(s),
                  u.forEach((c) => i._free(c)),
                  p)
                );
              }
            });
        }),
        _o,
        vi,
        Hi,
        Fi,
        ro,
        yo,
        wo,
        Yt = m(() => {
          (_o = (r) => {
            switch (r) {
              case "int8":
                return 3;
              case "uint8":
                return 2;
              case "bool":
                return 9;
              case "int16":
                return 5;
              case "uint16":
                return 4;
              case "int32":
                return 6;
              case "uint32":
                return 12;
              case "float16":
                return 10;
              case "float32":
                return 1;
              case "float64":
                return 11;
              case "string":
                return 8;
              case "int64":
                return 7;
              case "uint64":
                return 13;
              case "int4":
                return 22;
              case "uint4":
                return 21;
              default:
                throw new Error(`unsupported data type: ${r}`);
            }
          }),
            (vi = (r) => {
              switch (r) {
                case 3:
                  return "int8";
                case 2:
                  return "uint8";
                case 9:
                  return "bool";
                case 5:
                  return "int16";
                case 4:
                  return "uint16";
                case 6:
                  return "int32";
                case 12:
                  return "uint32";
                case 10:
                  return "float16";
                case 1:
                  return "float32";
                case 11:
                  return "float64";
                case 8:
                  return "string";
                case 7:
                  return "int64";
                case 13:
                  return "uint64";
                case 22:
                  return "int4";
                case 21:
                  return "uint4";
                default:
                  throw new Error(`unsupported data type: ${r}`);
              }
            }),
            (Hi = (r, i) => {
              let s = [
                  -1, 4, 1, 1, 2, 2, 4, 8, -1, 1, 2, 8, 4, 8, -1, -1, -1, -1,
                  -1, -1, -1, 0.5, 0.5
                ][r],
                u = typeof i == "number" ? i : i.reduce((d, p) => d * p, 1);
              return s > 0 ? Math.ceil(u * s) : void 0;
            }),
            (Fi = (r) => {
              switch (r) {
                case "float16":
                  return typeof Float16Array < "u" && Float16Array.from
                    ? Float16Array
                    : Uint16Array;
                case "float32":
                  return Float32Array;
                case "uint8":
                  return Uint8Array;
                case "int8":
                  return Int8Array;
                case "uint16":
                  return Uint16Array;
                case "int16":
                  return Int16Array;
                case "int32":
                  return Int32Array;
                case "bool":
                  return Uint8Array;
                case "float64":
                  return Float64Array;
                case "uint32":
                  return Uint32Array;
                case "int64":
                  return BigInt64Array;
                case "uint64":
                  return BigUint64Array;
                default:
                  throw new Error(`unsupported type: ${r}`);
              }
            }),
            (ro = (r) => {
              switch (r) {
                case "verbose":
                  return 0;
                case "info":
                  return 1;
                case "warning":
                  return 2;
                case "error":
                  return 3;
                case "fatal":
                  return 4;
                default:
                  throw new Error(`unsupported logging level: ${r}`);
              }
            }),
            (yo = (r) =>
              r === "float32" ||
              r === "float16" ||
              r === "int32" ||
              r === "int64" ||
              r === "uint32" ||
              r === "uint8" ||
              r === "bool" ||
              r === "uint4" ||
              r === "int4"),
            (wo = (r) => {
              switch (r) {
                case "none":
                  return 0;
                case "cpu":
                  return 1;
                case "cpu-pinned":
                  return 2;
                case "texture":
                  return 3;
                case "gpu-buffer":
                  return 4;
                default:
                  throw new Error(`unsupported data location: ${r}`);
              }
            });
        }),
        no,
        Ho = m(() => {
          Ke(),
            (no = async (r) => {
              if (typeof r == "string") {
                let i = await fetch(r);
                if (!i.ok)
                  throw new Error(`failed to load external data file: ${r}`);
                let s = i.headers.get("Content-Length"),
                  u = s ? parseInt(s, 10) : 0;
                if (u < 1073741824)
                  return new Uint8Array(await i.arrayBuffer());
                {
                  if (!i.body)
                    throw new Error(
                      `failed to load external data file: ${r}, no response body.`
                    );
                  let d = i.body.getReader(),
                    p;
                  try {
                    p = new ArrayBuffer(u);
                  } catch (b) {
                    if (b instanceof RangeError) {
                      let k = Math.ceil(u / 65536);
                      p = new WebAssembly.Memory({ initial: k, maximum: k })
                        .buffer;
                    } else throw b;
                  }
                  let c = 0;
                  for (;;) {
                    let { done: b, value: k } = await d.read();
                    if (b) break;
                    let E = k.byteLength;
                    new Uint8Array(p, c, E).set(k), (c += E);
                  }
                  return new Uint8Array(p, 0, u);
                }
              } else
                return r instanceof Blob
                  ? new Uint8Array(await r.arrayBuffer())
                  : r instanceof Uint8Array
                  ? r
                  : new Uint8Array(r);
            });
        }),
        qo,
        vo,
        Ko,
        Qo,
        bo,
        Xo,
        Kr,
        qn = m(() => {
          Yt(),
            (qo = ["V", "I", "W", "E", "F"]),
            (vo = (r, i) => {
              console.log(`[${qo[r]},${new Date().toISOString()}]${i}`);
            }),
            (bo = (r, i) => {
              (Ko = r), (Qo = i);
            }),
            (Xo = (r, i) => {
              let s = ro(r),
                u = ro(Ko);
              s >= u && vo(s, typeof i == "function" ? i() : i);
            }),
            (Kr = (...r) => {
              Qo && Xo(...r);
            });
        }),
        Ue,
        W = m(() => {
          Yt(), (Ue = (r, i) => new (Fi(i))(r));
        }),
        pe = m(() => {}),
        Pe,
        Oe,
        Le,
        nt,
        Et,
        Pt,
        Ct,
        Ot,
        or,
        Or = m(() => {
          qn(),
            pe(),
            (Pe = new Map([
              [64, 250],
              [128, 200],
              [256, 200],
              [512, 200],
              [2048, 230],
              [4096, 200],
              [8192, 50],
              [16384, 50],
              [32768, 50],
              [65536, 50],
              [131072, 50],
              [262144, 50],
              [524288, 50],
              [1048576, 50],
              [2097152, 30],
              [4194304, 20],
              [8388608, 10],
              [12582912, 10],
              [16777216, 10],
              [26214400, 15],
              [33554432, 22],
              [44236800, 2],
              [58982400, 6],
              [67108864, 6],
              [134217728, 6],
              [167772160, 6]
            ])),
            (Oe = []),
            (Le = (r) => Math.ceil(r / 16) * 16),
            (nt = (r) => {
              for (let i = 0; i < Oe.length; i++) {
                let s = Oe[i];
                if (r <= s) return s;
              }
              return Math.ceil(r / 16) * 16;
            }),
            (Et = 1),
            (Pt = () => Et++),
            (Ct = async (r, i, s, u) => {
              let d = Le(s),
                p = r.device.createBuffer({
                  size: d,
                  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                });
              try {
                let c = r.getCommandEncoder();
                r.endComputePass(),
                  c.copyBufferToBuffer(i, 0, p, 0, d),
                  r.flush(),
                  await p.mapAsync(GPUMapMode.READ);
                let b = p.getMappedRange();
                if (u) {
                  let k = u();
                  return k.set(new Uint8Array(b, 0, s)), k;
                } else return new Uint8Array(b.slice(0, s));
              } finally {
                p.destroy();
              }
            }),
            (Ot = class {
              constructor(r) {
                (this.backend = r),
                  (this.storageCache = new Map()),
                  (this.freeBuffers = new Map()),
                  (this.freeUniformBuffers = new Map()),
                  (this.buffersForUploadingPending = []),
                  (this.buffersPending = []),
                  (this.externalBuffers = new Map()),
                  (this.capturedPendingBuffers = new Map());
                for (let [i] of Pe)
                  Oe.push(i),
                    this.freeBuffers.set(i, []),
                    this.freeUniformBuffers.set(i, []);
              }
              upload(r, i) {
                let s = i.buffer,
                  u = i.byteOffset,
                  d = i.byteLength,
                  p = Le(d),
                  c = this.storageCache.get(r);
                if (!c)
                  throw new Error("gpu data for uploading does not exist");
                if (c.originalSize !== d)
                  throw new Error(
                    `inconsistent data size. gpu data size=${c.originalSize}, data size=${d}`
                  );
                let b = this.backend.device.createBuffer({
                    mappedAtCreation: !0,
                    size: p,
                    usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC
                  }),
                  k = b.getMappedRange();
                new Uint8Array(k).set(new Uint8Array(s, u, d)), b.unmap();
                let E = this.backend.getCommandEncoder();
                this.backend.endComputePass(),
                  E.copyBufferToBuffer(b, 0, c.gpuData.buffer, 0, p),
                  Kr(
                    "verbose",
                    () => `[WebGPU] GpuDataManager.upload(id=${r})`
                  ),
                  this.buffersForUploadingPending.push(b);
              }
              memcpy(r, i) {
                let s = this.storageCache.get(r);
                if (!s)
                  throw new Error("source gpu data for memcpy does not exist");
                let u = this.storageCache.get(i);
                if (!u)
                  throw new Error(
                    "destination gpu data for memcpy does not exist"
                  );
                if (s.originalSize !== u.originalSize)
                  throw new Error(
                    "inconsistent source and destination gpu data size"
                  );
                let d = Le(s.originalSize),
                  p = this.backend.getCommandEncoder();
                this.backend.endComputePass(),
                  p.copyBufferToBuffer(
                    s.gpuData.buffer,
                    0,
                    u.gpuData.buffer,
                    0,
                    d
                  );
              }
              registerExternalBuffer(r, i, s) {
                let u;
                if (s) {
                  if (((u = this.externalBuffers.get(s)), u === void 0))
                    throw new Error("previous buffer is not registered");
                  if (r === s)
                    return (
                      Kr(
                        "verbose",
                        () =>
                          `[WebGPU] GpuDataManager.registerExternalBuffer(size=${i}) => id=${u}, buffer is the same, skip.`
                      ),
                      u
                    );
                  if (
                    this.backend.capturedCommandList.has(
                      this.backend.currentSessionId
                    )
                  )
                    throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
                  this.externalBuffers.delete(s);
                } else u = Pt();
                return (
                  this.storageCache.set(u, {
                    gpuData: { id: u, type: 0, buffer: r },
                    originalSize: i
                  }),
                  this.externalBuffers.set(r, u),
                  Kr(
                    "verbose",
                    () =>
                      `[WebGPU] GpuDataManager.registerExternalBuffer(size=${i}) => id=${u}, registered.`
                  ),
                  u
                );
              }
              unregisterExternalBuffer(r) {
                let i = this.externalBuffers.get(r);
                i !== void 0 &&
                  (this.storageCache.delete(i),
                  this.externalBuffers.delete(r),
                  Kr(
                    "verbose",
                    () =>
                      `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${i}`
                  ));
              }
              create(
                r,
                i = GPUBufferUsage.STORAGE |
                  GPUBufferUsage.COPY_SRC |
                  GPUBufferUsage.COPY_DST
              ) {
                let s = nt(r),
                  u,
                  d = (i & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE,
                  p = (i & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
                if (d || p) {
                  let b = (d ? this.freeBuffers : this.freeUniformBuffers).get(
                    s
                  );
                  b
                    ? b.length > 0
                      ? (u = b.pop())
                      : (u = this.backend.device.createBuffer({
                          size: s,
                          usage: i
                        }))
                    : (u = this.backend.device.createBuffer({
                        size: s,
                        usage: i
                      }));
                } else
                  u = this.backend.device.createBuffer({ size: s, usage: i });
                let c = { id: Pt(), type: 0, buffer: u };
                return (
                  this.storageCache.set(c.id, { gpuData: c, originalSize: r }),
                  Kr(
                    "verbose",
                    () =>
                      `[WebGPU] GpuDataManager.create(size=${r}) => id=${c.id}`
                  ),
                  c
                );
              }
              get(r) {
                var i;
                return (i = this.storageCache.get(r)) == null
                  ? void 0
                  : i.gpuData;
              }
              release(r) {
                let i = this.storageCache.get(r);
                if (!i) throw new Error("releasing data does not exist");
                return (
                  Kr(
                    "verbose",
                    () =>
                      `[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${i.gpuData.id}`
                  ),
                  this.storageCache.delete(r),
                  this.buffersPending.push(i.gpuData.buffer),
                  i.originalSize
                );
              }
              async download(r, i) {
                let s = this.storageCache.get(r);
                if (!s) throw new Error("data does not exist");
                await Ct(this.backend, s.gpuData.buffer, s.originalSize, i);
              }
              refreshPendingBuffers() {
                for (let r of this.buffersForUploadingPending) r.destroy();
                if (
                  ((this.buffersForUploadingPending = []),
                  this.buffersPending.length !== 0)
                )
                  if (this.backend.sessionStatus === "default") {
                    for (let r of this.buffersPending) {
                      let i = Pe.get(r.size);
                      if (
                        (r.usage & GPUBufferUsage.STORAGE) ===
                        GPUBufferUsage.STORAGE
                      ) {
                        let s = this.freeBuffers.get(r.size) || [];
                        i === void 0 || s.length >= i ? r.destroy() : s.push(r);
                      } else if (
                        (r.usage & GPUBufferUsage.UNIFORM) ===
                        GPUBufferUsage.UNIFORM
                      ) {
                        let s = this.freeUniformBuffers.get(r.size) || [];
                        i === void 0 || s.length >= i ? r.destroy() : s.push(r);
                      } else r.destroy();
                    }
                    this.buffersPending = [];
                  } else {
                    let r = this.capturedPendingBuffers.get(
                      this.backend.currentSessionId
                    );
                    r ||
                      ((r = []),
                      this.capturedPendingBuffers.set(
                        this.backend.currentSessionId,
                        r
                      ));
                    for (let i of this.buffersPending) r.push(i);
                    this.buffersPending = [];
                  }
              }
              dispose() {
                this.freeBuffers.forEach((r) => {
                  r.forEach((i) => {
                    i.destroy();
                  });
                }),
                  this.freeUniformBuffers.forEach((r) => {
                    r.forEach((i) => {
                      i.destroy();
                    });
                  }),
                  this.storageCache.forEach((r) => {
                    r.gpuData.buffer.destroy();
                  }),
                  this.capturedPendingBuffers.forEach((r) => {
                    r.forEach((i) => {
                      i.destroy();
                    });
                  }),
                  (this.storageCache = new Map()),
                  (this.freeBuffers = new Map()),
                  (this.freeUniformBuffers = new Map()),
                  (this.capturedPendingBuffers = new Map());
              }
              onReleaseSession(r) {
                let i = this.capturedPendingBuffers.get(r);
                i &&
                  (i.forEach((s) => {
                    s.destroy();
                  }),
                  this.capturedPendingBuffers.delete(r));
              }
            }),
            (or = (...r) => new Ot(...r));
        }),
        ur,
        Qt,
        wr = m(() => {
          (ur = class {
            constructor(r) {
              Object.assign(this, r);
            }
            get cacheKey() {
              return (
                this.key ||
                  (this.key = Object.getOwnPropertyNames(this)
                    .sort()
                    .map((r) => `${this[r]}`)
                    .join(";")),
                this.key
              );
            }
          }),
            (Qt = (r) => new ur(r));
        }),
        An,
        vn,
        Ze,
        ei,
        Cr,
        hn,
        Bn,
        Zt = m(() => {
          (An = class {
            static calcMatMulShape(r, i) {
              return r[1] !== i[0] ? void 0 : [r[0], i[1]];
            }
          }),
            (vn = class {
              static calcShape(r, i, s = !1) {
                let u = r.length,
                  d = i.length;
                if (u === 0) return i;
                if (d === 0) return r;
                let p = Math.max(r.length, i.length),
                  c = new Array(p);
                if (s) {
                  if (u < 2 || d < 2) return;
                  let b = An.calcMatMulShape(
                    [r[u - 2], r[u - 1]],
                    [i[d - 2], i[d - 1]]
                  );
                  if (b === void 0) return;
                  [c[p - 2], c[p - 1]] = b;
                }
                for (let b = s ? 3 : 1; b <= p; b++) {
                  let k = u - b < 0 ? 1 : r[u - b],
                    E = d - b < 0 ? 1 : i[d - b];
                  if (k !== E && k > 1 && E > 1) return;
                  let q = Math.max(k, E);
                  if (k && E) c[p - b] = Math.max(k, E);
                  else {
                    if (q > 1) return;
                    c[p - b] = 0;
                  }
                }
                return c;
              }
              static isValidBroadcast(r, i) {
                let s = r.length,
                  u = i.length;
                if (s > u) return !1;
                for (let d = 1; d <= s; d++)
                  if (r[s - d] !== 1 && r[s - d] !== i[u - d]) return !1;
                return !0;
              }
            }),
            (Ze = class Uh {
              static size(i) {
                return Uh.getSizeFromDimensionRange(i, 0, i.length);
              }
              static convertShape(i, s = 4) {
                let u = i.length;
                if (u === 0) return [];
                let d = new Array(u),
                  p = u - 1;
                for (; p >= 0; ) {
                  if (i[p] % s === 0) {
                    d[p] = i[p] / s;
                    break;
                  }
                  if (s % i[p] !== 0) throw new Error("cannot convert shape");
                  (d[p] = 1), (s /= i[p]), p--;
                }
                for (p--; p >= 0; p--) d[p] = i[p];
                return d;
              }
              static sizeFromDimension(i, s) {
                if (s < 0 || s > i.length)
                  throw new Error(
                    `invalid dimension of ${s} for sizeFromDimension as Tensor has ${i.length} dimensions.`
                  );
                return Uh.getSizeFromDimensionRange(i, s, i.length);
              }
              static sizeToDimension(i, s) {
                if (s < 0 || s > i.length)
                  throw new Error(
                    `invalid dimension of ${s} for sizeToDimension as Tensor has ${i.length} dimensions.`
                  );
                return Uh.getSizeFromDimensionRange(i, 0, s);
              }
              static getSizeFromDimensionRange(i, s, u) {
                let d = 1;
                for (let p = s; p < u; p++) {
                  if (i[p] < 0)
                    throw new Error(
                      "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."
                    );
                  d *= i[p];
                }
                return d;
              }
              static computeStrides(i) {
                let s = i.length;
                if (s === 0) return [];
                if (s === 1) return [1];
                let u = new Array(s);
                (u[s - 1] = 1), (u[s - 2] = i[s - 1]);
                for (let d = s - 3; d >= 0; --d) u[d] = u[d + 1] * i[d + 1];
                return u;
              }
              static normalizeAxis(i, s) {
                if (i < -s && i >= s)
                  throw new Error("unsupported axis for this operation.");
                return i < 0 ? i + s : i;
              }
              static normalizeAxes(i, s) {
                return i.map((u) => this.normalizeAxis(u, s ?? i.length));
              }
              static sortBasedOnPerm(i, s) {
                return s ? s.map((u) => i[u]) : i.slice().reverse();
              }
              static padShape(i, s) {
                let u = i.length;
                return i.map((d, p) => d + s[p] + s[p + u]);
              }
              static areEqual(i, s) {
                return i.length !== s.length
                  ? !1
                  : i.every((u, d) => u === s[d]);
              }
            }),
            (ei = class Bf {
              static adjustPoolAttributes(i, s, u, d, p, c) {
                if (!i && u.length !== s.length - 2)
                  throw new Error(
                    "length of specified kernel shapes should be 2 less than length of input dimensions"
                  );
                if (i)
                  for (let b = 0; b < s.length - 2; b++)
                    b >= u.length ? u.push(s[b + 2]) : (u[b] = s[b + 2]);
                for (let b = 0; b < u.length; b++)
                  if (b < d.length) {
                    if (d[b] < 0)
                      throw new Error(
                        "strides should be greater than or equal to 1"
                      );
                  } else d.push(1);
                for (let b = 0; b < u.length; b++)
                  if (b < p.length) {
                    if (p[b] < 0)
                      throw new Error(
                        "dilations should be greater than or equal to 1"
                      );
                  } else p.push(1);
                for (let b = 0; b < u.length * 2; b++)
                  if (b < c.length) {
                    if (c[b] < 0)
                      throw new Error(
                        "pad should be greater than or equal to 1"
                      );
                  } else c.push(0);
                for (let b = 0; b < u.length; b++) {
                  if (u[b] <= 0)
                    throw new Error("kernel shapes need to be greater than 0");
                  if (c[b] >= u[b] || c[b + u.length] >= u[b])
                    throw new Error("pads should be smaller than kernel");
                }
              }
              static adjustPadsBasedOnAutoPad(i, s, u, d, p, c, b) {
                if (b) {
                  if (p.length !== 2 * (i.length - 2))
                    throw new Error(
                      "length of pads should be twice the length of data dimensions"
                    );
                  if (s.length !== i.length - 2)
                    throw new Error(
                      "length of strides should be the length of data dimensions"
                    );
                  if (d.length !== i.length - 2)
                    throw new Error(
                      "length of kernel shapes should be the length of data dimensions"
                    );
                  for (let k = 0; k < i.length - 2; k++)
                    Bf.adjustPadAndReturnShape(
                      i[k + (c ? 1 : 2)],
                      s[k],
                      u[k],
                      d[k],
                      p,
                      k,
                      k + i.length - 2,
                      b
                    );
                }
              }
              static computePoolOutputShape(i, s, u, d, p, c, b) {
                if (s.length <= 0)
                  throw new Error("input shape must be of size greater than 0");
                let k = [s[0], s[1]];
                return Bf.computeShapeHelper(i, s, k, u, d, p, c, b), k;
              }
              static computeConvOutputShape(i, s, u, d, p, c, b) {
                if (i.length <= 0 || s.length <= 0)
                  throw new Error(
                    "invalid input tensor dims or invalid filter tensor dims"
                  );
                let k = [i[0], s[0]];
                return Bf.computeShapeHelper(!1, i, k, u, d, p, c, b), k;
              }
              static computeShapeHelper(i, s, u, d, p, c, b, k) {
                if (i) for (let E = 0; E < s.length - 2; E++) u.push(1);
                else
                  for (let E = 0; E < s.length - 2; E++)
                    u.push(
                      Bf.adjustPadAndReturnShape(
                        s[E + 2],
                        d[E],
                        p[E],
                        c[E],
                        b,
                        E,
                        E + s.length - 2,
                        k
                      )
                    );
              }
              static adjustPadAndReturnShape(i, s, u, d, p, c, b, k) {
                let E = u * (d - 1) + 1;
                if (k && k !== "NOTSET")
                  switch (k) {
                    case "VALID":
                      return (
                        (p[c] = 0), (p[b] = 0), Math.floor((i - E) / s + 1)
                      );
                    case "SAME_LOWER":
                    case "SAME_UPPER":
                      if (u !== 1)
                        throw new Error(
                          "Dilation not supported for SAME_UPPER or SAME_LOWER"
                        );
                      {
                        let q = ((i + s - 1) / s - 1) * s + d - i;
                        return (
                          (p[c] = Math.floor(
                            k === "SAME_LOWER" ? (q + 1) / 2 : q / 2
                          )),
                          (p[b] = q - p[c]),
                          Math.floor((i + q - d) / s + 1)
                        );
                      }
                    default:
                      throw new Error("Unsupported AutoPad type");
                  }
                else return Math.floor((i + p[c] + p[b] - E) / s + 1);
              }
            }),
            (Cr = class {
              static getShapeOfGemmResult(r, i, s, u, d) {
                if (r.length !== 2 || s.length !== 2)
                  throw new Error("shape need to be of size 2");
                let p, c, b;
                i ? ((p = r[1]), (c = r[0])) : ((p = r[0]), (c = r[1]));
                let k = -1;
                if (
                  (u ? ((b = s[0]), (k = 1)) : ((b = s[1]), (k = 0)),
                  s[k] !== c)
                )
                  throw new Error("dimension mismatch");
                if (p <= 0 || b <= 0 || c <= 0)
                  throw new Error("invalid shape specified");
                if (d && !vn.isValidBroadcast(d, [p, b]))
                  throw new Error("gemm: invalid bias shape for broadcast");
                return [p, b, c];
              }
            }),
            (hn = -34028234663852886e22),
            (Bn = 34028234663852886e22);
        }),
        Kn,
        kn,
        Fr,
        Pr,
        zt,
        $r,
        jr,
        Zr,
        Qn,
        jt,
        Is,
        gt,
        Ht,
        _a,
        ya,
        Mu,
        xo,
        cr = m(() => {
          Yt(),
            Zt(),
            (Kn = 64),
            (kn = (r, i) => {
              if (i === 3)
                throw new Error(
                  "vec3 has same alignment as vec4, use vec4 instead"
                );
              switch (r) {
                case 10:
                  return i > 1 ? `vec${i}<f16>` : "f16";
                case 1:
                  return i > 1 ? `vec${i}<f32>` : "f32";
                case 6:
                  return i > 1 ? `vec${i}<i32>` : "i32";
                case 12:
                  return i > 1 ? `vec${i}<u32>` : "u32";
                case 7:
                  if (i > 1)
                    throw new Error(
                      "currently not supported vecX of uint64 yet"
                    );
                  return ["vec2<u32>", "i32"];
                case 13:
                  if (i > 1)
                    throw new Error(
                      "currently not supported vecX of uint64 yet"
                    );
                  return ["vec2<u32>", "u32"];
                case 9:
                  if (i !== 4) throw new Error("bool must be vec4");
                  return ["u32", "vec4<bool>"];
                case 22:
                  return "i32";
                case 21:
                  return "u32";
                default:
                  throw new Error(`Unknown data type: ${r}`);
              }
            }),
            (Fr = (r, i = 1) => {
              let s = kn(r, i);
              return typeof s == "string" ? s : s[0];
            }),
            (Pr = (r, i = 1) => {
              let s = kn(r, i);
              return typeof s == "string" ? s : s[1];
            }),
            (zt = (...r) => {
              let i = [];
              return (
                r.forEach((s) => {
                  s.length !== 0 &&
                    i.push(
                      { type: 12, data: s },
                      { type: 12, data: Ze.computeStrides(s) }
                    );
                }),
                i
              );
            }),
            ($r = (r) => (r % 4 === 0 ? 4 : r % 2 === 0 ? 2 : 1)),
            (jr = (r = "f32", i, s = "0") =>
              !i || i === 1 ? `${r}(${s})` : `vec${i}<${r}>(${s})`),
            (Zr = (r, i, s) =>
              r === "f32" ? s : i === 1 ? `f32(${s})` : `vec${i}<f32>(${s})`),
            (Qn = (r, i) =>
              i === 4
                ? `(${r}.x + ${r}.y + ${r}.z + ${r}.w)`
                : i === 2
                ? `(${r}.x + ${r}.y)`
                : i === 3
                ? `(${r}.x + ${r}.y + ${r}.z)`
                : r),
            (jt = (r, i, s, u) =>
              r.startsWith("uniforms.") && s > 4
                ? typeof i == "string"
                  ? u === "f16"
                    ? `${r}[(${i}) / 8][(${i}) % 8 / 4][(${i}) % 8 % 4]`
                    : `${r}[(${i}) / 4][(${i}) % 4]`
                  : u === "f16"
                  ? `${r}[${Math.floor(i / 8)}][${Math.floor((i % 8) / 4)}][${
                      (i % 8) % 4
                    }]`
                  : `${r}[${Math.floor(i / 4)}][${i % 4}]`
                : s > 1
                ? `${r}[${i}]`
                : r),
            (Is = (r, i, s, u, d) => {
              let p = typeof s == "number",
                c = p ? s : s.length,
                b = [...new Array(c).keys()],
                k =
                  c < 2 ? "u32" : c <= 4 ? `vec${c}<u32>` : `array<u32, ${c}>`,
                E = kn(i, d),
                q = typeof E == "string" ? E : E[1],
                H = typeof E == "string" ? E : E[0],
                w = { indices: k, value: q, storage: H, tensor: i },
                Z = (ut) => (typeof ut == "string" ? ut : `${ut}u`),
                re = {
                  offsetToIndices: !1,
                  indicesToOffset: !1,
                  broadcastedIndicesToOffset: !1,
                  set: !1,
                  setByIndices: !1,
                  get: !1,
                  getByIndices: !1
                },
                le = p ? "uniforms." : "",
                we = `${le}${r}_shape`,
                be = `${le}${r}_strides`,
                me = "";
              for (let ut = 0; ut < c - 1; ut++)
                me += `
    let dim${ut} = current / ${jt(be, ut, c)};
    let rest${ut} = current % ${jt(be, ut, c)};
    indices[${ut}] = dim${ut};
    current = rest${ut};
    `;
              me += `indices[${c - 1}] = current;`;
              let Fe =
                  c < 2
                    ? ""
                    : `
  fn o2i_${r}(offset: u32) -> ${w.indices} {
    var indices: ${w.indices};
    var current = offset;
    ${me}
    return indices;
  }`,
                Ce = (ut) => (
                  (re.offsetToIndices = !0), c < 2 ? ut : `o2i_${r}(${ut})`
                ),
                ze = [];
              if (c >= 2)
                for (let ut = c - 1; ut >= 0; ut--)
                  ze.push(`${jt(be, ut, c)} * (indices[${ut}])`);
              let dt =
                  c < 2
                    ? ""
                    : `
  fn i2o_${r}(indices: ${w.indices}) -> u32 {
    return ${ze.join("+")};
  }`,
                lt = (ut) => (
                  (re.indicesToOffset = !0), c < 2 ? ut : `i2o_${r}(${ut})`
                ),
                Mt = (...ut) =>
                  c === 0 ? "0u" : `${w.indices}(${ut.map(Z).join(",")})`,
                Dt = (ut, At) => (c < 2 ? `${ut}` : `${jt(ut, At, c)}`),
                Ut = (ut, At, sr) =>
                  c < 2 ? `${ut}=${sr};` : `${jt(ut, At, c)}=${sr};`,
                fr = {},
                br = (ut, At) => {
                  re.broadcastedIndicesToOffset = !0;
                  let sr = `${At.name}broadcastedIndicesTo${r}Offset`;
                  if (sr in fr) return `${sr}(${ut})`;
                  let Gr = [];
                  for (let gn = c - 1; gn >= 0; gn--) {
                    let Cn = At.indicesGet("outputIndices", gn + At.rank - c);
                    Gr.push(`${Dt(be, gn)} * (${Cn} % ${Dt(we, gn)})`);
                  }
                  return (
                    (fr[sr] = `fn ${sr}(outputIndices: ${
                      At.type.indices
                    }) -> u32 {
             return ${Gr.length > 0 ? Gr.join("+") : "0u"};
           }`),
                    `${sr}(${ut})`
                  );
                },
                rr = (ut, At) =>
                  (() => {
                    if (w.storage === w.value) return `${r}[${ut}]=${At};`;
                    if (w.storage === "vec2<u32>" && w.value === "i32")
                      return `${r}[${ut}]=vec2<u32>(u32(${At}), select(0u, 0xFFFFFFFFu, ${At} < 0));`;
                    if (w.storage === "vec2<u32>" && w.value === "u32")
                      return `${r}[${ut}]=vec2<u32>(u32(${At}), 0u);`;
                    if (w.storage === "u32" && w.value === "vec4<bool>")
                      return `${r}[${ut}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${At}));`;
                    throw new Error(
                      `not supported combination of storage type ${w.storage} and value type ${w.value} yet`
                    );
                  })(),
                Wr = (ut) =>
                  (() => {
                    if (w.storage === w.value) return `${r}[${ut}]`;
                    if (w.storage === "vec2<u32>" && w.value === "i32")
                      return `i32(${r}[${ut}].x)`;
                    if (w.storage === "vec2<u32>" && w.value === "u32")
                      return `u32(${r}[${ut}].x)`;
                    if (w.storage === "u32" && w.value === "vec4<bool>")
                      return `vec4<bool>(bool(${r}[${ut}] & 0xFFu), bool(${r}[${ut}] & 0xFF00u), bool(${r}[${ut}] & 0xFF0000u), bool(${r}[${ut}] & 0xFF000000u))`;
                    throw new Error(
                      `not supported combination of storage type ${w.storage} and value type ${w.value} yet`
                    );
                  })(),
                Jr =
                  c < 2
                    ? ""
                    : `
  fn get_${r}ByIndices(indices: ${w.indices}) -> ${q} {
    return ${Wr(`i2o_${r}(indices)`)};
  }`,
                Sr =
                  c < 2
                    ? ""
                    : (() => {
                        let ut = b.map((sr) => `d${sr}: u32`).join(", "),
                          At = b.map((sr) => `d${sr}`).join(", ");
                        return `
  fn get_${r}(${ut}) -> ${q} {
    return get_${r}ByIndices(${Mt(At)});
  }`;
                      })(),
                Hr = (...ut) => {
                  if (ut.length !== c)
                    throw new Error(`indices length must be ${c}`);
                  let At = ut.map(Z).join(",");
                  return c === 0
                    ? Wr("0u")
                    : c === 1
                    ? Wr(At[0])
                    : ((re.get = !0),
                      (re.getByIndices = !0),
                      (re.indicesToOffset = !0),
                      `get_${r}(${At})`);
                },
                tr = (ut) =>
                  c < 2
                    ? Wr(ut)
                    : ((re.getByIndices = !0),
                      (re.indicesToOffset = !0),
                      `get_${r}ByIndices(${ut})`),
                _r =
                  c < 2
                    ? ""
                    : `
  fn set_${r}ByIndices(indices: ${w.indices}, value: ${q}) {
    ${rr(`i2o_${r}(indices)`, "value")}
  }`,
                zr =
                  c < 2
                    ? ""
                    : (() => {
                        let ut = b.map((sr) => `d${sr}: u32`).join(", "),
                          At = b.map((sr) => `d${sr}`).join(", ");
                        return `
  fn set_${r}(${ut}, value: ${q}) {
    set_${r}ByIndices(${Mt(At)}, value);
  }`;
                      })();
              return {
                impl: () => {
                  let ut = [],
                    At = !1;
                  return (
                    re.offsetToIndices && (ut.push(Fe), (At = !0)),
                    re.indicesToOffset && (ut.push(dt), (At = !0)),
                    re.broadcastedIndicesToOffset &&
                      (Object.values(fr).forEach((sr) => ut.push(sr)),
                      (At = !0)),
                    re.set && (ut.push(zr), (At = !0)),
                    re.setByIndices && (ut.push(_r), (At = !0)),
                    re.get && (ut.push(Sr), (At = !0)),
                    re.getByIndices && (ut.push(Jr), (At = !0)),
                    !p &&
                      At &&
                      ut.unshift(
                        `const ${we} = ${w.indices}(${s.join(",")});`,
                        `const ${be} = ${w.indices}(${Ze.computeStrides(s).join(
                          ","
                        )});`
                      ),
                    ut.join(`
`)
                  );
                },
                type: w,
                offsetToIndices: Ce,
                indicesToOffset: lt,
                broadcastedIndicesToOffset: br,
                indices: Mt,
                indicesGet: Dt,
                indicesSet: Ut,
                set: (...ut) => {
                  if (ut.length !== c + 1)
                    throw new Error(`indices length must be ${c}`);
                  let At = ut[c];
                  if (typeof At != "string")
                    throw new Error("value must be string");
                  let sr = ut.slice(0, c).map(Z).join(",");
                  return c === 0
                    ? rr("0u", At)
                    : c === 1
                    ? rr(sr[0], At)
                    : ((re.set = !0),
                      (re.setByIndices = !0),
                      (re.indicesToOffset = !0),
                      `set_${r}(${sr}, ${At})`);
                },
                setByOffset: rr,
                setByIndices: (ut, At) =>
                  c < 2
                    ? rr(ut, At)
                    : ((re.setByIndices = !0),
                      (re.indicesToOffset = !0),
                      `set_${r}ByIndices(${ut}, ${At});`),
                get: Hr,
                getByOffset: Wr,
                getByIndices: tr,
                usage: u,
                name: r,
                strides: be,
                shape: we,
                rank: c
              };
            }),
            (gt = (r, i, s, u = 1) => Is(r, i, s, "input", u)),
            (Ht = (r, i, s, u = 1) => Is(r, i, s, "output", u)),
            (_a = (r, i, s, u = 1) => Is(r, i, s, "internal", u)),
            (ya = class {
              constructor(r, i) {
                (this.normalizedDispatchGroup = r),
                  (this.limits = i),
                  (this.internalVariables = []),
                  (this.variables = []),
                  (this.uniforms = []),
                  (this.variableIndex = 0);
              }
              guardAgainstOutOfBoundsWorkgroupSizes(r) {
                return `if (global_idx >= ${
                  typeof r == "number" ? `${r}u` : r
                }) { return; }`;
              }
              mainStart(r = Kn) {
                let i = typeof r == "number" ? r : r[0],
                  s = typeof r == "number" ? 1 : r[1],
                  u = typeof r == "number" ? 1 : r[2];
                if (
                  i > this.limits.maxComputeWorkgroupSizeX ||
                  s > this.limits.maxComputeWorkgroupSizeY ||
                  u > this.limits.maxComputeWorkgroupSizeZ
                )
                  throw new Error(
                    `workgroup size [${i}, ${s}, ${u}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`
                  );
                if (i * s * u > this.limits.maxComputeInvocationsPerWorkgroup)
                  throw new Error(
                    `workgroup size [${i}, ${s}, ${u}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`
                  );
                let d =
                    this.normalizedDispatchGroup[1] === 1 &&
                    this.normalizedDispatchGroup[2] === 1,
                  p = d
                    ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`
                    : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,
                  c = d
                    ? "let global_idx = global_id.x; let local_idx = local_id.x;"
                    : `let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${
            i * s * u
          }u + local_idx;`;
                return `@compute @workgroup_size(${i}, ${s}, ${u})
  fn main(${p}) {
    ${c}
  `;
              }
              appendVariableUniforms(r) {
                r.rank !== 0 &&
                  (r.shape.startsWith("uniforms.") &&
                    this.uniforms.push({
                      name: r.shape.replace("uniforms.", ""),
                      type: "u32",
                      length: r.rank
                    }),
                  r.strides.startsWith("uniforms.") &&
                    this.uniforms.push({
                      name: r.strides.replace("uniforms.", ""),
                      type: "u32",
                      length: r.rank
                    }));
              }
              declareVariable(r, i) {
                if (r.usage === "internal")
                  throw new Error(
                    "cannot use internal variable with declareVariable(). use registerInternalVariables() instead."
                  );
                this.variables.push(r), this.appendVariableUniforms(r);
                let s = r.usage === "input" ? "read" : "read_write",
                  u = r.type.storage;
                return `@group(0) @binding(${i}) var<storage, ${s}> ${r.name}: array<${u}>;`;
              }
              declareVariables(...r) {
                return r.map((i) =>
                  this.declareVariable(i, this.variableIndex++)
                ).join(`
`);
              }
              registerInternalVariable(r) {
                if (r.usage !== "internal")
                  throw new Error(
                    "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."
                  );
                this.internalVariables.push(r), this.appendVariableUniforms(r);
              }
              registerInternalVariables(...r) {
                return r.forEach((i) => this.registerInternalVariable(i)), this;
              }
              registerUniform(r, i, s = 1) {
                return (
                  this.uniforms.push({ name: r, type: i, length: s }), this
                );
              }
              registerUniforms(r) {
                return (this.uniforms = this.uniforms.concat(r)), this;
              }
              uniformDeclaration() {
                if (this.uniforms.length === 0) return "";
                let r = [];
                for (let { name: i, type: s, length: u } of this.uniforms)
                  if (u && u > 4)
                    s === "f16"
                      ? r.push(
                          `@align(16) ${i}:array<mat2x4<${s}>, ${Math.ceil(
                            u / 8
                          )}>`
                        )
                      : r.push(`${i}:array<vec4<${s}>, ${Math.ceil(u / 4)}>`);
                  else {
                    let d = u == null || u === 1 ? s : `vec${u}<${s}>`;
                    r.push(`${i}:${d}`);
                  }
                return `
      struct Uniforms { ${r.join(", ")} };
      @group(0) @binding(${
        this.variableIndex
      }) var<uniform> uniforms: Uniforms;`;
              }
              get additionalImplementations() {
                return (
                  this.uniformDeclaration() +
                  this.variables.map((r) => r.impl()).join(`
`) +
                  this.internalVariables.map((r) => r.impl()).join(`
`)
                );
              }
              get variablesInfo() {
                if (this.uniforms.length === 0) return;
                let r = (i) =>
                  [12, 10, 1, 6][["u32", "f16", "f32", "i32"].indexOf(i)];
                return this.uniforms.map((i) => [r(i.type), i.length ?? 1]);
              }
            }),
            (Mu = (r, i) => new ya(r, i)),
            (xo = (r, i) => {
              let s = r.length,
                u = [];
              for (let d = 0; d < s; d++) {
                let p = s - 1 - d,
                  c = r[p] || 1;
                (i[i.length - 1 - d] || 1) > 1 && c === 1 && u.unshift(p);
              }
              return u;
            });
        }),
        Tu,
        wa,
        Yo,
        ku,
        bi,
        Su,
        va,
        Mo = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (Tu = (r) => {
              if (!r || r.length !== 1)
                throw new Error("Transpose requires 1 input.");
            }),
            (wa = (r, i) =>
              i && i.length !== r ? [...new Array(r).keys()].reverse() : i),
            (Yo = (r, i) => Ze.sortBasedOnPerm(r, wa(r.length, i))),
            (ku = (r, i, s, u) => {
              let d = [];
              d.push(`fn perm(i: ${u.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`);
              for (let p = 0; p < i; ++p)
                d.push(s.indicesSet("a", r[p], `i[${p}]`));
              return (
                d.push("return a;}"),
                d.join(`
`)
              );
            }),
            (bi = (r, i) => {
              let s = r.dataType,
                u = r.dims.length,
                d = wa(u, i),
                p = Yo(r.dims, d),
                c = Ht("output", s, p.length),
                b = gt("a", s, u),
                k;
              if (d.length === 2 && d[0] === 1 && d[1] === 0) {
                let E = c.type.value,
                  q = [16, 16, 1];
                k = (H) => `
  ${H.registerUniform("output_size", "u32").declareVariables(b, c)}
  var<workgroup> tile : array<array<${E}, ${q[0] + 1}>, ${q[0]}>;
  ${H.mainStart(q)}
    var x = workgroup_id.x * ${q[0]}u + local_id.x;
    var y = workgroup_id.y * ${q[0]}u + local_id.y;
    let width = uniforms.output_shape[0];
    let height = uniforms.output_shape[1];
    if (x < width && y < height) {
      tile[local_id.y][local_id.x] = ${b.getByOffset("y * width + x")};
    }
    workgroupBarrier();
    x = workgroup_id.y * ${q[0]}u + local_id.x;
    y = workgroup_id.x * ${q[0]}u + local_id.y;
    if (x < height && y < width) {
      ${c.setByOffset("y * height + x", "tile[local_id.x][local_id.y]")}
    }
  }`;
              } else
                k = (E) => `
  ${E.registerUniform("output_size", "u32").declareVariables(b, c)}

  ${ku(d, u, b, c)}

  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${c.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${c.setByOffset("global_idx", b.getByIndices("aIndices"))}
  }`;
              return {
                name: "Transpose",
                shaderCache: { hint: `${i}`, inputDependencies: ["rank"] },
                getRunData: () => {
                  let E = Ze.size(p);
                  return {
                    outputs: [{ dims: p, dataType: r.dataType }],
                    dispatchGroup: { x: Math.ceil(E / 64) },
                    programUniforms: [{ type: 12, data: E }, ...zt(r.dims, p)]
                  };
                },
                getShaderSource: k
              };
            }),
            (Su = (r, i) => {
              Tu(r.inputs), r.compute(bi(r.inputs[0], i.perm));
            }),
            (va = (r) => Qt({ perm: r.perm }));
        }),
        Eu,
        Cu,
        Pu,
        $u,
        ba,
        Au,
        Iu,
        xa,
        Fu,
        zu,
        ti,
        Ou,
        Du,
        Ma,
        Lu,
        Bu,
        Ta,
        Ru,
        Nu,
        ka,
        ju,
        yp = m(() => {
          Yt(),
            Zt(),
            cr(),
            Ia(),
            Mo(),
            (Eu = {
              max: "select(bestValue, candidate, candidate > bestValue)",
              min: "select(bestValue, candidate, candidate < bestValue)",
              mean: "bestValue + candidate",
              sum: "bestValue + candidate",
              prod: "bestValue * candidate",
              sumSquare: "bestValue + candidate * candidate",
              logSumExp: "bestValue + exp(candidate)",
              l1: "bestValue + abs(candidate)",
              l2: "bestValue + candidate * candidate",
              logSum: "bestValue + candidate"
            }),
            (Cu = {
              max: "select(bestValue, candidate, candidate > bestValue)",
              min: "select(bestValue, candidate, candidate < bestValue)",
              mean: "bestValue + candidate",
              sum: "bestValue + candidate",
              prod: "bestValue * candidate",
              sumSquare: "bestValue + candidate",
              logSumExp: "bestValue + candidate",
              l1: "bestValue + candidate",
              l2: "bestValue + candidate",
              logSum: "bestValue + candidate"
            }),
            (Pu = {
              max: "_A[offset]",
              min: "_A[offset]",
              mean: "0",
              sum: "0",
              prod: "1",
              sumSquare: "0",
              logSumExp: "0",
              l1: "0",
              l2: "0",
              logSum: "0"
            }),
            ($u = {
              max: "bestValue",
              min: "bestValue",
              sum: "bestValue",
              prod: "bestValue",
              sumSquare: "bestValue",
              logSumExp: "log(bestValue)",
              l1: "bestValue",
              l2: "sqrt(bestValue)",
              logSum: "log(bestValue)"
            }),
            (ba = (r, i) => {
              let s = [];
              for (let u = i - r; u < i; ++u) s.push(u);
              return s;
            }),
            (Au = (r, i) => {
              let s = [],
                u = r.length;
              for (let p = 0; p < u; p++) i.indexOf(p) === -1 && s.push(r[p]);
              let d = i.map((p) => r[p]);
              return [s, d];
            }),
            (Iu = (r, i) => {
              let s = r.length + i.length,
                u = [],
                d = 0;
              for (let p = 0; p < s; p++)
                i.indexOf(p) === -1 ? u.push(r[d++]) : u.push(1);
              return u;
            }),
            (xa = (r, i) => {
              for (let s = 0; s < r.length; ++s)
                if (r[r.length - s - 1] !== i - 1 - s) return !1;
              return !0;
            }),
            (Fu = (r, i) => {
              let s = [];
              if (!xa(r, i)) {
                for (let u = 0; u < i; ++u) r.indexOf(u) === -1 && s.push(u);
                r.forEach((u) => s.push(u));
              }
              return s;
            }),
            (zu = (r, i, s, u, d, p, c) => {
              let b = s[0].dims,
                k = Ze.size(p),
                E = Ze.size(c),
                q = gt("_A", s[0].dataType, b),
                H = Ht("output", d, p),
                w = 32,
                Z = `
          var<workgroup> aBestValues : array<f32, ${w}>;
       `;
              return {
                name: r,
                shaderCache: i,
                getShaderSource: (re) => `
        ${re.registerUniform("reduceSize", "u32").declareVariables(q, H)}
        ${Z}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${re.mainStart(w)}

          let outputIndex = global_idx / ${w};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Pu[u]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${w}) {
           let candidate = f32(${q.getByOffset("offset + k")});
           bestValue = ${Eu[u]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${w}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Cu[u]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${H.setByOffset(
            "outputIndex",
            `${
              u === "mean"
                ? `${H.type.storage}(bestValue / f32(uniforms.reduceSize))`
                : `${H.type.storage}(${$u[u]})`
            }`
          )};
         }
        }`,
                getRunData: () => ({
                  outputs: [{ dims: p, dataType: d }],
                  dispatchGroup: { x: k },
                  programUniforms: [{ type: 12, data: E }]
                })
              };
            }),
            (ti = (r, i, s, u) => {
              let d = r.inputs.length === 1 ? s : zs(r.inputs, s),
                p = d.axes;
              p.length === 0 &&
                !d.noopWithEmptyAxes &&
                (p = r.inputs[0].dims.map((Z, re) => re));
              let c = Ze.normalizeAxes(p, r.inputs[0].dims.length),
                b = c,
                k = r.inputs[0],
                E = Fu(b, r.inputs[0].dims.length);
              E.length > 0 &&
                ((k = r.compute(bi(r.inputs[0], E), {
                  inputs: [0],
                  outputs: [-1]
                })[0]),
                (b = ba(b.length, k.dims.length)));
              let [q, H] = Au(k.dims, b),
                w = q;
              d.keepDims && (w = Iu(q, c)),
                r.compute(
                  zu(
                    i,
                    { hint: d.cacheKey, inputDependencies: ["type"] },
                    [k],
                    u,
                    r.inputs[0].dataType,
                    w,
                    H
                  ),
                  { inputs: [k] }
                );
            }),
            (Ou = (r, i) => {
              ti(r, "ReduceMeanShared", i, "mean");
            }),
            (Du = (r, i) => {
              ti(r, "ReduceL1Shared", i, "l1");
            }),
            (Ma = (r, i) => {
              ti(r, "ReduceL2Shared", i, "l2");
            }),
            (Lu = (r, i) => {
              ti(r, "ReduceLogSumExpShared", i, "logSumExp");
            }),
            (Bu = (r, i) => {
              ti(r, "ReduceMaxShared", i, "max");
            }),
            (Ta = (r, i) => {
              ti(r, "ReduceMinShared", i, "min");
            }),
            (Ru = (r, i) => {
              ti(r, "ReduceProdShared", i, "prod");
            }),
            (Nu = (r, i) => {
              ti(r, "ReduceSumShared", i, "sum");
            }),
            (ka = (r, i) => {
              ti(r, "ReduceSumSquareShared", i, "sumSquare");
            }),
            (ju = (r, i) => {
              ti(r, "ReduceLogSumShared", i, "logSum");
            });
        }),
        ri,
        Uu,
        Fs,
        zs,
        ui,
        Vu,
        Sa,
        Wu,
        Gu,
        Ea,
        Hu,
        qu,
        Ca,
        Ku,
        Qu,
        ni,
        Xu,
        Yu,
        Pa,
        Zu,
        Ju,
        $a,
        ec,
        tc,
        Aa,
        rc,
        Ia = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            yp(),
            (ri = (r) => {
              if (!r || r.length === 0 || r.length > 2)
                throw new Error("Reduce op requires 1 or 2 inputs.");
              if (r.length === 2 && r[1].dims.length !== 1)
                throw new Error("Invalid axes input dims.");
            }),
            (Uu = (r) => [
              "",
              "",
              `var value = ${r.getByIndices("input_indices")};`,
              ""
            ]),
            (Fs = (r, i, s, u, d, p, c = !1, b = !1) => {
              let k = [],
                E = s[0].dims,
                q = E.length,
                H = Ze.normalizeAxes(d, q),
                w = !b && H.length === 0;
              E.forEach((le, we) => {
                w || H.indexOf(we) >= 0 ? c && k.push(1) : k.push(le);
              });
              let Z = k.length,
                re = Ze.size(k);
              return {
                name: r,
                shaderCache: i,
                getShaderSource: (le) => {
                  let we = [],
                    be = gt("_A", s[0].dataType, q),
                    me = Ht("output", p, Z),
                    Fe = u(be, me, H),
                    Ce = Fe[2];
                  for (let ze = 0, dt = 0; ze < q; ze++)
                    w || H.indexOf(ze) >= 0
                      ? (c && dt++,
                        (Ce = `for(var j${ze}: u32 = 0; j${ze} < ${
                          E[ze]
                        }; j${ze}++) {
                  ${
                    Fe[2].includes("last_index")
                      ? `let last_index = j${ze};`
                      : ""
                  }
                  ${be.indicesSet("input_indices", ze, `j${ze}`)}
                  ${Ce}
                }`))
                      : (we.push(
                          `${be.indicesSet(
                            "input_indices",
                            ze,
                            me.indicesGet("output_indices", dt)
                          )};`
                        ),
                        dt++);
                  return `

        ${le.registerUniform("output_size", "u32").declareVariables(be, me)}

        ${le.mainStart()}
          ${le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${be.type.indices};
          let output_indices = ${me.offsetToIndices("global_idx")};

          ${we.join(`
`)}
          ${Fe[0]}       // init ops for reduce max/min
          ${Fe[1]}
          ${Ce}
          ${Fe[3]}
          ${
            Fe.length === 4
              ? me.setByOffset("global_idx", "value")
              : Fe.slice(4).join(`
`)
          }
        }`;
                },
                getRunData: () => ({
                  outputs: [{ dims: k, dataType: p }],
                  dispatchGroup: { x: Math.ceil(re / 64) },
                  programUniforms: [{ type: 12, data: re }, ...zt(E, k)]
                })
              };
            }),
            (zs = (r, i) => {
              let s = [];
              return (
                r[1].dims[0] > 0 &&
                  r[1].getBigInt64Array().forEach((u) => s.push(Number(u))),
                Qt({
                  axes: s,
                  keepDims: i.keepDims,
                  noopWithEmptyAxes: i.noopWithEmptyAxes
                })
              );
            }),
            (ui = (r, i, s, u) => {
              let d = r.inputs,
                p = d.length === 1 ? s : zs(d, s);
              r.compute(
                Fs(
                  i,
                  { hint: p.cacheKey, inputDependencies: ["rank"] },
                  [d[0]],
                  p.noopWithEmptyAxes && p.axes.length === 0 ? Uu : u,
                  p.axes,
                  d[0].dataType,
                  p.keepDims,
                  p.noopWithEmptyAxes
                ),
                { inputs: [0] }
              );
            }),
            (Vu = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceLogSum", i, (s, u) => [
                  `var value = ${u.type.storage}(0);`,
                  "",
                  `value += ${s.getByIndices("input_indices")};`,
                  "value = log(value);"
                ]);
            }),
            (Sa = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceL1", i, (s, u) => [
                  `var value = ${u.type.storage}(0);`,
                  "",
                  `value += abs(${s.getByIndices("input_indices")});`,
                  ""
                ]);
            }),
            (Wu = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceL2", i, (s, u) => [
                  `var t = ${u.type.value}(0); var value = ${u.type.value}(0);`,
                  "",
                  `t = ${s.getByIndices("input_indices")}; value += (t * t);`,
                  "value = sqrt(value);"
                ]);
            }),
            (Gu = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceLogSumExp", i, (s, u) => [
                  `var value = ${u.type.storage}(0);`,
                  "",
                  `value += exp(${s.getByIndices("input_indices")});`,
                  "value = log(value);"
                ]);
            }),
            (Ea = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceMax", i, (s, u, d) => {
                  let p = [];
                  for (let c = 0; c < s.rank; c++)
                    (d.indexOf(c) >= 0 || d.length === 0) &&
                      p.push(s.indicesSet("input_indices", c, 0));
                  return [
                    `${p.join(`
`)}`,
                    `var value = ${s.getByIndices("input_indices")};`,
                    `value = max(value, ${s.getByIndices("input_indices")});`,
                    ""
                  ];
                });
            }),
            (Hu = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceMean", i, (s, u, d) => {
                  let p = 1;
                  for (let c = 0; c < s.rank; c++)
                    (d.indexOf(c) >= 0 || d.length === 0) &&
                      (p *= r.inputs[0].dims[c]);
                  return [
                    "var sum = f32(0);",
                    "",
                    `sum += f32(${s.getByIndices("input_indices")});`,
                    `let value = ${u.type.value}(sum / ${p});`
                  ];
                });
            }),
            (qu = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceMin", i, (s, u, d) => {
                  let p = [];
                  for (let c = 0; c < s.rank; c++)
                    (d.indexOf(c) >= 0 || d.length === 0) &&
                      p.push(`input_indices[${c}] = 0;`);
                  return [
                    `${p.join(`
`)}`,
                    `var value = ${s.getByIndices("input_indices")};`,
                    `value = min(value, ${s.getByIndices("input_indices")});`,
                    ""
                  ];
                });
            }),
            (Ca = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceProd", i, (s, u) => [
                  `var value = ${u.type.storage}(1);`,
                  "",
                  `value *= ${s.getByIndices("input_indices")};`,
                  ""
                ]);
            }),
            (Ku = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceSum", i, (s, u) => [
                  `var value = ${u.type.storage}(0);`,
                  "",
                  `value += ${s.getByIndices("input_indices")};`,
                  ""
                ]);
            }),
            (Qu = (r, i) => {
              ri(r.inputs),
                ui(r, "ReduceSumSquare", i, (s, u) => [
                  `var t = ${u.type.value}(0); var value = ${u.type.value}(0);`,
                  "",
                  `t = ${s.getByIndices("input_indices")}; value += t * t;`,
                  ""
                ]);
            }),
            (ni = (r, i, s) => {
              if (i.length === 0) return s;
              let u = 1,
                d = 1;
              for (let p = 0; p < i.length; p++)
                i.indexOf(p) === -1 ? (u *= r[p]) : (d *= r[p]);
              return d < 32 && u > 1024;
            }),
            (Xu = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? Hu(r, i)
                : Ou(r, i);
            }),
            (Yu = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? Sa(r, i)
                : Du(r, i);
            }),
            (Pa = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? Wu(r, i)
                : Ma(r, i);
            }),
            (Zu = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? Gu(r, i)
                : Lu(r, i);
            }),
            (Ju = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? Ea(r, i)
                : Bu(r, i);
            }),
            ($a = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? qu(r, i)
                : Ta(r, i);
            }),
            (ec = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? Ca(r, i)
                : Ru(r, i);
            }),
            (tc = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? Ku(r, i)
                : Nu(r, i);
            }),
            (Aa = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? Qu(r, i)
                : ka(r, i);
            }),
            (rc = (r, i) => {
              ni(r.inputs[0].dims, i.axes, i.noopWithEmptyAxes)
                ? Vu(r, i)
                : ju(r, i);
            });
        }),
        Os,
        nc,
        ic,
        Ds,
        wp = m(() => {
          Yt(),
            wr(),
            Ia(),
            (Os = (r) => {
              if (!r || r.length === 0 || r.length > 2)
                throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
              if (r[0].dataType !== 1) throw new Error("Invalid input type.");
            }),
            (nc = (r, i) => {
              Os(r.inputs);
              let s = (u, d, p) => {
                let c = [];
                for (let b = 0; b < u.rank; b++)
                  (p.indexOf(b) >= 0 || p.length === 0) &&
                    c.push(`input_indices[${b}] = 0;`);
                return [
                  `${c.join(`
`)}`,
                  `var value = ${u.getByIndices("input_indices")};
var best_index : i32 = 0;`,
                  `if (${u.getByIndices("input_indices")} ${
                    i.selectLastIndex > 0 ? "<=" : "<"
                  } value) {
         value = ${u.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
                  "",
                  d.setByOffset("global_idx", "best_index")
                ];
              };
              r.compute(
                Fs(
                  "ArgMin",
                  { hint: i.cacheKey, inputDependencies: ["rank"] },
                  [r.inputs[0]],
                  s,
                  [i.axis],
                  7,
                  i.keepDims
                ),
                { inputs: [0] }
              );
            }),
            (ic = (r, i) => {
              Os(r.inputs);
              let s = (u, d, p) => {
                let c = [];
                for (let b = 0; b < u.rank; b++)
                  (p.indexOf(b) >= 0 || p.length === 0) &&
                    c.push(`input_indices[${b}] = 0;`);
                return [
                  `${c.join(`
`)}`,
                  `var value = ${u.getByIndices("input_indices")};
var best_index : i32 = 0;`,
                  `if (${u.getByIndices("input_indices")} ${
                    i.selectLastIndex > 0 ? ">=" : ">"
                  } value) {
         value = ${u.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
                  "",
                  d.setByOffset("global_idx", "best_index")
                ];
              };
              r.compute(
                Fs(
                  "argMax",
                  { hint: i.cacheKey, inputDependencies: ["rank"] },
                  [r.inputs[0]],
                  s,
                  [i.axis],
                  7,
                  i.keepDims
                ),
                { inputs: [0] }
              );
            }),
            (Ds = (r) => Qt(r));
        }),
        oc,
        Fa,
        sc,
        ac,
        To,
        lc,
        uc,
        Ls = m(() => {
          Yt(),
            Zt(),
            pe(),
            cr(),
            (oc = (r, i) => {
              let s = r[0],
                u = r[1],
                d = r[2],
                p = r[3],
                c = r[4],
                b = r[5];
              if (c && b)
                throw new Error(
                  "Attention cannot have both past and attention_bias"
                );
              if (s.dims.length !== 3)
                throw new Error('Input "input" must have 3 dimensions');
              let k = s.dims[0],
                E = s.dims[1],
                q = s.dims[2];
              if (d.dims.length !== 1)
                throw new Error(
                  'Input "bias" is expected to have 1 dimensions'
                );
              if (u.dims.length !== 2)
                throw new Error(
                  'Input "weights" is expected to have 2 dimensions'
                );
              if (u.dims[0] !== q)
                throw new Error(
                  "Input 1 dimension 0 should have same length as dimension 2 of input 0"
                );
              if (d.dims[0] !== u.dims[1])
                throw new Error(
                  'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"'
                );
              let H = d.dims[0] / 3,
                w = H,
                Z = w;
              if (i.qkvHiddenSizes.length > 0) {
                if (i.qkvHiddenSizes.length !== 3)
                  throw new Error(
                    "qkv_hidden_sizes attribute should have 3 elements"
                  );
                for (let Fe of i.qkvHiddenSizes)
                  if (Fe % i.numHeads !== 0)
                    throw new Error(
                      "qkv_hidden_sizes should be divisible by num_heads"
                    );
                (H = i.qkvHiddenSizes[0]),
                  (w = i.qkvHiddenSizes[1]),
                  (Z = i.qkvHiddenSizes[2]);
              }
              let re = E;
              if (H !== w)
                throw new Error(
                  "qkv_hidden_sizes first element should be same as the second"
                );
              if (d.dims[0] !== H + w + Z)
                throw new Error(
                  'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes'
                );
              let le = 0;
              if (c) {
                if (w !== Z)
                  throw new Error(
                    'Input "past" expect k_hidden_size == v_hidden_size'
                  );
                if (c.dims.length !== 5)
                  throw new Error('Input "past" must have 5 dimensions');
                if (c.dims[0] !== 2)
                  throw new Error('Input "past" first dimension must be 2');
                if (c.dims[1] !== k)
                  throw new Error(
                    'Input "past" second dimension must be batch_size'
                  );
                if (c.dims[2] !== i.numHeads)
                  throw new Error(
                    'Input "past" third dimension must be num_heads'
                  );
                if (c.dims[4] !== w / i.numHeads)
                  throw new Error(
                    'Input "past" fifth dimension must be k_hidden_size / num_heads'
                  );
                i.pastPresentShareBuffer || (le = c.dims[3]);
              }
              let we = re + le,
                be = -1,
                me = 0;
              if (p) throw new Error("Mask not supported");
              if (c) throw new Error("past is not supported");
              if (b) {
                if (b.dims.length !== 4)
                  throw new Error(
                    'Input "attention_bias" must have 4 dimensions'
                  );
                if (
                  b.dims[0] !== k ||
                  b.dims[1] !== i.numHeads ||
                  b.dims[2] !== E ||
                  b.dims[3] !== we
                )
                  throw new Error(
                    'Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)'
                  );
              }
              return {
                batchSize: k,
                sequenceLength: E,
                pastSequenceLength: le,
                kvSequenceLength: re,
                totalSequenceLength: we,
                maxSequenceLength: be,
                inputHiddenSize: q,
                hiddenSize: H,
                vHiddenSize: Z,
                headSize: Math.floor(H / i.numHeads),
                vHeadSize: Math.floor(Z / i.numHeads),
                numHeads: i.numHeads,
                isUnidirectional: !1,
                pastPresentShareBuffer: !1,
                maskFilterValue: i.maskFilterValue,
                maskType: me,
                scale: i.scale,
                broadcastResPosBias: !1,
                passPastInKv: !1,
                qkvFormat: 1
              };
            }),
            (Fa = (r, i, s) => {
              let u = $r(s),
                d = 64,
                p = s / u;
              p < d && (d = 32);
              let c = Math.ceil(s / u / d),
                b = [
                  { type: 1, data: 1 / s },
                  { type: 12, data: p },
                  { type: 12, data: c }
                ],
                k = Fr(r.dataType, u),
                E = Pr(1, u),
                q = ["type"],
                H = (w) => {
                  let Z = Ht("x", r.dataType, r.dims, u),
                    re = Pr(r.dataType),
                    le = [
                      { name: "d_inv", type: "f32" },
                      { name: "d_comp", type: "u32" },
                      { name: "elements_per_thread", type: "u32" }
                    ];
                  return `
  var<workgroup> thread_max: array<f32, ${d}>;
  var<workgroup> thread_sum: array<f32, ${d}>;
  ${w.registerUniforms(le).declareVariables(Z)}
  ${w.mainStart([d, 1, 1])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${d}) * uniforms.d_comp + local_offset;

    var thread_max_vector = ${E}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${E}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
      switch (u) {
        case 1:
          return "thread_max_vector";
        case 2:
          return "max(thread_max_vector.x, thread_max_vector.y)";
        case 4:
          return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
        default:
          throw new Error(`Unsupported components: ${u}`);
      }
    })()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${d}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${E}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${E}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
      switch (u) {
        case 1:
          return "sum_vector";
        case 2:
          return "sum_vector.x + sum_vector.y";
        case 4:
          return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
        default:
          throw new Error(`Unsupported components: ${u}`);
      }
    })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${d}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${Z.type.value}(${re}(uniforms.d_inv));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${E}(x[offset + i]);
        x[offset + i] = ${Z.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`;
                };
              return {
                name: "AttentionProbsSoftmax",
                shaderCache: { hint: `${d};${k};${u}`, inputDependencies: q },
                getShaderSource: H,
                getRunData: () => ({
                  outputs: [],
                  dispatchGroup: { x: i },
                  programUniforms: b
                })
              };
            }),
            (sc = (r, i, s, u, d, p, c, b) => {
              let k = b + p.kvSequenceLength,
                E = [p.batchSize, p.numHeads, p.sequenceLength, k],
                q = p.kvNumHeads === void 0 && r > 1 && u,
                H = q ? [p.batchSize, p.numHeads, k, p.headSize] : void 0,
                w = c.scale === 0 ? 1 / Math.sqrt(p.headSize) : c.scale,
                Z = $r(p.headSize),
                re = p.headSize / Z,
                le = 12,
                we = {
                  x: Math.ceil(k / le),
                  y: Math.ceil(p.sequenceLength / le),
                  z: p.batchSize * p.numHeads
                },
                be = [
                  { type: 12, data: p.sequenceLength },
                  { type: 12, data: re },
                  { type: 12, data: k },
                  { type: 12, data: p.numHeads },
                  { type: 1, data: w },
                  { type: 12, data: b },
                  { type: 12, data: p.kvSequenceLength }
                ],
                me = q && u && Ze.size(u.dims) > 0,
                Fe = ["type", "type"];
              me && Fe.push("type"), d && Fe.push("type");
              let Ce = [{ dims: E, dataType: i.dataType, gpuDataType: 0 }];
              q && Ce.push({ dims: H, dataType: i.dataType, gpuDataType: 0 });
              let ze = (dt) => {
                let lt = gt("q", i.dataType, i.dims, Z),
                  Mt = gt("key", s.dataType, s.dims, Z),
                  Dt = [lt, Mt];
                if (me) {
                  let Wr = gt("past_key", u.dataType, u.dims, Z);
                  Dt.push(Wr);
                }
                d && Dt.push(gt("attention_bias", d.dataType, d.dims));
                let Ut = Ht("output", i.dataType, E),
                  fr = [Ut];
                q && fr.push(Ht("present_key", i.dataType, H, Z));
                let br = Pr(1, Z),
                  rr = [
                    { name: "M", type: "u32" },
                    { name: "K", type: "u32" },
                    { name: "N", type: "u32" },
                    { name: "num_heads", type: "u32" },
                    { name: "alpha", type: "f32" },
                    { name: "past_sequence_length", type: "u32" },
                    { name: "kv_sequence_length", type: "u32" }
                  ];
                return `
  const TILE_SIZE = ${le}u;

  var<workgroup> tileQ: array<${lt.type.storage}, ${le * le}>;
  var<workgroup> tileK: array<${lt.type.storage}, ${le * le}>;
  ${dt.registerUniforms(rr).declareVariables(...Dt, ...fr)}
  ${dt.mainStart([le, le, 1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    ${
      me && q
        ? `
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx;
    let pastKeyOffset = uniforms.past_sequence_length * uniforms.K * headIdx;`
        : `
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;`
    }
    ${q ? "let presentKeyOffset = headIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${br}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${
        me && q
          ? `
              if (n + local_id.y < uniforms.past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else {
                tileK[idx] =
                         key[kOffset + (n + local_id.y - uniforms.past_sequence_length) * uniforms.K + w + local_id.x];
              }`
          : "tileK[idx] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];"
      }
      ${
        q
          ? "present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];"
          : ""
      }
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${br}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
        switch (Z) {
          case 1:
            return "value";
          case 2:
            return "value.x + value.y";
          case 4:
            return "value.x + value.y + value.z + value.w";
          default:
            throw new Error(`Unsupported components: ${Z}`);
        }
      })()};
        output[outputIdx] = ${Ut.type.value} (sum * uniforms.alpha) + ${
                  d ? "attention_bias[outputIdx]" : "0.0"
                };
    }
  }`;
              };
              return {
                name: "AttentionProbs",
                shaderCache: {
                  hint: `${Z};${d !== void 0};${u !== void 0};${r}`,
                  inputDependencies: Fe
                },
                getRunData: () => ({
                  outputs: Ce,
                  dispatchGroup: we,
                  programUniforms: be
                }),
                getShaderSource: ze
              };
            }),
            (ac = (r, i, s, u, d, p) => {
              let c = p + d.kvSequenceLength,
                b = d.nReps ? d.nReps : 1,
                k = d.vHiddenSize * b,
                E = d.kvNumHeads == null && r > 1 && u,
                q = E ? [d.batchSize, d.numHeads, c, d.headSize] : void 0,
                H = [d.batchSize, d.sequenceLength, k],
                w = 12,
                Z = {
                  x: Math.ceil(d.vHeadSize / w),
                  y: Math.ceil(d.sequenceLength / w),
                  z: d.batchSize * d.numHeads
                },
                re = [
                  { type: 12, data: d.sequenceLength },
                  { type: 12, data: c },
                  { type: 12, data: d.vHeadSize },
                  { type: 12, data: d.numHeads },
                  { type: 12, data: k },
                  { type: 12, data: p },
                  { type: 12, data: d.kvSequenceLength }
                ],
                le = E && u && Ze.size(u.dims) > 0,
                we = ["type", "type"];
              le && we.push("type");
              let be = [{ dims: H, dataType: i.dataType, gpuDataType: 0 }];
              E && be.push({ dims: q, dataType: i.dataType, gpuDataType: 0 });
              let me = (Fe) => {
                let Ce = gt("probs", i.dataType, i.dims),
                  ze = gt("v", s.dataType, s.dims),
                  dt = [Ce, ze];
                le && dt.push(gt("past_value", u.dataType, u.dims));
                let lt = [Ht("output", i.dataType, H)];
                E && lt.push(Ht("present_value", i.dataType, q));
                let Mt = [
                  { name: "M", type: "u32" },
                  { name: "K", type: "u32" },
                  { name: "N", type: "u32" },
                  { name: "num_heads", type: "u32" },
                  { name: "v_hidden_size", type: "u32" },
                  { name: "past_sequence_length", type: "u32" },
                  { name: "kv_sequence_length", type: "u32" }
                ];
                return `
  const TILE_SIZE = ${w}u;
  var<workgroup> tileQ: array<${Ce.type.value}, ${w * w}>;
  var<workgroup> tileK: array<${Ce.type.value}, ${w * w}>;
  ${Fe.registerUniforms(Mt).declareVariables(...dt, ...lt)}
  ${Fe.mainStart([w, w, 1])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   ${
     le && E
       ? `
    let pastValueOffset = headIdx * uniforms.N * uniforms.past_sequence_length + n;
    let vOffset = headIdx * uniforms.N * uniforms.kv_sequence_length + n;
      `
       : `
   let offsetB = headIdx * uniforms.N * uniforms.K + n;
            `
   }
    ${
      E ? "let presentValueOffset = headIdx * uniforms.N * uniforms.K + n;" : ""
    }
   var value = ${Ce.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${
          le && E
            ? `
        if (w + local_id.y < uniforms.past_sequence_length) {
          tileK[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else {
          tileK[idx] = v[vOffset + (w + local_id.y - uniforms.past_sequence_length) * uniforms.N];
        }
      `
            : `
        tileK[idx] = v[offsetB + (w + local_id.y) * uniforms.N];
      `
        }
        ${
          E
            ? "present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileK[idx];"
            : ""
        }
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
              };
              return {
                name: "AttentionScore",
                shaderCache: {
                  hint: `${u !== void 0};${r}`,
                  inputDependencies: we
                },
                getRunData: () => ({
                  outputs: be,
                  dispatchGroup: Z,
                  programUniforms: re
                }),
                getShaderSource: me
              };
            }),
            (To = (r, i, s, u, d, p, c, b, k, E, q) => {
              let H = Math.min(r.outputCount, 1 + (c ? 1 : 0) + (b ? 1 : 0)),
                w = E.kvNumHeads !== void 0 || H > 1 ? E.pastSequenceLength : 0,
                Z = w + E.kvSequenceLength,
                re = k && Ze.size(k.dims) > 0 ? k : void 0,
                le = [i, s];
              E.kvNumHeads === void 0 &&
                H > 1 &&
                c &&
                Ze.size(c.dims) > 0 &&
                le.push(c),
                re && le.push(re);
              let we = r.compute(sc(H, i, s, c, re, E, q, w), {
                inputs: le,
                outputs: E.kvNumHeads === void 0 && H > 1 ? [-1, 1] : [-1]
              })[0];
              r.compute(
                Fa(we, E.batchSize * E.numHeads * E.sequenceLength, Z),
                { inputs: [we], outputs: [] }
              );
              let be = [we, u];
              E.kvNumHeads === void 0 &&
                H > 1 &&
                b &&
                Ze.size(b.dims) > 0 &&
                be.push(b),
                r.compute(ac(H, we, u, b, E, w), {
                  inputs: be,
                  outputs: E.kvNumHeads === void 0 && H > 1 ? [0, 2] : [0]
                });
            }),
            (lc = (r, i) => {
              let s = [i.batchSize, i.numHeads, i.sequenceLength, i.headSize],
                u = i.sequenceLength,
                d = i.inputHiddenSize,
                p = i.headSize,
                c = 12,
                b = {
                  x: Math.ceil(i.headSize / c),
                  y: Math.ceil(i.sequenceLength / c),
                  z: i.batchSize * i.numHeads
                },
                k = [r.inputs[0], r.inputs[1], r.inputs[2]],
                E = [
                  { type: 12, data: u },
                  { type: 12, data: d },
                  { type: 12, data: p },
                  { type: 12, data: i.numHeads },
                  { type: 12, data: i.headSize },
                  { type: 12, data: i.hiddenSize },
                  {
                    type: 12,
                    data: i.hiddenSize + i.hiddenSize + i.vHiddenSize
                  }
                ],
                q = (H) => {
                  let w = Ht("output_q", k[0].dataType, s),
                    Z = Ht("output_k", k[0].dataType, s),
                    re = Ht("output_v", k[0].dataType, s),
                    le = gt("input", k[0].dataType, k[0].dims),
                    we = gt("weight", k[1].dataType, k[1].dims),
                    be = gt("bias", k[2].dataType, k[2].dims),
                    me = le.type.storage,
                    Fe = [
                      { name: "M", type: "u32" },
                      { name: "K", type: "u32" },
                      { name: "N", type: "u32" },
                      { name: "num_heads", type: "u32" },
                      { name: "head_size", type: "u32" },
                      { name: "hidden_size", type: "u32" },
                      { name: "ldb", type: "u32" }
                    ];
                  return `
  const TILE_SIZE = ${c}u;
  var<workgroup> tileInput: array<${me}, ${c * c}>;
  var<workgroup> tileWeightQ: array<${me}, ${c * c}>;
  var<workgroup> tileWeightK: array<${me}, ${c * c}>;
  var<workgroup> tileWeightV: array<${me}, ${c * c}>;
  ${H.registerUniforms(Fe).declareVariables(le, we, be, w, Z, re)}
  ${H.mainStart([c, c, 1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${me}(0);
    var valueK = ${me}(0);
    var valueV = ${me}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
                };
              return r.compute(
                {
                  name: "AttentionPrepare",
                  shaderCache: { inputDependencies: ["type", "type", "type"] },
                  getRunData: () => ({
                    outputs: [
                      {
                        dims: s,
                        dataType: r.inputs[0].dataType,
                        gpuDataType: 0
                      },
                      {
                        dims: s,
                        dataType: r.inputs[0].dataType,
                        gpuDataType: 0
                      },
                      {
                        dims: s,
                        dataType: r.inputs[0].dataType,
                        gpuDataType: 0
                      }
                    ],
                    dispatchGroup: b,
                    programUniforms: E
                  }),
                  getShaderSource: q
                },
                { inputs: k, outputs: [-1, -1, -1] }
              );
            }),
            (uc = (r, i) => {
              let s = oc(r.inputs, i),
                [u, d, p] = lc(r, s);
              return To(
                r,
                u,
                d,
                p,
                r.inputs[4],
                void 0,
                void 0,
                void 0,
                r.inputs[5],
                s,
                i
              );
            });
        }),
        cc,
        dc,
        za,
        fc,
        vp = m(() => {
          bt(),
            Yt(),
            Zt(),
            wr(),
            cr(),
            (cc = (r, i) => {
              if (!r || r.length !== 5)
                throw new Error("BatchNormalization requires 5 inputs");
              let s = (u, d, p) => {
                let c = d.length;
                if (c !== u.length)
                  throw new Error(`${p}: num dimensions != ${c}`);
                d.forEach((b, k) => {
                  if (b !== u[k])
                    throw new Error(`${p}: dim[${k}] do not match`);
                });
              };
              if (r[0].dims.length > 1) {
                let u =
                  i.format === "NHWC"
                    ? i.spatial
                      ? r[0].dims.slice(-1)
                      : r[0].dims
                          .slice(-1)
                          .concat(r[0].dims.slice(1, r[0].dims.length - 1))
                    : r[0].dims.slice(1, i.spatial ? 2 : void 0);
                s(r[1].dims, u, "Invalid input scale"),
                  s(r[2].dims, u, "Invalid input B"),
                  s(r[3].dims, u, "Invalid input mean"),
                  s(r[4].dims, u, "Invalid input var");
              } else
                s(r[1].dims, [1], "Invalid input scale"),
                  s(r[2].dims, [1], "Invalid input B"),
                  s(r[3].dims, [1], "Invalid input mean"),
                  s(r[4].dims, [1], "Invalid input var");
            }),
            (dc = (r, i) => {
              let { epsilon: s, spatial: u, format: d } = i,
                p = r[0].dims,
                c = u ? $r(p[p.length - 1]) : 1,
                b = d === "NHWC" && p.length > 1 ? c : 1,
                k = Ze.size(p) / c,
                E = u,
                q = E ? p.length : p,
                H = gt("x", r[0].dataType, r[0].dims, c),
                w = gt("scale", r[1].dataType, r[1].dims, b),
                Z = gt("bias", r[2].dataType, r[2].dims, b),
                re = gt("inputMean", r[3].dataType, r[3].dims, b),
                le = gt("inputVar", r[4].dataType, r[4].dims, b),
                we = Ht("y", r[0].dataType, q, c),
                be = () => {
                  let Fe = "";
                  if (u)
                    Fe = `let cOffset = ${
                      p.length === 1
                        ? "0u"
                        : d === "NHWC"
                        ? `outputIndices[${p.length - 1}] / ${c}`
                        : "outputIndices[1]"
                    };`;
                  else if (d === "NCHW")
                    Fe = `
            ${we.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${we.indicesToOffset("outputIndices")};`;
                  else {
                    Fe = `var cIndices = ${w.type.indices}(0);
                       cIndices[0] = outputIndices[${p.length - 1}];`;
                    for (let Ce = 1; Ce < w.rank; Ce++)
                      Fe += `cIndices[${Ce}] = outputIndices[${Ce}];`;
                    Fe += `let cOffset = ${w.indicesToOffset("cIndices")};`;
                  }
                  return Fe;
                },
                me = (Fe) => `
  const epsilon = ${s};
  ${Fe.registerUniform("outputSize", "u32").declareVariables(
    H,
    w,
    Z,
    re,
    le,
    we
  )}
  ${Fe.mainStart()}
  ${Fe.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${we.offsetToIndices(`global_idx * ${c}`)};
    ${be()}
    let scale = ${w.getByOffset("cOffset")};
    let bias = ${Z.getByOffset("cOffset")};
    let inputMean = ${re.getByOffset("cOffset")};
    let inputVar = ${le.getByOffset("cOffset")};
    let x = ${H.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${we.setByOffset("global_idx", "value")}
  }`;
              return {
                name: "BatchNormalization",
                shaderCache: {
                  hint: `${i.epsilon}_${i.format}_${u}_${c}`,
                  inputDependencies: E
                    ? ["rank", "type", "type", "type", "type"]
                    : void 0
                },
                getShaderSource: me,
                getRunData: () => ({
                  outputs: [{ dims: r[0].dims, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(k / 64) },
                  programUniforms: E
                    ? [{ type: 12, data: k }, ...zt(p)]
                    : [{ type: 12, data: k }]
                })
              };
            }),
            (za = (r) => Qt(r)),
            (fc = (r, i) => {
              let { inputs: s, outputCount: u } = r,
                d = za({ ...i, outputCount: u });
              if ((N.webgpu.validateInputContent && cc(s, d), i.trainingMode))
                throw new Error(
                  "BatchNormalization trainingMode is not supported yet."
                );
              r.compute(dc(s, d));
            });
        }),
        pc,
        hc,
        Oa,
        bp = m(() => {
          Zt(),
            cr(),
            (pc = (r) => {
              if (r[0].dims.length !== 3)
                throw new Error("input should have 3 dimensions");
              if (![320, 640, 1280].includes(r[0].dims[2]))
                throw new Error(
                  "number of channels should be 320, 640 or 1280"
                );
              if (r[1].dims.length !== 1)
                throw new Error("bias is expected to have 1 dimensions");
              if (r[0].dims[2] !== r[1].dims[0])
                throw new Error(
                  "last dimension of input and bias are not the same"
                );
            }),
            (hc = (r) => {
              let i = r[0].dims,
                s = r[0].dims[2],
                u = Ze.size(i) / 4,
                d = r[0].dataType,
                p = gt("input", d, i, 4),
                c = gt("bias", d, [s], 4),
                b = gt("residual", d, i, 4),
                k = Ht("output", d, i, 4);
              return {
                name: "BiasAdd",
                getRunData: () => ({
                  outputs: [{ dims: i, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(u / 64) }
                }),
                getShaderSource: (E) => `
  const channels = ${s}u / 4;
  ${E.declareVariables(p, c, b, k)}

  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let value = ${p.getByOffset("global_idx")}
      + ${c.getByOffset("global_idx % channels")} + ${b.getByOffset(
                  "global_idx"
                )};
    ${k.setByOffset("global_idx", "value")}
  }`
              };
            }),
            (Oa = (r) => {
              pc(r.inputs), r.compute(hc(r.inputs));
            });
        }),
        mc,
        Tr,
        gc,
        _c,
        Da,
        yc,
        wc,
        La,
        vc,
        bc,
        Ba,
        xc,
        Mc,
        Bs,
        Tc,
        kc,
        Zo,
        Ra,
        Rs,
        Na,
        Sc,
        Ec,
        Cc,
        ja,
        Pc,
        $c,
        Ac,
        Ua,
        Ic,
        Fc,
        Va,
        zc,
        Oc,
        Wa,
        Dc,
        Ga,
        Ha,
        qa,
        Ka,
        Qa,
        Lc,
        Bc,
        Rc,
        Nc,
        Ns,
        Xa = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (mc = (r, i, s, u, d, p) => {
              let c = Math.ceil(i / 4),
                b = "";
              typeof d == "string" ? (b = `${d}(a)`) : (b = d("a"));
              let k = gt("inputData", s, [c], 4),
                E = Ht("outputData", u, [c], 4);
              return `
      ${r.registerUniform("vec_size", "u32").declareVariables(k, E)}

  ${p ?? ""}

  ${r.mainStart()}
    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${k.getByOffset("global_idx")};
    ${E.setByOffset("global_idx", b)}
  }`;
            }),
            (Tr = (r, i, s, u, d, p = r.dataType) => ({
              name: i,
              shaderCache: { hint: d, inputDependencies: ["type"] },
              getShaderSource: (c) =>
                mc(c, Ze.size(r.dims), r.dataType, p, s, u),
              getRunData: (c) => ({
                outputs: [{ dims: r.dims, dataType: p }],
                dispatchGroup: { x: Math.ceil(Ze.size(c[0].dims) / 64 / 4) },
                programUniforms: [
                  { type: 12, data: Math.ceil(Ze.size(r.dims) / 4) }
                ]
              })
            })),
            (gc = (r) => {
              r.compute(Tr(r.inputs[0], "Abs", "abs"));
            }),
            (_c = (r) => {
              r.compute(Tr(r.inputs[0], "Acos", "acos"));
            }),
            (Da = (r) => {
              r.compute(Tr(r.inputs[0], "Acosh", "acosh"));
            }),
            (yc = (r) => {
              r.compute(Tr(r.inputs[0], "Asin", "asin"));
            }),
            (wc = (r) => {
              r.compute(Tr(r.inputs[0], "Asinh", "asinh"));
            }),
            (La = (r) => {
              r.compute(Tr(r.inputs[0], "Atan", "atan"));
            }),
            (vc = (r) => {
              r.compute(Tr(r.inputs[0], "Atanh", "atanh"));
            }),
            (bc = (r) => Qt(r)),
            (Ba = (r, i) => {
              let s;
              switch (i.to) {
                case 10:
                  s = "vec4<f16>";
                  break;
                case 1:
                  s = "vec4<f32>";
                  break;
                case 12:
                  s = "vec4<u32>";
                  break;
                case 6:
                  s = "vec4<i32>";
                  break;
                case 9:
                  s = "vec4<bool>";
                  break;
                default:
                  throw new RangeError(
                    `not supported type (specified in attribute 'to' from 'Cast' operator): ${i.to}`
                  );
              }
              r.compute(Tr(r.inputs[0], "Cast", s, void 0, i.cacheKey, i.to));
            }),
            (xc = (r) => {
              let i =
                  r.length >= 2 && r[1].data !== 0
                    ? r[1].getFloat32Array()[0]
                    : hn,
                s =
                  r.length >= 3 && r[2].data !== 0
                    ? r[2].getFloat32Array()[0]
                    : Bn;
              return Qt({ min: i, max: s });
            }),
            (Mc = (r, i) => {
              let s = r.inputs.length === 1 ? i : xc(r.inputs),
                u = Pr(r.inputs[0].dataType);
              r.compute(
                Tr(
                  r.inputs[0],
                  "Clip",
                  (d) => `clamp(${d}, clip_min_, clip_max_)`,
                  `
    const clip_min_: vec4<${u}> = vec4(${u}(${s.min}));
    const clip_max_: vec4<${u}> = vec4(${u}(${s.max}));
`,
                  s.cacheKey
                ),
                { inputs: [0] }
              );
            }),
            (Bs = (r) => {
              r.compute(Tr(r.inputs[0], "Ceil", "ceil"));
            }),
            (Tc = (r) => {
              r.compute(Tr(r.inputs[0], "Cos", "cos"));
            }),
            (kc = (r) => {
              r.compute(Tr(r.inputs[0], "Cosh", "cosh"));
            }),
            (Zo = (r) => Qt(r)),
            (Ra = (r, i) => {
              let s = Pr(r.inputs[0].dataType);
              r.compute(
                Tr(
                  r.inputs[0],
                  "Elu",
                  (u) => `elu_vf32(${u})`,
                  `
  const elu_alpha_ = ${s}(${i.alpha});

  fn elu_f32(a: ${s}) -> ${s} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${s}>) -> vec4<${s}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,
                  i.cacheKey
                )
              );
            }),
            (Rs = (r = "f32") => `
const r0: ${r} = 0.3275911;
const r1: ${r} = 0.254829592;
const r2: ${r} = -0.284496736;
const r3: ${r} = 1.421413741;
const r4: ${r} = -1.453152027;
const r5: ${r} = 1.061405429;

fn erf_vf32(v: vec4<${r}>) -> vec4<${r}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`),
            (Na = (r) => {
              let i = Pr(r.inputs[0].dataType);
              r.compute(Tr(r.inputs[0], "Erf", (s) => `erf_vf32(${s})`, Rs(i)));
            }),
            (Sc = (r) => {
              r.compute(Tr(r.inputs[0], "Exp", "exp"));
            }),
            (Ec = (r) => {
              r.compute(Tr(r.inputs[0], "Floor", "floor"));
            }),
            (Cc = (r) => {
              let i = Pr(r.inputs[0].dataType);
              r.compute(
                Tr(
                  r.inputs[0],
                  "Gelu",
                  (s) =>
                    `0.5 * ${s} * (1.0 + erf_vf32(${s} * 0.7071067811865475))`,
                  Rs(i)
                )
              );
            }),
            (ja = (r, i) => {
              let s = Pr(r.inputs[0].dataType);
              r.compute(
                Tr(
                  r.inputs[0],
                  "LeakyRelu",
                  (u) =>
                    `select(leaky_relu_alpha_ * ${u}, ${u}, ${u} >= vec4<${s}>(0.0))`,
                  `const leaky_relu_alpha_ = ${s}(${i.alpha});`,
                  i.cacheKey
                )
              );
            }),
            (Pc = (r) => {
              r.compute(Tr(r.inputs[0], "Not", (i) => `!${i}`));
            }),
            ($c = (r) => {
              r.compute(Tr(r.inputs[0], "Neg", (i) => `-${i}`));
            }),
            (Ac = (r) => {
              r.compute(Tr(r.inputs[0], "Reciprocal", (i) => `1.0/${i}`));
            }),
            (Ua = (r) => {
              let i = Pr(r.inputs[0].dataType);
              r.compute(
                Tr(
                  r.inputs[0],
                  "Relu",
                  (s) => `select(vec4<${i}>(0.0), ${s}, ${s} > vec4<${i}>(0.0))`
                )
              );
            }),
            (Ic = (r) => {
              r.compute(
                Tr(r.inputs[0], "Sigmoid", (i) => `(1.0 / (1.0 + exp(-${i})))`)
              );
            }),
            (Fc = (r) => Qt(r)),
            (Va = (r, i) => {
              let s = Pr(r.inputs[0].dataType);
              r.compute(
                Tr(
                  r.inputs[0],
                  "HardSigmoid",
                  (u) =>
                    `max(vec4<${s}>(0.0), min(vec4<${s}>(1.0), ${i.alpha} * ${u} + vec4<${s}>(${i.beta})))`,
                  void 0,
                  i.cacheKey
                )
              );
            }),
            (zc = (r) => {
              r.compute(Tr(r.inputs[0], "Sin", "sin"));
            }),
            (Oc = (r) => {
              r.compute(Tr(r.inputs[0], "Sinh", "sinh"));
            }),
            (Wa = (r) => {
              r.compute(Tr(r.inputs[0], "Sqrt", "sqrt"));
            }),
            (Dc = (r) => {
              r.compute(Tr(r.inputs[0], "Tan", "tan"));
            }),
            (Ga = (r) =>
              `sign(${r}) * (1 - exp(-2 * abs(${r}))) / (1 + exp(-2 * abs(${r})))`),
            (Ha = (r) => {
              r.compute(Tr(r.inputs[0], "Tanh", Ga));
            }),
            (qa = (r = "f32") => `
const fast_gelu_a: ${r} = 0.5;
const fast_gelu_b: ${r} = 0.7978845608028654;
const fast_gelu_c: ${r} = 0.035677408136300125;

fn tanh_v(v: vec4<${r}>) -> vec4<${r}> {
  return ${Ga("v")};
}
`),
            (Ka = (r) =>
              `(fast_gelu_a + fast_gelu_a * tanh_v(${r} * (fast_gelu_c * ${r} * ${r} + fast_gelu_b))) * ${r}`),
            (Qa = (r) => {
              let i = Pr(r.inputs[0].dataType);
              r.compute(
                Tr(
                  r.inputs[0],
                  "FastGelu",
                  Ka,
                  qa(i),
                  void 0,
                  r.inputs[0].dataType
                )
              );
            }),
            (Lc = (r, i) => {
              let s = Pr(r.inputs[0].dataType);
              return (
                r.compute(
                  Tr(
                    r.inputs[0],
                    "ThresholdedRelu",
                    (u) =>
                      `select(vec4<${s}>(0.0), ${u}, ${u} > thresholded_relu_alpha_)`,
                    `const thresholded_relu_alpha_ = vec4<${s}>(${i.alpha});`,
                    i.cacheKey
                  )
                ),
                0
              );
            }),
            (Bc = (r) => {
              r.compute(Tr(r.inputs[0], "Log", "log"));
            }),
            (Rc = (r, i) => `
const alpha = vec4<${r}>(${i});
const one = ${r}(1.0);
const zero = ${r}(0.0);

fn quick_gelu_impl(x: vec4<${r}>) -> vec4<${r}> {
  let v = x *alpha;
  var x1 : vec4<${r}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`),
            (Nc = (r) => `quick_gelu_impl(${r})`),
            (Ns = (r, i) => {
              let s = Pr(r.inputs[0].dataType);
              r.compute(
                Tr(
                  r.inputs[0],
                  "QuickGelu",
                  Nc,
                  Rc(s, i.alpha),
                  i.cacheKey,
                  r.inputs[0].dataType
                )
              );
            });
        }),
        jc,
        Uc,
        Ya,
        xp = m(() => {
          Zt(),
            cr(),
            Xa(),
            (jc = (r) => {
              if (r[0].dims.length !== 3)
                throw new Error("input should have 3 dimensions");
              if (![2560, 5120, 10240].includes(r[0].dims[2]))
                throw new Error("hidden state should be 2560, 5120 or 10240");
              if (r[1].dims.length !== 1)
                throw new Error("bias is expected to have 1 dimensions");
              if (r[0].dims[2] !== r[1].dims[0])
                throw new Error(
                  "last dimension of input and bias are not the same"
                );
            }),
            (Uc = (r) => {
              let i = r[0].dims.slice();
              i[2] = i[2] / 2;
              let s = gt("input", r[0].dataType, r[0].dims, 4),
                u = gt("bias", r[0].dataType, [r[0].dims[2]], 4),
                d = Ht("output", r[0].dataType, i, 4),
                p = Ze.size(i) / 4,
                c = Fr(r[0].dataType);
              return {
                name: "BiasSplitGelu",
                getRunData: () => ({
                  outputs: [{ dims: i, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(p / 64) }
                }),
                getShaderSource: (b) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${r[0].dims[2] / 4 / 2}u;

  ${b.declareVariables(s, u, d)}

  ${Rs(c)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes(p)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${d.setByOffset("global_idx", "valueLeft * geluRight")}
  }`
              };
            }),
            (Ya = (r) => {
              jc(r.inputs), r.compute(Uc(r.inputs));
            });
        }),
        Vc,
        Wc,
        ci,
        Za,
        Gc,
        Hc,
        Ja,
        qc,
        Kc,
        el,
        Qc,
        Xc,
        tl,
        Mp = m(() => {
          Yt(),
            Zt(),
            cr(),
            (Vc = (r, i, s, u, d, p, c, b, k, E, q, H) => {
              let w, Z;
              typeof b == "string"
                ? (w = Z = (me, Fe) => `${b}((${me}),(${Fe}))`)
                : typeof b == "function"
                ? (w = Z = b)
                : ((w = b.scalar), (Z = b.vector));
              let re = Ht("outputData", q, u.length, 4),
                le = gt("aData", k, i.length, 4),
                we = gt("bData", E, s.length, 4),
                be;
              if (d)
                if (p) {
                  let me = Ze.size(i) === 1,
                    Fe = Ze.size(s) === 1,
                    Ce = i.length > 0 && i[i.length - 1] % 4 === 0,
                    ze = s.length > 0 && s[s.length - 1] % 4 === 0;
                  me || Fe
                    ? (be = re.setByOffset(
                        "global_idx",
                        Z(
                          me
                            ? `${le.type.value}(${le.getByOffset("0")}.x)`
                            : le.getByOffset("global_idx"),
                          Fe
                            ? `${we.type.value}(${we.getByOffset("0")}.x)`
                            : we.getByOffset("global_idx")
                        )
                      ))
                    : (be = `
            let outputIndices = ${re.offsetToIndices("global_idx * 4u")};
            let offsetA = ${le.broadcastedIndicesToOffset("outputIndices", re)};
            let offsetB = ${we.broadcastedIndicesToOffset("outputIndices", re)};
            ${re.setByOffset(
              "global_idx",
              Z(
                c || Ce
                  ? le.getByOffset("offsetA / 4u")
                  : `${le.type.value}(${le.getByOffset(
                      "offsetA / 4u"
                    )}[offsetA % 4u])`,
                c || ze
                  ? we.getByOffset("offsetB / 4u")
                  : `${we.type.value}(${we.getByOffset(
                      "offsetB / 4u"
                    )}[offsetB % 4u])`
              )
            )}
          `);
                } else
                  be = re.setByOffset(
                    "global_idx",
                    Z(
                      le.getByOffset("global_idx"),
                      we.getByOffset("global_idx")
                    )
                  );
              else {
                if (!p)
                  throw new Error(
                    "no necessary to use scalar implementation for element-wise binary op implementation."
                  );
                let me = (Fe, Ce, ze = "") => {
                  let dt = `aData[indexA${Ce}][componentA${Ce}]`,
                    lt = `bData[indexB${Ce}][componentB${Ce}]`;
                  return `
            let outputIndices${Ce} = ${re.offsetToIndices(
                    `global_idx * 4u + ${Ce}u`
                  )};
            let offsetA${Ce} = ${le.broadcastedIndicesToOffset(
                    `outputIndices${Ce}`,
                    re
                  )};
            let offsetB${Ce} = ${we.broadcastedIndicesToOffset(
                    `outputIndices${Ce}`,
                    re
                  )};
            let indexA${Ce} = offsetA${Ce} / 4u;
            let indexB${Ce} = offsetB${Ce} / 4u;
            let componentA${Ce} = offsetA${Ce} % 4u;
            let componentB${Ce} = offsetB${Ce} % 4u;
            ${Fe}[${Ce}] = ${ze}(${w(dt, lt)});
          `;
                };
                q === 9
                  ? (be = `
            var data = vec4<u32>(0);
            ${me("data", 0, "u32")}
            ${me("data", 1, "u32")}
            ${me("data", 2, "u32")}
            ${me("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`)
                  : (be = `
            ${me("outputData[global_idx]", 0)}
            ${me("outputData[global_idx]", 1)}
            ${me("outputData[global_idx]", 2)}
            ${me("outputData[global_idx]", 3)}
          `);
              }
              return `
        ${r.registerUniform("vec_size", "u32").declareVariables(le, we, re)}

        ${H ?? ""}

        ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${be}
      }`;
            }),
            (Wc = (r, i, s, u, d, p, c = s.dataType) => {
              let b = !Ze.areEqual(s.dims, u.dims),
                k = s.dims,
                E = Ze.size(s.dims),
                q = !1,
                H = !1,
                w = [b];
              if (b) {
                let Z = vn.calcShape(s.dims, u.dims, !1);
                if (!Z)
                  throw new Error(
                    "Can't perform binary op on the given tensors"
                  );
                (k = Z), (E = Ze.size(k));
                let re = Ze.size(s.dims) === 1,
                  le = Ze.size(u.dims) === 1,
                  we = s.dims.length > 0 && s.dims[s.dims.length - 1] % 4 === 0,
                  be = u.dims.length > 0 && u.dims[u.dims.length - 1] % 4 === 0;
                w.push(re), w.push(le), w.push(we), w.push(be);
                let me = 1;
                for (let Fe = 1; Fe < k.length; Fe++) {
                  let Ce = s.dims[s.dims.length - Fe] ?? 1,
                    ze = u.dims[u.dims.length - Fe] ?? 1;
                  if (Ce === ze) me *= Ce;
                  else break;
                }
                me % 4 === 0
                  ? ((H = !0), (q = !0))
                  : (re || le || we || be) && (q = !0);
              } else q = !0;
              return (
                w.push(q),
                {
                  name: r,
                  shaderCache: {
                    hint: i + w.map((Z) => Z.toString()).join("_"),
                    inputDependencies: ["rank", "rank"]
                  },
                  getShaderSource: (Z) =>
                    Vc(
                      Z,
                      s.dims,
                      u.dims,
                      k,
                      q,
                      b,
                      H,
                      d,
                      s.dataType,
                      u.dataType,
                      c,
                      p
                    ),
                  getRunData: () => ({
                    outputs: [{ dims: k, dataType: c }],
                    dispatchGroup: { x: Math.ceil(E / 64 / 4) },
                    programUniforms: [
                      { type: 12, data: Math.ceil(Ze.size(k) / 4) },
                      ...zt(s.dims, u.dims, k)
                    ]
                  })
                }
              );
            }),
            (ci = (r, i, s, u, d, p) => {
              r.compute(Wc(i, d ?? "", r.inputs[0], r.inputs[1], s, u, p));
            }),
            (Za = (r) => {
              ci(r, "Add", (i, s) => `${i}+${s}`);
            }),
            (Gc = (r) => {
              ci(r, "Div", (i, s) => `${i}/${s}`);
            }),
            (Hc = (r) => {
              ci(
                r,
                "Equal",
                {
                  scalar: (i, s) => `u32(${i}==${s})`,
                  vector: (i, s) => `vec4<u32>(${i}==${s})`
                },
                void 0,
                void 0,
                9
              );
            }),
            (Ja = (r) => {
              ci(r, "Mul", (i, s) => `${i}*${s}`);
            }),
            (qc = (r) => {
              let i = gt("input", r.inputs[0].dataType, r.inputs[0].dims).type
                .value;
              ci(
                r,
                "Pow",
                {
                  scalar: (s, u) => `pow_custom(${s},${u})`,
                  vector: (s, u) => `pow_vector_custom(${s},${u})`
                },
                `
    fn pow_custom(a : ${i}, b : ${i}) -> ${i} {
      if (b == ${i}(0.0)) {
        return ${i}(1.0);
      } else if (a < ${i}(0.0) && f32(b) != floor(f32(b))) {
        return ${i}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${i}(1.0), round(f32(abs(b) % ${i}(2.0))) != 1.0) * ${i}(${
                  i === "i32" ? "round" : ""
                }(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${i}>, b : vec4<${i}>) -> vec4<${i}> {
      // TODO: implement vectorized pow
      return vec4<${i}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `
              );
            }),
            (Kc = (r) => {
              ci(r, "Sub", (i, s) => `${i}-${s}`);
            }),
            (el = (r) => {
              ci(
                r,
                "Greater",
                {
                  scalar: (i, s) => `u32(${i}>${s})`,
                  vector: (i, s) => `vec4<u32>(${i}>${s})`
                },
                void 0,
                void 0,
                9
              );
            }),
            (Qc = (r) => {
              ci(
                r,
                "Less",
                {
                  scalar: (i, s) => `u32(${i}<${s})`,
                  vector: (i, s) => `vec4<u32>(${i}<${s})`
                },
                void 0,
                void 0,
                9
              );
            }),
            (Xc = (r) => {
              ci(
                r,
                "GreaterOrEqual",
                {
                  scalar: (i, s) => `u32(${i}>=${s})`,
                  vector: (i, s) => `vec4<u32>(${i}>=${s})`
                },
                void 0,
                void 0,
                9
              );
            }),
            (tl = (r) => {
              ci(
                r,
                "LessOrEqual",
                {
                  scalar: (i, s) => `u32(${i}<=${s})`,
                  vector: (i, s) => `vec4<u32>(${i}<=${s})`
                },
                void 0,
                void 0,
                9
              );
            });
        }),
        Yc,
        Zc,
        Jc,
        ed,
        td,
        rl,
        Tp = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (Yc = (r, i) => {
              if (!r || r.length < 1) throw new Error("too few inputs");
              let s = 0,
                u = r[s],
                d = u.dataType,
                p = u.dims.length;
              r.forEach((c, b) => {
                if (b !== s) {
                  if (c.dataType !== d)
                    throw new Error("input tensors should be one type");
                  if (c.dims.length !== p)
                    throw new Error("input tensors should have the same shape");
                  c.dims.forEach((k, E) => {
                    if (E !== i && k !== u.dims[E])
                      throw new Error("non concat dimensions must match");
                  });
                }
              });
            }),
            (Zc = (r, i) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${r}u>(${i});
    for (var i: u32 = 0u; i < ${r}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${r}u;
  }`),
            (Jc = (r, i) => {
              let s = r.length,
                u = [];
              for (let d = 0; d < s; ++d) {
                let p = i.setByOffset(
                  "global_idx",
                  r[d].getByIndices("indices")
                );
                s === 1
                  ? u.push(p)
                  : d === 0
                  ? u.push(`if (inputIndex == ${d}u) { ${p} }`)
                  : d === s - 1
                  ? u.push(`else { ${p} }`)
                  : u.push(`else if (inputIndex == ${d}) { ${p} }`);
              }
              return u.join(`
`);
            }),
            (ed = (r, i, s, u) => {
              let d = Ze.size(s),
                p = new Array(r.length),
                c = new Array(r.length),
                b = 0,
                k = [],
                E = [],
                q = [{ type: 12, data: d }];
              for (let le = 0; le < r.length; ++le)
                (b += r[le].dims[i]),
                  (p[le] = b),
                  E.push(r[le].dims.length),
                  (c[le] = gt(`input${le}`, u, E[le])),
                  k.push("rank"),
                  q.push({ type: 12, data: p[le] });
              for (let le = 0; le < r.length; ++le) q.push(...zt(r[le].dims));
              q.push(...zt(s));
              let H = Ht("output", u, s.length),
                w = H.indicesGet("indices", i),
                Z = Array.from(Array(p.length).keys())
                  .map((le) => `uniforms.sizeInConcatAxis${le}`)
                  .join(","),
                re = (le) => `

  ${(() => {
    le.registerUniform("outputSize", "u32");
    for (let we = 0; we < r.length; we++)
      le.registerUniform(`sizeInConcatAxis${we}`, "u32");
    return le.declareVariables(...c, H);
  })()}

  ${Zc(p.length, Z)}

  ${le.mainStart()}
    ${le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${H.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${w});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${p.length}u>(${Z});
      ${w} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Jc(c, H)}
  }`;
              return {
                name: "Concat",
                shaderCache: { hint: `${i}`, inputDependencies: k },
                getRunData: () => ({
                  outputs: [{ dims: s, dataType: u }],
                  dispatchGroup: { x: Math.ceil(d / 64) },
                  programUniforms: q
                }),
                getShaderSource: re
              };
            }),
            (td = (r, i) => {
              let s = r.inputs,
                u = s[0].dims,
                d = Ze.normalizeAxis(i.axis, u.length);
              Yc(s, d);
              let p = u.slice();
              p[d] = s.reduce(
                (b, k) => b + (k.dims.length > d ? k.dims[d] : 0),
                0
              );
              let c = s.filter((b) => Ze.size(b.dims) > 0);
              r.compute(ed(c, d, p, s[0].dataType), { inputs: c });
            }),
            (rl = (r) => Qt({ axis: r.axis }));
        }),
        qi,
        zi,
        Ki,
        nl,
        Rn = m(() => {
          Yt(),
            Zt(),
            (qi = (r, i, s = "f32") => {
              switch (r.activation) {
                case "Relu":
                  return `value = max(value, ${i}(0.0));`;
                case "Sigmoid":
                  return `value = (${i}(1.0) / (${i}(1.0) + exp(-value)));`;
                case "Clip":
                  return `value = clamp(value, ${i}(${s}(uniforms.clip_min)), ${i}(${s}(uniforms.clip_max)));`;
                case "HardSigmoid":
                  return `value = max(${i}(0.0), min(${i}(1.0), ${s}(uniforms.alpha) * value + ${s}(uniforms.beta)));`;
                case "LeakyRelu":
                  return `value = select(${s}(uniforms.alpha) * value, value, value >= ${i}(0.0));`;
                case "Tanh":
                  return `let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;
                case "":
                  return "";
                default:
                  throw new Error(`Unsupported activation ${r.activation}`);
              }
            }),
            (zi = (r, i) => {
              r.activation === "Clip"
                ? i.push(
                    { type: 1, data: r.clipMax },
                    { type: 1, data: r.clipMin }
                  )
                : r.activation === "HardSigmoid"
                ? i.push({ type: 1, data: r.alpha }, { type: 1, data: r.beta })
                : r.activation === "LeakyRelu" &&
                  i.push({ type: 1, data: r.alpha });
            }),
            (Ki = (r, i) => {
              r.activation === "Clip"
                ? i.push(
                    { name: "clip_max", type: "f32" },
                    { name: "clip_min", type: "f32" }
                  )
                : r.activation === "HardSigmoid"
                ? i.push(
                    { name: "alpha", type: "f32" },
                    { name: "beta", type: "f32" }
                  )
                : r.activation === "LeakyRelu" &&
                  i.push({ name: "alpha", type: "f32" });
            }),
            (nl = (r) => {
              let i = (r == null ? void 0 : r.activation) || "";
              if (i === "HardSigmoid") {
                let [s, u] = (r == null ? void 0 : r.activation_params) || [
                  0.2, 0.5
                ];
                return { activation: i, alpha: s, beta: u };
              } else if (i === "Clip") {
                let [s, u] = (r == null ? void 0 : r.activation_params) || [
                  hn,
                  Bn
                ];
                return { activation: i, clipMax: u, clipMin: s };
              } else if (i === "LeakyRelu") {
                let [s] = (r == null ? void 0 : r.activation_params) || [0.01];
                return { activation: i, alpha: s };
              }
              return { activation: i };
            });
        }),
        Sn,
        il,
        js = m(() => {
          (Sn = (r, i) => {
            switch (r) {
              case 1:
                return i;
              case 2:
                return `vec2<${i}>`;
              case 3:
                return `vec3<${i}>`;
              case 4:
                return `vec4<${i}>`;
              default:
                throw new Error(`${r}-component is not supported.`);
            }
          }),
            (il = (r) => `
      ${r ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `);
        }),
        ol,
        sl = m(() => {
          ol = (r) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${r}.x), i32(${r}.y), i32(${r}.z), 1));
}
`;
        }),
        rd,
        nd,
        Us,
        al,
        Vs,
        Ws,
        id,
        ll,
        io = m(() => {
          Yt(),
            Zt(),
            cr(),
            Rn(),
            js(),
            (rd = (r, i) =>
              r
                ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${
            i ? ", batchIndices" : ""
          });
        `
                : `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${i ? ", batchIndices" : ""});
        `),
            (nd = (r, i) =>
              r
                ? `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${
          i === 3
            ? ""
            : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"
        }
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${i === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`
                : `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${i === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`),
            (Us = (r, i, s = "f32", u, d = !1, p = 32, c = !1, b = 32) => {
              let k = i[1] * r[1],
                E = i[0] * r[0],
                q = d ? k : p,
                H = d ? p : k,
                w = q / i[0],
                Z = p / i[1];
              if (
                !(
                  ((d && w === 4 && r[1] === 4) ||
                    (!d && (w === 3 || w === 4))) &&
                  q % i[0] === 0 &&
                  p % i[1] === 0 &&
                  r[0] === 4
                )
              )
                throw new Error(`If transposeA ${d} is true, innerElementSize ${w} and workPerThread[1] ${r[1]} must be 4.
      Otherwise, innerElementSize ${w} must be 3 or 4.
  tileAWidth ${q} must be divisible by workgroupSize[0]${i[0]}. tileInner ${p} must be divisible by workgroupSize[1] ${i[1]}. colPerThread ${r[0]} must be 4.`);
              return `
var<workgroup> mm_Asub: array<array<vec${w}<${s}>, ${q / w}>, ${H}>;
var<workgroup> mm_Bsub: array<array<vec4<${s}>, ${E / r[0]}>, ${p}>;

const rowPerThread = ${r[1]};
const colPerThread = ${r[0]};
const innerElementSize = ${w};
const tileInner = ${p};

@compute @workgroup_size(${i[0]}, ${i[1]}, ${i[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${c ? "0" : "i32(globalId.z)"};
  ${u ? `let batchIndices = ${u.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${k};

  let num_tiles = ${
    c ? `${Math.ceil(b / p)}` : "(uniforms.dim_inner - 1) / tileInner + 1"
  };
  var kStart = ${c ? `i32(globalId.z) * ${b}` : "0"};

  var acc: array<vec4<${s}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${Z};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${rd(d, u)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${Z}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${
            u ? ", batchIndices" : ""
          });
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${
            w === 3
              ? ""
              : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"
          }

          ${nd(d, w)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
            }),
            (al = (r, i) =>
              r
                ? `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${i ? ", batchIndices" : ""});
            `
                : `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${i ? ", batchIndices" : ""});
            `),
            (Vs = (r) =>
              r
                ? "let ACached = mm_Asub[k][tileRow + innerRow];"
                : "let ACached = mm_Asub[tileRow + innerRow][k];"),
            (Ws = (
              r,
              i,
              s = "f32",
              u,
              d = !1,
              p = 32,
              c = !1,
              b = 32,
              k = !1
            ) => {
              let E = r[1] * i[1],
                q = r[0] * i[0],
                H = d ? E : p,
                w = d ? p : E;
              if (!(w % i[1] === 0 && H % i[0] === 0 && p % i[1] === 0))
                throw new Error(
                  `tileAHight ${w} must be divisible by workgroupSize[1]${i[1]}, tileAWidth ${H} must be divisible by workgroupSize[0]${i[0]}, tileInner ${p} must be divisible by workgroupSize[1]${i[1]}`
                );
              let Z = w / i[1],
                re = H / i[0],
                le = p / i[1],
                we = k
                  ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${E};
    let globalColStart = i32(workgroupId.x) * ${q};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${w}; inputRow = inputRow + ${
                      i[1]
                    }) {
        for (var inputCol = localCol; inputCol < ${H}; inputCol = inputCol + ${
                      i[0]
                    }) {
          ${al(d, u)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${
                      i[1]
                    }) {
            for (var inputCol = localCol; inputCol < ${q}; inputCol = inputCol + ${
                      i[0]
                    }) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${u ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${s}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${i[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${
            d
              ? `mm_Asub[k][localRow + innerRow * ${i[1]}];`
              : `mm_Asub[localRow + innerRow * ${i[1]}][k];`
          }
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${i[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${i[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `
                  : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${E};

let tileRowA = i32(localId.y) * ${Z};
let tileColA = i32(localId.x) * ${re};
let tileRowB = i32(localId.y) * ${le};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${Z}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${re}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${al(d, u)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${le}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${u ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${s}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Vs(d)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
              return `
  var<workgroup> mm_Asub : array<array<${s}, ${H}>, ${w}>;
  var<workgroup> mm_Bsub : array<array<${s}, ${q}>, ${p}>;
  const rowPerThread = ${r[1]};
  const colPerThread = ${r[0]};
  const tileInner = ${p};

@compute @workgroup_size(${i[0]}, ${i[1]}, ${i[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${c ? "0" : "i32(globalId.z)"};
    ${u ? `let batchIndices = ${u.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${
      c ? `${Math.ceil(b / p)}` : "(uniforms.dim_inner - 1) / tileInner + 1"
    };
    var kStart = ${c ? `i32(globalId.z) * ${b}` : "0"};

    var acc : array<array<${s}, colPerThread>, rowPerThread>;
    ${we}
  }
`;
            }),
            (id = (r, i, s, u, d, p = !1) => {
              let [c, b, k] = d,
                [E, q, H, w] = u,
                Z = xo(c, k),
                re = xo(b, k),
                le = Fr(u[0].type.tensor),
                we = () => {
                  let me = q.rank,
                    Fe = E.rank,
                    Ce = `var aIndices: ${q.type.indices};`;
                  for (let ze = me - 2 - 1, dt = Fe - 1; ze >= 0; ze--, dt--)
                    Ce += `
aIndices[${ze}] = ${Fe > 1 ? `batchIndices[${dt}]` : "batchIndices"};`;
                  return (
                    Z.forEach((ze) => {
                      Ce += `
aIndices[${ze}] = 0;`;
                    }),
                    (Ce += `
aIndices[${me - 2}] = u32(row);
                   aIndices[${me - 1}] = u32(colIn);`),
                    Ce
                  );
                },
                be = () => {
                  let me = H.rank,
                    Fe = E.rank,
                    Ce = `var bIndices: ${H.type.indices};`;
                  for (let ze = me - 2 - 1, dt = Fe - 1; ze >= 0; ze--, dt--)
                    Ce += `
bIndices[${ze}] = ${Fe > 1 ? `batchIndices[${dt}]` : "batchIndices"};`;
                  return (
                    re.forEach((ze) => {
                      Ce += `
bIndices[${ze}] = 0;`;
                    }),
                    (Ce += `
bIndices[${me - 2}] = u32(row);
                   bIndices[${me - 1}] = u32(colIn);`),
                    Ce
                  );
                };
              return `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${
      E.type.indices
    }) -> ${Sn(r, le)} {
      var value = ${Sn(r, le)}(0.0);
      let col = colIn * ${r};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${we()}
        value = ${q.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${
      E.type.indices
    }) -> ${Sn(r, le)} {
      var value = ${Sn(r, le)}(0.0);
      let col = colIn * ${r};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${be()}
        value = ${H.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Sn(r, le)}) {
      let col = colIn * ${r};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${
          i
            ? `value = value + ${
                p ? "bias[colIn]" : `${Sn(r, le)}(bias[row])`
              };`
            : ""
        }
        ${s}
        ${w.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
            }),
            (ll = (r, i, s, u, d = !1, p) => {
              let c = r[0].dims,
                b = r[1].dims,
                k = c.slice(0, -2),
                E = b.slice(0, -2),
                q = u ? u.slice(0, -2) : s.slice(0, -2),
                H = Ze.size(q),
                w = c[c.length - 2],
                Z = c[c.length - 1],
                re = b[b.length - 1],
                le = Z % 4 === 0 && re % 4 === 0,
                we = w <= 8 ? [4, 1, 1] : [4, 4, 1],
                be = [8, 8, 1],
                me = [
                  Math.ceil(re / be[0] / we[0]),
                  Math.ceil(w / be[1] / we[1]),
                  Math.ceil(H / be[2] / we[2])
                ],
                Fe = le ? 4 : 1,
                Ce = [...k, w, Z / Fe],
                ze = Ce.length,
                dt = [...E, Z, re / Fe],
                lt = dt.length,
                Mt = [H, w, re / Fe],
                Dt = [
                  { type: 6, data: w },
                  { type: 6, data: re },
                  { type: 6, data: Z }
                ];
              zi(i, Dt), Dt.push(...zt(q, Ce, dt));
              let Ut = ["rank", "rank"],
                fr = r.length > 2;
              fr && (Dt.push(...zt(r[2].dims)), Ut.push("rank")),
                Dt.push(...zt(Mt));
              let br = (rr) => {
                let Wr = q.length,
                  Jr = _a("batchDims", r[0].dataType, Wr, 1),
                  Sr = Fr(r[0].dataType),
                  Hr = gt("a", r[0].dataType, ze, Fe),
                  tr = gt("b", r[1].dataType, lt, Fe),
                  _r = Ht("result", r[0].dataType, Mt.length, Fe),
                  zr = [Hr, tr];
                if (fr) {
                  let gn = d ? Fe : 1;
                  zr.push(gt("bias", r[2].dataType, r[2].dims.length, gn));
                }
                let ut = [
                  { name: "dim_a_outer", type: "i32" },
                  { name: "dim_b_outer", type: "i32" },
                  { name: "dim_inner", type: "i32" }
                ];
                Ki(i, ut);
                let At = Fr(_r.type.tensor),
                  sr = qi(i, _r.type.value, At),
                  Gr = id(Fe, fr, sr, [Jr, Hr, tr, _r], [k, E, q], d);
                return `
  ${rr
    .registerUniforms(ut)
    .registerInternalVariables(Jr)
    .declareVariables(...zr, _r)}
  ${Gr}
  ${le ? Us(we, be, Sr, Jr) : Ws(we, be, Sr, Jr)}
                   `;
              };
              return {
                name: "MatMul",
                shaderCache: {
                  hint: `${we};${i.activation};${le};${d}`,
                  inputDependencies: Ut
                },
                getRunData: () => ({
                  outputs: [{ dims: p ? p(s) : s, dataType: r[0].dataType }],
                  dispatchGroup: { x: me[0], y: me[1], z: me[2] },
                  programUniforms: Dt
                }),
                getShaderSource: br
              };
            });
        }),
        od,
        sd,
        kp = m(() => {
          Yt(),
            qn(),
            cr(),
            Rn(),
            js(),
            sl(),
            io(),
            (od = (r, i, s, u, d = !1, p, c = 4, b = 4, k = 4, E = "f32") => {
              let q = (Dt) => {
                  switch (Dt) {
                    case 1:
                      return "resData = x[xIndex];";
                    case 3:
                      return `resData = vec3<${E}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
                    case 4:
                      return "resData = x[xIndex / 4];";
                    default:
                      throw new Error(
                        `innerElementSize ${Dt} is not supported.`
                      );
                  }
                },
                H = (Dt) => {
                  switch (Dt) {
                    case 1:
                      return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
                    case 4:
                      return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
                    default:
                      throw new Error(
                        `innerElementSize ${Dt} is not supported.`
                      );
                  }
                },
                w = r
                  ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `
                  : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,
                Z = r
                  ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `
                  : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,
                re = r
                  ? "i32(uniforms.x_shape[1])"
                  : "i32(uniforms.x_shape[2])",
                le = r
                  ? "i32(uniforms.x_shape[2])"
                  : "i32(uniforms.x_shape[3])",
                we = r ? "row" : "col",
                be = r ? "col" : "row",
                me = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${
      r ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"
    };
    let outRow = ${we} / outWidth;
    let outCol = ${we} % outWidth;

    let WRow = ${be} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${be} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${be} % inChannels;
    var resData = ${Sn(c, E)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${re} && xCol >= 0 && xCol < ${le}) {
      ${w}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${q(c)}
    }
    return resData;`,
                Fe = r
                  ? i && u
                    ? `
    let col = colIn * ${c};
    ${me}`
                    : `
    let col = colIn * ${c};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${me}
    }
    return ${Sn(c, E)}(0.0);`
                  : u && s
                  ? `
    let col = colIn * ${c};
    ${me}`
                  : `
    let col = colIn * ${c};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${me}
    }
    return ${Sn(c, E)}(0.0);`,
                Ce = `${H(b)}`,
                ze = Sn(k, E),
                dt = Sn(r ? c : b, E),
                lt = Sn(r ? b : c, E),
                Mt = qi(p, ze, E);
              return `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${dt} {
      ${r ? Fe : Ce}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${lt} {
      ${r ? Ce : Fe}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${ze}) {
      let col = colIn * ${k};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${
        r ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"
      };
      ${Z}
      ${il(d)}
      ${Mt}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
            }),
            (sd = (r, i, s, u, d, p, c, b, k) => {
              let E = i.format === "NHWC",
                q = E ? r[0].dims[3] : r[0].dims[1],
                H = s[0],
                w = E ? s[2] : s[3],
                Z = E ? s[1] : s[2],
                re = E ? s[3] : s[1],
                le = E && (q % 4 === 0 || q % 3 === 0) && re % 4 === 0,
                we = E ? re : w * Z,
                be = E ? w * Z : re,
                me = [8, 8, 1],
                Fe = u <= 8 ? [4, 1, 1] : [4, 4, 1],
                Ce = [
                  Math.ceil(we / me[0] / Fe[0]),
                  Math.ceil(be / me[1] / Fe[1]),
                  Math.ceil(H / me[2] / Fe[2])
                ];
              Kr("verbose", () => `[conv2d_mm_webgpu] dispatch = ${Ce}`);
              let ze = le ? (E && q % 4 !== 0 ? 3 : 4) : 1,
                dt = me[1] * Fe[1],
                lt = me[0] * Fe[0],
                Mt = Math.max(me[0] * ze, me[1]),
                Dt = u % dt === 0,
                Ut = d % lt === 0,
                fr = p % Mt === 0,
                br = le ? [ze, 4, 4] : [1, 1, 1],
                rr = [
                  { type: 6, data: u },
                  { type: 6, data: d },
                  { type: 6, data: p },
                  { type: 6, data: [i.pads[0], i.pads[1]] },
                  { type: 6, data: i.strides },
                  { type: 6, data: i.dilations }
                ];
              zi(i, rr), rr.push(...zt(r[0].dims, r[1].dims));
              let Wr = ["rank", "rank"];
              c && (rr.push(...zt(r[2].dims)), Wr.push("rank")),
                rr.push(...zt(s));
              let Jr = (Sr) => {
                let Hr = [
                  { name: "dim_a_outer", type: "i32" },
                  { name: "dim_b_outer", type: "i32" },
                  { name: "dim_inner", type: "i32" },
                  { name: "pad", type: "i32", length: 2 },
                  { name: "stride", type: "i32", length: 2 },
                  { name: "dilation", type: "i32", length: 2 }
                ];
                Ki(i, Hr);
                let tr = le ? 4 : 1,
                  _r = Fr(r[0].dataType),
                  zr = `
      fn setOutputAtIndex(flatIndex : i32, value : ${le ? `vec4<${_r}>` : _r}) {
        result[flatIndex] = ${le ? `vec4<${_r}>` : _r}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${
        le ? `vec4<${_r}>` : _r
      }) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${le ? "/ 4" : ""}, value);
      }`,
                  ut = gt(
                    "x",
                    r[0].dataType,
                    r[0].dims.length,
                    ze === 3 ? 1 : ze
                  ),
                  At = gt("w", r[1].dataType, r[1].dims.length, tr),
                  sr = [ut, At],
                  Gr = Ht("result", r[0].dataType, s.length, tr);
                if (c) {
                  let gn = gt("bias", r[2].dataType, r[2].dims.length, tr);
                  sr.push(gn),
                    (zr += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${
          le ? `vec4<${_r}>` : _r
        } {
          return bias[coords.${E ? "w" : "y"}${le ? "/ 4" : ""}];
        }`);
                }
                return `
        ${ol("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Sr.registerUniforms(Hr).declareVariables(...sr, Gr)}
        ${zr}
        ${od(E, Dt, Ut, fr, c, i, br[0], br[1], br[2], _r)}
        ${
          le
            ? Us(Fe, me, _r, void 0, !E, Mt)
            : Ws(Fe, me, _r, void 0, !E, Mt, !1, void 0, b)
        }`;
              };
              return {
                name: "Conv2DMatMul",
                shaderCache: {
                  hint: `${i.cacheKey};${ze};${le};${Dt};${Ut};${fr};${dt};${lt};${Mt}`,
                  inputDependencies: Wr
                },
                getRunData: () => ({
                  outputs: [{ dims: k ? k(s) : s, dataType: r[0].dataType }],
                  dispatchGroup: { x: Ce[0], y: Ce[1], z: Ce[2] },
                  programUniforms: rr
                }),
                getShaderSource: Jr
              };
            });
        }),
        ad,
        Jo,
        es,
        ld,
        ul,
        Sp,
        ud,
        cd,
        Ep = m(() => {
          Yt(),
            qn(),
            Zt(),
            cr(),
            Rn(),
            js(),
            (ad = (r) => {
              let i = 1;
              for (let s = 0; s < r.length; s++) i *= r[s];
              return i;
            }),
            (Jo = (r) => (typeof r == "number" ? [r, r, r] : r)),
            (es = (r, i) => (i <= 1 ? r : r + (r - 1) * (i - 1))),
            (ld = (r, i, s, u = 1) => {
              let d = es(i, u);
              return Math.floor((r[0] * (s - 1) - s + d) / 2);
            }),
            (ul = (r, i, s, u, d) => {
              d == null && (d = ld(r, i[0], u[0]));
              let p = [0, 0, 0, s];
              for (let c = 0; c < 3; c++)
                r[c] + 2 * d >= i[c] &&
                  (p[c] = Math.trunc((r[c] - i[c] + 2 * d) / u[c] + 1));
              return p;
            }),
            (Sp = (r, i, s, u, d, p, c, b, k, E) => {
              let q, H, w, Z;
              if ((r === "VALID" && (r = 0), typeof r == "number")) {
                q = { top: r, bottom: r, left: r, right: r, front: r, back: r };
                let re = ul([i, s, u, 1], [b, k, E], 1, [d, p, c], r);
                (H = re[0]), (w = re[1]), (Z = re[2]);
              } else if (Array.isArray(r)) {
                if (!r.every((le, we, be) => le === be[0]))
                  throw Error(`Unsupported padding parameter: ${r}`);
                q = {
                  top: r[0],
                  bottom: r[1],
                  left: r[2],
                  right: r[3],
                  front: r[4],
                  back: r[5]
                };
                let re = ul([i, s, u, 1], [b, k, E], 1, [d, p, c], r[0]);
                (H = re[0]), (w = re[1]), (Z = re[2]);
              } else if (r === "SAME_UPPER") {
                (H = Math.ceil(i / d)),
                  (w = Math.ceil(s / p)),
                  (Z = Math.ceil(u / c));
                let re = (H - 1) * d + b - i,
                  le = (w - 1) * p + k - s,
                  we = (Z - 1) * c + E - u,
                  be = Math.floor(re / 2),
                  me = re - be,
                  Fe = Math.floor(le / 2),
                  Ce = le - Fe,
                  ze = Math.floor(we / 2),
                  dt = we - ze;
                q = {
                  top: Fe,
                  bottom: Ce,
                  left: ze,
                  right: dt,
                  front: be,
                  back: me
                };
              } else throw Error(`Unknown padding parameter: ${r}`);
              return { padInfo: q, outDepth: H, outHeight: w, outWidth: Z };
            }),
            (ud = (r, i, s, u, d, p = !1, c = "channelsLast") => {
              let b, k, E, q, H;
              if (c === "channelsLast") [b, k, E, q, H] = r;
              else if (c === "channelsFirst") [b, H, k, E, q] = r;
              else throw new Error(`Unknown dataFormat ${c}`);
              let [w, , Z, re, le] = i,
                [we, be, me] = Jo(s),
                [Fe, Ce, ze] = Jo(u),
                dt = es(Z, Fe),
                lt = es(re, Ce),
                Mt = es(le, ze),
                {
                  padInfo: Dt,
                  outDepth: Ut,
                  outHeight: fr,
                  outWidth: br
                } = Sp(d, k, E, q, we, be, me, dt, lt, Mt),
                rr = p ? w * H : w,
                Wr = [0, 0, 0, 0, 0];
              return (
                c === "channelsFirst"
                  ? (Wr = [b, rr, Ut, fr, br])
                  : c === "channelsLast" && (Wr = [b, Ut, fr, br, rr]),
                {
                  batchSize: b,
                  dataFormat: c,
                  inDepth: k,
                  inHeight: E,
                  inWidth: q,
                  inChannels: H,
                  outDepth: Ut,
                  outHeight: fr,
                  outWidth: br,
                  outChannels: rr,
                  padInfo: Dt,
                  strideDepth: we,
                  strideHeight: be,
                  strideWidth: me,
                  filterDepth: Z,
                  filterHeight: re,
                  filterWidth: le,
                  effectiveFilterDepth: dt,
                  effectiveFilterHeight: lt,
                  effectiveFilterWidth: Mt,
                  dilationDepth: Fe,
                  dilationHeight: Ce,
                  dilationWidth: ze,
                  inShape: r,
                  outShape: Wr,
                  filterShape: i
                }
              );
            }),
            (cd = (r, i, s, u, d, p) => {
              let c = p === "channelsLast";
              c ? r[0].dims[3] : r[0].dims[1];
              let b = [64, 1, 1],
                k = { x: s.map((we, be) => be) },
                E = [Math.ceil(ad(k.x.map((we) => s[we])) / b[0]), 1, 1];
              Kr("verbose", () => `[conv3d_naive_webgpu] dispatch = ${E}`);
              let q = 1,
                H = Ze.size(s),
                w = [
                  { type: 12, data: H },
                  { type: 12, data: u },
                  { type: 12, data: d },
                  { type: 12, data: i.strides },
                  { type: 12, data: i.dilations }
                ];
              zi(i, w), w.push(...zt(r[0].dims, r[1].dims));
              let Z = ["rank", "rank"],
                re = r.length === 3;
              re && (w.push(...zt(r[2].dims)), Z.push("rank")),
                w.push(...zt(s));
              let le = (we) => {
                let be = [
                  { name: "output_size", type: "u32" },
                  { name: "filter_dims", type: "u32", length: u.length },
                  { name: "pads", type: "u32", length: d.length },
                  { name: "strides", type: "u32", length: i.strides.length },
                  { name: "dilations", type: "u32", length: i.dilations.length }
                ];
                Ki(i, be);
                let me = 1,
                  Fe = Fr(r[0].dataType),
                  Ce = gt("x", r[0].dataType, r[0].dims.length, q),
                  ze = gt("W", r[1].dataType, r[1].dims.length, me),
                  dt = [Ce, ze],
                  lt = Ht("result", r[0].dataType, s.length, me),
                  Mt = "";
                if (re) {
                  let fr = gt("bias", r[2].dataType, r[2].dims.length, me);
                  dt.push(fr),
                    (Mt += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${Fe} {
          return bias[${c ? jt("coords", 4, 5) : jt("coords", 1, 5)}];
        }`);
                }
                let Dt = Sn(q, Fe),
                  Ut = qi(i, Dt, Fe);
                return `
            ${Mt}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${Ce.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${ze.getByIndices("aIndices")};
            }
          ${we.registerUniforms(be).declareVariables(...dt, lt)}
          ${we.mainStart()}
          ${we.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${lt.offsetToIndices("global_idx")};
              let batch = ${jt("coords", 0, Ce.rank)};
              let d2 = ${
                c
                  ? jt("coords", Ce.rank - 1, Ce.rank)
                  : jt("coords", 1, Ce.rank)
              };
              let xFRCCorner = vec3<u32>(${
                c ? jt("coords", 1, Ce.rank) : jt("coords", 2, Ce.rank)
              },
              ${c ? jt("coords", 2, Ce.rank) : jt("coords", 3, Ce.rank)},
              ${
                c ? jt("coords", 3, Ce.rank) : jt("coords", 4, Ce.rank)
              }) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${
                c
                  ? jt("uniforms.x_shape", 1, Ce.rank)
                  : jt("uniforms.x_shape", 2, Ce.rank)
              };
              let xShapeZ = ${
                c
                  ? jt("uniforms.x_shape", 2, Ce.rank)
                  : jt("uniforms.x_shape", 3, Ce.rank)
              };
              let xShapeW = ${
                c
                  ? jt("uniforms.x_shape", 3, Ce.rank)
                  : jt("uniforms.x_shape", 4, Ce.rank)
              };
              let xShapeU = ${
                c
                  ? jt("uniforms.x_shape", 4, Ce.rank)
                  : jt("uniforms.x_shape", 1, Ce.rank)
              };
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${
                        c
                          ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `
                          : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `
                      }
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${
                          c
                            ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`
                            : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`
                        }
                    } else if (inputDepthVec4Remainder == 2) {
                      ${
                        c
                          ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `
                          : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `
                      }
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${
                        c
                          ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `
                          : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `
                      }
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${re ? "value = value + getBiasByOutputCoords(coords)" : ""};
              ${Ut}
              result[global_idx] = f32(value);
          }`;
              };
              return {
                name: "Conv3DNaive",
                shaderCache: {
                  hint: `${i.cacheKey};${c};${q};${re}`,
                  inputDependencies: Z
                },
                getRunData: () => ({
                  outputs: [{ dims: s, dataType: r[0].dataType }],
                  dispatchGroup: { x: E[0], y: E[1], z: E[2] },
                  programUniforms: w
                }),
                getShaderSource: le
              };
            });
        }),
        ko,
        dd,
        Cp = m(() => {
          Yt(),
            Zt(),
            cr(),
            gl(),
            Rn(),
            (ko = (r, i, s) => {
              let u = r.length > 2,
                d = u ? "value += b[output_channel];" : "",
                p = r[0].dims,
                c = r[1].dims,
                b = c[0] / i.group,
                k = i.format === "NHWC",
                E = dl(p, c, i.dilations, i.pads, i.strides, k),
                q = Ze.size(E),
                H = [
                  { type: 12, data: q },
                  { type: 12, data: i.dilations },
                  { type: 12, data: [i.strides[0], i.strides[1]] },
                  { type: 12, data: [i.pads[0], i.pads[1]] },
                  { type: 12, data: b }
                ];
              zi(i, H), H.push(...zt(p, c));
              let w = ["rank", "rank"];
              u && (H.push(...zt(r[2].dims)), w.push("rank")), H.push(...zt(E));
              let Z = (re) => {
                let le = Ht("output", r[0].dataType, E.length),
                  we = Fr(le.type.tensor),
                  be = qi(i, le.type.value, we),
                  me = gt("x", r[0].dataType, p.length),
                  Fe = gt("w", r[1].dataType, c.length),
                  Ce = [me, Fe];
                u && Ce.push(gt("b", r[2].dataType, r[2].dims.length));
                let ze = [
                  { name: "output_size", type: "u32" },
                  {
                    name: "dilations",
                    type: "u32",
                    length: i.dilations.length
                  },
                  { name: "strides", type: "u32", length: 2 },
                  { name: "pads", type: "u32", length: 2 },
                  { name: "output_channels_per_group", type: "u32" }
                ];
                return (
                  Ki(i, ze),
                  `
  ${re.registerUniforms(ze).declareVariables(...Ce, le)}

  ${re.mainStart()}
    ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${le.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${k ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${
      k ? 1 : 2
    }], outputIndices[${k ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel / uniforms.output_channels_per_group;

    var value: ${le.type.value} = ${le.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[${k ? 1 : 2}]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[${k ? 2 : 3}]) {
            continue;
          }

          let xVal = ${
            k
              ? me.get("batch", "xHeight", "xWidth", "input_channel")
              : me.get("batch", "input_channel", "xHeight", "xWidth")
          };
          let wVal = ${Fe.get(
            "output_channel",
            "wInChannel",
            "wHeight",
            "wWidth"
          )};
          value += xVal*wVal;
        }
      }
    }
    ${d}
    ${be}
    ${le.setByOffset("global_idx", "value")}
  }`
                );
              };
              return {
                name: "GroupedConv",
                shaderCache: { hint: i.cacheKey, inputDependencies: w },
                getRunData: () => ({
                  outputs: [{ dims: s ? s(E) : E, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(q / 64) },
                  programUniforms: H
                }),
                getShaderSource: Z
              };
            }),
            (dd = (r, i, s, u) => {
              let d = r.length > 2,
                p = $r(s[3]),
                c = $r(s[2]),
                b = Ze.size(s) / p / c,
                k = [
                  r[0].dims[0],
                  r[0].dims[1],
                  r[0].dims[2],
                  r[0].dims[3] / p
                ],
                E = [
                  r[1].dims[0],
                  r[1].dims[1],
                  r[1].dims[2],
                  r[1].dims[3] / p
                ],
                q = [s[0], s[1], s[2], s[3] / p],
                H = [
                  { type: 12, data: b },
                  { type: 6, data: [i.strides[0], i.strides[1]] },
                  { type: 6, data: [i.pads[0], i.pads[1]] }
                ];
              zi(i, H), H.push(...zt(k, E, q));
              let w = (c - 1) * i.strides[1] + E[1],
                Z = (re) => {
                  let le = Ht("output", r[0].dataType, q.length, p),
                    we = Fr(le.type.tensor),
                    be = qi(i, le.type.value, we),
                    me = gt("x", r[0].dataType, k.length, p),
                    Fe = gt("w", r[1].dataType, E.length, p),
                    Ce = [me, Fe];
                  d && Ce.push(gt("b", r[2].dataType, r[2].dims, p));
                  let ze = d ? "value += b[output_channel];" : "",
                    dt = [
                      { name: "output_size", type: "u32" },
                      { name: "strides", type: "i32", length: 2 },
                      { name: "pads", type: "i32", length: 2 }
                    ];
                  return (
                    Ki(i, dt),
                    `
  ${re.registerUniforms(dt).declareVariables(...Ce, le)}
  ${re.mainStart()}
    ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${c}u;
    let col = (index1 % width1) * ${c}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${me.type.value}, ${w}>;
    var values: array<${le.type.value}, ${c}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${E[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${w}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${me.get(
              "batch",
              "u32(x_height)",
              "u32(x_width)",
              "input_channel"
            )};
          } else {
            x_vals[i] = ${me.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${E[1]}; w_width++) {
          let w_val = ${Fe.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${c}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${c}u; i++) {
      var value = values[i];
      ${ze}
      ${be}
      ${le.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`
                  );
                };
              return {
                name: "GroupedConv-Vectorize",
                shaderCache: {
                  hint: `${i.cacheKey};${p};${c};${w};${E[0]};${E[1]}`,
                  inputDependencies: d
                    ? ["rank", "rank", "type"]
                    : ["rank", "rank"]
                },
                getRunData: () => ({
                  outputs: [{ dims: u ? u(s) : s, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(b / 64) },
                  programUniforms: H
                }),
                getShaderSource: Z
              };
            });
        }),
        cl,
        fd,
        pd,
        Gs = m(() => {
          Yt(),
            Zt(),
            io(),
            cr(),
            Rn(),
            (cl = (r, i, s, u, d = !1, p) => {
              let c = r[0].dims,
                b = r[1].dims,
                k = c[c.length - 2],
                E = b[b.length - 1],
                q = c[c.length - 1],
                H = $r(E),
                w = $r(q),
                Z = $r(k),
                re = Ze.size(s) / H / Z,
                le = r.length > 2,
                we = u ? u.slice(0, -2) : s.slice(0, -2),
                be = [Ze.size(we), k, E],
                me = [
                  { type: 12, data: re },
                  { type: 12, data: k },
                  { type: 12, data: E },
                  { type: 12, data: q }
                ];
              zi(i, me),
                me.push(...zt(we, c, b)),
                le && me.push(...zt(r[2].dims)),
                me.push(...zt(be));
              let Fe = (Ce) => {
                let ze = _a("batch_dims", r[0].dataType, we.length),
                  dt = gt("a", r[0].dataType, c.length, w),
                  lt = gt("b", r[1].dataType, b.length, H),
                  Mt = Ht("output", r[0].dataType, be.length, H),
                  Dt = Fr(Mt.type.tensor),
                  Ut = qi(i, Mt.type.value, Dt),
                  fr = [dt, lt],
                  br = "";
                if (le) {
                  let zr = d ? H : 1;
                  fr.push(gt("bias", r[2].dataType, r[2].dims.length, zr)),
                    (br = `${
                      d
                        ? `value += bias[col / ${zr}];`
                        : `value += ${Mt.type.value}(bias[row + i]);`
                    }`);
                }
                let rr = c.slice(0, -2),
                  Wr = b.slice(0, -2),
                  Jr = xo(rr, we),
                  Sr = xo(Wr, we),
                  Hr = [
                    { name: "output_size", type: "u32" },
                    { name: "M", type: "u32" },
                    { name: "N", type: "u32" },
                    { name: "K", type: "u32" }
                  ];
                Ki(i, Hr);
                let tr = (zr, ut) => {
                    let At = zr.rank,
                      sr = zr.name;
                    if (At === 2)
                      return `var ${sr}_indices = ${zr.type.indices}(0u, 0u);`;
                    let Gr = ze.rank,
                      gn = `var ${sr}_indices: ${zr.type.indices};`;
                    for (let Cn = At - 2 - 1, is = Gr - 1; Cn >= 0; Cn--, is--)
                      gn += `
${sr}_indices[${Cn}] = ${Gr > 1 ? `batch_indices[${is}]` : "batch_indices"};`;
                    return (
                      ut.forEach((Cn) => {
                        gn += `
${sr}_indices[${Cn}] = 0;`;
                      }),
                      (gn += `${sr}_indices[${At - 2}] = 0u;
                     ${sr}_indices[${At - 1}] = 0u;`),
                      gn
                    );
                  },
                  _r = () => {
                    let zr = `var a_data: ${dt.type.value};`;
                    for (let ut = 0; ut < w; ut++)
                      zr += `
              let b_data${ut} = b[(b_offset + (k + ${ut}) * uniforms.N + col) / ${H}];`;
                    for (let ut = 0; ut < Z; ut++) {
                      zr += `a_data = a[(a_offset + (row + ${ut}) * uniforms.K + k) / ${w}];`;
                      for (let At = 0; At < w; At++)
                        zr += `
            values[${ut}] = fma(${lt.type.value}(a_data${
                          w === 1 ? "" : `[${At}]`
                        }), b_data${At}, values[${ut}]);
`;
                    }
                    return zr;
                  };
                return `
  ${Ce.registerUniforms(Hr)
    .registerInternalVariables(ze)
    .declareVariables(...fr, Mt)}
  ${Ce.mainStart()}
    ${Ce.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${H})) * ${H};
    var index1 = global_idx / (uniforms.N / ${H});
    let stride1 = uniforms.M / ${Z};
    let row = (index1 % stride1) * ${Z};
    let batch = index1 / stride1;

    ${
      s.length === 2
        ? ""
        : `let batch_indices = ${ze.offsetToIndices("batch")};`
    }
    ${tr(dt, Jr)}
    let a_offset = ${dt.indicesToOffset("a_indices")};
    ${tr(lt, Sr)}
    let b_offset = ${lt.indicesToOffset("b_indices")};
    var values: array<${Mt.type.value}, ${Z}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${w}) {
      ${_r()}
    }
    for (var i = 0u; i < ${Z}u; i++) {
      var value = values[i];
      ${br}
      ${Ut}
      let cur_indices = ${Mt.type.indices}(batch, row + i, col);
      let offset = ${Mt.indicesToOffset("cur_indices")};
      ${Mt.setByOffset(`offset / ${H}`, "value")};
    }
  }
  `;
              };
              return {
                name: "MatMulNaive",
                shaderCache: {
                  hint: `${i.activation};${H};${w};${Z};${d}`,
                  inputDependencies: le
                    ? ["rank", "rank", "rank"]
                    : ["rank", "rank"]
                },
                getRunData: () => ({
                  outputs: [{ dims: p ? p(s) : s, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(re / 64) },
                  programUniforms: me
                }),
                getShaderSource: Fe
              };
            }),
            (fd = (r) => {
              if (!r || r.length !== 2)
                throw new Error("MatMul requires 2 inputs.");
              if (
                r[0].dims[r[0].dims.length - 1] !==
                r[1].dims[r[1].dims.length - 2]
              )
                throw new Error("shared dimension does not match.");
            }),
            (pd = (r) => {
              fd(r.inputs);
              let i = vn.calcShape(r.inputs[0].dims, r.inputs[1].dims, !0);
              if (!i) throw new Error("Can't use matmul on the given tensors");
              let s = i[i.length - 1],
                u = r.inputs[0].dims[r.inputs[0].dims.length - 1];
              s < 8 && u < 8
                ? r.compute(cl(r.inputs, { activation: "" }, i))
                : r.compute(ll(r.inputs, { activation: "" }, i));
            });
        }),
        dl,
        Hs,
        hd,
        qs,
        fl,
        pl,
        hl,
        md,
        ml,
        gl = m(() => {
          Zt(),
            kp(),
            Ep(),
            io(),
            Cp(),
            Rn(),
            Gs(),
            Mo(),
            (dl = (r, i, s, u, d, p) => {
              let c = r[0],
                b = r.slice(p ? 1 : 2, p ? 3 : 4),
                k = b.length,
                E = i[0],
                q = i.slice(2).map((w, Z) => w + (w - 1) * (s[Z] - 1)),
                H = b
                  .map((w, Z) => w + u[Z] + u[Z + k])
                  .map((w, Z) => Math.floor((w - q[Z] + d[Z]) / d[Z]));
              return H.splice(0, 0, c), H.splice(p ? 3 : 1, 0, E), H;
            }),
            (Hs = [2, 3, 1, 0]),
            (hd = (r, i) => {
              if (!r || (r.length !== 2 && r.length !== 3))
                throw new Error("Conv requires 2 or 3 inputs");
              if (r[0].dims.length > 5)
                throw new Error("greater than 5D is not supported");
              if (r[0].dims.length !== r[1].dims.length)
                throw new Error("filter does not have same dimension as input");
              let s = r[0].dims[i.format === "NHWC" ? r[0].dims.length - 1 : 1],
                u = r[1].dims[1] * i.group;
              if (s !== u)
                throw new Error(
                  "FILTER_IN_CHANNEL should be equal to DATA_CHANNEL"
                );
              if (
                r.length === 3 &&
                (r[2].dims.length !== 1 || r[1].dims[0] !== r[2].dims[0])
              )
                throw new Error("invalid bias");
              let d = r[0].dims.length - 2;
              if (i.dilations.length !== d)
                throw new Error(`dilations should be ${d}D`);
              if (i.strides.length !== d)
                throw new Error(`strides should be ${d}D`);
              if (i.pads.length !== d * 2)
                throw new Error(`pads should be ${d * 2}D`);
              if (
                i.kernelShape.length !== 0 &&
                i.kernelShape.length !== r[1].dims.length - 2
              )
                throw new Error("invalid kernel shape");
            }),
            (qs = (r, i) => {
              let s = r.kernelShape.slice();
              for (let p = 2; p < i[1].dims.length; ++p)
                s[p - 2] === 0 && (s[p - 2] = i[1].dims[p]);
              let u = r.pads.slice();
              ei.adjustPadsBasedOnAutoPad(
                i[0].dims,
                r.strides,
                r.dilations,
                s,
                u,
                r.format === "NHWC",
                r.autoPad
              );
              let d = Object.assign({}, r);
              return Object.assign(d, { kernelShape: s, pads: u }), d;
            }),
            (fl = (r) => {
              let i = nl(r),
                s = r.format,
                u = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][r.auto_pad],
                d = r.dilations,
                p = r.group,
                c = r.kernel_shape,
                b = r.pads,
                k = r.strides,
                E = r.w_is_const();
              return {
                autoPad: u,
                format: s,
                dilations: d,
                group: p,
                kernelShape: c,
                pads: b,
                strides: k,
                wIsConst: E,
                ...i,
                cacheKey: `${r.format};${i.activation};`
              };
            }),
            (pl = (r, i, s, u) => {
              let d = s.format === "NHWC";
              if (s.group !== 1) {
                if (
                  !r.adapterInfo.isArchitecture("ampere") &&
                  d &&
                  i[1].dims[0] === s.group &&
                  i[1].dims[1] === 1 &&
                  s.dilations[0] === 1 &&
                  s.dilations[1] === 1
                ) {
                  let dt = dl(
                      i[0].dims,
                      i[1].dims,
                      s.dilations,
                      s.pads,
                      s.strides,
                      d
                    ),
                    lt =
                      r.kernelCustomData.wT ??
                      r.compute(bi(i[1], Hs), {
                        inputs: [1],
                        outputs: [s.wIsConst ? -2 : -1]
                      })[0];
                  s.wIsConst &&
                    !r.kernelCustomData.wT &&
                    (r.kernelCustomData.wT = lt);
                  let Mt = [i[0], lt];
                  i.length === 3 && Mt.push(i[2]),
                    r.compute(dd(Mt, s, dt, u), { inputs: Mt });
                } else r.compute(ko(i, s, u));
                return;
              }
              let p = i.length === 3,
                c = i[0].dims[d ? 1 : 2],
                b = i[0].dims[d ? 2 : 3],
                k = i[0].dims[d ? 3 : 1],
                E = i[1].dims[2],
                q = i[1].dims[3],
                H = dl(i[0].dims, i[1].dims, s.dilations, s.pads, s.strides, d),
                w = H[d ? 1 : 2],
                Z = H[d ? 2 : 3],
                re = H[d ? 3 : 1],
                le =
                  d && E === c && q === b && s.pads[0] === 0 && s.pads[1] === 0;
              if (
                le ||
                (E === 1 &&
                  q === 1 &&
                  s.dilations[0] === 1 &&
                  s.dilations[1] === 1 &&
                  s.strides[0] === 1 &&
                  s.strides[1] === 1 &&
                  s.pads[0] === 0 &&
                  s.pads[1] === 0)
              ) {
                let dt = H[0],
                  lt,
                  Mt,
                  Dt,
                  Ut = [];
                if (d) {
                  let rr =
                    r.kernelCustomData.wT ??
                    r.compute(bi(i[1], Hs), {
                      inputs: [1],
                      outputs: [s.wIsConst ? -2 : -1]
                    })[0];
                  if (
                    (s.wIsConst &&
                      !r.kernelCustomData.wT &&
                      (r.kernelCustomData.wT = rr),
                    le)
                  ) {
                    let Wr = c * b * k;
                    (lt = i[0].reshape([1, dt, Wr])),
                      (Mt = rr.reshape([1, Wr, re])),
                      (Dt = [1, dt, re]);
                  } else
                    (lt = i[0].reshape([dt, c * b, k])),
                      (Mt = rr.reshape([1, k, re])),
                      (Dt = [dt, w * Z, re]);
                  Ut.push(lt), Ut.push(Mt);
                } else
                  (lt = i[0].reshape([dt, k, c * b])),
                    (Mt = i[1].reshape([1, re, k])),
                    (Dt = [dt, re, w * Z]),
                    Ut.push(Mt),
                    Ut.push(lt);
                p && Ut.push(i[2]);
                let fr = Dt[2],
                  br = Ut[0].dims[Ut[0].dims.length - 1];
                fr < 8 && br < 8
                  ? r.compute(cl(Ut, s, H, Dt, d, u), { inputs: Ut })
                  : r.compute(ll(Ut, s, H, Dt, d, u), { inputs: Ut });
                return;
              }
              let we = !0,
                be =
                  r.kernelCustomData.wT ??
                  r.compute(bi(i[1], Hs), {
                    inputs: [1],
                    outputs: [s.wIsConst ? -2 : -1]
                  })[0];
              s.wIsConst &&
                !r.kernelCustomData.wT &&
                (r.kernelCustomData.wT = be);
              let me = [i[0], be];
              p && me.push(i[2]);
              let Fe = d ? w * Z : re,
                Ce = d ? re : w * Z,
                ze = E * q * k;
              r.compute(sd(me, s, H, Fe, Ce, ze, p, we, u), { inputs: me });
            }),
            (hl = (r, i) => {
              let s = i.format === "NHWC",
                u = [
                  r.inputs[0].reshape(
                    s
                      ? [
                          r.inputs[0].dims[0],
                          1,
                          r.inputs[0].dims[1],
                          r.inputs[0].dims[2]
                        ]
                      : [
                          r.inputs[0].dims[0],
                          r.inputs[0].dims[1],
                          1,
                          r.inputs[0].dims[2]
                        ]
                  ),
                  r.inputs[1].reshape([
                    r.inputs[1].dims[0],
                    r.inputs[1].dims[1],
                    1,
                    r.inputs[1].dims[2]
                  ])
                ];
              r.inputs.length === 3 && u.push(r.inputs[2]);
              let d = [0, i.pads[0], 0, i.pads[1]],
                p = [1].concat(i.strides),
                c = [1].concat(i.dilations),
                b = [1].concat(i.kernelShape),
                k = qs(
                  { ...i, pads: d, strides: p, dilations: c, kernelShape: b },
                  u
                );
              pl(r, u, k, (E) => (s ? [E[0], E[2], E[3]] : [E[0], E[1], E[3]]));
            }),
            (md = (r, i, s) => {
              let u = s.format === "NHWC" ? "channelsLast" : "channelsFirst",
                d = qs(s, i),
                p = s.autoPad === "NOTSET" ? s.pads : s.autoPad,
                c = ud(i[0].dims, i[1].dims, s.strides, s.dilations, p, !1, u);
              r.compute(
                cd(
                  i,
                  d,
                  c.outShape,
                  [c.filterDepth, c.filterHeight, c.filterWidth],
                  [c.padInfo.front, c.padInfo.top, c.padInfo.left],
                  u
                )
              );
            }),
            (ml = (r, i) => {
              if ((hd(r.inputs, i), r.inputs[0].dims.length === 3)) hl(r, i);
              else if (r.inputs[0].dims.length === 5) md(r, r.inputs, i);
              else {
                let s = qs(i, r.inputs);
                pl(r, r.inputs, s);
              }
            });
        }),
        gd,
        _d,
        yd = m(() => {
          Yt(),
            qn(),
            cr(),
            Rn(),
            js(),
            sl(),
            io(),
            (gd = (r, i = !1, s, u, d = 4) => {
              let p = (we) => {
                  switch (we) {
                    case 1:
                      return "return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";
                    case 4:
                      return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${u}(v0, v1, v2, v3);
            `;
                    default:
                      throw new Error(
                        `innerElementSize ${we} is not supported.`
                      );
                  }
                },
                c = r
                  ? `
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `
                  : `
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,
                b = r
                  ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `
                  : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,
                k = r ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])",
                E = r ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])",
                q = r ? "row" : "col",
                H = r ? "col" : "row",
                w = `
      let inChannels = ${
        r ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"
      };
      let outWidth = ${
        r ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"
      };
      let outRow = ${q} / outWidth;
      let outCol = ${q} % outWidth;

      let WRow = ${H} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${H} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${k}) || fract(xR) > 0.0) {
        return ${u}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${E}) || fract(xC) > 0.0) {
        return ${u}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${H} % inChannels;
      ${c}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${d}];`,
                Z = r
                  ? `
      let col = colIn * ${d};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${w}
      }
      return ${u}(0.0);`
                  : `
      let col = colIn * ${d};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${w}
      }
      return ${u}(0.0);`,
                re = `
      let col = colIn * ${d};
      let inChannels = ${
        r ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"
      };
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${
        r
          ? "row < uniforms.dim_inner && col < uniforms.dim_b_outer"
          : "row < uniforms.dim_inner && col < uniforms.dim_a_outer"
      }  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${p(d)}
      }
      return ${u}(0.0);
      `,
                le = qi(s, u);
              return `
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${u} {
    ${r ? Z : re}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${u} {
    ${r ? re : Z}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${u}) {
    let col = colIn * ${d};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${
        r ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"
      };
      ${b}
      ${il(i)}
      ${le}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${d}] = value;
    }
  }`;
            }),
            (_d = (r, i, s, u, d, p, c, b) => {
              let k = i.format === "NHWC",
                E = k ? r[0].dims[3] : r[0].dims[1],
                q = s[0],
                H = k ? s[2] : s[3],
                w = k ? s[1] : s[2],
                Z = k ? s[3] : s[1],
                re = k && E % 4 === 0 && E % 3 && Z % 4 === 0,
                le = k ? Z : H * w,
                we = k ? H * w : Z,
                be = [8, 8, 1],
                me = u <= 8 ? [4, 1, 1] : [4, 4, 1],
                Fe = [
                  Math.ceil(le / be[0] / me[0]),
                  Math.ceil(we / be[1] / me[1]),
                  Math.ceil(q / be[2] / me[2])
                ];
              Kr("verbose", () => `[conv_backprop_mm_webgpu] dispatch = ${Fe}`);
              let Ce = re ? 4 : 1,
                ze = Math.max(be[0] * Ce, be[1]),
                dt = re ? 4 : 1,
                lt = [i.kernelShape[k ? 1 : 2], i.kernelShape[k ? 2 : 3]],
                Mt = [
                  lt[0] +
                    (i.dilations[0] <= 1
                      ? 0
                      : (lt[0] - 1) * (i.dilations[0] - 1)),
                  lt[1] +
                    (i.dilations[1] <= 1
                      ? 0
                      : (lt[1] - 1) * (i.dilations[1] - 1))
                ],
                Dt = [
                  Mt[0] - 1 - Math.floor((i.pads[0] + i.pads[2]) / 2),
                  Mt[1] - 1 - Math.floor((i.pads[1] + i.pads[3]) / 2)
                ],
                Ut = [
                  { type: 6, data: u },
                  { type: 6, data: d },
                  { type: 6, data: p },
                  { type: 6, data: i.strides },
                  { type: 6, data: i.dilations },
                  { type: 6, data: lt },
                  { type: 6, data: Dt }
                ];
              zi(i, Ut), Ut.push(...zt(r[0].dims, r[1].dims));
              let fr = ["rank", "rank"];
              c && (Ut.push(...zt(r[2].dims)), fr.push("rank")),
                Ut.push(...zt(s));
              let br = (rr) => {
                let Wr = gt("x", r[0].dataType, r[0].dims.length, dt),
                  Jr = gt("w", r[1].dataType, r[1].dims.length, 1),
                  Sr = Ht("result", r[0].dataType, s.length, dt),
                  Hr = [Wr, Jr],
                  tr = "";
                if (c) {
                  let ut = gt("bias", r[2].dataType, r[2].dims.length, dt);
                  Hr.push(ut),
                    (tr += `
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${ut.type.value} {
            return bias[coords.${k ? "w" : "y"}${re ? "/ 4" : ""}];
          }`);
                }
                let _r = [
                  { name: "dim_a_outer", type: "i32" },
                  { name: "dim_b_outer", type: "i32" },
                  { name: "dim_inner", type: "i32" },
                  { name: "strides", type: "i32", length: 2 },
                  { name: "dilations", type: "i32", length: 2 },
                  { name: "filter_dims", type: "i32", length: lt.length },
                  { name: "pads", type: "i32", length: Dt.length }
                ];
                Ki(i, _r);
                let zr = Fr(r[0].dataType, 1);
                if (zr !== "f16" && zr !== "f32")
                  throw new Error(`elemType ${zr} is not supported.`);
                return `
        ${ol("uniforms.result_strides")}
        ${rr.registerUniforms(_r).declareVariables(...Hr, Sr)};
        ${tr}
        ${gd(k, c, i, Wr.type.value, Ce)}
        ${
          re
            ? Us(me, be, zr, void 0, !k, ze)
            : Ws(me, be, zr, void 0, !k, ze, !1, void 0, b)
        }`;
              };
              return {
                name: "Conv2DTransposeMatMul",
                shaderCache: {
                  hint: `${i.cacheKey};${me};${be};${re}`,
                  inputDependencies: fr
                },
                getRunData: () => ({
                  outputs: [{ dims: s, dataType: r[0].dataType }],
                  dispatchGroup: { x: Fe[0], y: Fe[1], z: Fe[2] },
                  programUniforms: Ut
                }),
                getShaderSource: br
              };
            });
        }),
        wd,
        _l,
        yl = m(() => {
          Yt(),
            qn(),
            Zt(),
            cr(),
            (wd = (r, i, s, u, d, p = !1, c, b, k = !1) => {
              let E = k ? 1 : 2,
                q = k ? 2 : 3,
                H = k ? 3 : 1,
                w = p ? 2 : 1,
                Z = `
  fn setOutputAtIndex(flatIndex : u32, value : ${p ? `vec4<${c}>` : c}) {
    result[flatIndex] = ${p ? `vec4<${c}>` : c}(value);
  }`;
              u &&
                (Z += `
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${p ? `vec4<${c}>` : c} {
      return bias[coords.${k ? "w" : "y"}${p ? "/ 4" : ""}];
    }`);
              let re = p ? 4 : 1,
                le = gt("W", i[1].dataType, i[1].dims.length, re),
                we = gt("Dy", i[0].dataType, i[0].dims.length, re),
                be = [we, le];
              u && be.push(gt("bias", i[2].dataType, [s[H]].length, re));
              let me = Ht("result", i[0].dataType, s.length, re),
                Fe = `{
        let batch: u32 = ${
          d ? "global_id.z" : "workgroup_id.z"
        } / uniforms.result_shape[1];
        let r = ${
          d ? "global_id.z" : "workgroup_id.z"
        } % uniforms.result_shape[1];
        let c = ${d ? "global_id.y" : "workgroup_id.y"} * ${w};
        let d1: u32 = ${d ? "global_id.x" : "workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${c}>, ${w}>;
        for (var i = 0; i < ${w}; i++) {
          dotProd[i] = vec4<${c}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${c}(dyCorner.x) + ${c}(wR)) / ${c}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${c}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${c}(dyCorner.y) + ${c}(wC)) / ${c}(uniforms.strides.y);
            let dyC2 = (${c}(dyCorner.y) + 1.0 + ${c}(wC)) / ${c}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${c}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${c}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1",
                  "d2"
                )};
                let wValue1 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1 + 1",
                  "d2"
                )};
                let wValue2 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1 + 2",
                  "d2"
                )};
                let wValue3 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1 + 3",
                  "d2"
                )};

                var xValue = ${we.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${c}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${we.get("batch", "idyR", "idyC2", "d2")};

                dotProd[1] = dotProd[1] + vec4<${c}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${H}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1",
                  "d2"
                )};
                let wValue1 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1 + 1",
                  "d2"
                )};
                let wValue2 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1 + 2",
                  "d2"
                )};
                let wValue3 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1 + 3",
                  "d2"
                )};

                var xValue = ${we.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${c}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1",
                  "d2"
                )};
                let wValue1 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1 + 1",
                  "d2"
                )};
                let wValue2 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1 + 2",
                  "d2"
                )};
                let wValue3 = ${le.get(
                  "u32(wRPerm)",
                  "u32(wCPerm)",
                  "d1 + 3",
                  "d2"
                )};

                var xValue = ${we.get("batch", "idyR", "idyC2", "d2")};
                let tmpval = vec4<${c}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${w}; i = i + 1) {
          let value = dotProd[i] + ${u ? "bias[c+i]" : `vec4<${c}>(0.0)`};
          ${me.set("batch", "r", "c + i", "d1", "value")};
        }
      }`,
                Ce = `
          let outputIndices = ${me.offsetToIndices("global_idx")};
          let batch = ${me.indicesGet("outputIndices", 0)};
          let d1 = ${me.indicesGet("outputIndices", H)};
          let r = ${me.indicesGet("outputIndices", E)};
          let c = ${me.indicesGet("outputIndices", q)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${c}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${c}(dyRCorner) + ${c}(wR)) / ${c}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${c}(uniforms.Dy_shape[${E}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${c}(dyCCorner) + ${c}(wC)) / ${c}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${c}(uniforms.Dy_shape[${q}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${
                  k
                    ? we.get("batch", "idyR", "idyC", "inputChannel")
                    : we.get("batch", "inputChannel", "idyR", "idyC")
                };
                let wValue = ${le.get(
                  "inputChannel",
                  "wOutChannel",
                  "u32(wRPerm)",
                  "u32(wCPerm)"
                )};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${u ? "bias[d1]" : `${c}(0.0)`};
          ${me.setByOffset("global_idx", "value")};
        `;
              return `
  ${r.registerUniforms(b).declareVariables(...be, me)}
  ${Z}

    ${r.mainStart()}
    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${p ? Fe : Ce}}`;
            }),
            (_l = (r, i, s) => {
              let u = r.length > 2,
                d = i.outputShape,
                p = Ze.size(d),
                c = [Math.ceil(p / 64), 1, 1];
              Kr("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${c}`);
              let b = i.format === "NHWC",
                k = ["rank", "rank"],
                E = [i.strides[0], i.strides[1]],
                q = [i.kernelShape[b ? 1 : 2], i.kernelShape[b ? 2 : 3]],
                H = [i.dilations[0], i.dilations[1]],
                w = [
                  q[0] +
                    (i.dilations[0] <= 1
                      ? 0
                      : (i.kernelShape[b ? 1 : 2] - 1) * (i.dilations[0] - 1)),
                  q[1] +
                    (i.dilations[1] <= 1
                      ? 0
                      : (i.kernelShape[b ? 2 : 3] - 1) * (i.dilations[1] - 1))
                ],
                Z = [
                  w[0] - 1 - Math.floor((i.pads[0] + i.pads[2]) / 2),
                  w[1] - 1 - Math.floor(i.pads[1] + i.pads[3]) / 2
                ],
                re = !1,
                le = i.group,
                we = r[1].dims,
                be = we[0] / le,
                me = we[1],
                Fe = [
                  { type: 12, data: p },
                  { type: 12, data: E },
                  { type: 12, data: q },
                  { type: 12, data: H },
                  { type: 12, data: w },
                  { type: 6, data: Z },
                  { type: 12, data: be },
                  { type: 12, data: me },
                  ...zt(r[0].dims, r[1].dims)
                ];
              u && (Fe.push(...zt(r[2].dims)), k.push("rank")),
                Fe.push(...zt(d));
              let Ce = c[1] === 1 && c[2] === 1,
                ze = (dt) => {
                  let lt = [
                      { name: "output_size", type: "u32" },
                      { name: "strides", type: "u32", length: E.length },
                      { name: "filter_dims", type: "u32", length: q.length },
                      { name: "dilations", type: "u32", length: q.length },
                      {
                        name: "effective_filter_dims",
                        type: "u32",
                        length: w.length
                      },
                      { name: "pads", type: "i32", length: Z.length },
                      { name: "input_channels_per_group", type: "u32" },
                      { name: "output_channels_per_group", type: "u32" }
                    ],
                    Mt = Fr(r[0].dataType);
                  return `${wd(dt, r, d, u, Ce, re, Mt, lt, b)}`;
                };
              return {
                name: "ConvTranspose2D",
                shaderCache: { hint: `${i.cacheKey};`, inputDependencies: k },
                getRunData: () => ({
                  dispatchGroup: { x: c[0], y: c[1], z: c[2] },
                  outputs: [{ dims: s ? s(d) : d, dataType: r[0].dataType }],
                  programUniforms: Fe
                }),
                getShaderSource: ze
              };
            });
        }),
        vd,
        bd,
        xd,
        wl,
        vl,
        Ks,
        Pp,
        Md,
        Td,
        bl,
        $p = m(() => {
          yd(),
            yl(),
            Rn(),
            Mo(),
            (vd = (r, i, s, u, d, p) => (r - 1) * i + s + (u - 1) * d + 1 - p),
            (bd = (r, i, s, u, d) => {
              let p = Math.floor(r / 2);
              i === "SAME_UPPER"
                ? ((s[u] = p), (s[d] = r - p))
                : i === "SAME_LOWER" && ((s[u] = r - p), (s[d] = p));
            }),
            (xd = (r, i, s, u, d, p, c, b, k, E) => {
              let q = r.length - 2,
                H = E.length === 0;
              if (k.length === 0) for (let re = 0; re < q; ++re) k.push(0);
              let w = r[0],
                Z = i[b ? 3 : 1] * d;
              for (
                let re = 0, le = r.length - q - (b ? 1 : 0);
                re < q;
                ++re, ++le
              ) {
                let we = r[le],
                  be = H ? we * c[re] : E[re],
                  me = vd(we, c[re], p[re], i[le], s[re], be);
                bd(me, u, p, re, re + q),
                  H &&
                    E.push(
                      c[re] * (we - 1) +
                        k[re] +
                        (i[le] - 1) * s[re] +
                        1 -
                        p[re] -
                        p[re + q]
                    );
              }
              E.splice(0, 0, w), E.splice(b ? 3 : 1, 0, Z);
            }),
            (wl = (r, i) => {
              let s = r.kernelShape.slice();
              if (
                r.kernelShape.length === 0 ||
                r.kernelShape.reduce((H, w) => H * w, 1) === 0
              ) {
                s.length = 0;
                for (let H = 2; H < i[1].dims.length; ++H) s.push(i[1].dims[H]);
              }
              let u = r.format === "NHWC";
              s.splice(0, 0, i[1].dims[0]),
                s.splice(u ? 3 : 1, 0, i[1].dims[1]);
              let d = r.pads.slice(),
                p = r.outputShape.slice(),
                c = r.outputPadding.slice(),
                b = i[0].dims,
                k = r.dilations.slice();
              if (k.reduce((H, w) => H + w, 0) === 0) {
                let H = i[0].dims.length - 2;
                k = new Array(H).fill(1);
              }
              let E = r.strides.slice();
              if (E.reduce((H, w) => H + w, 0) === 0) {
                let H = i[0].dims.length - 2;
                E = new Array(H).fill(1);
              }
              xd(b, s, k, r.autoPad, r.group, d, E, u, c, p);
              let q = Object.assign({}, r);
              return (
                Object.assign(q, {
                  kernelShape: s,
                  pads: d,
                  outputPadding: c,
                  outputShape: p,
                  dilations: k,
                  strides: E
                }),
                q
              );
            }),
            (vl = (r) => {
              let i = nl(r),
                s = r.format,
                u = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][
                  typeof r.autoPad > "u" ? 0 : r.autoPad
                ],
                d = r.dilations,
                p = r.group,
                c = r.kernelShape,
                b = r.pads,
                k = r.strides,
                E = r.wIsConst(),
                q = r.outputPadding,
                H = r.outputShape;
              return {
                autoPad: u,
                format: s,
                dilations: d,
                group: p,
                kernelShape: c,
                outputPadding: q,
                outputShape: H,
                pads: b,
                strides: k,
                wIsConst: E,
                ...i,
                cacheKey: `${r.format};${i.activation};`
              };
            }),
            (Ks = (r, i) => {
              if (!r || (r.length !== 2 && r.length !== 3))
                throw new Error("Conv requires 2 or 3 inputs");
              if (r[0].dims.length !== 4 && r[0].dims.length !== 3)
                throw new Error("currently only support 2-dimensional conv");
              if (r[0].dims.length !== r[1].dims.length)
                throw new Error("filter does not have same dimension as input");
              let s = r[0].dims[i.format === "NHWC" ? r[0].dims.length - 1 : 1],
                u = r[1].dims[0];
              if (s !== u)
                throw new Error(
                  "FILTER_IN_CHANNEL should be equal to DATA_CHANNEL"
                );
              let d = r[1].dims[1] * i.group;
              if (
                r.length === 3 &&
                (r[2].dims.length !== 1 || r[2].dims[0] !== d)
              )
                throw new Error("invalid bias");
              let p = r[0].dims.length - 2;
              if (
                i.dilations.reduce((c, b) => c + b, 0) > 0 &&
                i.dilations.length !== p
              )
                throw new Error(`dilations should be ${p}D`);
              if (
                i.strides.reduce((c, b) => c + b, 0) > 0 &&
                i.strides.length !== p
              )
                throw new Error(`strides should be ${p}D`);
              if (
                i.pads.reduce((c, b) => c + b, 0) > 0 &&
                i.pads.length !== p * 2
              )
                throw new Error(`pads should be ${p * 2}D`);
              if (i.outputPadding.length !== p && i.outputPadding.length !== 0)
                throw new Error(`output_padding should be ${p}D`);
              if (
                i.kernelShape.reduce((c, b) => c + b, 0) > 0 &&
                i.kernelShape.length !== 0 &&
                i.kernelShape.length !== r[1].dims.length - 2
              )
                throw new Error("invalid kernel shape");
              if (
                i.outputShape.length !== 0 &&
                i.outputShape.length !== r[0].dims.length - 2
              )
                throw new Error("invalid output shape");
            }),
            (Pp = [2, 3, 1, 0]),
            (Md = (r, i, s) => {
              let u = wl(s, i),
                d = s.format === "NHWC",
                p = u.outputShape,
                c = p[d ? 3 : 1],
                b = i[0].dims[d ? 3 : 1];
              if (u.group !== 1 || (c === 1 && b === 1)) {
                r.compute(_l(i, u));
                return;
              }
              let k = p[d ? 1 : 2],
                E = p[d ? 2 : 3],
                q = i[1].dims[2],
                H = i[1].dims[3],
                w = d ? k * E : c,
                Z = d ? c : k * E,
                re = q * H * b,
                le = !0,
                we =
                  r.kernelCustomData.wT ??
                  r.compute(bi(i[1], Pp), {
                    inputs: [1],
                    outputs: [s.wIsConst ? -2 : -1]
                  })[0];
              s.wIsConst &&
                !r.kernelCustomData.wT &&
                (r.kernelCustomData.wT = we);
              let be = [i[0], we],
                me = i.length === 3;
              me &&
                (!d && i[2].dims.length === 1
                  ? be.push(i[2].reshape([i[2].dims[0], 1, 1]))
                  : be.push(i[2])),
                r.compute(_d(be, u, p, w, Z, re, me, le), { inputs: be });
            }),
            (Td = (r, i) => {
              let s = i.format === "NHWC",
                u = [
                  r.inputs[0].reshape(
                    s
                      ? [
                          r.inputs[0].dims[0],
                          1,
                          r.inputs[0].dims[1],
                          r.inputs[0].dims[2]
                        ]
                      : [
                          r.inputs[0].dims[0],
                          r.inputs[0].dims[1],
                          1,
                          r.inputs[0].dims[2]
                        ]
                  ),
                  r.inputs[1].reshape([
                    r.inputs[1].dims[0],
                    r.inputs[1].dims[1],
                    1,
                    r.inputs[1].dims[2]
                  ])
                ];
              r.inputs.length === 3 && u.push(r.inputs[2]);
              let d = i.kernelShape;
              (d.length === 0 || d[0] === 0) && (d = [r.inputs[1].dims[2]]);
              let p = i.dilations;
              (p.length === 0 || p[0] === 0) && (p = [1]);
              let c = i.strides;
              (c.length === 0 || c[0] === 0) && (c = [1]);
              let b = i.pads;
              b.length === 0 && (b = [0, 0]),
                (b = [0, b[0], 0, b[1]]),
                (c = [1].concat(c)),
                (p = [1].concat(p)),
                (d = [1].concat(d));
              let k = wl(
                { ...i, pads: b, strides: c, dilations: p, kernelShape: d },
                u
              );
              r.compute(
                _l(u, k, (E) => (s ? [E[0], E[2], E[3]] : [E[0], E[1], E[3]]))
              );
            }),
            (bl = (r, i) => {
              Ks(r.inputs, i),
                r.inputs[0].dims.length === 3 ? Td(r, i) : Md(r, r.inputs, i);
            });
        }),
        kd,
        xl,
        Sd,
        Ap = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (kd = (r, i, s, u) => {
              let d = Ze.size(i),
                p = i.length,
                c = gt("input", r, p),
                b = Ht("output", r, p),
                k =
                  s.dataType === 6
                    ? s.getInt32Array()[0]
                    : Number(s.getBigInt64Array()[0]),
                E = Ze.normalizeAxis(k, p),
                q = (H) => {
                  let w = ` i32(${c.indicesGet(
                      "inputIndices",
                      "uniforms.axis"
                    )}) `,
                    Z = jt("uniforms.input_shape", "uniforms.axis", p),
                    re = u.reverse ? w + (u.exclusive ? " + 1" : "") : "0",
                    le = u.reverse ? Z : w + (u.exclusive ? "" : " + 1");
                  return `
                ${H.registerUniform("outputSize", "u32")
                  .registerUniform("axis", "u32")
                  .declareVariables(c, b)}
                ${H.mainStart()}
                  ${H.guardAgainstOutOfBoundsWorkgroupSizes(
                    "uniforms.outputSize"
                  )}
                  var inputIndices = ${b.offsetToIndices("global_idx")};
                  var sum = ${b.type.value}(0);
                  let first : i32 = ${re};
                  let last : i32 = ${le};
                  for (var i : i32 = first; i < last; i++) {
                    ${c.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${c.getByIndices("inputIndices")};
                  }
                  ${b.setByOffset("global_idx", "sum")};
                }`;
                };
              return {
                name: "CumSum",
                shaderCache: { hint: u.cacheKey, inputDependencies: ["rank"] },
                getRunData: () => ({
                  outputs: [{ dims: i, dataType: r }],
                  dispatchGroup: { x: Math.ceil(d / 64) },
                  programUniforms: [
                    { type: 12, data: d },
                    { type: 12, data: E },
                    ...zt(i, i)
                  ]
                }),
                getShaderSource: q
              };
            }),
            (xl = (r, i) => {
              let s = r.inputs[0].dims,
                u = r.inputs[0].dataType,
                d = r.inputs[1];
              r.compute(kd(u, s, d, i), { inputs: [0] });
            }),
            (Sd = (r) => {
              let i = r.exclusive === 1,
                s = r.reverse === 1;
              return Qt({ exclusive: i, reverse: s });
            });
        }),
        Ml,
        Ip,
        Fp,
        Tl,
        kl,
        zp = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (Ml = (r) => {
              if (!r || r.length !== 1)
                throw new Error("DepthToSpace requires 1 input.");
              if (r[0].dims.length !== 4)
                throw new Error("DepthToSpace requires 4D input.");
            }),
            (Ip = (r, i, s, u) => {
              let d = [];
              d.push(`fn perm(i: ${u.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`);
              for (let p = 0; p < i; ++p)
                d.push(s.indicesSet("a", r[p], `i[${p}]`));
              return (
                d.push("return a;}"),
                d.join(`
`)
              );
            }),
            (Fp = (r, i) => {
              let s,
                u,
                d,
                p,
                c,
                b,
                k = i.format === "NHWC",
                E = i.blocksize,
                q = i.mode === "DCR";
              k
                ? (([s, u, d, p] = r.dims),
                  (c = q
                    ? [s, u, d, E, E, p / E ** 2]
                    : [s, u, d, p / E ** 2, E, E]),
                  (b = q ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3]))
                : (([s, u, d, p] = [
                    r.dims[0],
                    r.dims[2],
                    r.dims[3],
                    r.dims[1]
                  ]),
                  (c = q
                    ? [s, E, E, p / E ** 2, u, d]
                    : [s, p / E ** 2, E, E, u, d]),
                  (b = q ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3]));
              let H = r.reshape(c),
                w = H.dims.length,
                Z = r.dataType,
                re = gt("a", Z, w),
                le = Ht("output", Z, w),
                we = (be) => `
  ${be.registerUniform("output_size", "u32").declareVariables(re, le)}

  ${Ip(b, w, re, le)}

  ${be.mainStart()}
    ${be.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${le.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${le.setByOffset("global_idx", re.getByIndices("aIndices"))}
  }`;
              return {
                name: "DepthToSpace",
                shaderCache: {
                  hint: `${r.dims};${i.blocksize};${i.mode}`,
                  inputDependencies: ["rank"]
                },
                getRunData: (be) => {
                  let me = k
                      ? [s, u * E, d * E, p / E ** 2]
                      : [s, p / E ** 2, u * E, d * E],
                    Fe = Ze.size(me),
                    Ce = H.dims,
                    ze = Ze.sortBasedOnPerm(Ce, b);
                  return {
                    outputs: [{ dims: me, dataType: be[0].dataType }],
                    dispatchGroup: { x: Math.ceil(Fe / 64) },
                    programUniforms: [{ type: 12, data: Fe }, ...zt(Ce, ze)]
                  };
                },
                getShaderSource: we
              };
            }),
            (Tl = (r, i) => {
              Ml(r.inputs), r.compute(Fp(r.inputs[0], i));
            }),
            (kl = (r) =>
              Qt({ blocksize: r.blocksize, mode: r.mode, format: r.format }));
        }),
        Qs,
        So,
        Sl,
        Ed,
        El,
        Cd,
        Pd,
        Xs,
        $d,
        Ad,
        Dr,
        Im = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (Qs = "[a-zA-Z]|\\.\\.\\."),
            (So = "(" + Qs + ")+"),
            (Sl = "^" + So + "$"),
            (Ed = "(" + So + ",)*" + So),
            (El = "^" + Ed + "$"),
            (Cd = class {
              constructor(r = -1) {
                (this.symbolToIndices = new Map()), (this.inputIndex = r);
              }
              addSymbol(r, i) {
                let s = this.symbolToIndices.get(r);
                s === void 0 ? (s = [i]) : s.push(i),
                  this.symbolToIndices.set(r, s);
              }
            }),
            (Pd = class {
              constructor(r, i) {
                var d;
                (this.equation = i),
                  (this.hasEllipsis = !1),
                  (this.symbolToInfo = new Map()),
                  (this.lhs = new Array()),
                  (this.outputDims = []);
                let [s, u] = i.includes("->") ? i.split("->", 2) : [i, ""];
                if (!s.match(RegExp(El))) throw new Error("Invalid LHS term");
                if (
                  (s.split(",").forEach((p, c) => {
                    let b = r[c].dims.slice();
                    if (!p.match(RegExp(Sl)))
                      throw new Error("Invalid LHS term");
                    let k = this.processTerm(p, !0, b, c);
                    this.lhs.push(k);
                  }),
                  u === "")
                )
                  u += [...this.symbolToInfo.entries()]
                    .filter(([p, c]) => c.count === 1 || p === "...")
                    .map(([p]) => p)
                    .join("");
                else if (!u.match(RegExp(So))) throw new Error("Invalid RHS");
                (d = u.match(RegExp(Qs, "g"))) == null ||
                  d.forEach((p) => {
                    if (p === "...")
                      this.outputDims = this.outputDims.concat(
                        this.ellipsisDims
                      );
                    else {
                      let c = this.symbolToInfo.get(p);
                      if (c === void 0) throw new Error("Invalid RHS symbol");
                      this.outputDims.push(c.dimValue);
                    }
                  }),
                  (this.rhs = this.processTerm(u, !1, this.outputDims));
              }
              addSymbol(r, i, s) {
                let u = this.symbolToInfo.get(r);
                if (u !== void 0) {
                  if (u.dimValue !== i && u.count !== 1)
                    throw new Error("Dimension mismatch");
                  u.count++, u.inputIndices.push(s);
                } else u = { count: 1, dimValue: i, inputIndices: [s] };
                this.symbolToInfo.set(r, u);
              }
              processTerm(r, i, s, u = -1) {
                let d = s.length,
                  p = !1,
                  c = [],
                  b = 0;
                if (!r.match(RegExp(Sl)) && !i && r !== "")
                  throw new Error("Invalid LHS term");
                let k = r.match(RegExp(Qs, "g")),
                  E = new Cd(u);
                return (
                  k == null ||
                    k.forEach((q, H) => {
                      if (q === "...") {
                        if (p)
                          throw new Error(
                            "Only one ellipsis is allowed per input term"
                          );
                        p = !0;
                        let w = d - k.length + 1;
                        if (w < 0) throw new Error("Ellipsis out of bounds");
                        if (((c = s.slice(b, b + w)), this.hasEllipsis)) {
                          if (
                            this.ellipsisDims.length !== c.length ||
                            this.ellipsisDims.toString() !== c.toString()
                          )
                            throw new Error("Ellipsis dimensions mismatch");
                        } else if (i)
                          (this.hasEllipsis = !0), (this.ellipsisDims = c);
                        else
                          throw new Error(
                            "Ellipsis must be specified in the LHS"
                          );
                        for (let Z = 0; Z < c.length; Z++) {
                          let re = String.fromCharCode(48 + Z);
                          E.addSymbol(re, H + Z), this.addSymbol(re, s[b++], u);
                        }
                      } else
                        E.addSymbol(
                          q,
                          H +
                            (this.hasEllipsis
                              ? this.ellipsisDims.length - 1
                              : 0)
                        ),
                          this.addSymbol(q, s[b++], u);
                    }),
                  E
                );
              }
            }),
            (Xs = (r) => r + "_max"),
            ($d = (r, i, s, u) => {
              let d = r
                  .map((E) => E.length)
                  .map((E, q) => gt(`input${q}`, i, E)),
                p = Ze.size(u),
                c = Ht("output", i, u.length),
                b = [...s.symbolToInfo.keys()].filter(
                  (E) => !s.rhs.symbolToIndices.has(E)
                ),
                k = (E) => {
                  let q = [],
                    H = "var prod = 1.0;",
                    w = "var sum = 0.0;",
                    Z = "sum += prod;",
                    re = [],
                    le = [],
                    we = [],
                    be = [],
                    me = s.symbolToInfo.size === s.rhs.symbolToIndices.size;
                  s.symbolToInfo.forEach((Ce, ze) => {
                    var dt;
                    if (s.rhs.symbolToIndices.has(ze)) {
                      let lt =
                        (dt = s.rhs.symbolToIndices.get(ze)) == null
                          ? void 0
                          : dt[0];
                      lt !== void 0 &&
                        s.lhs.forEach((Mt, Dt) => {
                          if (Ce.inputIndices.includes(Dt)) {
                            let Ut = Mt.symbolToIndices.get(ze);
                            if (Ut === void 0)
                              throw new Error("Invalid symbol error");
                            Ut.forEach((fr) => {
                              q.push(
                                `${d[Dt].indicesSet(
                                  `input${Dt}Indices`,
                                  fr,
                                  c.indicesGet("outputIndices", lt)
                                )}`
                              );
                            });
                          }
                        });
                    } else
                      s.lhs.forEach((lt, Mt) => {
                        if (Ce.inputIndices.includes(Mt)) {
                          let Dt = lt.symbolToIndices.get(ze);
                          if (Dt === void 0)
                            throw new Error("Invalid symbol error");
                          Dt.forEach((Ut) => {
                            re.push(
                              `${d[Mt].indicesSet(
                                `input${Mt}Indices`,
                                Ut,
                                `${ze}`
                              )}`
                            );
                          }),
                            be.push(
                              `prod *= ${d[Mt].getByIndices(
                                `input${Mt}Indices`
                              )};`
                            );
                        }
                      }),
                        le.push(
                          `for(var ${ze}: u32 = 0; ${ze} < uniforms.${Xs(
                            ze
                          )}; ${ze}++) {`
                        ),
                        we.push("}");
                  });
                  let Fe = me
                    ? [
                        ...q,
                        `let sum = ${d
                          .map((Ce, ze) => Ce.getByIndices(`input${ze}Indices`))
                          .join(" * ")};`
                      ]
                    : [...q, w, ...le, ...re, H, ...be, Z, ...we];
                  return `
            ${E.registerUniforms(
              b.map((Ce) => ({ name: `${Xs(Ce)}`, type: "u32" }))
            )
              .registerUniform("outputSize", "u32")
              .declareVariables(...d, c)}

            ${E.mainStart()}
            ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${c.offsetToIndices("global_idx")};
            ${d.map((Ce, ze) => `var input${ze}Indices: ${d[ze].type.indices};`)
              .join(`
`)}
            ${Fe.join(`
`)};
            ${c.setByOffset("global_idx", "sum")};
          }`;
                };
              return {
                name: "Einsum",
                shaderCache: {
                  hint: s.equation,
                  inputDependencies: r.map(() => "rank")
                },
                getRunData: () => {
                  let E = b
                    .filter((H) => s.symbolToInfo.has(H))
                    .map((H) => {
                      var w;
                      return {
                        type: 12,
                        data:
                          ((w = s.symbolToInfo.get(H)) == null
                            ? void 0
                            : w.dimValue) || 0
                      };
                    });
                  E.push({ type: 12, data: p });
                  let q = r
                    .map((H, w) => [...zt(H)])
                    .reduce((H, w) => H.concat(w), E);
                  return (
                    q.push(...zt(u)),
                    {
                      outputs: [{ dims: u, dataType: i }],
                      dispatchGroup: { x: Math.ceil(p / 64) },
                      programUniforms: q
                    }
                  );
                },
                getShaderSource: k
              };
            }),
            (Ad = (r, i) => {
              let s = new Pd(r.inputs, i.equation),
                u = s.outputDims,
                d = r.inputs.map((p, c) => p.dims);
              r.compute($d(d, r.inputs[0].dataType, s, u));
            }),
            (Dr = (r) => {
              let i = r.equation.replace(/\s+/g, "");
              return Qt({ equation: i });
            });
        }),
        Op,
        Id,
        Cl,
        Fd,
        zd,
        Dp = m(() => {
          Yt(),
            Zt(),
            cr(),
            (Op = (r) => {
              if (!r || r.length !== 2)
                throw new Error("Expand requires 2 input.");
              let i = r[0].dims,
                s = Array.from(r[1].getBigInt64Array(), Number),
                u = s.length < i.length ? 0 : s.length - i.length,
                d = i.length < s.length ? 0 : i.length - s.length;
              for (; u < s.length && d < i.length; ++u, ++d)
                if (s[u] !== i[d] && s[u] !== 1 && i[d] !== 1)
                  throw new Error(
                    "Expand requires shape to be broadcastable to input"
                  );
            }),
            (Id = (r, i) => {
              let s = r.length - i.length,
                u = [];
              for (let d = 0; d < s; ++d) u.push(r[d]);
              for (let d = 0; d < i.length; ++d)
                u.push(i[d] === 1 ? r[d + s] : i[d]);
              return u;
            }),
            (Cl = (r, i) => (r.length > i.length ? Id(r, i) : Id(i, r))),
            (Fd = (r) => {
              let i = r[0].dims,
                s = Array.from(r[1].getBigInt64Array(), Number),
                u = Cl(i, s),
                d = r[0].dataType,
                p = d === 9 ? 4 : 1,
                c = Math.ceil(Ze.size(u) / p),
                b = (E) => {
                  let q = gt("input", d, i.length, p),
                    H = Ht("output", d, u.length, p),
                    w;
                  if (d === 9) {
                    let Z = (re, le, we = "") => `
          let outputIndices${le} = ${H.offsetToIndices(
                      `outputOffset + ${le}u`
                    )};
          let offset${le} = ${q.broadcastedIndicesToOffset(
                      `outputIndices${le}`,
                      H
                    )};
          let index${le} = offset${le} / 4u;
          let component${le} = offset${le} % 4u;
          ${re}[${le}] = ${we}(${q.getByOffset(`index${le}`)}[component${le}]);
        `;
                    w = `
        let outputOffset = global_idx * ${p};
        var data = vec4<u32>(0);
        ${Z("data", 0, "u32")}
        ${Z("data", 1, "u32")}
        ${Z("data", 2, "u32")}
        ${Z("data", 3, "u32")}
        ${H.setByOffset("global_idx", "data")}
      }`;
                  } else
                    w = `
        let outputIndices = ${H.offsetToIndices("global_idx")};
        let inputOffset = ${q.broadcastedIndicesToOffset("outputIndices", H)};
        ${H.setByOffset("global_idx", q.getByOffset("inputOffset"))}
      }`;
                  return `
    ${E.registerUniform("vec_size", "u32").declareVariables(q, H)}
    ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${w}`;
                },
                k = [{ type: 12, data: c }, ...zt(i, u)];
              return {
                name: "Expand",
                shaderCache: {
                  hint: `${u.length}`,
                  inputDependencies: ["rank"]
                },
                getShaderSource: b,
                getRunData: () => ({
                  outputs: [{ dims: u, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(c / 64) },
                  programUniforms: k
                })
              };
            }),
            (zd = (r) => {
              Op(r.inputs), r.compute(Fd(r.inputs), { inputs: [0] });
            });
        }),
        Od,
        Pl,
        Dd = m(() => {
          Yt(),
            Zt(),
            cr(),
            Xa(),
            (Od = (r) => {
              let i = r[0].dataType,
                s = Ze.size(r[0].dims),
                u = Ze.size(r[1].dims),
                d = u % 4 === 0,
                p = (c) => {
                  let b = gt("x", i, [1], 4),
                    k = gt("bias", i, [1], 4),
                    E = Ht("y", i, [1], 4),
                    q = [
                      { name: "output_vec_size", type: "u32" },
                      { name: "bias_size", type: "u32" }
                    ],
                    H = (Z) => `
      let bias${Z}_offset: u32 = (global_idx * 4 + ${Z}) % uniforms.bias_size;
      let bias${Z} = ${k.getByOffset(
                      `bias${Z}_offset / 4`
                    )}[bias${Z}_offset % 4];`,
                    w = d
                      ? `
      let bias = ${k.getByOffset("global_idx % (uniforms.bias_size / 4)")};`
                      : `${H(0)}${H(1)}${H(2)}${H(3)}
      let bias = ${b.type.value}(bias0, bias1, bias2, bias3);`;
                  return `${c.registerUniforms(q).declareVariables(b, k, E)}

    ${qa(Pr(i))}

    ${c.mainStart(Kn)}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${b.getByOffset("global_idx")};
      ${w}
      let x_in = x + bias;
      ${E.setByOffset("global_idx", Ka("x_in"))}
    }`;
                };
              return {
                name: "FastGeluWithBias",
                shaderCache: {
                  hint: `${d}`,
                  inputDependencies: ["type", "type"]
                },
                getShaderSource: p,
                getRunData: (c) => ({
                  outputs: [{ dims: c[0].dims, dataType: c[0].dataType }],
                  programUniforms: [
                    { type: 12, data: Math.ceil(s / 4) },
                    { type: 12, data: u }
                  ],
                  dispatchGroup: { x: Math.ceil(s / Kn / 4) }
                })
              };
            }),
            (Pl = (r) => {
              r.inputs.length < 2 || Ze.size(r.inputs[1].dims) === 0
                ? Qa(r)
                : r.compute(Od(r.inputs));
            });
        }),
        Ld,
        Bd,
        $l,
        Lp,
        Fm = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (Ld = (r) => {
              if (!r || r.length !== 2)
                throw new Error("Gather requires 2 inputs.");
            }),
            (Bd = (r, i) => {
              let s = r[0].dims,
                u = r[1].dims,
                d = s.length,
                p = Ze.normalizeAxis(i.axis, d),
                c = s.slice(0);
              c.splice(p, 1, ...u);
              let b = s[p],
                k = r[0].dataType === 9 ? 4 : 1,
                E = Math.ceil(Ze.size(c) / k),
                q = [
                  { type: 12, data: E },
                  { type: 6, data: b },
                  { type: 12, data: p },
                  ...zt(r[0].dims, r[1].dims, c)
                ],
                H = (w) => {
                  let Z = gt("data", r[0].dataType, r[0].dims.length, k),
                    re = gt("inputIndices", r[1].dataType, r[1].dims.length),
                    le = Ht("output", r[0].dataType, c.length, k),
                    we = (me) => {
                      let Fe = u.length,
                        Ce = `var indicesIndices${me}  = ${re.type.indices}(0);`;
                      for (let ze = 0; ze < Fe; ze++)
                        Ce += `${
                          Fe > 1
                            ? `indicesIndices${me}[${ze}]`
                            : `indicesIndices${me}`
                        } = ${
                          c.length > 1
                            ? `outputIndices${me}[uniforms.axis + ${ze}]`
                            : `outputIndices${me}`
                        };`;
                      Ce += `
          var idx${me} = ${re.getByIndices(`indicesIndices${me}`)};
          if (idx${me} < 0) {
            idx${me} = idx${me} + uniforms.axisDimLimit;
          }
          var dataIndices${me} : ${Z.type.indices};
        `;
                      for (let ze = 0, dt = 0; ze < d; ze++)
                        ze === p
                          ? ((Ce += `${
                              d > 1
                                ? `dataIndices${me}[${ze}]`
                                : `dataIndices${me}`
                            } = u32(idx${me});`),
                            (dt += Fe))
                          : ((Ce += `${
                              d > 1
                                ? `dataIndices${me}[${ze}]`
                                : `dataIndices${me}`
                            } = ${
                              c.length > 1
                                ? `outputIndices${me}[${dt}]`
                                : `outputIndices${me}`
                            };`),
                            dt++);
                      return Ce;
                    },
                    be;
                  if (r[0].dataType === 9) {
                    let me = (Fe, Ce, ze = "") => `
          let outputIndices${Ce} = ${le.offsetToIndices(
                      `outputOffset + ${Ce}u`
                    )};
          ${we(Ce)};
          let offset${Ce} = ${Z.indicesToOffset(`dataIndices${Ce}`)};
          let index${Ce} = offset${Ce} / 4u;
          let component${Ce} = offset${Ce} % 4u;
          ${Fe}[${Ce}] = ${ze}(${Z.getByOffset(`index${Ce}`)}[component${Ce}]);
        `;
                    be = `
        let outputOffset = global_idx * ${k};
        var value = vec4<u32>(0);
        ${me("value", 0, "u32")}
        ${me("value", 1, "u32")}
        ${me("value", 2, "u32")}
        ${me("value", 3, "u32")}
        ${le.setByOffset("global_idx", "value")}
      `;
                  } else
                    be = `
      let outputIndices = ${le.offsetToIndices("global_idx")};
      ${we("")};
      let value = ${Z.getByIndices("dataIndices")};
      ${le.setByOffset("global_idx", "value")};
      `;
                  return `
      ${w
        .registerUniform("outputSize", "u32")
        .registerUniform("axisDimLimit", "i32")
        .registerUniform("axis", "u32")
        .declareVariables(Z, re, le)}
      ${w.mainStart()}
        ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${be}
      }`;
                };
              return {
                name: "Gather",
                shaderCache: {
                  hint: i.cacheKey,
                  inputDependencies: ["rank", "rank"]
                },
                getRunData: () => ({
                  outputs: [{ dims: c, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(E / 64) },
                  programUniforms: q
                }),
                getShaderSource: H
              };
            }),
            ($l = (r) => Qt({ axis: r.axis })),
            (Lp = (r, i) => {
              let s = r.inputs;
              Ld(s), r.compute(Bd(r.inputs, i));
            });
        }),
        Rd,
        Nd,
        jd,
        Ud,
        Bp = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (Rd = (r, i) => {
              if (r.length < 3 || r.length > 4)
                throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");
              let s = Ze.normalizeAxis(i.quantizeAxis, r[0].dims.length),
                u = i.blockSize,
                d = r[0],
                p = r[2],
                c = r.length === 4 ? r[3] : void 0;
              if (
                p.dims.length !== d.dims.length ||
                !d.dims
                  .map((b, k) =>
                    k === s ? Math.ceil(b / u) === p.dims[k] : b === p.dims[k]
                  )
                  .reduce((b, k) => b && k, !0)
              )
                throw new Error(
                  "Scales must have the same rank as the input tensor and the dims should match except on gatherAxis."
                );
              if (c) {
                if (c.dataType !== d.dataType)
                  throw new Error(
                    "Zero point must have the same data type as the input tensor."
                  );
                if (
                  c.dims.length !== p.dims.length ||
                  !c.dims
                    .map((b, k) => b === p.dims[k])
                    .reduce((b, k) => b && k, !0)
                )
                  throw new Error(
                    "Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis."
                  );
              }
            }),
            (Nd = (r, i) => {
              let s = r[0].dims,
                u = r[1].dims,
                d = s.length,
                p = Ze.normalizeAxis(i.gatherAxis, d),
                c = Ze.normalizeAxis(i.quantizeAxis, d),
                b = s.slice(0);
              b.splice(p, 1, ...u);
              let k = Ze.size(b),
                E = r[2].dataType,
                q = r[0].dataType === 22,
                H = [
                  { type: 12, data: k },
                  { type: 12, data: c },
                  { type: 12, data: p },
                  { type: 12, data: i.blockSize },
                  ...zt(...r.map((Z, re) => Z.dims), b)
                ],
                w = (Z) => {
                  let re = gt("data", r[0].dataType, r[0].dims.length),
                    le = gt("inputIndices", r[1].dataType, r[1].dims.length),
                    we = gt("scales", r[2].dataType, r[2].dims.length),
                    be =
                      r.length > 3
                        ? gt("zeroPoint", r[3].dataType, r[3].dims.length)
                        : void 0,
                    me = Ht("output", E, b.length),
                    Fe = [re, le, we];
                  be && Fe.push(be);
                  let Ce = [
                    { name: "output_size", type: "u32" },
                    { name: "quantize_axis", type: "u32" },
                    { name: "gather_axis", type: "u32" },
                    { name: "block_size", type: "u32" }
                  ];
                  return `
        ${Z.registerUniforms(Ce).declareVariables(...Fe, me)}
        ${Z.mainStart()}
        let output_indices = ${me.offsetToIndices("global_idx")};
        var indices_indices = ${le.type.indices}(0);
        ${
          u.length > 1
            ? `
          for (var i: u32 = 0; i < ${u.length}; i++) {
            let index = ${me.indicesGet(
              "output_indices",
              "uniforms.gather_axis + i"
            )};
            ${le.indicesSet("indices_indices", "i", "index")};
          }`
            : `indices_indices = ${me.indicesGet(
                "output_indices",
                "uniforms.gather_axis"
              )};`
        };
        var data_indices = ${re.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${me.indicesGet("output_indices", "i")};
          ${re.indicesSet("data_indices", "i", "index")};
        }
        var index_from_indices = ${le.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${s[p]};
        }
        ${re.indicesSet(
          "data_indices",
          "uniforms.gather_axis",
          "u32(index_from_indices)"
        )};
        for (var i = uniforms.gather_axis + 1; i < ${b.length}; i++) {
          let index = ${me.indicesGet("output_indices", `i + ${u.length} - 1`)};
          ${re.indicesSet("data_indices", "i", "index")};
        }
        let data_offset = ${re.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${re.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${
          q ? "unpack4xI8" : "unpack4xU8"
        }(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${we.indicesGet(
          "data_indices",
          "uniforms.quantize_axis"
        )} / uniforms.block_size;
        ${we.indicesSet(
          "scale_indices",
          "uniforms.quantize_axis",
          "quantize_axis_index"
        )};
        var scale = ${we.getByIndices("scale_indices")};
        ${
          be
            ? `
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${be.indicesToOffset(
                "zero_point_indices"
              )};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${be.getByOffset(
                "zero_point_offset / 8"
              )};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${
                q ? "unpack4xI8" : "unpack4xU8"
              }(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`
            : "var zero_point = 0"
        };
        let dequantized_data = ${Pr(E)}(quantized_data - zero_point) * scale;
        ${me.setByOffset("global_idx", "dequantized_data")};
    }`;
                };
              return {
                name: "GatherBlockQuantized",
                shaderCache: {
                  hint: `${i.cacheKey};${r
                    .filter((Z, re) => re !== 1)
                    .map((Z) => Z.dims.join("_"))
                    .join(";")}`,
                  inputDependencies: Array.from(
                    { length: r.length },
                    (Z, re) => "rank"
                  )
                },
                getRunData: () => ({
                  outputs: [{ dims: b, dataType: E }],
                  dispatchGroup: { x: Math.ceil(k / 64) },
                  programUniforms: H
                }),
                getShaderSource: w
              };
            }),
            (jd = (r, i) => {
              let s = r.inputs;
              Rd(s, i), r.compute(Nd(r.inputs, i));
            }),
            (Ud = (r) =>
              Qt({
                blockSize: r.blockSize,
                gatherAxis: r.gatherAxis,
                quantizeAxis: r.quantizeAxis
              }));
        }),
        Vd,
        Wd,
        Gd,
        Hd,
        Rp = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (Vd = (r) => {
              if (!r || r.length !== 2)
                throw new Error("GatherElements requires 2 inputs.");
              if (r[0].dims.length < 1)
                throw new Error(
                  "GatherElements requires that the data input be rank >= 1."
                );
              if (r[0].dims.length !== r[1].dims.length)
                throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
            }),
            (Wd = (r, i) => {
              let s = r[0].dims,
                u = r[0].dataType,
                d = s.length,
                p = r[1].dims,
                c = r[1].dataType,
                b = Ze.normalizeAxis(i.axis, d),
                k = s[b],
                E = p.slice(0),
                q = Ze.size(E),
                H = gt("input", u, d),
                w = gt("indicesInput", c, p.length),
                Z = Ht("output", u, E.length),
                re = [
                  { type: 12, data: q },
                  { type: 6, data: k },
                  { type: 12, data: b }
                ];
              return (
                re.push(...zt(s, p, E)),
                {
                  name: "GatherElements",
                  shaderCache: { inputDependencies: ["rank", "rank"] },
                  getRunData: () => ({
                    outputs: [{ dims: E, dataType: r[0].dataType }],
                    dispatchGroup: { x: Math.ceil(q / 64) },
                    programUniforms: re
                  }),
                  getShaderSource: (le) => `
      ${le
        .registerUniform("outputSize", "u32")
        .registerUniform("axisDimLimit", "i32")
        .registerUniform("axis", "u32")
        .declareVariables(H, w, Z)}
      ${le.mainStart()}
      ${le.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${Z.offsetToIndices("global_idx")};

      var idx = ${w.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${H.type.indices}(outputIndices);
      ${H.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${H.getByIndices("inputIndices")};

      ${Z.setByOffset("global_idx", "value")};
  }`
                }
              );
            }),
            (Gd = (r) => Qt({ axis: r.axis })),
            (Hd = (r, i) => {
              let s = r.inputs;
              Vd(s), r.compute(Wd(r.inputs, i));
            });
        }),
        qd,
        Kd,
        Qd,
        Xd,
        Np = m(() => {
          Yt(),
            Zt(),
            cr(),
            (qd = (r) => {
              if (!r) throw new Error("Input is missing");
              if (r.length < 2 || r.length > 3)
                throw new Error("Invaid input number.");
              if (r.length === 3 && r[2].dims.length > 2)
                throw new Error("Invalid input shape of C");
              if (
                r[0].dataType !== r[1].dataType ||
                (r.length === 3 && r[0].dataType !== r[2].dataType)
              )
                throw new Error("Input types are mismatched");
            }),
            (Kd = (r, i) => {
              let s = r[0].dims.slice(),
                u = r[1].dims.slice(),
                [d, p, c] = Cr.getShapeOfGemmResult(
                  s,
                  i.transA,
                  u,
                  i.transB,
                  r.length === 3 ? r[2].dims : void 0
                ),
                b = [d, p];
              if (!b) throw new Error("Can't use gemm on the given tensors");
              let k = Ze.size(b),
                E = [
                  { type: 12, data: k },
                  { type: 12, data: d },
                  { type: 12, data: p },
                  { type: 12, data: c },
                  { type: 1, data: i.alpha },
                  { type: 1, data: i.beta }
                ],
                q = ["type", "type"];
              r.length === 3 && (E.push(...zt(r[2].dims)), q.push("rank")),
                E.push(...zt(b));
              let H = (w) => {
                let Z = "";
                i.transA && i.transB
                  ? (Z =
                      "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];")
                  : i.transA && !i.transB
                  ? (Z =
                      "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];")
                  : !i.transA && i.transB
                  ? (Z =
                      "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];")
                  : !i.transA &&
                    !i.transB &&
                    (Z =
                      "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");
                let re = i.alpha === 1 ? "" : "value *= uniforms.alpha;",
                  le = gt("a", r[0].dataType, r[0].dims),
                  we = gt("b", r[1].dataType, r[1].dims),
                  be = le.type.value,
                  me = null,
                  Fe = [le, we];
                r.length === 3 &&
                  ((me = gt("c", r[2].dataType, r[2].dims.length)),
                  Fe.push(me));
                let Ce = Ht("output", r[0].dataType, b.length);
                Fe.push(Ce);
                let ze = [
                  { name: "output_size", type: "u32" },
                  { name: "M", type: "u32" },
                  { name: "N", type: "u32" },
                  { name: "K", type: "u32" },
                  { name: "alpha", type: "f32" },
                  { name: "beta", type: "f32" }
                ];
                return `
  ${w.registerUniforms(ze).declareVariables(...Fe)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${be}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${Z}
    }

    ${re}
    ${
      me != null
        ? `let cOffset = ${me.broadcastedIndicesToOffset(
            "vec2(m, n)",
            Ce
          )}; value += ${be}(uniforms.beta) * ${me.getByOffset("cOffset")};`
        : ""
    }
    output[global_idx] = value;
  }`;
              };
              return {
                name: "Gemm",
                shaderCache: { hint: `${i.cacheKey}`, inputDependencies: q },
                getRunData: () => ({
                  outputs: [{ dims: b, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(k / 64) },
                  programUniforms: E
                }),
                getShaderSource: H
              };
            }),
            (Qd = (r) => {
              let i = r.transA,
                s = r.transB,
                u = r.alpha,
                d = r.beta;
              return {
                transA: i,
                transB: s,
                alpha: u,
                beta: d,
                cacheKey: `${r.transA};${r.transB};${r.alpha === 1}`
              };
            }),
            (Xd = (r, i) => {
              qd(r.inputs), r.compute(Kd(r.inputs, i));
            });
        }),
        In,
        jp,
        Al,
        Il,
        Yd,
        ts,
        Zd,
        Jd = m(() => {
          Yt(),
            Zt(),
            wr(),
            pe(),
            Ls(),
            cr(),
            Mo(),
            (In = (r, i) =>
              r.length > i && r[i].dims.length > 0 ? r[i] : void 0),
            (jp = (r, i) => {
              let s = r[0],
                u = In(r, 1),
                d = In(r, 2),
                p = In(r, 3),
                c = In(r, 4),
                b = In(r, 5),
                k = In(r, 6),
                E = In(r, 7);
              if (s.dims.length !== 3 && s.dims.length !== 5)
                throw new Error(
                  "Input query is expected to have 3 or 5 dimensions"
                );
              let q = s.dims[0],
                H = s.dims[1],
                w = s.dims.length === 3 ? s.dims[2] : i.numHeads * s.dims[4],
                Z = H,
                re = 0,
                le = 0,
                we = Math.floor(w / i.numHeads);
              if (k && E && Ze.size(k.dims) && Ze.size(E.dims)) {
                if (k.dims.length !== 4)
                  throw new Error(
                    'Input "past_key" is expected to have 4 dimensions'
                  );
                if (
                  k.dims[0] !== q ||
                  k.dims[1] !== i.numHeads ||
                  k.dims[3] !== we
                )
                  throw new Error(
                    'Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)'
                  );
                if (
                  E.dims[0] !== q ||
                  E.dims[1] !== i.numHeads ||
                  E.dims[3] !== we
                )
                  throw new Error(
                    'Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)'
                  );
                if (k.dims[2] !== E.dims[2])
                  throw new Error(
                    'Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)'
                  );
                if (E.dims.length !== 4)
                  throw new Error(
                    'Input "past_value" is expected to have 4 dimensions'
                  );
                (re = k.dims[2]), (le = k.dims[2]);
              } else if ((k && Ze.size(k.dims)) || (E && Ze.size(E.dims)))
                throw new Error(
                  'Input "past_key" and "past_value" shall be both present or both absent'
                );
              let be;
              if (u && Ze.size(u.dims) > 0) {
                if (s.dims.length !== 3)
                  throw new Error(
                    'Input "query" is expected to have 3 dimensions when key is given'
                  );
                if (u.dims.length < 3 || u.dims.length > 5)
                  throw new Error(
                    'Input "key" is expected to have 3, 4, or 5 dimensions'
                  );
                if (s.dims[0] !== u.dims[0])
                  throw new Error(
                    'Input "query" and "key" shall have same dim 0 (batch size)'
                  );
                if (u.dims.length === 3) {
                  if (u.dims[2] !== s.dims[2])
                    throw new Error(
                      'Input "query" and "key" shall have same dim 2 (hidden_size)'
                    );
                  (be = 2), (Z = u.dims[1]);
                } else if (u.dims.length === 5) {
                  if (
                    u.dims[2] !== i.numHeads ||
                    u.dims[3] !== 2 ||
                    u.dims[4] !== we
                  )
                    throw new Error(
                      'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv'
                    );
                  if (d)
                    throw new Error(
                      'Expect "value" be none when "key" has packed kv format.'
                    );
                  (be = 5), (Z = u.dims[1]);
                } else {
                  if (u.dims[1] !== i.numHeads || u.dims[3] !== we)
                    throw new Error(
                      'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key'
                    );
                  (be = 0), (Z = u.dims[2]);
                }
              } else {
                if (s.dims.length !== 5)
                  throw new Error(
                    'Input "query" is expected to have 5 dimensions when key is empty'
                  );
                if (s.dims[2] !== i.numHeads || s.dims[3] !== 3)
                  throw new Error(
                    'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv'
                  );
                be = 3;
              }
              if (p && Ze.size(p.dims) > 0) {
                if (p.dims.length !== 1)
                  throw new Error(
                    'Input "bias" is expected to have 1 dimension'
                  );
                if (u && u.dims.length === 5 && u.dims[3] === 2)
                  throw new Error("bias is not allowed for packed kv.");
              }
              let me = re + Z,
                Fe = 0;
              if (c && Ze.size(c.dims) > 0) {
                Fe = 8;
                let lt = c.dims;
                throw (
                  (lt.length === 1
                    ? lt[0] === q
                      ? (Fe = 1)
                      : lt[0] === 3 * q + 2 && (Fe = 3)
                    : lt.length === 2 &&
                      lt[0] === q &&
                      lt[1] === me &&
                      (Fe = 5),
                  Fe === 8
                    ? new Error(
                        'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'
                      )
                    : new Error("Mask not supported"))
                );
              }
              let Ce = !1,
                ze = w;
              if (d && Ze.size(d.dims) > 0) {
                if (d.dims.length !== 3 && d.dims.length !== 4)
                  throw new Error(
                    'Input "value" is expected to have 3 or 4 dimensions'
                  );
                if (s.dims[0] !== d.dims[0])
                  throw new Error(
                    'Input "query" and "value" shall have same dim 0 (batch_size)'
                  );
                if (d.dims.length === 3) {
                  if (Z !== d.dims[1])
                    throw new Error(
                      'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)'
                    );
                  ze = d.dims[2];
                } else {
                  if (Z !== d.dims[2])
                    throw new Error(
                      'Input "key" and "value" shall have the same dim 2 (kv_sequence_length)'
                    );
                  (ze = d.dims[1] * d.dims[3]), (Ce = !0);
                }
              }
              let dt = !1;
              if (c && Ze.size(c.dims) > 0)
                throw new Error("Key padding mask is not supported");
              if (b && Ze.size(b.dims) > 0) {
                if (b.dims.length !== 4)
                  throw new Error(
                    'Input "attention_bias" is expected to have 4 dimensions'
                  );
                if (
                  b.dims[0] !== q ||
                  b.dims[1] !== i.numHeads ||
                  b.dims[2] !== H ||
                  b.dims[3] !== me
                )
                  throw new Error(
                    'Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)'
                  );
              }
              return {
                batchSize: q,
                sequenceLength: H,
                pastSequenceLength: re,
                kvSequenceLength: Z,
                totalSequenceLength: me,
                maxSequenceLength: le,
                inputHiddenSize: 0,
                hiddenSize: w,
                vHiddenSize: ze,
                headSize: we,
                vHeadSize: Math.floor(ze / i.numHeads),
                numHeads: i.numHeads,
                isUnidirectional: !1,
                pastPresentShareBuffer: !1,
                maskFilterValue: i.maskFilterValue,
                maskType: Fe,
                scale: i.scale,
                broadcastResPosBias: dt,
                passPastInKv: Ce,
                qkvFormat: be
              };
            }),
            (Al = (r) => Qt({ ...r })),
            (Il = Qt({ perm: [0, 2, 1, 3] })),
            (Yd = (r, i, s, u, d, p, c) => {
              let b = [u, d, p],
                k = Ze.size(b),
                E = [
                  { type: 12, data: k },
                  { type: 12, data: c },
                  { type: 12, data: p }
                ],
                q = (H) => {
                  let w = Ht("qkv_with_bias", i.dataType, b),
                    Z = gt("qkv", i.dataType, b),
                    re = gt("bias", s.dataType, b),
                    le = [
                      { name: "output_size", type: "u32" },
                      { name: "bias_offset", type: "u32" },
                      { name: "hidden_size", type: "u32" }
                    ];
                  return `
  ${H.registerUniforms(le).declareVariables(Z, re, w)}
  ${H.mainStart()}
    ${H.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
                };
              return r.compute(
                {
                  name: "MultiHeadAttentionAddBias",
                  shaderCache: { inputDependencies: ["type", "type"] },
                  getRunData: () => ({
                    outputs: [
                      { dims: b, dataType: i.dataType, gpuDataType: 0 }
                    ],
                    dispatchGroup: { x: Math.ceil(k / 64) },
                    programUniforms: E
                  }),
                  getShaderSource: q
                },
                { inputs: [i, s], outputs: [-1] }
              )[0];
            }),
            (ts = (r, i, s, u, d, p, c, b) => {
              let k = p;
              if (c && Ze.size(c.dims) > 0) {
                if (u === 1)
                  throw new Error(
                    "AddBiasReshape is not implemented. Please export your model with packed QKV or KV"
                  );
                return (
                  (k = Yd(r, p, c, i, u, s * d, b)),
                  (k = k.reshape([i, u, s, d])),
                  r.compute(bi(k, Il.perm), { inputs: [k], outputs: [-1] })[0]
                );
              } else
                return (
                  p.dims.length === 3 && (k = p.reshape([i, u, s, d])),
                  r.compute(bi(k, Il.perm), { inputs: [k], outputs: [-1] })[0]
                );
            }),
            (Zd = (r, i) => {
              let s = jp(r.inputs, i),
                u = r.inputs[0],
                d = In(r.inputs, 1),
                p = In(r.inputs, 2),
                c = In(r.inputs, 3),
                b = In(r.inputs, 4),
                k = In(r.inputs, 5),
                E = In(r.inputs, 6),
                q = In(r.inputs, 7);
              if (u.dims.length === 5)
                throw new Error("Packed QKV is not implemented");
              if ((d == null ? void 0 : d.dims.length) === 5)
                throw new Error("Packed KV is not implemented");
              let H = d && p && d.dims.length === 4 && p.dims.length === 4,
                w = ts(
                  r,
                  s.batchSize,
                  s.numHeads,
                  s.sequenceLength,
                  s.headSize,
                  u,
                  c,
                  0
                );
              if (H) return To(r, w, d, p, b, void 0, E, q, k, s, i);
              if (!d || !p) throw new Error("key and value must be provided");
              let Z = ts(
                  r,
                  s.batchSize,
                  s.numHeads,
                  s.kvSequenceLength,
                  s.headSize,
                  d,
                  c,
                  s.hiddenSize
                ),
                re = ts(
                  r,
                  s.batchSize,
                  s.numHeads,
                  s.kvSequenceLength,
                  s.vHeadSize,
                  p,
                  c,
                  2 * s.hiddenSize
                );
              To(r, w, Z, re, b, void 0, E, q, k, s, i);
            });
        }),
        Fl,
        ef,
        tf,
        zl,
        rf,
        nf = m(() => {
          Yt(),
            Zt(),
            cr(),
            (Fl = (r) => Array.from(r.getBigInt64Array(), Number)),
            (ef = (r) => {
              if (!r || r.length !== 2)
                throw new Error("Tile requires 2 inputs.");
              if (
                r[0].dataType !== 1 &&
                r[0].dataType !== 10 &&
                r[0].dataType !== 6 &&
                r[0].dataType !== 12
              )
                throw new Error(
                  "Tile only support float, float16, int32, and uint32 data types"
                );
              if (r[1].dataType !== 7)
                throw new Error(
                  "Tile `repeats` input should be of int64 data type"
                );
              if (r[1].dims.length !== 1)
                throw new Error("Tile `repeats` input should be 1-D");
              if (Fl(r[1]).length !== r[0].dims.length)
                throw new Error(
                  "Tile `repeats` input should have same number of elements as rank of input data tensor"
                );
            }),
            (tf = (r, i) => {
              let s = [];
              for (let u = 0; u < r.length; ++u) s.push(r[u] * i[u]);
              return s;
            }),
            (zl = (r, i) => {
              let s = r[0].dims,
                u = i ?? Fl(r[1]),
                d = tf(s, u),
                p = Ze.size(d),
                c = r[0].dataType,
                b = gt("input", c, s.length),
                k = Ht("output", c, d.length),
                E = (q) => `
      const inputShape = ${b.indices(...s)};
      ${q.registerUniform("output_size", "u32").declareVariables(b, k)}
      ${q.mainStart()}
      ${q.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${k.offsetToIndices("global_idx")};
      var input_indices: ${b.type.indices};
      for (var i = 0; i < ${s.length}; i++) {
        let input_dim_i = ${b.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${k.indicesGet(
          "output_indices",
          "i"
        )}  % input_dim_i;

        ${b.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${k.setByOffset("global_idx", b.getByIndices("input_indices"))}
    }`;
              return {
                name: "Tile",
                shaderCache: { hint: `${u}`, inputDependencies: ["rank"] },
                getRunData: () => ({
                  outputs: [{ dims: d, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(p / 64) },
                  programUniforms: [{ type: 12, data: p }, ...zt(r[0].dims, d)]
                }),
                getShaderSource: E
              };
            }),
            (rf = (r) => {
              ef(r.inputs), r.compute(zl(r.inputs), { inputs: [0] });
            });
        }),
        of,
        Ol,
        sf,
        af,
        Dl,
        lf,
        Up = m(() => {
          Yt(),
            Zt(),
            wr(),
            Ls(),
            cr(),
            Jd(),
            nf(),
            Mo(),
            (of = (r, i) => {
              let s = r[0],
                u = r[1],
                d = r[2],
                p = r[3],
                c = r[4];
              if (s.dims.length !== 3 && s.dims.length !== 5)
                throw new Error(
                  "Input query is expected to have 3 or 5 dimensions"
                );
              let b = !1,
                k = s.dims[0],
                E = s.dims[1],
                q =
                  s.dims.length === 3
                    ? b
                      ? s.dims[2] / 3
                      : s.dims[2]
                    : i.numHeads * s.dims[4],
                H = E,
                w = 0,
                Z = 0,
                re = Math.floor(q / i.numHeads),
                le = p && p.dims.length !== 0,
                we = c && c.dims.length !== 0,
                be = !0;
              if (le && we) {
                if (p.dims.length !== 4)
                  throw new Error(
                    'Input "past_key" is expected to have 4 dimensions'
                  );
                if (c.dims.length !== 4)
                  throw new Error(
                    'Input "past_value" is expected to have 4 dimensions'
                  );
                (w = p.dims[1]), (Z = p.dims[1]);
              } else if (le || we)
                throw new Error(
                  'Input "past_key" and "past_value" shall be both present or both absent'
                );
              let me;
              if (u) {
                if (s.dims.length !== 3)
                  throw new Error(
                    'Input "query" is expected to have 3 dimensions when key is given'
                  );
                if (u.dims.length < 3 || u.dims.length > 5)
                  throw new Error(
                    'Input "key" is expected to have 3, 4, or 5 dimensions'
                  );
                if (s.dims[0] !== u.dims[0])
                  throw new Error(
                    'Input "query" and "key" shall have same dim 0 (batch size)'
                  );
                if (u.dims.length === 3) {
                  if (s.dims[2] % u.dims[2] !== 0)
                    throw new Error(
                      'Dimension 2 of "query" should be a multiple of "key"'
                    );
                  (me = 2), (H = u.dims[1]);
                } else if (u.dims.length === 5) {
                  if (
                    u.dims[2] !== i.numHeads ||
                    u.dims[3] !== 2 ||
                    u.dims[4] !== re
                  )
                    throw new Error(
                      'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv'
                    );
                  if (d)
                    throw new Error(
                      'Expect "value" be none when "key" has packed kv format.'
                    );
                  (me = 5), (H = u.dims[1]);
                } else {
                  if (u.dims[1] !== i.numHeads || u.dims[3] !== re)
                    throw new Error(
                      'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key'
                    );
                  (me = 0), (H = u.dims[2]);
                }
              } else {
                if (s.dims.length !== 3 && s.dims.length !== 5)
                  throw new Error(
                    'Input "query" is expected to have 3 or 5 dimensions when key is empty'
                  );
                if (
                  s.dims.length === 5 &&
                  (s.dims[2] !== i.numHeads || s.dims[3] !== 3)
                )
                  throw new Error(
                    'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv'
                  );
                me = 3;
              }
              let Fe = 0,
                Ce = !1,
                ze = q;
              if (d) {
                if (d.dims.length !== 3 && d.dims.length !== 4)
                  throw new Error(
                    'Input "value" is expected to have 3 or 4 dimensions'
                  );
                if (s.dims[0] !== d.dims[0])
                  throw new Error(
                    'Input "query" and "value" shall have same dim 0 (batch_size)'
                  );
                if (d.dims.length === 3) {
                  if (H !== d.dims[1])
                    throw new Error(
                      'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)'
                    );
                  ze = d.dims[2];
                } else {
                  if (H !== d.dims[2])
                    throw new Error(
                      'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)'
                    );
                  (ze = d.dims[1] * d.dims[3]), (Ce = !0);
                }
              }
              let dt = w + H;
              return {
                batchSize: k,
                sequenceLength: E,
                pastSequenceLength: w,
                kvSequenceLength: H,
                totalSequenceLength: dt,
                maxSequenceLength: Z,
                inputHiddenSize: 0,
                hiddenSize: q,
                vHiddenSize: ze,
                headSize: re,
                vHeadSize: Math.floor(ze / i.kvNumHeads),
                numHeads: i.numHeads,
                kvNumHeads: i.kvNumHeads,
                nReps: i.numHeads / i.kvNumHeads,
                pastPresentShareBuffer: !1,
                maskType: Fe,
                scale: i.scale,
                broadcastResPosBias: !1,
                passPastInKv: Ce,
                qkvFormat: me,
                isPastkvBSNH: be
              };
            }),
            (Ol = (r, i, s, u) => {
              let d = [
                  u.batchSize,
                  u.totalSequenceLength,
                  u.kvNumHeads,
                  u.headSize
                ],
                p = 4,
                c = Ze.size(d) / p,
                b = u.totalSequenceLength,
                k = Ht("present_kv", s, d.length, p),
                E = gt("new_kv", r.dataType, r.dims.length, p),
                q = i ? gt("past_kv", i.dataType, i.dims.length, p) : void 0,
                H = Math.ceil(u.headSize / p),
                w = { x: b, y: r.dims[0], z: 1 },
                Z = i ? ["rank", "rank"] : ["rank"],
                re = [
                  { type: 12, data: c },
                  { type: 12, data: u.pastSequenceLength },
                  { type: 12, data: u.kvSequenceLength },
                  { type: 12, data: u.totalSequenceLength }
                ],
                le = [E];
              q
                ? (re.push(...zt(r.dims), ...zt(i.dims), ...zt(d)), le.push(q))
                : re.push(...zt(r.dims), ...zt(d));
              let we = [
                  { name: "output_size", type: "u32" },
                  { name: "past_seqlen", type: "u32" },
                  { name: "new_seqlen", type: "u32" },
                  { name: "present_seqlen", type: "u32" }
                ],
                be = `      let past_batch_stride = uniforms.past_seqlen * num_heads * H;
        var past_head_stride = uniforms.past_seqlen * H;
        if (is_bsnh) {
          past_head_stride = H;
        }
        let in_offset = b * past_batch_stride + s * row_stride + n * past_head_stride + h;
        present_kv[out_offset] = past_kv[in_offset];`,
                me = `      let new_batch_stride = uniforms.new_seqlen * num_heads * H;
        let new_row_stride = num_heads * H;
        let new_head_stride = H;
        let in_offset = b * new_batch_stride + (s - past_seqlen) * new_row_stride + n * new_head_stride + h;
        present_kv[out_offset] = new_kv[in_offset];`,
                Fe = i
                  ? `if (s < past_seqlen) {
        ${be}
        } else if (s < past_seqlen + uniforms.new_seqlen) {
        ${me}
        }`
                  : `if (s < past_seqlen + uniforms.new_seqlen) {
          ${me}
        }`,
                Ce = (ze) => `

  ${ze.registerUniforms(we).declareVariables(...le, k)}
  ${ze.mainStart([H, u.kvNumHeads, 1])}
    ${ze.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    var indices = ${k.offsetToIndices("global_idx")};
    let h = local_id.x;
    let n = local_id.y;
    let s = workgroup_id.x;
    let b = workgroup_id.y;
    let num_heads = ${u.kvNumHeads}u;
    let H = ${H}u;

    let present_seqlen = uniforms.present_seqlen;
    let present_batch_stride = present_seqlen * num_heads * H;
    var row_stride = H;
    let is_bsnh = ${u.isPastkvBSNH};

    if (is_bsnh) {
      row_stride = num_heads * H;
    }
    var present_head_stride = present_seqlen * H;
    if (is_bsnh) {
      present_head_stride = H;
    }

    let past_seqlen = uniforms.past_seqlen;

    let out_offset = b * present_batch_stride + s * row_stride + n * present_head_stride + h;
    ${Fe}
  }`;
              return {
                name: "ConcatPastNew",
                shaderCache: {
                  hint: `${u.kvNumHeads}${H}${!!i}`,
                  inputDependencies: Z
                },
                getRunData: () => ({
                  outputs: [{ dims: d, dataType: s }],
                  dispatchGroup: w,
                  programUniforms: re
                }),
                getShaderSource: Ce
              };
            }),
            (sf = (r) => Qt({ ...r })),
            (af = Qt({ perm: [0, 2, 1, 3] })),
            (Dl = (r, i, s, u, d) => {
              let p = i,
                c = u.kvNumHeads,
                b = u.nReps;
              return (
                i.dims.length === 3 &&
                  u.kvSequenceLength !== 0 &&
                  (p = i.reshape([
                    u.batchSize,
                    u.kvSequenceLength,
                    c,
                    u.headSize
                  ])),
                s
                  ? (p = r.compute(Ol(p, s, p.dataType, u), {
                      inputs: [p, s],
                      outputs: [u.isPastkvBSNH ? d : -1]
                    })[0])
                  : (p = r.compute(Ol(p, void 0, p.dataType, u), {
                      inputs: [p],
                      outputs: [u.isPastkvBSNH ? d : -1]
                    })[0]),
                b !== 1 &&
                  ((p = r.compute(zl([p], [1, 1, 1, b]), {
                    inputs: [p],
                    outputs: [-1]
                  })[0]),
                  (p = p.reshape([
                    u.batchSize,
                    u.totalSequenceLength,
                    c * b,
                    u.headSize
                  ]))),
                r.compute(bi(p, af.perm), { inputs: [p], outputs: [-1] })[0]
              );
            }),
            (lf = (r, i) => {
              var k;
              let s = of(r.inputs, i);
              if (r.inputs[0].dims.length === 5)
                throw new Error("Packed QKV is not implemented");
              if (((k = r.inputs[1]) == null ? void 0 : k.dims.length) === 5)
                throw new Error("Packed KV is not implemented");
              let u = ts(
                  r,
                  s.batchSize,
                  s.numHeads,
                  s.sequenceLength,
                  s.headSize,
                  r.inputs[0],
                  void 0,
                  0
                ),
                d =
                  r.inputs[3] && r.inputs[3].dims.length !== 0
                    ? r.inputs[3]
                    : void 0,
                p =
                  r.inputs[4] && r.inputs[4].dims.length !== 0
                    ? r.inputs[4]
                    : void 0,
                c = Dl(r, r.inputs[1], d, s, 1),
                b = Dl(r, r.inputs[2], p, s, 2);
              To(r, u, c, b, void 0, void 0, void 0, void 0, void 0, s, i);
            });
        }),
        uf,
        cf,
        df,
        ff,
        Vp = m(() => {
          Yt(),
            Zt(),
            cr(),
            (uf = (r, i) => {
              let s = r[0].dims,
                u = s,
                d = 2,
                p = Ze.sizeToDimension(s, d),
                c = Ze.sizeFromDimension(s, d),
                b = $r(c),
                k = c / b,
                E = [s[0], s[1], k],
                q = ["rank", "type", "type"],
                H = [
                  { type: 12, data: c },
                  { type: 12, data: k }
                ];
              H.push(...zt(E, E));
              let w = (Z) => {
                let re = gt("x", r[0].dataType, E.length, b),
                  le = gt("scale", r[1].dataType, r[1].dims),
                  we = gt("bias", r[2].dataType, r[2].dims),
                  be = Ht("output", r[0].dataType, E.length, b),
                  me = [re, le, we, be],
                  Fe = re.type.value,
                  Ce = b === 1 ? "f32" : `vec${b}<f32>`,
                  ze = 64,
                  dt = [
                    { name: "normSize", type: "u32" },
                    { name: "normPackedSize", type: "u32" }
                  ];
                return `
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${Ce}, ${ze}>;
  const workgroupSize = ${ze}u;
  ${Z.registerUniforms(dt).declareVariables(...me)}
  ${Z.mainStart(ze)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${Ce}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${Ce}(${re.get("batch", "channel", "h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${Qn("workgroupShared[0]", b)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${Ce}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${Ce}(${re.get(
                  "batch",
                  "channel",
                  "h"
                )}) - ${Ce}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${Qn("workgroupShared[0]", b)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${
      i.epsilon
    }));
    let channelScale = invStdDev * f32(${le.getByOffset("channel")});
    let channelShift = f32(${we.getByOffset(
      "channel"
    )}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${re.get(
        "batch",
        "channel",
        "h"
      )} * ${Fe}(${Ce}(channelScale)) + ${Fe}(${Ce}(channelShift));
      ${be.set("batch", "channel", "h", "value")};
    }
  }`;
              };
              return {
                name: "InstanceNormalization",
                shaderCache: {
                  hint: `${i.epsilon};${b}`,
                  inputDependencies: q
                },
                getRunData: () => ({
                  outputs: [{ dims: u, dataType: r[0].dataType }],
                  dispatchGroup: { x: p },
                  programUniforms: H
                }),
                getShaderSource: w
              };
            }),
            (cf = (r, i, s, u, d, p, c, b) => {
              let k = $r(c),
                E = 64,
                q = k === 1 ? "vec2f" : `mat2x${k}f`,
                H = k === 1 ? "f32" : `vec${k}f`,
                w = (dt, lt) => `${q}(${dt}, ${lt})`,
                Z = (d * c) / k,
                re = Math.ceil(p / E),
                le = ["type"],
                we = [
                  { type: 12, data: re },
                  { type: 12, data: p },
                  { type: 12, data: Math.floor(c / k) },
                  { type: 12, data: Math.floor((p * c) / k) }
                ],
                be = (dt) => {
                  let lt = gt("input", i.dataType, i.dims, k);
                  return `
  ${dt.declareVariables(lt)}
  @group(0) @binding(1) var<storage, read_write> output : array<${q}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${dt.mainStart(E)}
    let currentImageNumber = global_idx / ${E} / uniforms.C;
    let currentChannelNumber = (global_idx / ${E}) % uniforms.C;
    let wgOffset = local_id.x * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${jr("f32", k)};
    var squaredSum = ${jr("f32", k)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${H}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${w("sum", "squaredSum")};
  }`;
                },
                me = r.compute(
                  {
                    name: "InstanceNormComputeMean",
                    shaderCache: { hint: `${k}`, inputDependencies: le },
                    getRunData: () => ({
                      outputs: [{ dims: [d, c, E, 2], dataType: 1 }],
                      dispatchGroup: { x: (d * c) / k },
                      programUniforms: we
                    }),
                    getShaderSource: be
                  },
                  { inputs: [i], outputs: [-1] }
                )[0],
                Fe = [
                  { type: 12, data: Z },
                  { type: 12, data: p },
                  { type: 12, data: Math.floor(c / k) },
                  { type: 12, data: Math.floor((E * c) / k) }
                ],
                Ce = ["type", "type", "type"],
                ze = (dt) => {
                  let lt = gt("scale", s.dataType, s.dims, k),
                    Mt = gt("bias", u.dataType, u.dims, k);
                  return `
  @group(0) @binding(0) var<storage, read> input : array<${q}>;
  @group(0) @binding(1) var<storage, read> scale : array<${lt.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${Mt.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${q}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${dt.mainStart()}
    ${dt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${jr("f32", k)};
    var squaredSum = ${jr("f32", k)};
    for (var i: u32 = 0; i < min(${E}, uniforms.H); i++) {
        let value = input[offset + i + currentChannelNumber * ${E}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${b}));
    let channelScale = invStdDev * ${H}(scale[currentChannelNumber]);
    let channelShift = ${H}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${w("channelScale", "channelShift")};
  }`;
                };
              return r.compute(
                {
                  name: "InstanceNormComputeChannelScaleShift",
                  shaderCache: { hint: `${k};${b}`, inputDependencies: Ce },
                  getRunData: () => ({
                    outputs: [{ dims: [d, c, 2], dataType: 1 }],
                    dispatchGroup: { x: Math.ceil(Z / 64) },
                    programUniforms: Fe
                  }),
                  getShaderSource: ze
                },
                { inputs: [me, s, u], outputs: [-1] }
              )[0];
            }),
            (df = (r, i, s) => {
              let u = i[0].dims,
                d = u,
                p = u[0],
                c = u[u.length - 1],
                b = Ze.sizeFromDimension(u, 1) / c,
                k = $r(c),
                E = Ze.size(d) / k,
                q = [
                  { type: 12, data: b },
                  { type: 12, data: Math.floor(c / k) }
                ],
                H = ["type", "type"],
                w = cf(r, i[0], i[1], i[2], p, b, c, s.epsilon),
                Z = (re) => {
                  let le = Fr(i[0].dataType),
                    we = k === 1 ? "vec2f" : `mat2x${k}f`,
                    be = k === 1 ? le : `vec${k}<${le}>`,
                    me = gt("input", i[0].dataType, i[0].dims, k),
                    Fe = Ht("output", i[0].dataType, d, k);
                  return `
  @group(0) @binding(0) var<storage, read> input : array<${me.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${we}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${
    Fe.type.storage
  }>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${re.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${be}(scale[0]), ${be}(scale[1]));
  }`;
                };
              r.compute(
                {
                  name: "InstanceNormalizationNHWC",
                  shaderCache: { hint: `${k}`, inputDependencies: H },
                  getRunData: () => ({
                    outputs: [{ dims: d, dataType: i[0].dataType }],
                    dispatchGroup: { x: Math.ceil(E / 64) },
                    programUniforms: q
                  }),
                  getShaderSource: Z
                },
                { inputs: [i[0], w] }
              );
            }),
            (ff = (r, i) => {
              i.format === "NHWC"
                ? df(r, r.inputs, i)
                : r.compute(uf(r.inputs, i));
            });
        }),
        pf,
        hf,
        mf,
        zm = m(() => {
          Yt(),
            Zt(),
            cr(),
            (pf = (r) => {
              if (!r || r.length < 2)
                throw new Error("layerNorm requires at least 2 inputs.");
            }),
            (hf = (r, i, s) => {
              let u = i.simplified,
                d = r[0].dims,
                p = r[1],
                c = !u && r[2],
                b = d,
                k = Ze.normalizeAxis(i.axis, d.length),
                E = Ze.sizeToDimension(d, k),
                q = Ze.sizeFromDimension(d, k),
                H = Ze.size(p.dims),
                w = c ? Ze.size(c.dims) : 0;
              if (H !== q || (c && w !== q))
                throw new Error(`Size of X.shape()[axis:] == ${q}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${H} and bias size of ${w}`);
              let Z = [];
              for (let ze = 0; ze < d.length; ++ze)
                ze < k ? Z.push(d[ze]) : Z.push(1);
              let re = $r(q),
                le = ["type", "type"],
                we = [
                  { type: 12, data: E },
                  { type: 1, data: q },
                  { type: 12, data: Math.floor(q / re) },
                  { type: 1, data: i.epsilon }
                ];
              c && le.push("type");
              let be = s > 1,
                me = s > 2,
                Fe = (ze) => {
                  let dt = Fr(r[0].dataType),
                    lt = [
                      gt("x", r[0].dataType, r[0].dims, re),
                      gt("scale", p.dataType, p.dims, re)
                    ];
                  c && lt.push(gt("bias", c.dataType, c.dims, re)),
                    lt.push(Ht("output", r[0].dataType, b, re)),
                    be && lt.push(Ht("mean_data_output", 1, Z)),
                    me && lt.push(Ht("inv_std_output", 1, Z));
                  let Mt = [
                    { name: "norm_count", type: "u32" },
                    { name: "norm_size", type: "f32" },
                    { name: "norm_size_vectorized", type: "u32" },
                    { name: "epsilon", type: "f32" }
                  ];
                  return `
  ${ze.registerUniforms(Mt).declareVariables(...lt)}
  ${ze.mainStart()}
    ${ze.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${jr("f32", re)};
    var mean_square_vector = ${jr("f32", re)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Zr(dt, re, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Qn("mean_vector", re)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Qn(
      "mean_square_vector",
      re
    )} / uniforms.norm_size ${u ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Zr(dt, re, "x[j + offset]")};
      let f32scale = ${Zr(dt, re, "scale[j]")};
      output[j + offset] = ${lt[0].type.value}((f32input ${
                    u ? "" : "- mean"
                  }) * inv_std_dev * f32scale
        ${c ? `+ ${Zr(dt, re, "bias[j]")}` : ""}
      );
    }

    ${be ? "mean_data_output[global_idx] = mean" : ""};
    ${me ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
                },
                Ce = [{ dims: b, dataType: r[0].dataType }];
              return (
                be && Ce.push({ dims: Z, dataType: 1 }),
                me && Ce.push({ dims: Z, dataType: 1 }),
                {
                  name: "LayerNormalization",
                  shaderCache: {
                    hint: `${re};${s};${u}`,
                    inputDependencies: le
                  },
                  getRunData: () => ({
                    outputs: Ce,
                    dispatchGroup: { x: Math.ceil(E / 64) },
                    programUniforms: we
                  }),
                  getShaderSource: Fe
                }
              );
            }),
            (mf = (r, i) => {
              pf(r.inputs), r.compute(hf(r.inputs, i, r.outputCount));
            });
        }),
        pr,
        gf,
        yn,
        bn,
        Fn = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (pr = (r, i) => {
              if (r.length < 3 || r.length > 4)
                throw new Error("MatMulNBits requires 3 or 4 inputs");
              let s = r[0],
                u = s.dims.length;
              if (s.dims[u - 1] !== i.k)
                throw new Error(
                  "The last dim of input shape does not match the k value"
                );
              let d = Math.floor((i.k + i.blockSize - 1) / i.blockSize),
                p = (i.blockSize / 8) * i.bits,
                c = r[1];
              if (!Ze.areEqual(c.dims, [i.n, d, p]))
                throw new Error(
                  "The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize"
                );
              let b = r[2].dims;
              if (Ze.size(b) !== i.n * d)
                throw new Error("scales input size error.");
              if (r.length === 4) {
                let k = r[3].dims,
                  E = i.bits > 4 ? i.n * d : i.n * Math.floor((d + 1) / 2);
                if (Ze.size(k) !== E)
                  throw new Error("zeroPoints input size error.");
              }
            }),
            (gf = (r, i) => {
              let s = r[0].dims,
                u = s.length,
                d = s[u - 2],
                p = i.k,
                c = i.n,
                b = s.slice(0, u - 2),
                k = Ze.size(b),
                E = r[1].dims[2] / 4,
                q = r[0].dataType,
                H = $r(i.k),
                w = $r(E),
                Z = $r(c),
                re = b.concat([d, c]),
                le = d > 1 && (c / Z) % 2 === 0 ? 2 : 1,
                we = Ze.size(re) / Z / le,
                be = 64,
                me = [],
                Fe = [k, d, p / H],
                Ce = Ze.convertShape(r[1].dims).slice();
              Ce.splice(-1, 1, E / w),
                me.push(...zt(Fe)),
                me.push(...zt(Ce)),
                me.push(...zt(r[2].dims)),
                r.length === 4 && me.push(...zt(Ze.convertShape(r[3].dims)));
              let ze = [k, d, c / Z];
              me.push(...zt(ze));
              let dt = (lt) => {
                let Mt = Fe.length,
                  Dt = gt("a", r[0].dataType, Mt, H),
                  Ut = gt("b", 12, Ce.length, w),
                  fr = gt("scales", r[2].dataType, r[2].dims.length),
                  br = [Dt, Ut, fr],
                  rr =
                    r.length === 4
                      ? gt("zero_points", 12, r[3].dims.length)
                      : void 0;
                rr && br.push(rr);
                let Wr = ze.length,
                  Jr = Ht("output", r[0].dataType, Wr, Z),
                  Sr = Fr(r[0].dataType),
                  Hr = (() => {
                    switch (H) {
                      case 1:
                        return `array<${Sr}, 8>`;
                      case 2:
                        return `mat4x2<${Sr}>`;
                      case 4:
                        return `mat2x4<${Sr}>`;
                      default:
                        throw new Error(`${H}-component is not supported.`);
                    }
                  })(),
                  tr = () => {
                    let ut = `
          // reuse a data
            var input_offset = ${Dt.indicesToOffset(
              `${Dt.type.indices}(batch, row, word_offset)`
            )};
            var a_data: ${Hr};
            for (var j: u32 = 0; j < ${8 / H}; j++) {
              a_data[j] = ${Dt.getByOffset("input_offset")};
              input_offset++;
            }
          `;
                    for (let At = 0; At < Z * le; At++)
                      ut += `
            b_value = ${w === 1 ? `b${At}_data` : `b${At}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${Hr}(${Array.from(
                        { length: 4 },
                        (sr, Gr) =>
                          `${Sr}(b_value_lower[${Gr}]), ${Sr}(b_value_upper[${Gr}])`
                      ).join(", ")});
            b_dequantized_values = ${
              H === 1
                ? `${Hr}(${Array.from(
                    { length: 8 },
                    (sr, Gr) =>
                      `(b_quantized_values[${Gr}] - ${
                        rr ? `zero_point${At}` : "zero_point"
                      }) * scale${At}`
                  ).join(", ")});`
                : `(b_quantized_values - ${Hr}(${Array(8)
                    .fill(`${rr ? `zero_point${At}` : "zero_point"}`)
                    .join(",")})) * scale${At};`
            };
            workgroup_shared[local_id.x * ${le} + ${Math.floor(At / Z)}]${
                        Z > 1 ? `[${At % Z}]` : ""
                      } += ${Array.from(
                        { length: 8 / H },
                        (sr, Gr) =>
                          `${
                            H === 1
                              ? `a_data[${Gr}] * b_dequantized_values[${Gr}]`
                              : `dot(a_data[${Gr}], b_dequantized_values[${Gr}])`
                          }`
                      ).join(" + ")};
          `;
                    return ut;
                  },
                  _r = () => {
                    let ut = `
            var col_index = col * ${Z};
            ${
              rr
                ? `
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`
                : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Sr}(8);`
            }
            `;
                    for (let At = 0; At < Z * le; At++)
                      ut += `
            let scale${At} = ${fr.getByOffset(
                        "col_index * nBlocksPerCol + block"
                      )};
            ${
              rr
                ? `
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${rr.getByOffset(
              "zero_point_word_index"
            )} >> zero_point_bits_offset;
            let zero_point${At} = ${Sr}((zero_point_word) & 0xFu);`
                : ""
            }
            col_index += 1;`;
                    return ut;
                  },
                  zr = () => {
                    let ut = `col_index = col * ${Z};`;
                    for (let At = 0; At < Z * le; At++)
                      ut += `
            let b${At}_data = ${Ut.getByIndices(
                        `${Ut.type.indices}(col_index, block, word)`
                      )};
            col_index += 1;`;
                    return (
                      (ut += `
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${Hr};
            var b_dequantized_values: ${Hr};`),
                      ut
                    );
                  };
                return `
        var<workgroup> workgroup_shared: array<${Jr.type.value}, ${le * be}>;
        ${lt.declareVariables(...br, Jr)}
        ${lt.mainStart([be, 1, 1])}
          let output_indices = ${Jr.offsetToIndices(
            `(global_idx / ${be}) * ${le}`
          )};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${be}) {
            //process one block
            var word_offset: u32 = block * ${i.blockSize / H};
            ${_r()}
            for (var word: u32 = 0; word < ${E}; word += ${w}) {
              ${zr()}
              for (var i: u32 = 0; i < ${w}; i++) {
                ${tr()}
                word_offset += ${8 / H};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${le}) {
            var output_value: ${Jr.type.value} = ${Jr.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${be}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${le};
            }
            ${Jr.setByIndices(
              `${Jr.type.indices}(batch, row, col + local_id.x)`,
              "output_value"
            )};
          }
        }`;
              };
              return {
                name: "MatMulNBits",
                shaderCache: {
                  hint: `${i.blockSize};${i.bits};${H};${w};${Z};${le};${be}`,
                  inputDependencies: Array(r.length).fill("rank")
                },
                getRunData: () => ({
                  outputs: [{ dims: re, dataType: q }],
                  dispatchGroup: { x: we },
                  programUniforms: me
                }),
                getShaderSource: dt
              };
            }),
            (yn = (r, i) => {
              pr(r.inputs, i), r.compute(gf(r.inputs, i));
            }),
            (bn = (r) => Qt(r));
        }),
        oo,
        Wp,
        _f,
        yf,
        U,
        G,
        ie,
        Se,
        Je,
        at = m(() => {
          Yt(),
            Zt(),
            cr(),
            (oo = (r) => {
              if (!r || r.length < 1) throw new Error("Too few inputs");
              if (r[0].dataType !== 1 && r[0].dataType !== 10)
                throw new Error("Input type must be float or float16.");
              if (r.length >= 2) {
                let i = r[0].dims.length * 2 === r[1].dims[0];
                if (
                  (r.length === 4 && (i = r[3].dims[0] * 2 === r[1].dims[0]),
                  !i)
                )
                  throw new Error(
                    "The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes]."
                  );
              }
            }),
            (Wp = (r, i, s) => {
              let u = "";
              for (let d = i - 1; d >= 0; --d)
                u += `
            k = i32(${r.indicesGet("indices", d)}) - ${jt(
                  "uniforms.pads",
                  d,
                  s
                )};
            if (k < 0) {
              break;
            }
            if (k >= i32(${jt("uniforms.x_shape", d, i)})) {
              break;
            }
            offset += k * i32(${jt("uniforms.x_strides", d, i)});
        `;
              return `
          value = ${r.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${u}
            value = x[offset];
          }
      `;
            }),
            (_f = (r, i, s) => {
              let u = "";
              for (let d = i - 1; d >= 0; --d)
                u += `
                k = i32(${r.indicesGet("indices", d)}) - ${jt(
                  "uniforms.pads",
                  d,
                  s
                )};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${jt("uniforms.x_shape", d, i)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${jt("uniforms.x_shape", d, i)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${jt("uniforms.x_strides", d, i)});
            `;
              return `
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `;
            }),
            (yf = (r, i, s) => {
              let u = "";
              for (let d = i - 1; d >= 0; --d)
                u += `
                k = i32(${r.indicesGet("indices", d)}) - ${jt(
                  "uniforms.pads",
                  d,
                  s
                )};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${jt("uniforms.x_shape", d, i)})) {
                  k = i32(${jt("uniforms.x_shape", d, i)}) - 1;
                }
                offset += k * i32(${jt("uniforms.x_strides", d, i)});
            `;
              return `
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `;
            }),
            (U = (r, i, s) => {
              let u = "";
              for (let d = i - 1; d >= 0; --d)
                u += `
                k = i32(${r.indicesGet("indices", d)}) - ${jt(
                  "uniforms.pads",
                  d,
                  s
                )};
                if (k < 0)  {
                  k += i32(${jt("uniforms.x_shape", d, i)}]);
                }
                if (k >= i32(${jt("uniforms.x_shape", d, i)})) {
                  k -= i32(${jt("uniforms.x_shape", d, i)});
                }
                offset += k * i32(${jt("uniforms.x_strides", d, i)});
            `;
              return `
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `;
            }),
            (G = (r, i, s) => {
              switch (s.mode) {
                case 0:
                  return Wp(r, i, s.pads.length);
                case 1:
                  return _f(r, i, s.pads.length);
                case 2:
                  return yf(r, i, s.pads.length);
                case 3:
                  return U(r, i, s.pads.length);
                default:
                  throw new Error("Invalid mode");
              }
            }),
            (ie = (r, i) => {
              let s = Ze.padShape(r[0].dims.slice(), i.pads),
                u = r[0].dims,
                d = Ze.size(s),
                p = [
                  { type: 12, data: d },
                  { type: 6, data: i.pads }
                ],
                c = r.length >= 3 && r[2].data;
              i.mode === 0 &&
                p.push({ type: c ? r[2].dataType : 1, data: i.value }),
                p.push(...zt(r[0].dims, s));
              let b = ["rank"],
                k = (E) => {
                  let q = Ht("output", r[0].dataType, s.length),
                    H = gt("x", r[0].dataType, u.length),
                    w = H.type.value,
                    Z = G(q, u.length, i),
                    re = [
                      { name: "output_size", type: "u32" },
                      { name: "pads", type: "i32", length: i.pads.length }
                    ];
                  return (
                    i.mode === 0 &&
                      re.push({ name: "constant_value", type: c ? w : "f32" }),
                    `
            ${E.registerUniforms(re).declareVariables(H, q)}
            ${E.mainStart()}
            ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${q.offsetToIndices("global_idx")};

            var value = ${w}(0);
            ${Z}
            output[global_idx] = value;
        }`
                  );
                };
              return {
                name: "Pad",
                shaderCache: { hint: `${i.mode}${c}`, inputDependencies: b },
                getRunData: () => ({
                  outputs: [{ dims: s, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(Ze.size(s) / 64) },
                  programUniforms: p
                }),
                getShaderSource: k
              };
            }),
            (Se = (r, i) => {
              if (r.length > 1) {
                let s = r[1].getBigInt64Array(),
                  u =
                    r.length >= 3 && r[2].data
                      ? r[2].dataType === 10
                        ? r[2].getUint16Array()[0]
                        : r[2].getFloat32Array()[0]
                      : 0,
                  d = r[0].dims.length,
                  p = new Int32Array(2 * d).fill(0);
                if (r.length >= 4) {
                  let b = r[3].getBigInt64Array();
                  for (let k = 0; k < b.length; k++)
                    (p[Number(b[k])] = Number(s[k])),
                      (p[Number(b[k]) + d] = Number(s[k + b.length]));
                } else s.forEach((b, k) => (p[Number(k)] = Number(b)));
                let c = [];
                return (
                  p.forEach((b) => c.push(b)),
                  { mode: i.mode, value: u, pads: c }
                );
              } else return i;
            }),
            (Je = (r, i) => {
              oo(r.inputs);
              let s = Se(r.inputs, i);
              r.compute(ie(r.inputs, s), { inputs: [0] });
            });
        }),
        _t,
        It,
        qt,
        dr,
        mr,
        Lr,
        gr,
        xr,
        hr,
        vr,
        kr,
        Vr,
        Nn,
        jn,
        xi,
        zn,
        mn,
        En,
        Ll,
        Bl = m(() => {
          bt(),
            Yt(),
            Zt(),
            cr(),
            (_t = (r) => {
              if (N.webgpu.validateInputContent && (!r || r.length !== 1))
                throw new Error("Pool ops requires 1 input.");
            }),
            (It = (r, i, s) => {
              let u = i.format === "NHWC",
                d = r.dims.slice();
              u && d.splice(1, 0, d.pop());
              let p = Object.hasOwnProperty.call(i, "dilations"),
                c = i.kernelShape.slice(),
                b = i.strides.slice(),
                k = p ? i.dilations.slice() : [],
                E = i.pads.slice();
              ei.adjustPoolAttributes(s, d, c, b, k, E);
              let q = ei.computePoolOutputShape(s, d, b, k, c, E, i.autoPad),
                H = Object.assign({}, i);
              p
                ? Object.assign(H, {
                    kernelShape: c,
                    strides: b,
                    pads: E,
                    dilations: k,
                    cacheKey: i.cacheKey
                  })
                : Object.assign(H, {
                    kernelShape: c,
                    strides: b,
                    pads: E,
                    cacheKey: i.cacheKey
                  });
              let w = q.slice();
              return w.push(w.splice(1, 1)[0]), [H, u ? w : q];
            }),
            (qt = (r, i) => {
              let s = i.format === "NHWC",
                u = Ze.size(r),
                d = Ze.size(i.kernelShape),
                p = [
                  { type: 12, data: u },
                  { type: 12, data: d }
                ],
                c = [
                  { name: "outputSize", type: "u32" },
                  { name: "kernelSize", type: "u32" }
                ];
              if (i.kernelShape.length <= 2) {
                let b = i.kernelShape[i.kernelShape.length - 1],
                  k = i.strides[i.strides.length - 1],
                  E = i.pads[i.pads.length / 2 - 1],
                  q = i.pads[i.pads.length - 1],
                  H = !!(E + q);
                p.push(
                  { type: 12, data: b },
                  { type: 12, data: k },
                  { type: 12, data: E },
                  { type: 12, data: q }
                ),
                  c.push(
                    { name: "kw", type: "u32" },
                    { name: "sw", type: "u32" },
                    { name: "pwStart", type: "u32" },
                    { name: "pwEnd", type: "u32" }
                  );
                let w = !1;
                if (i.kernelShape.length === 2) {
                  let Z = i.kernelShape[i.kernelShape.length - 2],
                    re = i.strides[i.strides.length - 2],
                    le = i.pads[i.pads.length / 2 - 2],
                    we = i.pads[i.pads.length - 2];
                  (w = !!(le + we)),
                    p.push(
                      { type: 12, data: Z },
                      { type: 12, data: re },
                      { type: 12, data: le },
                      { type: 12, data: we }
                    ),
                    c.push(
                      { name: "kh", type: "u32" },
                      { name: "sh", type: "u32" },
                      { name: "phStart", type: "u32" },
                      { name: "phEnd", type: "u32" }
                    );
                }
                return [p, c, !0, H, w];
              } else {
                if (s)
                  throw new Error(
                    "Pooling with kernelShape.length > 2 is not supported for NHWC format."
                  );
                let b = Ze.computeStrides(i.kernelShape);
                p.push(
                  { type: 12, data: b },
                  { type: 12, data: i.pads },
                  { type: 12, data: i.strides }
                ),
                  c.push(
                    { name: "kernelStrides", type: "u32", length: b.length },
                    { name: "pads", type: "u32", length: i.pads.length },
                    { name: "strides", type: "u32", length: i.strides.length }
                  );
                let k = i.pads.reduce((E, q) => E + q);
                return [p, c, !!k, !1, !1];
              }
            }),
            (dr = (r, i, s, u, d, p, c, b, k, E, q, H) => {
              let w = d.format === "NHWC",
                Z = i.type.value,
                re = Ht("output", i.type.tensor, u);
              if (d.kernelShape.length <= 2) {
                let le = "",
                  we = "",
                  be = "",
                  me = s - (w ? 2 : 1);
                if (
                  (q
                    ? (le = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${me}] = indices[${me}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${me}] < 0 || xIndices[${me}]
                      >= uniforms.x_shape[${me}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${i.indicesToOffset("xIndices")}];
                  ${p}
                }`)
                    : (le = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${me}] = indices[${me}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${i.indicesToOffset("xIndices")}];
                  ${p}
                }`),
                  d.kernelShape.length === 2)
                ) {
                  let Fe = s - (w ? 3 : 2);
                  H
                    ? (we = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${Fe}] = indices[${Fe}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${Fe}] < 0 || xIndices[${Fe}] >= uniforms.x_shape[${Fe}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `)
                    : (we = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${Fe}] = indices[${Fe}] * uniforms.sh - uniforms.phStart + j;
                `),
                    (be = `
              }
            `);
                }
                return `
            ${r.registerUniforms(k).declareVariables(i, re)}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${re.offsetToIndices("global_idx")};
              var xIndices = ${re.offsetToIndices("global_idx")};

              var value = ${Z}(${b});
              var pad = 0;
              ${we}
              ${le}
              ${be}
              ${c}

              output[global_idx] = value;
            }`;
              } else {
                if (w)
                  throw new Error(
                    "Pooling with kernelShape.length > 2 is not supported for NHWC format."
                  );
                let le = d.kernelShape.length,
                  we = d.pads.length,
                  be = "";
                return (
                  E
                    ? (be = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${i.indicesToOffset("xIndices")}];
                ${p}
              }`)
                    : (be = `
              }
              let x_val = x[${i.indicesToOffset("xIndices")}];
              ${p}
            `),
                  `
            ${r.registerUniforms(k).declareVariables(i, re)}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${re.offsetToIndices("global_idx")};
              var xIndices = ${re.offsetToIndices("global_idx")};

              var offsets: array<u32, ${le}>;

              var value = ${Z}(${b});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${le - 1}u; j++) {
                  offsets[j] = offset / ${jt(
                    "uniforms.kernelStrides",
                    "j",
                    le
                  )};
                  offset -= offsets[j] * ${jt(
                    "uniforms.kernelStrides",
                    "j",
                    le
                  )};
                }
                offsets[${le - 1}] = offset;

                isPad = false;
                for (var j = ${s - le}u; j < ${s}u; j++) {
                  xIndices[j] = indices[j] * ${jt(
                    "uniforms.strides",
                    `j - ${s - le}u`,
                    le
                  )}
                    + offsets[j - ${s - le}u] - ${jt(
                    "uniforms.pads",
                    "j - 2u",
                    we
                  )};
                  ${be}
              }
              ${c}

              output[global_idx] = value;
            }`
                );
              }
            }),
            (mr = (r) =>
              `${r.format};${r.ceilMode};${r.autoPad};${r.kernelShape.length}`),
            (Lr = (r) => `${mr(r)};${r.countIncludePad}`),
            (gr = (r) => `${mr(r)};${r.storageOrder};${r.dilations}`),
            (xr = (r) => ({
              format: r.format,
              autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][
                r.auto_pad
              ],
              ceilMode: r.ceil_mode,
              kernelShape: r.kernel_shape,
              strides: r.strides,
              pads: r.pads
            })),
            (hr = (r, i, s, u) => {
              let [d, p] = It(i, u, s),
                c = gt("x", i.dataType, i.dims.length),
                b = c.type.value,
                k = "value += x_val;",
                E = "";
              d.countIncludePad
                ? (E += `value /= ${b}(uniforms.kernelSize);`)
                : (E += `value /= ${b}(i32(uniforms.kernelSize) - pad);`);
              let [q, H, w, Z, re] = qt(p, d);
              q.push(...zt(i.dims, p));
              let le = ["rank"];
              return {
                name: r,
                shaderCache: {
                  hint: `${u.cacheKey};${w};${Z};${re}`,
                  inputDependencies: le
                },
                getRunData: () => ({
                  outputs: [{ dims: p, dataType: i.dataType }],
                  dispatchGroup: { x: Math.ceil(Ze.size(p) / 64) },
                  programUniforms: q
                }),
                getShaderSource: (we) =>
                  dr(we, c, i.dims.length, p.length, d, k, E, 0, H, w, Z, re)
              };
            }),
            (vr = (r) => {
              let i = r.count_include_pad !== 0,
                s = xr(r);
              if (s.ceilMode !== 0)
                throw new Error(
                  "using ceil() in shape computation is not yet supported for AveragePool"
                );
              let u = { countIncludePad: i, ...s, cacheKey: "" };
              return { ...u, cacheKey: Lr(u) };
            }),
            (kr = (r, i) => {
              _t(r.inputs), r.compute(hr("AveragePool", r.inputs[0], !1, i));
            }),
            (Vr = {
              autoPad: "",
              ceilMode: 0,
              countIncludePad: !1,
              kernelShape: [],
              strides: [],
              pads: [],
              storageOrder: 0,
              dilations: []
            }),
            (Nn = (r) => {
              let i = r.format;
              return { format: i, ...Vr, cacheKey: i };
            }),
            (jn = (r, i) => {
              _t(r.inputs),
                r.compute(hr("GlobalAveragePool", r.inputs[0], !0, i));
            }),
            (xi = (r, i, s, u) => {
              let [d, p] = It(i, u, s),
                c = `
      value = max(x_val, value);
    `,
                b = "",
                k = gt("x", i.dataType, i.dims.length),
                E = ["rank"],
                [q, H, w, Z, re] = qt(p, d);
              return (
                q.push(...zt(i.dims, p)),
                {
                  name: r,
                  shaderCache: {
                    hint: `${u.cacheKey};${w};${Z};${re}`,
                    inputDependencies: E
                  },
                  getRunData: () => ({
                    outputs: [{ dims: p, dataType: i.dataType }],
                    dispatchGroup: { x: Math.ceil(Ze.size(p) / 64) },
                    programUniforms: q
                  }),
                  getShaderSource: (le) =>
                    dr(
                      le,
                      k,
                      i.dims.length,
                      p.length,
                      d,
                      c,
                      b,
                      i.dataType === 10 ? -65504 : -1e5,
                      H,
                      w,
                      Z,
                      re
                    )
                }
              );
            }),
            (zn = (r, i) => {
              _t(r.inputs), r.compute(xi("MaxPool", r.inputs[0], !1, i));
            }),
            (mn = (r) => {
              let i = r.storage_order,
                s = r.dilations,
                u = xr(r);
              if (i !== 0)
                throw new Error(
                  "column major storage order is not yet supported for MaxPool"
                );
              if (u.ceilMode !== 0)
                throw new Error(
                  "using ceil() in shape computation is not yet supported for MaxPool"
                );
              let d = { storageOrder: i, dilations: s, ...u, cacheKey: "" };
              return { ...d, cacheKey: gr(d) };
            }),
            (En = (r) => {
              let i = r.format;
              return { format: i, ...Vr, cacheKey: i };
            }),
            (Ll = (r, i) => {
              _t(r.inputs), r.compute(xi("GlobalMaxPool", r.inputs[0], !0, i));
            });
        }),
        Rl,
        Om,
        Mi,
        Eo,
        Dm = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (Rl = (r, i) => {
              if (r.length < 2 || r.length > 3)
                throw new Error("DequantizeLinear requires 2 or 3 inputs.");
              if (r.length === 3 && r[1].dims === r[2].dims)
                throw new Error(
                  "x-scale and x-zero-point must have the same shape."
                );
              if (r.length === 3 && r[0].dataType !== r[2].dataType)
                throw new Error(
                  "x and x-zero-point must have the same data type."
                );
              if (r[0].dataType === 6 && r.length > 2)
                throw new Error(
                  "In the case of dequantizing int32 there is no zero point."
                );
              if (
                r[1].dims.length !== 0 &&
                r[1].dims.length !== 1 &&
                r[1].dims.length !== r[0].dims.length
              )
                throw new Error(
                  "scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor."
                );
              if (r.length > 2) {
                if (r[0].dataType !== r[2].dataType)
                  throw new Error(
                    "x and x-zero-point must have the same data type."
                  );
                if (r[1].dims.length !== r[2].dims.length)
                  throw new Error(
                    "scale and zero-point inputs must have the same rank."
                  );
                if (
                  !r[1].dims
                    .map((s, u) => s === r[2].dims[u])
                    .reduce((s, u) => s && u, !0)
                )
                  throw new Error(
                    "scale and zero-point inputs must have the same shape."
                  );
              }
              if (i.blockSize > 0) {
                if (
                  r[1].dims.length === 0 ||
                  (r[1].dims.length === 1 && r[1].dims[0] === 1)
                )
                  throw new Error(
                    "blockSize must be set only for block quantization."
                  );
                if (
                  !r[1].dims
                    .map((d, p) => p === i.axis || d === r[0].dims[p])
                    .reduce((d, p) => d && p, !0)
                )
                  throw new Error(
                    "For block qunatization, scale input shape to match the input shape except for the axis"
                  );
                if (r[1].dims.length !== r[0].dims.length)
                  throw new Error(
                    "For block qunatization the scale input rank must be the same as the x rank."
                  );
                let s = r[0].dims[i.axis],
                  u = r[1].dims[i.axis];
                if (
                  i.blockSize < Math.ceil(s / u) ||
                  i.blockSize > Math.ceil(s / (u - 1) - 1)
                )
                  throw new Error(
                    "blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)]."
                  );
              }
            }),
            (Om = (r, i) => {
              let s = Ze.normalizeAxis(i.axis, r[0].dims.length),
                u = r[0].dataType,
                d = u === 3,
                p = r[0].dims,
                c = r[1].dataType,
                b = Ze.size(p),
                k = u === 3 || u === 2,
                E = k ? [Math.ceil(Ze.size(r[0].dims) / 4)] : r[0].dims,
                q = r[1].dims,
                H = r.length > 2 ? r[2] : void 0,
                w = H
                  ? k
                    ? [Math.ceil(Ze.size(H.dims) / 4)]
                    : H.dims
                  : void 0,
                Z = q.length === 0 || (q.length === 1 && q[0] === 1),
                re = Z === !1 && q.length === 1,
                le = $r(b),
                we = Z && (!k || le === 4),
                be = we ? le : 1,
                me = we && !k ? le : 1,
                Fe = gt("input", k ? 12 : u, E.length, me),
                Ce = gt("scale", c, q.length),
                ze = H ? gt("zero_point", k ? 12 : u, w.length) : void 0,
                dt = Ht("output", c, p.length, be),
                lt = [Fe, Ce];
              ze && lt.push(ze);
              let Mt = [E, q];
              H && Mt.push(w);
              let Dt = [
                  { type: 12, data: b / be },
                  { type: 12, data: s },
                  { type: 12, data: i.blockSize },
                  ...zt(...Mt, p)
                ],
                Ut = (fr) => {
                  let br = [
                    { name: "output_size", type: "u32" },
                    { name: "axis", type: "u32" },
                    { name: "block_size", type: "u32" }
                  ];
                  return `
      ${fr.registerUniforms(br).declareVariables(...lt, dt)}
      ${fr.mainStart()}
          ${fr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${dt.offsetToIndices("global_idx")};

          // Set input x
          ${
            k
              ? `
            let input = ${Fe.getByOffset("global_idx / 4")};
            let x_vec = ${d ? "unpack4xI8(input)" : "unpack4xU8(input)"};
            let x_value = ${be === 1 ? "x_vec[global_idx % 4]" : "x_vec"};`
              : `let x_value = ${Fe.getByOffset("global_idx")};`
          };

          // Set scale input
          ${
            Z
              ? `let scale_value= ${Ce.getByOffset("0")}`
              : re
              ? `
            let scale_index = ${dt.indicesGet(
              "output_indices",
              "uniforms.axis"
            )};
            let scale_value= ${Ce.getByOffset("scale_index")};`
              : `
            var scale_indices: ${Ce.type.indices} = output_indices;
            let index = ${Ce.indicesGet(
              "scale_indices",
              "uniforms.axis"
            )} / uniforms.block_size;
            ${Ce.indicesSet("scale_indices", "uniforms.axis", "index")};
            let scale_value= ${Ce.getByIndices("scale_indices")};`
          };

          // Set zero-point input
          ${
            ze
              ? Z
                ? k
                  ? `
                let zero_point_input = ${ze.getByOffset("0")};
                let zero_point_vec =  ${
                  d
                    ? "unpack4xI8(zero_point_input)"
                    : "unpack4xU8(zero_point_input)"
                };
                let zero_point_value= zero_point_vec[0]`
                  : `let zero_point_value = ${ze.getByOffset("0")}`
                : re
                ? k
                  ? `
                let zero_point_index = ${dt.indicesGet(
                  "output_indices",
                  "uniforms.axis"
                )};
                let zero_point_input = ${ze.getByOffset(
                  "zero_point_index / 4"
                )};
                let zero_point_vec =  ${
                  d
                    ? "unpack4xI8(zero_point_input)"
                    : "unpack4xU8(zero_point_input)"
                };
                let zero_point_value = zero_point_vec[zero_point_index % 4]`
                  : `
                let zero_point_index = ${dt.indicesGet(
                  "output_indices",
                  "uniforms.axis"
                )};
                let zero_point_value = ${ze.getByOffset("zero_point_index")};`
                : k
                ? `
                let zero_point_offset = ${Ce.indicesToOffset("scale_indices")};
                let zero_point_input = ${ze.getByOffset(
                  "zero_point_offset / 4"
                )};
                let zero_point_vec = ${
                  d
                    ? "unpack4xI8(zero_point_input)"
                    : "unpack4xU8(zero_point_input)"
                };
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`
                : `let zero_point_value = ${ze.getByIndices("scale_indices")};`
              : `let zero_point_value = ${
                  k ? (d ? "i32" : "u32") : Fe.type.value
                }(0);`
          };
      // Compute and write output
      ${dt.setByOffset(
        "global_idx",
        `${dt.type.value}(x_value - zero_point_value) * scale_value`
      )};
      }`;
                };
              return {
                name: "DequantizeLinear",
                shaderCache: {
                  hint: i.cacheKey,
                  inputDependencies: ze
                    ? ["rank", "rank", "rank"]
                    : ["rank", "rank"]
                },
                getShaderSource: Ut,
                getRunData: () => ({
                  outputs: [{ dims: p, dataType: c }],
                  dispatchGroup: { x: Math.ceil(b / be / 64), y: 1, z: 1 },
                  programUniforms: Dt
                })
              };
            }),
            (Mi = (r, i) => {
              Rl(r.inputs, i), r.compute(Om(r.inputs, i));
            }),
            (Eo = (r) => Qt({ axis: r.axis, blockSize: r.blockSize }));
        }),
        Gp,
        Hp,
        wf,
        Mx = m(() => {
          bt(),
            Yt(),
            cr(),
            (Gp = (r, i, s) => {
              let u = r === i,
                d = r < i && s < 0,
                p = r > i && s > 0;
              if (u || d || p)
                throw new Error("Range these inputs' contents are invalid.");
            }),
            (Hp = (r, i, s, u) => {
              let d = Math.abs(Math.ceil((i - r) / s)),
                p = [d],
                c = d,
                b = [
                  { type: 12, data: c },
                  { type: u, data: r },
                  { type: u, data: s },
                  ...zt(p)
                ],
                k = (E) => {
                  let q = Ht("output", u, p.length),
                    H = q.type.value,
                    w = [
                      { name: "outputSize", type: "u32" },
                      { name: "start", type: H },
                      { name: "delta", type: H }
                    ];
                  return `
        ${E.registerUniforms(w).declareVariables(q)}
        ${E.mainStart()}
        ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${H}(global_idx) * uniforms.delta;
      }`;
                };
              return {
                name: "Range",
                shaderCache: { hint: `${u}` },
                getShaderSource: k,
                getRunData: () => ({
                  outputs: [{ dims: p, dataType: u }],
                  dispatchGroup: { x: Math.ceil(c / 64) },
                  programUniforms: b
                })
              };
            }),
            (wf = (r) => {
              let i = 0,
                s = 0,
                u = 0;
              r.inputs[0].dataType === 6
                ? ((i = r.inputs[0].getInt32Array()[0]),
                  (s = r.inputs[1].getInt32Array()[0]),
                  (u = r.inputs[2].getInt32Array()[0]))
                : r.inputs[0].dataType === 1 &&
                  ((i = r.inputs[0].getFloat32Array()[0]),
                  (s = r.inputs[1].getFloat32Array()[0]),
                  (u = r.inputs[2].getFloat32Array()[0])),
                N.webgpu.validateInputContent && Gp(i, s, u),
                r.compute(Hp(i, s, u, r.inputs[0].dataType), { inputs: [] });
            });
        }),
        N0,
        j0,
        U0,
        V0,
        W0,
        G0,
        H0,
        q0,
        K0,
        Q0,
        X0,
        Lm,
        Y0,
        Z0,
        J0,
        ey,
        ty,
        ry,
        ny,
        Tx = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (N0 = (r, i) => {
              if (
                (r.every(
                  (s) =>
                    s > 0 ||
                    (() => {
                      throw new Error(
                        "Resize requires scales input values to be positive"
                      );
                    })
                ),
                r.length > 0)
              ) {
                if (i.mode === "linear") {
                  if (
                    !(
                      r.length === 2 ||
                      r.length === 3 ||
                      (r.length === 4 && r[0] === 1 && r[1] === 1) ||
                      (r.length === 4 && r[0] === 1 && r[3] === 1) ||
                      (r.length === 5 && r[0] === 1 && r[1] === 1)
                    )
                  )
                    throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`);
                } else if (
                  i.mode === "cubic" &&
                  !(
                    r.length === 2 ||
                    (r.length === 4 && r[0] === 1 && r[1] === 1) ||
                    (r.length === 4 && r[0] === 1 && r[3] === 1)
                  )
                )
                  throw new Error(
                    "Resize requires scales input size to be 2 or 4 for cubic mode"
                  );
              }
            }),
            (j0 = (r, i, s) => {
              i.every(
                (d) =>
                  (d >= 0 && d < s) ||
                  (() => {
                    throw new Error(
                      "Resize requires axes input values to be positive and less than rank"
                    );
                  })
              );
              let u = new Array(s).fill(1);
              return i.forEach((d, p) => (u[d] = r[p])), u;
            }),
            (U0 = (r, i, s, u, d, p) => {
              let [c, b, k] =
                  s > 10 ? [1, 2, 3] : [-1, r.length > 1 ? 1 : -1, -1],
                E = r[0].dims.length;
              if (c > 0 && r.length > c && r[c].dims.length > 0)
                r[c].getFloat32Array().forEach((q) => p.push(q));
              else if (i.coordinateTransformMode === "tf_crop_and_resize")
                throw new Error(
                  "Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize"
                );
              if (b > 0 && r.length > b && r[b].dims.length > 0) {
                if (
                  (r[b].getFloat32Array().forEach((q) => u.push(q)),
                  u.length !== 0 &&
                    u.length !== E &&
                    s >= 18 &&
                    u.length !== i.axes.length)
                )
                  throw new Error(
                    "Resize requires scales input size to be same as input rank or axes size for opset 18 and up"
                  );
                N0(u, i),
                  i.axes.length > 0 &&
                    j0(u, i.axes, E).forEach((q, H) => (u[H] = q));
              }
              if (
                k > 0 &&
                r.length > k &&
                (r[k].getBigInt64Array().forEach((q) => d.push(Number(q))),
                d.length !== E || (s >= 18 && d.length === i.axes.length))
              )
                throw new Error(
                  "Resize requires sizes input size to be same as input rank or axes size for opset 18 and up"
                );
              if (i.axes.length > 0) {
                if (u.length !== i.axes.length)
                  throw new Error(
                    'Resize requires "scales" input size to be of axes rank when axes attributes is specified'
                  );
                if (d.length !== i.axes.length)
                  throw new Error(
                    'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified'
                  );
              }
              if (
                typeof u < "u" &&
                typeof d < "u" &&
                u.length > 0 &&
                d.length > E
              )
                throw new Error(
                  "Resize requires only of scales or sizes to be specified"
                );
            }),
            (V0 = (r, i) =>
              `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${i} { ` +
              (() => {
                switch (r) {
                  case "asymmetric":
                    return `return ${i}(xResized) / ${i}(xScale);`;
                  case "pytorch_half_pixel":
                    return `if (lengthResized > 1) {
                    return (${i}(xResized) + 0.5) / ${i}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
                  case "tf_half_pixel_for_nn":
                    return `return (${i}(xResized) + 0.5) / ${i}(xScale);`;
                  case "align_corners":
                    return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${i}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${i}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${i}(lengthResized - 1);
                    return whole + fract;
                  }`;
                  case "tf_crop_and_resize":
                    return `if (lengthResized > 1) {
                    return ${i}(roiStart) * ${i}(lengthOriginal - 1) +
                        (${i}(xResized) * ${i}(roiEnd - roiStart) * ${i}(lengthOriginal - 1)) /
                        ${i}(lengthResized - 1);
                  } else {
                    return 0.5 * ${i}(roiStart + roiEnd) * ${i}(lengthOriginal - 1);
                  }`;
                  case "half_pixel_symmetric":
                    return `const outputWidth = ${i}xScale * ${i}(lengthResized);
                  const adjustment = ${i}(lengthResized) / outputWidth;
                  const center = ${i}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${i}(xResized) + 0.5) / ${i}(xScale)) - 0.5;`;
                  case "half_pixel":
                    return `return ((${i}(xResized) + 0.5) / ${i}(xScale)) - 0.5;`;
                  default:
                    throw new Error(
                      `Coordinate transform mode ${r} is not supported`
                    );
                }
              })() +
              "}"),
            (W0 = (r, i, s) =>
              `fn getNearestPixelFromOriginal(xOriginal: ${s}, isDownSample: bool) -> ${s} {` +
              (() => {
                switch (r) {
                  case "round_prefer_ceil":
                    return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
                  case "floor":
                    return "return floor(xOriginal);";
                  case "ceil":
                    return "return ceil(xOriginal);";
                  case "round_prefer_floor":
                    return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
                  case "simple":
                  default:
                    if (i < 11)
                      return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
                    throw new Error(`Nearest mode ${r} is not supported`);
                }
              })() +
              "}"),
            (G0 = (r, i, s) => {
              let u = new Array(s).fill(0).concat(new Array(s).fill(1)),
                d = r.length === 0 ? u : r.slice();
              return i.length > 0
                ? (i.forEach((p, c) => {
                    (u[p] = d[c]), (u[c + s] = d[i.length + c]);
                  }),
                  u)
                : d;
            }),
            (H0 = (r, i, s, u) => {
              let d = [];
              if (s.length > 0)
                if (u.length > 0) {
                  if ((r.forEach((p) => d.push(p)), Math.max(...u) > r.length))
                    throw new Error("axes is out of bound");
                  u.forEach((p, c) => (d[p] = s[c]));
                } else s.forEach((p) => d.push(p));
              else {
                if (i.length === 0)
                  throw new Error("Resize requires either scales or sizes.");
                d = r.map((p, c) => Math.round(p * i[c]));
              }
              return d;
            }),
            (q0 = (r, i, s) => {
              let u = (() => {
                switch (s.keepAspectRatioPolicy) {
                  case "not_larger":
                    return s.axes.length > 0
                      ? Math.min(...s.axes.map((p) => i[p]), Number.MAX_VALUE)
                      : Math.min(...i, Number.MAX_VALUE);
                  case "not_smaller":
                    return s.axes.length > 0
                      ? Math.max(...s.axes.map((p) => i[p]), Number.MIN_VALUE)
                      : Math.max(...i, Number.MIN_VALUE);
                  default:
                    throw new Error(
                      `Keep aspect ratio policy ${s.keepAspectRatioPolicy} is not supported`
                    );
                }
              })();
              i.fill(1, 0, i.length);
              let d = r.slice();
              return (
                s.axes.length > 0
                  ? (s.axes.forEach((p) => (i[p] = u)),
                    s.axes.forEach((p) => (d[p] = Math.round(r[p] * i[p]))))
                  : (i.fill(u, 0, i.length),
                    d.forEach((p, c) => (d[c] = Math.round(p * i[c])))),
                d
              );
            }),
            (K0 = (r, i, s, u, d) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${
      r.type.indices
    }) -> array<${r.type.value}, ${s.length}> {
      var original_indices: array<${r.type.value}, ${s.length}>;
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${r.indicesGet("output_indices", "i")};
        var scale = ${jt("uniforms.scales", "i", u)};
        var roi_low = ${jt("uniforms.roi", "i", d)};
        var roi_hi = ${jt("uniforms.roi", `i + ${i.length}`, d)};
        if (scale == 1.0) {
          original_indices[i] = ${r.type.value}(output_index);
        } else {
          var input_shape_i = ${jt("uniforms.input_shape", "i", i.length)};
          var output_shape_i = ${jt("uniforms.output_shape", "i", s.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`),
            (Q0 = (r, i, s, u, d, p, c) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${
      i.type.indices
    }) -> ${r.type.indices} {
      var input_indices: ${r.type.indices};
      for (var i:u32 = 0; i < ${u.length}; i++) {
        var output_index = ${i.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${jt("uniforms.scales", "i", d)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${jt("uniforms.roi", "i", p)};
          var roi_hi = ${jt("uniforms.roi", `i + ${s.length}`, p)};
          var input_shape_i = ${jt("uniforms.input_shape", "i", s.length)};
          var output_shape_i = ${jt("uniforms.output_shape", "i", u.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${c} || (original_idx >= 0 && original_idx < ${
              i.type.value
            }(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${i.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${r.indicesSet("input_indices", "i", " input_index")}
      }
      return input_indices;
    }`),
            (X0 = (r, i) => `
    fn checkInputIndices(input_indices: ${r.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${i.length}; i++) {
        var input_index = ${r.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${jt(
          "uniforms.input_shape",
          "i",
          i.length
        )}) {
          return false;
        }
      }
      return true;
    }`),
            (Lm = (r, i, s, u) =>
              r.rank > u
                ? `
    ${r.indicesSet("input_indices", i, "channel")};
    ${r.indicesSet("input_indices", s, "batch")};
`
                : ""),
            (Y0 = (r, i, s, u, d) => {
              let [p, c, b, k] = s.length === 2 ? [-1, 0, 1, -1] : [0, 2, 3, 1],
                E = r.type.value;
              return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${E} {
      var input_indices: ${r.type.indices};
      ${r.indicesSet("input_indices", c, `max(0, min(row, ${s[c]} - 1))`)};
      ${r.indicesSet("input_indices", b, `max(0, min(col, ${s[b]} - 1))`)};
      ${Lm(r, k, p, 2)}
      return ${r.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${i.type.indices}) -> ${E} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${E} = originalIndices[${c}];
      var col:${E} = originalIndices[${b}];
      ${
        u
          ? `if (row < 0 || row > (${s[c]} - 1) || col < 0 || col > (${s[b]} - 1)) {
        return ${d};
      }`
          : ""
      };
      row = max(0, min(row, ${s[c]} - 1));
      col = max(0, min(col, ${s[b]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${s.length > 2 ? `u32(originalIndices[${k}])` : "0"};
      var batch: u32 =  ${s.length > 2 ? `u32(originalIndices[${p}])` : "0"};
      var x11: ${E} = getInputValue(batch, channel, row1, col1);
      var x12: ${E} = getInputValue(batch, channel, row1, col2);
      var x21: ${E} = getInputValue(batch, channel, row2, col1);
      var x22: ${E} = getInputValue(batch, channel, row2, col2);
      var dx1: ${E} = abs(row - ${E}(row1));
      var dx2: ${E} = abs(${E}(row2) - row);
      var dy1: ${E} = abs(col - ${E}(col1));
      var dy2: ${E} = abs(${E}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
            }),
            (Z0 = (r, i, s, u, d, p, c, b, k, E) => {
              let q = s.length === 2,
                [H, w] = q ? [0, 1] : [2, 3],
                Z = r.type.value,
                re = (le) => {
                  let we = le === H ? "row" : "col";
                  return `
      fn ${we}CubicInterpolation(input_indices: ${
                    r.type.indices
                  }, output_indices: ${i.type.indices}) -> ${Z} {
        var output_index = ${i.indicesGet("output_indices", le)};
        var originalIdx: ${Z} = getOriginalCoordinateFromResizedCoordinate(output_index, ${
                    d[le]
                  },
        ${u[le]}, ${s[le]}, ${p[le]}, ${p[le]} + ${s.length});
        var fractOriginalIdx: ${Z} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${b} && (originalIdx < 0 || originalIdx > (${s[le]} - 1))) {
          return ${k};
        }
        var data: array<${Z}, 4> = array<${Z}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${we}: ${Z} = originalIdx + ${Z}(i);
          if (${we} < 0 || ${we} >= ${s[le]}) {
            ${
              E
                ? `coefs[i + 1] = 0.0;
                        continue;`
                : b
                ? `return ${k};`
                : `${we} = max(0, min(${we}, ${s[le]} - 1));`
            };
          }
        var input_indices_copy: ${r.type.indices} = input_indices;
          ${r.indicesSet("input_indices_copy", le, `u32(${we})`)};
          data[i + 1] = ${
            le === H
              ? r.getByIndices("input_indices_copy")
              : "rowCubicInterpolation(input_indices_copy, output_indices)"
          };
        }
        return cubicInterpolation1D(data, coefs);
      }`;
                };
              return `
    ${re(H)};
    ${re(w)};
  fn getCubicInterpolationCoefs(s: ${Z}) -> array<${Z}, 4> {
    var absS = abs(s);
    var coeffs: array<${Z}, 4> = array<${Z}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${Z} = 1.0 - absS;
    var twoMinusAbsS: ${Z} = 2.0 - absS;
    var onePlusAbsS: ${Z} = 1.0 + absS;
    coeffs[0] = ((${c} * onePlusAbsS - 5 * ${c}) * onePlusAbsS + 8 * ${c}) * onePlusAbsS - 4 * ${c};
    coeffs[1] = ((${c} + 2) * absS - (${c} + 3)) * absS * absS + 1;
    coeffs[2] = ((${c} + 2) * oneMinusAbsS - (${c} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${c} * twoMinusAbsS - 5 * ${c}) * twoMinusAbsS + 8 * ${c}) * twoMinusAbsS - 4 * ${c};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${Z}, 4>, coefs: array<${Z}, 4>) -> ${Z} {
    var coefsSum: ${Z} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${i.type.indices}) -> ${Z} {
    var input_indices: ${r.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
            }),
            (J0 = (r, i, s, u, d) => {
              let [p, c, b, k, E] =
                  s.length === 3 ? [-1, 0, 1, 2, -1] : [0, 2, 3, 4, 1],
                q = r.type.value;
              return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${q} {
      var input_indices: ${r.type.indices};
      ${r.indicesSet("input_indices", c, `max(0, min(depth, ${s[c]} - 1))`)};
      ${r.indicesSet("input_indices", b, `max(0, min(height, ${s[b]} - 1))`)};
      ${r.indicesSet("input_indices", k, `max(0, min(width, ${s[k]} - 1))`)};
      ${Lm(r, E, p, 3)}
      return ${r.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${i.type.indices}) -> ${q} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${q} = originalIndices[${c}];
      var height:${q} = originalIndices[${b}];
      var width:${q} = originalIndices[${k}];
      ${
        u
          ? `if (depth < 0 || depth > (${s[c]} - 1) || height < 0 || height > (${s[b]} - 1) || width < 0 || (width > ${s[k]} - 1)) {
      return ${d};
        }`
          : ""
      };

    depth = max(0, min(depth, ${s[c]} - 1));
      height = max(0, min(height, ${s[b]} - 1));
      width = max(0, min(width, ${s[k]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${s.length > 3 ? `u32(originalIndices[${E}])` : "0"};
      var batch: u32 =  ${s.length > 3 ? `u32(originalIndices[${p}])` : "0"};

      var x111: ${q} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${q} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${q} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${q} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${q} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${q} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${q} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${q} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${q} = abs(depth - ${q}(depth1));
      var dx2: ${q} = abs(${q}(depth2) - depth);
      var dy1: ${q} = abs(height - ${q}(height1));
      var dy2: ${q} = abs(${q}(height2) - height);
      var dz1: ${q} = abs(width - ${q}(width1));
      var dz2: ${q} = abs(${q}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
            }),
            (ey = (r, i, s, u, d, p) => {
              let c = r.dims,
                b = G0(p, i.axes, c.length),
                k = H0(c, u, d, i.axes),
                E = u.slice();
              u.length === 0 &&
                ((E = c.map((me, Fe) => (me === 0 ? 1 : k[Fe] / me))),
                i.keepAspectRatioPolicy !== "stretch" && (k = q0(c, E, i)));
              let q = Ht("output", r.dataType, k.length),
                H = gt("input", r.dataType, c.length),
                w = Ze.size(k),
                Z = c.length === k.length && c.every((me, Fe) => me === k[Fe]),
                re = i.coordinateTransformMode === "tf_crop_and_resize",
                le = i.extrapolationValue,
                we = H.type.value,
                be = (me) => `
      ${
        Z
          ? ""
          : `
      ${V0(i.coordinateTransformMode, we)};
      ${(() => {
        switch (i.mode) {
          case "nearest":
            return `
              ${X0(H, c)};
              ${W0(i.nearestMode, s, we)};
              ${Q0(H, q, c, k, E.length, b.length, re)};
              `;
          case "linear":
            return `
              ${K0(q, c, k, E.length, b.length)};
              ${(() => {
                if (c.length === 2 || c.length === 4)
                  return `${Y0(H, q, c, re, le)}`;
                if (c.length === 3 || c.length === 5)
                  return `${J0(H, q, c, re, le)}`;
                throw Error(
                  "Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode."
                );
              })()};
            `;
          case "cubic":
            return `
            ${(() => {
              if (c.length === 2 || c.length === 4)
                return `${Z0(
                  H,
                  q,
                  c,
                  k,
                  E,
                  b,
                  i.cubicCoeffA,
                  re,
                  i.extrapolationValue,
                  i.excludeOutside
                )}`;
              throw Error(
                "Cubic mode only supports input dims 2 and 4 are supported in linear mode."
              );
            })()};
            `;
          default:
            throw Error("Invalid resize mode");
        }
      })()};
      `
      }
      ${me
        .registerUniform("output_size", "u32")
        .registerUniform("scales", "f32", E.length)
        .registerUniform("roi", "f32", b.length)
        .declareVariables(H, q)}
      ${me.mainStart()}
        ${me.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${
          Z
            ? "output[global_idx] = input[global_idx];"
            : `
        let output_indices = ${q.offsetToIndices("global_idx")};
        var input_indices: ${H.type.indices};
        ${(() => {
          switch (i.mode) {
            case "nearest":
              return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${H.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${i.extrapolationValue};
                }`;
            case "linear":
              return `output[global_idx] = ${
                c.length === 2 || c.length === 4
                  ? "bilinearInterpolation"
                  : "trilinearInterpolation"
              }(output_indices);`;
            case "cubic":
              return "output[global_idx] = bicubicInterpolation(output_indices);";
            default:
              throw Error(`Unsupported resize mode: ${i.mode}`);
          }
        })()};
`
        }
      }`;
              return {
                name: "Resize",
                shaderCache: {
                  hint: `${i.cacheKey}|${s}|${E.length > 0 ? E : ""}|${
                    d.length > 0 ? d : ""
                  }|${b.length > 0 ? b : ""}|${Z}|${c}`,
                  inputDependencies: ["rank"]
                },
                getShaderSource: be,
                getRunData: () => ({
                  outputs: [{ dims: k, dataType: r.dataType }],
                  dispatchGroup: { x: Math.ceil(w / 64) },
                  programUniforms: [
                    { type: 12, data: w },
                    { type: 1, data: E },
                    { type: 1, data: b },
                    ...zt(c, k)
                  ]
                })
              };
            }),
            (ty = (r) => {
              let i = r.customDataBuffer;
              return new Uint32Array(i, i.byteOffset, 1)[0];
            }),
            (ry = (r, i) => {
              let s = [],
                u = [],
                d = [],
                p = ty(r);
              if (i.antialias !== 0)
                throw Error(
                  "Only default value (0) for Antialias attribute is supported"
                );
              U0(r.inputs, i, p, s, u, d),
                r.compute(ey(r.inputs[0], i, p, s, u, d), { inputs: [0] });
            }),
            (ny = (r) => {
              let i = r.antialias,
                s = r.axes,
                u = r.coordinateTransformMode,
                d = r.cubicCoeffA,
                p = r.excludeOutside !== 0,
                c = r.extrapolationValue,
                b = r.keepAspectRatioPolicy,
                k = r.mode,
                E = r.nearestMode === "" ? "simple" : r.nearestMode;
              return Qt({
                antialias: i,
                axes: s,
                coordinateTransformMode: u,
                cubicCoeffA: d,
                excludeOutside: p,
                extrapolationValue: c,
                keepAspectRatioPolicy: b,
                mode: k,
                nearestMode: E
              });
            });
        }),
        iy,
        oy,
        sy,
        kx = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (iy = (r, i) => {
              let [s, u, d, p] = r,
                { numHeads: c, rotaryEmbeddingDim: b } = i;
              if (s.dims.length !== 3 && s.dims.length !== 4)
                throw new Error(
                  `Input 'x' is expected to have 3 or 4 dimensions, got ${s.dims.length}`
                );
              if (
                !Ze.areEqual(u.dims, []) &&
                !Ze.areEqual(u.dims, [1]) &&
                u.dims.length !== 2
              )
                throw new Error(
                  `Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${u.dims.length}`
                );
              if (d.dims.length !== 2)
                throw new Error(
                  `Input 'cos_cache' is expected to have 2 dimensions, got ${d.dims.length}`
                );
              if (p.dims.length !== 2)
                throw new Error(
                  `Input 'sin_cache' is expected to have 2 dimensions, got ${p.dims.length}`
                );
              if (!Ze.areEqual(d.dims, p.dims))
                throw new Error(
                  "Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape"
                );
              if (b > 0 && c === 0)
                throw new Error(
                  "num_heads must be provided if rotary_embedding_dim is specified"
                );
              let k = s.dims[0],
                E = s.dims[s.dims.length - 2],
                q = d.dims[0],
                H = Ze.sizeFromDimension(s.dims, 1) / E,
                w = b === 0 ? d.dims[1] * 2 : H / c;
              if (b > w)
                throw new Error(
                  "rotary_embedding_dim must be less than or equal to head_size"
                );
              if (u.dims.length === 2) {
                if (k !== u.dims[0])
                  throw new Error(
                    `Input 'position_ids' dimension 0 should be of size batch_size, got ${u.dims[0]}`
                  );
                if (E !== u.dims[1])
                  throw new Error(
                    `Input 'position_ids' dimension 1 should be of size sequence_length, got ${u.dims[1]}`
                  );
              }
              if (w / 2 !== d.dims[1] && b / 2 !== d.dims[1])
                throw new Error(
                  `Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${d.dims[1]}`
                );
              if (E > q)
                throw new Error(
                  "Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported"
                );
            }),
            (oy = (r, i) => {
              let {
                  interleaved: s,
                  numHeads: u,
                  rotaryEmbeddingDim: d,
                  scale: p
                } = i,
                c = r[0].dims[0],
                b = Ze.sizeFromDimension(r[0].dims, 1),
                k = r[0].dims[r[0].dims.length - 2],
                E = b / k,
                q = r[2].dims[1],
                H = d === 0 ? q * 2 : E / u,
                w = new Array(c, k, E / H, H - q),
                Z = Ze.computeStrides(w),
                re = [
                  { type: 1, data: p },
                  { type: 12, data: w },
                  { type: 12, data: Z },
                  ...(r[0].dims.length === 3
                    ? new Array({ type: 12, data: [b, E, H, 1] })
                    : []),
                  ...(r[0].dims.length === 4
                    ? new Array({ type: 12, data: [b, H, k * H, 1] })
                    : []),
                  ...zt(r[0].dims, r[1].dims, r[2].dims, r[3].dims, r[0].dims)
                ],
                le = (we) => {
                  let be = gt("input", r[0].dataType, r[0].dims.length),
                    me = gt("position_ids", r[1].dataType, r[1].dims.length),
                    Fe = gt("cos_cache", r[2].dataType, r[2].dims.length),
                    Ce = gt("sin_cache", r[3].dataType, r[3].dims.length),
                    ze = Ht("output", r[0].dataType, r[0].dims.length);
                  return (
                    we.registerUniforms([
                      { name: "scale", type: "f32" },
                      { name: "global_shape", type: "u32", length: w.length },
                      { name: "global_strides", type: "u32", length: Z.length },
                      {
                        name: "input_output_strides",
                        type: "u32",
                        length: Z.length
                      }
                    ]),
                    `
        ${we.declareVariables(be, me, Fe, Ce, ze)}

        ${we.mainStart(Kn)}
          let half_rotary_emb_dim = uniforms.${Fe.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${we.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${me.broadcastedIndicesToOffset(
                  "bsnh.xy",
                  Ht("", me.type.tensor, 2)
                )};
            let position_id =
                u32(${me.getByOffset(
                  "position_ids_idx"
                )}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${s});
            let j = i + select(half_rotary_emb_dim, 1, ${s});
            let re = ${be.getByOffset("i")} * ${Fe.get(
                      "position_id",
                      "bsnh[3]"
                    )} -
                ${be.getByOffset("j")} * ${Ce.get("position_id", "bsnh[3]")};
            ${ze.setByOffset("i", "re")}
            let im = ${be.getByOffset("i")} * ${Ce.get(
                      "position_id",
                      "bsnh[3]"
                    )} +
                ${be.getByOffset("j")} * ${Fe.get("position_id", "bsnh[3]")};
            ${ze.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${ze.setByOffset("k", be.getByOffset("k"))}
          }
        }`
                  );
                };
              return {
                name: "RotaryEmbedding",
                shaderCache: {
                  hint: Qt({ interleaved: s }).cacheKey,
                  inputDependencies: ["rank", "rank", "rank", "rank"]
                },
                getShaderSource: le,
                getRunData: () => ({
                  outputs: [{ dims: r[0].dims, dataType: r[0].dataType }],
                  dispatchGroup: { x: Math.ceil(Ze.size(w) / Kn) },
                  programUniforms: re
                })
              };
            }),
            (sy = (r, i) => {
              iy(r.inputs, i), r.compute(oy(r.inputs, i));
            });
        }),
        ay,
        ly,
        uy,
        Sx = m(() => {
          Yt(),
            Zt(),
            cr(),
            (ay = (r) => {
              if (!r || r.length < 3)
                throw new Error("layerNorm requires at least 3 inputs.");
              let i = r[0],
                s = r[1],
                u = r[2];
              if (i.dataType !== s.dataType || i.dataType !== u.dataType)
                throw new Error("All inputs must have the same data type");
              if (i.dims.length !== 3 && i.dims.length !== 2)
                throw new Error("Input must be 2D or 3D");
              if (s.dims.length !== 3 && s.dims.length !== 2)
                throw new Error("Skip must be 2D or 3D");
              let d = i.dims[i.dims.length - 1],
                p = i.dims[i.dims.length - 2];
              if (s.dims[s.dims.length - 1] !== d)
                throw new Error("Skip must have the same hidden size as input");
              if (s.dims[s.dims.length - 2] !== p)
                throw new Error(
                  "Skip must have the same sequence length as input"
                );
              if (u.dims.length !== 1) throw new Error("Gamma must be 1D");
              if (u.dims[u.dims.length - 1] !== d)
                throw new Error(
                  "Gamma must have the same hidden size as input"
                );
              if (r.length > 3) {
                let c = r[3];
                if (c.dims.length !== 1) throw new Error("Beta must be 1D");
                if (c.dims[c.dims.length - 1] !== d)
                  throw new Error(
                    "Beta must have the same hidden size as input"
                  );
              }
              if (r.length > 4) {
                let c = r[4];
                if (c.dims.length !== 1) throw new Error("Bias must be 1D");
                if (c.dims[c.dims.length - 1] !== d)
                  throw new Error(
                    "Bias must have the same hidden size as input"
                  );
              }
            }),
            (ly = (r, i, s, u) => {
              let d = i.simplified,
                p = r[0].dims,
                c = Ze.size(p),
                b = p,
                k = c,
                E = p.slice(-1)[0],
                q = u ? p.slice(0, -1).concat(1) : [],
                H = !d && r.length > 3,
                w = r.length > 4,
                Z = u && s > 1,
                re = u && s > 2,
                le = s > 3,
                we = 64,
                be = $r(E),
                me = [
                  { type: 12, data: k },
                  { type: 12, data: be },
                  { type: 12, data: E },
                  { type: 1, data: i.epsilon }
                ],
                Fe = (ze) => {
                  let dt = [
                      { name: "output_size", type: "u32" },
                      { name: "components", type: "u32" },
                      { name: "hidden_size", type: "u32" },
                      { name: "epsilon", type: "f32" }
                    ],
                    lt = [
                      gt("x", r[0].dataType, r[0].dims, be),
                      gt("skip", r[1].dataType, r[1].dims, be),
                      gt("gamma", r[2].dataType, r[2].dims, be)
                    ];
                  H && lt.push(gt("beta", r[3].dataType, r[3].dims, be)),
                    w && lt.push(gt("bias", r[4].dataType, r[4].dims, be)),
                    lt.push(Ht("output", r[0].dataType, b, be)),
                    Z && lt.push(Ht("mean_output", 1, q)),
                    re && lt.push(Ht("inv_std_output", 1, q)),
                    le &&
                      lt.push(Ht("input_skip_bias_sum", r[0].dataType, b, be));
                  let Mt = Fr(r[0].dataType),
                    Dt = Fr(1, be);
                  return `

      ${ze.registerUniforms(dt).declareVariables(...lt)}
      var<workgroup> sum_shared : array<${Dt}, ${we}>;
      var<workgroup> sum_squared_shared : array<${Dt}, ${we}>;

      ${ze.mainStart([we, 1, 1])}
        let ix = local_id.x;
        let iy = global_id.x / ${we};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${we};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${we - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${w ? "bias[offset1d + i]" : Mt + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${le ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${Zr(Mt, be, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${we};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Qn("sum", be)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Qn(
          "square_sum",
          be
        )} / f32(uniforms.hidden_size) ${
                    d ? "" : "- mean * mean"
                  } + uniforms.epsilon);
        ${Z ? "mean_output[global_idx] = mean;" : ""}
        ${re ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${
            d ? "" : `- ${Mt}(mean)`
          }) *
            ${Mt}(inv_std_dev) * gamma[offset1d + i]
            ${H ? "+ beta[offset1d + i]" : ""};
        }
      }`;
                },
                Ce = [{ dims: b, dataType: r[0].dataType }];
              return (
                s > 1 && Ce.push({ dims: q, dataType: 1 }),
                s > 2 && Ce.push({ dims: q, dataType: 1 }),
                s > 3 && Ce.push({ dims: p, dataType: r[0].dataType }),
                {
                  name: "SkipLayerNormalization",
                  shaderCache: {
                    hint: `${be};${Z};${re};${le}`,
                    inputDependencies: r.map((ze, dt) => "type")
                  },
                  getShaderSource: Fe,
                  getRunData: () => ({
                    outputs: Ce,
                    dispatchGroup: { x: Math.ceil(k / E) },
                    programUniforms: me
                  })
                }
              );
            }),
            (uy = (r, i) => {
              ay(r.inputs);
              let s = [0];
              r.outputCount > 1 && s.push(-3),
                r.outputCount > 2 && s.push(-3),
                r.outputCount > 3 && s.push(3),
                r.compute(ly(r.inputs, i, r.outputCount, !1), { outputs: s });
            });
        }),
        cy,
        vf,
        dy,
        Bm,
        fy,
        py,
        hy,
        my,
        Ex = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (cy = (r, i) => {
              if (!r || r.length < 1) throw new Error("too few inputs");
              if (i.axes.length !== 0) {
                if (
                  i.axes.length !== i.starts.length ||
                  i.axes.length !== i.ends.length
                )
                  throw new Error(
                    "axes, starts and ends must have the same length"
                  );
              } else if (i.starts.length !== i.ends.length)
                throw new Error("starts and ends must have the same length");
              r.slice(1).forEach((s, u) => {
                if (r[u + 1].dataType !== 6 && r[u + 1].dataType !== 7)
                  throw new Error(
                    `Input ${u} must be an array of int32 or int64`
                  );
              });
            }),
            (vf = (r, i) => {
              let s = [];
              if (r.length > i)
                if (r[i].dataType === 7)
                  r[i].getBigInt64Array().forEach((u) => s.push(Number(u)));
                else if (r[i].dataType === 6)
                  r[i].getInt32Array().forEach((u) => s.push(Number(u)));
                else
                  throw new Error(
                    `Input ${i} must be an array of int32 or int64`
                  );
              return s;
            }),
            (dy = (r, i) => {
              if (r.length > 1) {
                let s = vf(r, 1),
                  u = vf(r, 2),
                  d = vf(r, 3);
                return (
                  d.length === 0 && (d = [...Array(r[0].dims.length).keys()]),
                  Qt({ starts: s, ends: u, axes: d })
                );
              } else return i;
            }),
            (Bm = (r, i, s, u, d) => {
              let p = r;
              return (
                r < 0 && (p += s[u[i]]),
                d[i] < 0
                  ? Math.max(0, Math.min(p, s[u[i]] - 1))
                  : Math.max(0, Math.min(p, s[u[i]]))
              );
            }),
            (fy = (r, i, s) => `fn calculateInputIndices(output_indices: ${
              i.type.indices
            }) -> ${r.type.indices} {
          var input_indices: ${r.type.indices};
          var carry = 0u;
          for (var i = ${s.length}; i >= 0; i--) {
            let input_shape_i = ${jt("uniforms.input_shape", "i", s.length)};
            let steps_i = ${jt("uniforms.steps", "i", s.length)};
            let signs_i = ${jt("uniforms.signs", "i", s.length)};
            let starts_i = ${jt("uniforms.starts", "i", s.length)};
            var output_index = ${i.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${r.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`),
            (py = (r, i) => {
              let s = r[0].dims,
                u = Ze.size(s),
                d =
                  i.axes.length > 0
                    ? Ze.normalizeAxes(i.axes, s.length)
                    : [...Array(s.length).keys()],
                p = vf(r, 4);
              p.forEach(
                (be) =>
                  be !== 0 ||
                  (() => {
                    throw new Error("step cannot be 0");
                  })
              ),
                p.length === 0 && (p = Array(d.length).fill(1));
              let c = i.starts.map((be, me) => Bm(be, me, s, d, p)),
                b = i.ends.map((be, me) => Bm(be, me, s, d, p));
              if (d.length !== c.length || d.length !== b.length)
                throw new Error(
                  "start, ends and axes should have the same number of elements"
                );
              if (d.length !== s.length)
                for (let be = 0; be < s.length; ++be)
                  d.includes(be) ||
                    (c.splice(be, 0, 0),
                    b.splice(be, 0, s[be]),
                    p.splice(be, 0, 1));
              let k = p.map((be) => Math.sign(be));
              p.forEach((be, me, Fe) => {
                if (be < 0) {
                  let Ce = (b[me] - c[me]) / be,
                    ze = c[me],
                    dt = ze + Ce * p[me];
                  (c[me] = dt), (b[me] = ze), (Fe[me] = -be);
                }
              });
              let E = s.slice(0);
              d.forEach((be, me) => {
                E[be] = Math.ceil((b[be] - c[be]) / p[be]);
              });
              let q = { dims: E, dataType: r[0].dataType },
                H = Ht("output", r[0].dataType, E.length),
                w = gt("input", r[0].dataType, r[0].dims.length),
                Z = Ze.size(E),
                re = [
                  { name: "outputSize", type: "u32" },
                  { name: "starts", type: "u32", length: c.length },
                  { name: "signs", type: "i32", length: k.length },
                  { name: "steps", type: "u32", length: p.length }
                ],
                le = [
                  { type: 12, data: Z },
                  { type: 12, data: c },
                  { type: 6, data: k },
                  { type: 12, data: p },
                  ...zt(r[0].dims, E)
                ],
                we = (be) => `
      ${be.registerUniforms(re).declareVariables(w, H)}
        ${fy(w, H, s)}
        ${be.mainStart()}
          ${be.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${H.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${H.setByOffset("global_idx", w.getByIndices("input_indices"))}
      }`;
              return {
                name: "Slice",
                shaderCache: {
                  hint: `${k.length}_${c.length}_${p.length}`,
                  inputDependencies: ["rank"]
                },
                getShaderSource: we,
                getRunData: () => ({
                  outputs: [q],
                  dispatchGroup: { x: Math.ceil(u / 64) },
                  programUniforms: le
                })
              };
            }),
            (hy = (r, i) => {
              cy(r.inputs, i);
              let s = dy(r.inputs, i);
              r.compute(py(r.inputs, s), { inputs: [0] });
            }),
            (my = (r) => {
              let i = r.starts,
                s = r.ends,
                u = r.axes;
              return Qt({ starts: i, ends: s, axes: u });
            });
        }),
        gy,
        _y,
        yy,
        wy,
        Cx = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (gy = (r) => {
              if (!r || r.length !== 1)
                throw new Error("Softmax op requires 1 input.");
            }),
            (_y = (r, i) => {
              let s = r.dims,
                u = Ze.size(s),
                d = 64,
                p = i.axis;
              if ((p < 0 && (p = s.length + p), p < s.length - 1))
                throw new Error("softmax only supports last axis for now.");
              let c = s[p],
                b = u / c,
                k = $r(c),
                E = c / k,
                q = (we, be) =>
                  be === 4
                    ? `max(max(${we}.x, ${we}.y), max(${we}.z, ${we}.w))`
                    : be === 2
                    ? `max(${we}.x, ${we}.y)`
                    : be === 3
                    ? `max(max(${we}.x, ${we}.y), ${we}.z)`
                    : we,
                H = gt("x", r.dataType, r.dims, k),
                w = Ht("result", r.dataType, r.dims, k),
                Z = H.type.value,
                re =
                  Fr(r.dataType) === "f32"
                    ? `var threadMax = ${Z}(-3.402823e+38f);`
                    : `var threadMax = ${Z}(-65504.0h);`,
                le = (we) => `
      var<workgroup> rowMaxShared : ${Z};
      var<workgroup> rowSumShared : ${Z};
      var<workgroup> threadShared : array<${Z}, ${d}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${Z} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${Z}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${we.registerUniform("packedCols", "i32").declareVariables(H, w)}
      ${we.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${d};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${re}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${Z}(${q("threadShared[0]", k)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${Z}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${Z}(${Qn("threadShared[0]", k)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;
              return {
                name: "Softmax",
                shaderCache: { hint: `${k}`, inputDependencies: ["type"] },
                getRunData: () => ({
                  outputs: [{ dims: s, dataType: r.dataType }],
                  dispatchGroup: { x: b },
                  programUniforms: [{ type: 6, data: E }]
                }),
                getShaderSource: le
              };
            }),
            (yy = (r, i) => {
              gy(r.inputs), r.compute(_y(r.inputs[0], i));
            }),
            (wy = (r) => Qt({ axis: r.axis }));
        }),
        vy,
        by,
        xy,
        My,
        Ty,
        ky,
        Sy,
        Px = m(() => {
          Yt(),
            Zt(),
            wr(),
            cr(),
            (vy = (r) => {
              if (!r || r.length < 1) throw new Error("too few inputs");
            }),
            (by = (r, i) => {
              let s = [],
                u = i.numOutputs;
              return (
                r[1].dims[0] > 0 &&
                  (r[1].getBigInt64Array().forEach((d) => s.push(Number(d))),
                  (u = s.length)),
                Qt({ numOutputs: u, axis: i.axis, splitSizes: s })
              );
            }),
            (xy = (r) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${r}u; i += 1u ) {
    if (index < ${jt("uniforms.size_in_split_axis", "i", r)}) {
        return i;
    }
    }
    return ${r}u;
}`),
            (My = (r) => {
              let i = r.length,
                s = [];
              for (let u = 0; u < i; ++u) {
                let d = r[u].setByIndices("indices", "input[global_idx]");
                i === 1
                  ? s.push(d)
                  : u === 0
                  ? s.push(`if (output_number == ${u}u) { ${d} }`)
                  : u === i - 1
                  ? s.push(`else { ${d} }`)
                  : s.push(`else if (output_number == ${u}) { ${d} }`);
              }
              return `
      fn writeBufferData(output_number: u32, indices: ${
        r[0].type.indices
      }, global_idx: u32) {
        ${s.join(`
`)}
      }`;
            }),
            (Ty = (r, i) => {
              let s = r[0].dims,
                u = Ze.size(s),
                d = r[0].dataType,
                p = Ze.normalizeAxis(i.axis, s.length),
                c = new Array(i.numOutputs),
                b = gt("input", d, s.length),
                k = new Array(i.numOutputs),
                E = [],
                q = [],
                H = 0,
                w = [{ type: 12, data: u }];
              for (let re = 0; re < i.numOutputs; re++) {
                (H += i.splitSizes[re]), (k[re] = H);
                let le = s.slice();
                (le[p] = i.splitSizes[re]),
                  q.push(le),
                  (c[re] = Ht(`output${re}`, d, le.length)),
                  E.push({ dims: q[re], dataType: r[0].dataType });
              }
              w.push({ type: 12, data: k }, ...zt(s, ...q));
              let Z = (re) => `
  ${re
    .registerUniform("input_size", "u32")
    .registerUniform("size_in_split_axis", "u32", k.length)
    .declareVariables(b, ...c)}
  ${xy(k.length)}
  ${My(c)}

  ${re.mainStart()}
    ${re.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${b.offsetToIndices("global_idx")};
    var index = ${b.indicesGet("indices", p)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${jt(
        "uniforms.size_in_split_axis",
        "output_number - 1u",
        k.length
      )};
      ${b.indicesSet("indices", p, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
              return {
                name: "Split",
                shaderCache: { hint: i.cacheKey, inputDependencies: ["rank"] },
                getShaderSource: Z,
                getRunData: () => ({
                  outputs: E,
                  dispatchGroup: { x: Math.ceil(u / 64) },
                  programUniforms: w
                })
              };
            }),
            (ky = (r, i) => {
              vy(r.inputs);
              let s = r.inputs.length === 1 ? i : by(r.inputs, i);
              r.compute(Ty(r.inputs, s), { inputs: [0] });
            }),
            (Sy = (r) => {
              let i = r.axis,
                s = r.splitSizes,
                u = r.numOutputs < 0 ? s.length : r.numOutputs;
              if (u !== s.length)
                throw new Error(
                  "numOutputs and splitSizes lengh must be equal"
                );
              return Qt({ axis: i, numOutputs: u, splitSizes: s });
            });
        }),
        Ey,
        Cy,
        Py,
        $x = m(() => {
          Yt(),
            Zt(),
            cr(),
            (Ey = (r, i, s, u, d) => {
              let p = Ht("output_data", d, s.length, 4),
                c = gt("a_data", i[1].dataType, i[1].dims.length, 4),
                b = gt("b_data", i[2].dataType, i[2].dims.length, 4),
                k = gt("c_data", i[0].dataType, i[0].dims.length, 4),
                E,
                q = (H, w, Z) => `select(${w}, ${H}, ${Z})`;
              if (!u)
                E = p.setByOffset(
                  "global_idx",
                  q(
                    c.getByOffset("global_idx"),
                    b.getByOffset("global_idx"),
                    k.getByOffset("global_idx")
                  )
                );
              else {
                let H = (w, Z, re = "") => {
                  let le = `a_data[index_a${Z}][component_a${Z}]`,
                    we = `b_data[index_b${Z}][component_b${Z}]`,
                    be = `bool(c_data[index_c${Z}] & (0xffu << (component_c${Z} * 8)))`;
                  return `
            let output_indices${Z} = ${p.offsetToIndices(
                    `global_idx * 4u + ${Z}u`
                  )};
            let offset_a${Z} = ${c.broadcastedIndicesToOffset(
                    `output_indices${Z}`,
                    p
                  )};
            let offset_b${Z} = ${b.broadcastedIndicesToOffset(
                    `output_indices${Z}`,
                    p
                  )};
            let offset_c${Z} = ${k.broadcastedIndicesToOffset(
                    `output_indices${Z}`,
                    p
                  )};
            let index_a${Z} = offset_a${Z} / 4u;
            let index_b${Z} = offset_b${Z} / 4u;
            let index_c${Z} = offset_c${Z} / 4u;
            let component_a${Z} = offset_a${Z} % 4u;
            let component_b${Z} = offset_b${Z} % 4u;
            let component_c${Z} = offset_c${Z} % 4u;
            ${w}[${Z}] = ${re}(${q(le, we, be)});
          `;
                };
                d === 9
                  ? (E = `
            var data = vec4<u32>(0);
            ${H("data", 0, "u32")}
            ${H("data", 1, "u32")}
            ${H("data", 2, "u32")}
            ${H("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`)
                  : (E = `
            ${H("output_data[global_idx]", 0)}
            ${H("output_data[global_idx]", 1)}
            ${H("output_data[global_idx]", 2)}
            ${H("output_data[global_idx]", 3)}
          `);
              }
              return `
        ${r.registerUniform("vec_size", "u32").declareVariables(k, c, b, p)}
        ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${E}
      }`;
            }),
            (Cy = (r) => {
              let i = r[1].dims,
                s = r[2].dims,
                u = r[0].dims,
                d = r[1].dataType,
                p = !(Ze.areEqual(i, s) && Ze.areEqual(s, u)),
                c = i,
                b = Ze.size(i);
              if (p) {
                let E = vn.calcShape(vn.calcShape(i, s, !1), u, !1);
                if (!E)
                  throw new Error(
                    "Can't perform where op on the given tensors"
                  );
                (c = E), (b = Ze.size(c));
              }
              let k = Math.ceil(b / 4);
              return {
                name: "Where",
                shaderCache: { inputDependencies: ["rank", "rank", "rank"] },
                getShaderSource: (E) => Ey(E, r, c, p, d),
                getRunData: () => ({
                  outputs: [{ dims: c, dataType: d }],
                  dispatchGroup: { x: Math.ceil(b / 64 / 4) },
                  programUniforms: [{ type: 12, data: k }, ...zt(u, i, s, c)]
                })
              };
            }),
            (Py = (r) => {
              r.compute(Cy(r.inputs));
            });
        }),
        $y,
        Ax = m(() => {
          wp(),
            Ls(),
            vp(),
            bp(),
            xp(),
            Mp(),
            Tp(),
            gl(),
            $p(),
            Ap(),
            zp(),
            Im(),
            Dp(),
            Dd(),
            Fm(),
            Bp(),
            Rp(),
            Np(),
            Up(),
            Vp(),
            zm(),
            Gs(),
            Fn(),
            Jd(),
            at(),
            Bl(),
            Dm(),
            Mx(),
            Ia(),
            Tx(),
            kx(),
            Sx(),
            Ex(),
            Cx(),
            Px(),
            nf(),
            Mo(),
            Xa(),
            $x(),
            ($y = new Map([
              ["Abs", [gc]],
              ["Acos", [_c]],
              ["Acosh", [Da]],
              ["Add", [Za]],
              ["ArgMax", [ic, Ds]],
              ["ArgMin", [nc, Ds]],
              ["Asin", [yc]],
              ["Asinh", [wc]],
              ["Atan", [La]],
              ["Atanh", [vc]],
              ["Attention", [uc]],
              ["AveragePool", [kr, vr]],
              ["BatchNormalization", [fc]],
              ["BiasAdd", [Oa]],
              ["BiasSplitGelu", [Ya]],
              ["Cast", [Ba, bc]],
              ["Ceil", [Bs]],
              ["Clip", [Mc]],
              ["Concat", [td, rl]],
              ["Conv", [ml, fl]],
              ["ConvTranspose", [bl, vl]],
              ["Cos", [Tc]],
              ["Cosh", [kc]],
              ["CumSum", [xl, Sd]],
              ["DepthToSpace", [Tl, kl]],
              ["DequantizeLinear", [Mi, Eo]],
              ["Div", [Gc]],
              ["Einsum", [Ad, Dr]],
              ["Elu", [Ra, Zo]],
              ["Equal", [Hc]],
              ["Erf", [Na]],
              ["Exp", [Sc]],
              ["Expand", [zd]],
              ["FastGelu", [Pl]],
              ["Floor", [Ec]],
              ["FusedConv", [ml, fl]],
              ["Gather", [Lp, $l]],
              ["GatherElements", [Hd, Gd]],
              ["GatherBlockQuantized", [jd, Ud]],
              ["Gelu", [Cc]],
              ["Gemm", [Xd, Qd]],
              ["GlobalAveragePool", [jn, Nn]],
              ["GlobalMaxPool", [Ll, En]],
              ["Greater", [el]],
              ["GreaterOrEqual", [Xc]],
              ["GroupQueryAttention", [lf, sf]],
              ["HardSigmoid", [Va, Fc]],
              ["InstanceNormalization", [ff]],
              ["LayerNormalization", [mf]],
              ["LeakyRelu", [ja, Zo]],
              ["Less", [Qc]],
              ["LessOrEqual", [tl]],
              ["Log", [Bc]],
              ["MatMul", [pd]],
              ["MatMulNBits", [yn, bn]],
              ["MaxPool", [zn, mn]],
              ["Mul", [Ja]],
              ["MultiHeadAttention", [Zd, Al]],
              ["Neg", [$c]],
              ["Not", [Pc]],
              ["Pad", [Je]],
              ["Pow", [qc]],
              ["QuickGelu", [Ns, Zo]],
              ["Range", [wf]],
              ["Reciprocal", [Ac]],
              ["ReduceMin", [$a]],
              ["ReduceMean", [Xu]],
              ["ReduceMax", [Ju]],
              ["ReduceSum", [tc]],
              ["ReduceProd", [ec]],
              ["ReduceL1", [Yu]],
              ["ReduceL2", [Pa]],
              ["ReduceLogSum", [rc]],
              ["ReduceLogSumExp", [Zu]],
              ["ReduceSumSquare", [Aa]],
              ["Relu", [Ua]],
              ["Resize", [ry, ny]],
              ["RotaryEmbedding", [sy]],
              ["Sigmoid", [Ic]],
              ["Sin", [zc]],
              ["Sinh", [Oc]],
              ["Slice", [hy, my]],
              ["SkipLayerNormalization", [uy]],
              ["Split", [ky, Sy]],
              ["Sqrt", [Wa]],
              ["Softmax", [yy, wy]],
              ["Sub", [Kc]],
              ["Tan", [Dc]],
              ["Tanh", [Ha]],
              ["ThresholdedRelu", [Lc, Zo]],
              ["Tile", [rf]],
              ["Transpose", [Su, va]],
              ["Where", [Py]]
            ]));
        }),
        Ay,
        Ix = m(() => {
          bt(),
            qn(),
            cr(),
            (Ay = class {
              constructor(r) {
                (this.backend = r),
                  (this.repo = new Map()),
                  (this.attributesBound = !1);
              }
              getArtifact(r) {
                return this.repo.get(r);
              }
              setArtifact(r, i) {
                this.repo.set(r, i);
              }
              run(r, i, s, u, d) {
                et(r.programInfo.name);
                let p = this.backend.device,
                  c = this.backend.getComputePassEncoder();
                this.backend.writeTimestamp(
                  this.backend.pendingDispatchNumber * 2
                );
                let b = [];
                for (let E of i)
                  b.push({ binding: b.length, resource: { buffer: E.buffer } });
                for (let E of s)
                  b.push({ binding: b.length, resource: { buffer: E.buffer } });
                d && b.push({ binding: b.length, resource: d });
                let k = p.createBindGroup({
                  layout: r.computePipeline.getBindGroupLayout(0),
                  entries: b,
                  label: r.programInfo.name
                });
                if (this.backend.sessionStatus === "capturing") {
                  let E = {
                    kernelId: this.backend.currentKernelId,
                    computePipeline: r.computePipeline,
                    bindGroup: k,
                    dispatchGroup: u
                  };
                  this.backend.capturedCommandList
                    .get(this.backend.currentSessionId)
                    .push(E);
                }
                c.setPipeline(r.computePipeline),
                  c.setBindGroup(0, k),
                  c.dispatchWorkgroups(...u),
                  this.backend.writeTimestamp(
                    this.backend.pendingDispatchNumber * 2 + 1
                  ),
                  this.backend.pendingDispatchNumber++,
                  (this.backend.pendingDispatchNumber >=
                    this.backend.maxDispatchNumber ||
                    this.backend.queryType === "at-passes") &&
                    this.backend.endComputePass(),
                  this.backend.pendingDispatchNumber >=
                    this.backend.maxDispatchNumber && this.backend.flush(),
                  A(r.programInfo.name);
              }
              dispose() {}
              build(r, i) {
                et(r.name);
                let s = this.backend.device,
                  u = [];
                s.features.has("shader-f16") && u.push("enable f16;");
                let d = Mu(i, this.backend.device.limits),
                  p = r.getShaderSource(d),
                  c = `${u.join(`
`)}
${d.additionalImplementations}
${p}`,
                  b = s.createShaderModule({ code: c, label: r.name });
                Kr("verbose", () => `[WebGPU] ${r.name} shader code: ${c}`);
                let k = s.createComputePipeline({
                  compute: { module: b, entryPoint: "main" },
                  layout: "auto",
                  label: r.name
                });
                return (
                  A(r.name),
                  {
                    programInfo: r,
                    computePipeline: k,
                    uniformVariablesInfo: d.variablesInfo
                  }
                );
              }
              normalizeDispatchGroupSize(r) {
                let i = typeof r == "number" ? r : r.x,
                  s = typeof r == "number" ? 1 : r.y || 1,
                  u = typeof r == "number" ? 1 : r.z || 1,
                  d =
                    this.backend.device.limits.maxComputeWorkgroupsPerDimension;
                if (i <= d && s <= d && u <= d) return [i, s, u];
                let p = i * s * u,
                  c = Math.ceil(Math.sqrt(p));
                if (c > d) {
                  if (((c = Math.ceil(Math.cbrt(p))), c > d))
                    throw new Error(
                      "Total dispatch size exceeds WebGPU maximum."
                    );
                  return [c, c, c];
                } else return [c, c, 1];
              }
            });
        }),
        Iy,
        Fy,
        zy,
        Oy,
        Fx = m(() => {
          bt(),
            Yt(),
            qn(),
            W(),
            Or(),
            Ax(),
            Ix(),
            (Iy = (r, i) => {
              if (i.length !== r.length)
                throw new Error(
                  `inputDependencies length ${i.length} is not equal to inputTensors length ${r.length}.`
                );
              let s = [];
              for (let u = 0; u < r.length; ++u) {
                let d = r[u].dataType;
                switch (i[u]) {
                  case "none": {
                    s.push("");
                    break;
                  }
                  case "type": {
                    s.push(`${d}`);
                    break;
                  }
                  case "rank": {
                    let p = r[u].dims.length;
                    s.push(`${d};${p}`);
                    break;
                  }
                  case "dims": {
                    let p = r[u].dims.join(",");
                    s.push(`${d};${p}`);
                    break;
                  }
                  default:
                    throw new Error(`unsupported input dependency: ${i[u]}`);
                }
              }
              return s.join("|");
            }),
            (Fy = (r, i, s) => {
              var d, p;
              let u = r.name;
              return (
                (d = r.shaderCache) != null &&
                  d.hint &&
                  (u += "[" + r.shaderCache.hint + "]"),
                (u +=
                  ":" +
                  s +
                  `:${Iy(
                    i,
                    ((p = r.shaderCache) == null
                      ? void 0
                      : p.inputDependencies) ?? new Array(i.length).fill("dims")
                  )}`),
                u
              );
            }),
            (zy = class {
              constructor(r) {
                r &&
                  ((this.architecture = r.architecture),
                  (this.vendor = r.vendor));
              }
              isArchitecture(r) {
                return this.architecture === r;
              }
              isVendor(r) {
                return this.vendor === r;
              }
            }),
            (Oy = class {
              constructor() {
                (this.currentSessionId = null),
                  (this.currentKernelId = null),
                  (this.commandEncoder = null),
                  (this.computePassEncoder = null),
                  (this.maxDispatchNumber = 16),
                  (this.pendingDispatchNumber = 0),
                  (this.pendingKernels = []),
                  (this.pendingQueries = new Map()),
                  (this.sessionStatus = "default"),
                  (this.capturedCommandList = new Map()),
                  (this.capturedPendingKernels = new Map()),
                  (this.sessionExternalDataMapping = new Map());
              }
              get currentKernelCustomData() {
                if (this.currentKernelId === null)
                  throw new Error(
                    "currentKernelCustomData(): currentKernelId is null. (should not happen)"
                  );
                let r = this.kernelCustomData.get(this.currentKernelId);
                return (
                  r ||
                    ((r = {}),
                    this.kernelCustomData.set(this.currentKernelId, r)),
                  r
                );
              }
              async initialize(r, i) {
                this.env = r;
                let s = [],
                  u = {
                    requiredLimits: {
                      maxComputeWorkgroupStorageSize:
                        i.limits.maxComputeWorkgroupStorageSize,
                      maxComputeWorkgroupsPerDimension:
                        i.limits.maxComputeWorkgroupsPerDimension,
                      maxStorageBufferBindingSize:
                        i.limits.maxStorageBufferBindingSize,
                      maxBufferSize: i.limits.maxBufferSize,
                      maxComputeInvocationsPerWorkgroup:
                        i.limits.maxComputeInvocationsPerWorkgroup,
                      maxComputeWorkgroupSizeX:
                        i.limits.maxComputeWorkgroupSizeX,
                      maxComputeWorkgroupSizeY:
                        i.limits.maxComputeWorkgroupSizeY,
                      maxComputeWorkgroupSizeZ:
                        i.limits.maxComputeWorkgroupSizeZ
                    },
                    requiredFeatures: s
                  };
                i.features.has(
                  "chromium-experimental-timestamp-query-inside-passes"
                )
                  ? s.push(
                      "chromium-experimental-timestamp-query-inside-passes"
                    )
                  : i.features.has("timestamp-query") &&
                    s.push("timestamp-query"),
                  i.features.has("shader-f16") && s.push("shader-f16"),
                  (this.device = await i.requestDevice(u)),
                  (this.adapterInfo = new zy(
                    i.info || (await i.requestAdapterInfo())
                  )),
                  (this.gpuDataManager = or(this)),
                  (this.programManager = new Ay(this)),
                  (this.kernels = new Map()),
                  (this.kernelPersistentData = new Map()),
                  (this.kernelCustomData = new Map()),
                  bo(r.logLevel, !!r.debug),
                  (this.device.onuncapturederror = (d) => {
                    d.error instanceof GPUValidationError &&
                      console.error(
                        `An uncaught WebGPU validation error was raised: ${d.error.message}`
                      );
                  }),
                  Object.defineProperty(this.env.webgpu, "device", {
                    value: this.device,
                    writable: !1,
                    enumerable: !0,
                    configurable: !1
                  }),
                  Object.defineProperty(this.env.webgpu, "adapter", {
                    value: i,
                    writable: !1,
                    enumerable: !0,
                    configurable: !1
                  }),
                  this.setQueryType();
              }
              dispose() {
                typeof this.querySet < "u" && this.querySet.destroy(),
                  this.gpuDataManager.dispose();
              }
              getCommandEncoder() {
                return (
                  this.commandEncoder ||
                    (this.commandEncoder = this.device.createCommandEncoder()),
                  this.commandEncoder
                );
              }
              getComputePassEncoder() {
                if (!this.computePassEncoder) {
                  let r = this.getCommandEncoder(),
                    i = {};
                  this.queryType === "at-passes" &&
                    (i.timestampWrites = {
                      querySet: this.querySet,
                      beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
                      endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
                    }),
                    (this.computePassEncoder = r.beginComputePass(i));
                }
                return this.computePassEncoder;
              }
              endComputePass() {
                this.computePassEncoder &&
                  (this.computePassEncoder.end(),
                  (this.computePassEncoder = null));
              }
              flush() {
                if (!this.commandEncoder) return;
                et(), this.endComputePass();
                let r;
                this.queryType !== "none" &&
                  (this.commandEncoder.resolveQuerySet(
                    this.querySet,
                    0,
                    this.pendingDispatchNumber * 2,
                    this.queryResolveBuffer,
                    0
                  ),
                  (r = this.device.createBuffer({
                    size: this.pendingDispatchNumber * 2 * 8,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
                  })),
                  this.pendingQueries.set(r, this.pendingKernels),
                  (this.pendingKernels = []),
                  this.commandEncoder.copyBufferToBuffer(
                    this.queryResolveBuffer,
                    0,
                    r,
                    0,
                    this.pendingDispatchNumber * 2 * 8
                  )),
                  this.device.queue.submit([this.commandEncoder.finish()]),
                  this.gpuDataManager.refreshPendingBuffers(),
                  (this.commandEncoder = null),
                  (this.pendingDispatchNumber = 0),
                  this.queryType !== "none" &&
                    r.mapAsync(GPUMapMode.READ).then(() => {
                      var u;
                      let i = new BigUint64Array(r.getMappedRange()),
                        s = this.pendingQueries.get(r);
                      for (let d = 0; d < i.length / 2; d++) {
                        let p = s[d],
                          c = p.kernelId,
                          b = this.kernels.get(c),
                          k = b.kernelType,
                          E = b.kernelName,
                          q = p.programName,
                          H = p.inputTensorViews,
                          w = p.outputTensorViews,
                          Z = i[d * 2],
                          re = i[d * 2 + 1];
                        typeof this.queryTimeBase > "u" &&
                          (this.queryTimeBase = Z);
                        let le = Number(Z - this.queryTimeBase),
                          we = Number(re - this.queryTimeBase);
                        if (
                          !Number.isSafeInteger(le) ||
                          !Number.isSafeInteger(we)
                        )
                          throw new RangeError("incorrect timestamp range");
                        if ((u = this.env.webgpu.profiling) != null && u.ondata)
                          this.env.webgpu.profiling.ondata({
                            version: 1,
                            inputsMetadata: H.map((be) => ({
                              dims: be.dims,
                              dataType: vi(be.dataType)
                            })),
                            outputsMetadata: w.map((be) => ({
                              dims: be.dims,
                              dataType: vi(be.dataType)
                            })),
                            kernelId: c,
                            kernelType: k,
                            kernelName: E,
                            programName: q,
                            startTime: le,
                            endTime: we
                          });
                        else {
                          let be = "";
                          H.forEach((Fe, Ce) => {
                            be += `input[${Ce}]: [${Fe.dims}] | ${vi(
                              Fe.dataType
                            )}, `;
                          });
                          let me = "";
                          w.forEach((Fe, Ce) => {
                            me += `output[${Ce}]: [${Fe.dims}] | ${vi(
                              Fe.dataType
                            )}, `;
                          }),
                            console.log(
                              `[profiling] kernel "${c}|${k}|${E}|${q}" ${be}${me}execution time: ${
                                we - le
                              } ns`
                            );
                        }
                        je("GPU", `${q}::${Z}::${re}`);
                      }
                      r.unmap(), this.pendingQueries.delete(r);
                    }),
                  A();
              }
              run(r, i, s, u, d, p) {
                et(r.name);
                let c = [];
                for (let me = 0; me < i.length; ++me) {
                  let Fe = i[me].data;
                  if (Fe === 0) continue;
                  let Ce = this.gpuDataManager.get(Fe);
                  if (!Ce) throw new Error(`no GPU data for input: ${Fe}`);
                  c.push(Ce);
                }
                let {
                    outputs: b,
                    dispatchGroup: k,
                    programUniforms: E
                  } = r.getRunData(i),
                  q = s.length === 0 ? b.map((me, Fe) => Fe) : s;
                if (q.length !== b.length)
                  throw new Error(
                    `Output size ${q.length} must be equal to ${b.length}.`
                  );
                let H = [],
                  w = [];
                for (let me = 0; me < b.length; ++me) {
                  if (!Number.isInteger(q[me]) || q[me] < -3 || q[me] >= p)
                    throw new Error(`Invalid output index: ${q[me]}`);
                  if (q[me] === -3) continue;
                  let Fe = q[me] === -1,
                    Ce = q[me] === -2,
                    ze =
                      Fe || Ce
                        ? d(b[me].dataType, b[me].dims)
                        : u(q[me], b[me].dataType, b[me].dims);
                  if ((H.push(ze), ze.data === 0)) continue;
                  let dt = this.gpuDataManager.get(ze.data);
                  if (!dt)
                    throw new Error(`no GPU data for output: ${ze.data}`);
                  if ((Fe && this.temporaryData.push(dt), Ce)) {
                    let lt = this.kernelPersistentData.get(
                      this.currentKernelId
                    );
                    lt ||
                      ((lt = []),
                      this.kernelPersistentData.set(this.currentKernelId, lt)),
                      lt.push(dt);
                  }
                  w.push(dt);
                }
                if (c.length !== i.length || w.length !== H.length) {
                  if (w.length === 0) return A(r.name), H;
                  throw new Error(
                    `Program ${r.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`
                  );
                }
                let Z;
                if (E) {
                  let me = 0,
                    Fe = [];
                  E.forEach((lt) => {
                    let Mt = typeof lt.data == "number" ? [lt.data] : lt.data;
                    if (Mt.length === 0) return;
                    let Dt = lt.type === 10 ? 2 : 4,
                      Ut,
                      fr;
                    lt.type === 10
                      ? ((fr =
                          Mt.length > 4
                            ? 16
                            : Mt.length > 2
                            ? 8
                            : Mt.length * Dt),
                        (Ut = Mt.length > 4 ? 16 : Dt * Mt.length))
                      : ((fr = Mt.length <= 2 ? Mt.length * Dt : 16),
                        (Ut = 16)),
                      (me = Math.ceil(me / fr) * fr),
                      Fe.push(me);
                    let br = lt.type === 10 ? 8 : 4;
                    me +=
                      Mt.length > 4
                        ? Math.ceil(Mt.length / br) * Ut
                        : Mt.length * Dt;
                  });
                  let Ce = 16;
                  me = Math.ceil(me / Ce) * Ce;
                  let ze = new ArrayBuffer(me);
                  E.forEach((lt, Mt) => {
                    let Dt = Fe[Mt],
                      Ut = typeof lt.data == "number" ? [lt.data] : lt.data;
                    if (lt.type === 6)
                      new Int32Array(ze, Dt, Ut.length).set(Ut);
                    else if (lt.type === 12)
                      new Uint32Array(ze, Dt, Ut.length).set(Ut);
                    else if (lt.type === 10)
                      new Uint16Array(ze, Dt, Ut.length).set(Ut);
                    else if (lt.type === 1)
                      new Float32Array(ze, Dt, Ut.length).set(Ut);
                    else
                      throw new Error(
                        `Unsupported uniform type: ${vi(lt.type)}`
                      );
                  });
                  let dt = this.gpuDataManager.create(
                    me,
                    GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM
                  );
                  this.device.queue.writeBuffer(dt.buffer, 0, ze, 0, me),
                    this.gpuDataManager.release(dt.id),
                    (Z = { offset: 0, size: me, buffer: dt.buffer });
                }
                let re = this.programManager.normalizeDispatchGroupSize(k),
                  le = re[1] === 1 && re[2] === 1,
                  we = Fy(r, i, le),
                  be = this.programManager.getArtifact(we);
                if (
                  (be ||
                    ((be = this.programManager.build(r, re)),
                    this.programManager.setArtifact(we, be),
                    Kr(
                      "info",
                      () => `[artifact] key: ${we}, programName: ${r.name}`
                    )),
                  E && be.uniformVariablesInfo)
                ) {
                  if (E.length !== be.uniformVariablesInfo.length)
                    throw new Error(
                      `Uniform variables count mismatch: expect ${be.uniformVariablesInfo.length}, got ${E.length} in program "${be.programInfo.name}".`
                    );
                  for (let me = 0; me < E.length; me++) {
                    let Fe = E[me],
                      Ce = Fe.type,
                      ze = typeof Fe.data == "number" ? 1 : Fe.data.length,
                      [dt, lt] = be.uniformVariablesInfo[me];
                    if (Ce !== dt || ze !== lt)
                      throw new Error(
                        `Uniform variable ${me} mismatch: expect type ${dt} with size ${lt}, got type ${Ce} with size ${ze} in program "${be.programInfo.name}".`
                      );
                  }
                }
                if (
                  (Kr(
                    "info",
                    () =>
                      `[ProgramManager] run "${r.name}" (key=${we}) with ${re[0]}x${re[1]}x${re[2]}`
                  ),
                  this.queryType !== "none" ||
                    this.sessionStatus === "capturing")
                ) {
                  let me = {
                    kernelId: this.currentKernelId,
                    programName: be.programInfo.name,
                    inputTensorViews: i,
                    outputTensorViews: H
                  };
                  this.pendingKernels.push(me),
                    this.sessionStatus === "capturing" &&
                      this.capturedPendingKernels
                        .get(this.currentSessionId)
                        .push(me);
                }
                return this.programManager.run(be, c, w, re, Z), A(r.name), H;
              }
              upload(r, i) {
                this.gpuDataManager.upload(r, i);
              }
              memcpy(r, i) {
                this.gpuDataManager.memcpy(r, i);
              }
              async download(r, i) {
                await this.gpuDataManager.download(r, i);
              }
              alloc(r) {
                return this.gpuDataManager.create(r).id;
              }
              free(r) {
                return this.gpuDataManager.release(r);
              }
              createKernel(r, i, s, u) {
                let d = $y.get(r);
                if (!d) throw new Error(`kernel not implemented: ${r}`);
                let p = {
                  kernelType: r,
                  kernelName: u,
                  kernelEntry: d[0],
                  attributes: [d[1], s]
                };
                this.kernels.set(i, p);
              }
              releaseKernel(r) {
                let i = this.kernelPersistentData.get(r);
                if (i) {
                  for (let s of i) this.gpuDataManager.release(s.id);
                  this.kernelPersistentData.delete(r);
                }
                this.kernelCustomData.delete(r), this.kernels.delete(r);
              }
              computeKernel(r, i, s) {
                let u = this.kernels.get(r);
                if (!u) throw new Error(`kernel not created: ${r}`);
                let d = u.kernelType,
                  p = u.kernelName,
                  c = u.kernelEntry,
                  b = u.attributes;
                if (this.currentKernelId !== null)
                  throw new Error(
                    `kernel "[${d}] ${p}" is not allowed to be called recursively`
                  );
                (this.currentKernelId = r),
                  b[0] && ((b[1] = b[0](b[1])), (b[0] = void 0)),
                  Kr(
                    "info",
                    () => `[WebGPU] Start to run kernel "[${d}] ${p}"...`
                  );
                let k = this.env.debug;
                this.temporaryData = [];
                try {
                  return (
                    k && this.device.pushErrorScope("validation"), c(i, b[1]), 0
                  );
                } catch (E) {
                  return (
                    s.push(
                      Promise.resolve(
                        `[WebGPU] Kernel "[${d}] ${p}" failed. ${E}`
                      )
                    ),
                    1
                  );
                } finally {
                  k &&
                    s.push(
                      this.device
                        .popErrorScope()
                        .then((E) =>
                          E
                            ? `GPU validation error for kernel "[${d}] ${p}": ${E.message}`
                            : null
                        )
                    );
                  for (let E of this.temporaryData)
                    this.gpuDataManager.release(E.id);
                  (this.temporaryData = []), (this.currentKernelId = null);
                }
              }
              registerBuffer(r, i, s, u) {
                let d = this.sessionExternalDataMapping.get(r);
                d ||
                  ((d = new Map()), this.sessionExternalDataMapping.set(r, d));
                let p = d.get(i),
                  c = this.gpuDataManager.registerExternalBuffer(
                    s,
                    u,
                    p == null ? void 0 : p[1]
                  );
                return d.set(i, [c, s]), c;
              }
              unregisterBuffers(r) {
                let i = this.sessionExternalDataMapping.get(r);
                i &&
                  (i.forEach((s) =>
                    this.gpuDataManager.unregisterExternalBuffer(s[1])
                  ),
                  this.sessionExternalDataMapping.delete(r));
              }
              getBuffer(r) {
                let i = this.gpuDataManager.get(r);
                if (!i) throw new Error(`no GPU data for buffer: ${r}`);
                return i.buffer;
              }
              createDownloader(r, i, s) {
                return async () => {
                  let u = await Ct(this, r, i);
                  return Ue(u.buffer, s);
                };
              }
              writeTimestamp(r) {
                this.queryType === "inside-passes" &&
                  this.computePassEncoder.writeTimestamp(this.querySet, r);
              }
              setQueryType() {
                var r;
                (this.queryType = "none"),
                  (((r = this.env.webgpu.profiling) == null
                    ? void 0
                    : r.mode) === "default" ||
                    (typeof this.env.trace > "u"
                      ? this.env.wasm.trace
                      : this.env.trace)) &&
                    (this.device.features.has(
                      "chromium-experimental-timestamp-query-inside-passes"
                    )
                      ? (this.queryType = "inside-passes")
                      : this.device.features.has("timestamp-query") &&
                        (this.queryType = "at-passes"),
                    this.queryType !== "none" &&
                      typeof this.querySet > "u" &&
                      ((this.querySet = this.device.createQuerySet({
                        type: "timestamp",
                        count: this.maxDispatchNumber * 2
                      })),
                      (this.queryResolveBuffer = this.device.createBuffer({
                        size: this.maxDispatchNumber * 2 * 8,
                        usage:
                          GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE
                      }))));
              }
              captureBegin() {
                Kr("info", "captureBegin"),
                  this.capturedCommandList.get(this.currentSessionId) ||
                    this.capturedCommandList.set(this.currentSessionId, []),
                  this.capturedPendingKernels.get(this.currentSessionId) ||
                    this.capturedPendingKernels.set(this.currentSessionId, []),
                  this.flush(),
                  (this.sessionStatus = "capturing");
              }
              captureEnd() {
                Kr("info", "captureEnd"),
                  this.flush(),
                  (this.sessionStatus = "default");
              }
              replay() {
                Kr("info", "replay"), (this.sessionStatus = "replaying");
                let r = this.capturedCommandList.get(this.currentSessionId),
                  i = this.capturedPendingKernels.get(this.currentSessionId),
                  s = r.length;
                this.pendingKernels = [];
                for (let u = 0; u < s; u++) {
                  let d = this.getComputePassEncoder(),
                    p = r[u];
                  this.writeTimestamp(this.pendingDispatchNumber * 2),
                    d.setPipeline(p.computePipeline),
                    d.setBindGroup(0, p.bindGroup),
                    d.dispatchWorkgroups(...p.dispatchGroup),
                    this.writeTimestamp(this.pendingDispatchNumber * 2 + 1),
                    this.pendingDispatchNumber++,
                    this.queryType !== "none" && this.pendingKernels.push(i[u]),
                    (this.pendingDispatchNumber >= this.maxDispatchNumber ||
                      this.queryType === "at-passes") &&
                      this.endComputePass(),
                    this.pendingDispatchNumber >= this.maxDispatchNumber &&
                      this.flush();
                }
                this.flush(), (this.sessionStatus = "default");
              }
              onReleaseSession(r) {
                this.unregisterBuffers(r),
                  this.capturedCommandList.has(r) &&
                    this.capturedCommandList.delete(r),
                  this.capturedPendingKernels.has(r) &&
                    this.capturedPendingKernels.delete(r),
                  this.gpuDataManager.onReleaseSession(r);
              }
              onRunStart(r) {
                (this.currentSessionId = r), this.setQueryType();
              }
            });
        }),
        Dy = {};
      g(Dy, { init: () => By });
      var qp,
        Ly,
        By,
        zx = m(() => {
          Yt(),
            Fx(),
            qn(),
            Zt(),
            (qp = class vx {
              constructor(i, s, u, d) {
                (this.module = i),
                  (this.dataType = s),
                  (this.data = u),
                  (this.dims = d);
              }
              getUint16Array() {
                if (this.dataType !== 10 && this.dataType !== 4)
                  throw new Error("Invalid data type");
                let i = Ze.size(this.dims);
                return i === 0
                  ? new Uint16Array()
                  : new Uint16Array(this.module.HEAP8.buffer, this.data, i);
              }
              getFloat32Array() {
                if (this.dataType !== 1) throw new Error("Invalid data type");
                let i = Ze.size(this.dims);
                return i === 0
                  ? new Float32Array()
                  : new Float32Array(this.module.HEAP8.buffer, this.data, i);
              }
              getBigInt64Array() {
                if (this.dataType !== 7) throw new Error("Invalid data type");
                let i = Ze.size(this.dims);
                return i === 0
                  ? new BigInt64Array()
                  : new BigInt64Array(this.module.HEAP8.buffer, this.data, i);
              }
              getInt32Array() {
                if (this.dataType !== 6) throw new Error("Invalid data type");
                let i = Ze.size(this.dims);
                return i === 0
                  ? new Int32Array()
                  : new Int32Array(this.module.HEAP8.buffer, this.data, i);
              }
              reshape(i) {
                if (Ze.size(i) !== Ze.size(this.dims))
                  throw new Error("Invalid new shape");
                return new vx(this.module, this.dataType, this.data, i);
              }
            }),
            (Ly = class {
              constructor(r, i, s) {
                (this.module = r),
                  (this.backend = i),
                  (this.customDataOffset = 0),
                  (this.customDataSize = 0),
                  (this.adapterInfo = i.adapterInfo);
                let u = r.HEAPU32,
                  d = s >>> 2;
                this.opKernelContext = u[d++];
                let p = u[d++];
                (this.outputCount = u[d++]),
                  (this.customDataOffset = u[d++]),
                  (this.customDataSize = u[d++]);
                let c = [];
                for (let b = 0; b < p; b++) {
                  let k = u[d++],
                    E = u[d++],
                    q = u[d++],
                    H = [];
                  for (let w = 0; w < q; w++) H.push(u[d++]);
                  c.push(new qp(r, k, E, H));
                }
                this.inputs = c;
              }
              get kernelCustomData() {
                return this.backend.currentKernelCustomData;
              }
              get customDataBuffer() {
                return this.module.HEAPU8.subarray(
                  this.customDataOffset,
                  this.customDataOffset + this.customDataSize
                );
              }
              getMaxComputeWorkgroupSizes() {
                return [
                  this.backend.device.limits.maxComputeWorkgroupSizeX,
                  this.backend.device.limits.maxComputeWorkgroupSizeY,
                  this.backend.device.limits.maxComputeWorkgroupSizeZ
                ];
              }
              getMaxComputeWorkgroupStoragesize() {
                return this.backend.device.limits
                  .maxComputeWorkgroupStorageSize;
              }
              compute(r, i) {
                var c;
                let s =
                    ((c = i == null ? void 0 : i.inputs) == null
                      ? void 0
                      : c.map((b) =>
                          typeof b == "number" ? this.inputs[b] : b
                        )) ?? this.inputs,
                  u = (i == null ? void 0 : i.outputs) ?? [],
                  d = (b, k, E) => new qp(this.module, k, this.output(b, E), E),
                  p = (b, k) => {
                    let E = Hi(b, k);
                    if (!E) throw new Error(`Unsupported data type: ${b}`);
                    let q =
                      E > 0 ? this.backend.gpuDataManager.create(E).id : 0;
                    return new qp(this.module, b, q, k);
                  };
                return this.backend.run(r, s, u, d, p, this.outputCount);
              }
              output(r, i) {
                let s = this.module.stackSave();
                try {
                  let u = this.module.stackAlloc((1 + i.length) * 4),
                    d = u >> 2;
                  this.module.HEAPU32[d++] = i.length;
                  for (let p = 0; p < i.length; p++)
                    this.module.HEAPU32[d++] = i[p];
                  return this.module._JsepOutput(this.opKernelContext, r, u);
                } catch (u) {
                  throw new Error(
                    `Failed to generate kernel's output[${r}] with dims [${i}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${u}`
                  );
                } finally {
                  this.module.stackRestore(s);
                }
              }
            }),
            (By = async (r, i, s, u) => {
              let d = i.jsepInit;
              if (!d)
                throw new Error(
                  "Failed to initialize JSEP. The WebAssembly module is not built with JSEP support."
                );
              if (r === "webgpu") {
                let p = new Oy();
                await p.initialize(s, u),
                  d("webgpu", [
                    p,
                    (c) => p.alloc(c),
                    (c) => p.free(c),
                    (c, b, k, E = !1) => {
                      if (E)
                        Kr(
                          "verbose",
                          () =>
                            `[WebGPU] jsepCopyGpuToGpu: src=${c}, dst=${b}, size=${k}`
                        ),
                          p.memcpy(c, b);
                      else {
                        Kr(
                          "verbose",
                          () =>
                            `[WebGPU] jsepCopyCpuToGpu: dataOffset=${c}, gpuDataId=${b}, size=${k}`
                        );
                        let q = i.HEAPU8.subarray(c >>> 0, (c >>> 0) + k);
                        p.upload(b, q);
                      }
                    },
                    async (c, b, k) => {
                      Kr(
                        "verbose",
                        () =>
                          `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${c}, dataOffset=${b}, size=${k}`
                      ),
                        await p.download(c, () =>
                          i.HEAPU8.subarray(b >>> 0, (b >>> 0) + k)
                        );
                    },
                    (c, b, k) =>
                      p.createKernel(
                        c,
                        b,
                        k,
                        i.UTF8ToString(i._JsepGetNodeName(b))
                      ),
                    (c) => p.releaseKernel(c),
                    (c, b, k, E) => {
                      Kr(
                        "verbose",
                        () =>
                          `[WebGPU] jsepRun: sessionHandle=${k}, kernel=${c}, contextDataOffset=${b}`
                      );
                      let q = new Ly(i, p, b);
                      return p.computeKernel(c, q, E);
                    },
                    () => p.captureBegin(),
                    () => p.captureEnd(),
                    () => p.replay()
                  ]);
              } else d("webnn");
            });
        }),
        Ry,
        Rm,
        Nm,
        rs,
        Ny,
        Kp,
        jm,
        Um,
        Vm,
        Wm,
        Gm,
        Hm,
        jy = m(() => {
          $s(),
            As(),
            Yt(),
            Tn(),
            Wi(),
            Ho(),
            (Ry = (r, i) => {
              Qr()._OrtInit(r, i) !== 0 && Nr("Can't initialize onnxruntime.");
            }),
            (Rm = async (r) => {
              Ry(r.wasm.numThreads, ro(r.logLevel));
            }),
            (Nm = async (r, i) => {
              {
                let s = (zx(), v(Dy)).init;
                if (i === "webgpu") {
                  if (typeof navigator > "u" || !navigator.gpu)
                    throw new Error(
                      "WebGPU is not supported in current environment"
                    );
                  let u = r.webgpu.adapter;
                  if (u) {
                    if (
                      typeof u.limits != "object" ||
                      typeof u.features != "object" ||
                      typeof u.requestDevice != "function"
                    )
                      throw new Error(
                        "Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object."
                      );
                  } else {
                    let d = r.webgpu.powerPreference;
                    if (
                      d !== void 0 &&
                      d !== "low-power" &&
                      d !== "high-performance"
                    )
                      throw new Error(
                        `Invalid powerPreference setting: "${d}"`
                      );
                    let p = r.webgpu.forceFallbackAdapter;
                    if (p !== void 0 && typeof p != "boolean")
                      throw new Error(
                        `Invalid forceFallbackAdapter setting: "${p}"`
                      );
                    if (
                      ((u = await navigator.gpu.requestAdapter({
                        powerPreference: d,
                        forceFallbackAdapter: p
                      })),
                      !u)
                    )
                      throw new Error(
                        'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
                      );
                  }
                  await s("webgpu", Qr(), r, u);
                }
                if (i === "webnn") {
                  if (typeof navigator > "u" || !navigator.ml)
                    throw new Error(
                      "WebNN is not supported in current environment"
                    );
                  await s("webnn", Qr(), r);
                }
              }
            }),
            (rs = new Map()),
            (Ny = (r) => {
              let i = Qr(),
                s = i.stackSave();
              try {
                let u = i.stackAlloc(8);
                return (
                  i._OrtGetInputOutputCount(r, u, u + 4) !== 0 &&
                    Nr("Can't get session input/output count."),
                  [i.HEAP32[u / 4], i.HEAP32[u / 4 + 1]]
                );
              } finally {
                i.stackRestore(s);
              }
            }),
            (Kp = (r) => {
              let i = Qr(),
                s = i._malloc(r.byteLength);
              if (s === 0)
                throw new Error(
                  `Can't create a session. failed to allocate a buffer of size ${r.byteLength}.`
                );
              return i.HEAPU8.set(r, s), [s, r.byteLength];
            }),
            (jm = async (r, i) => {
              var H, w;
              let s,
                u,
                d = Qr();
              Array.isArray(r)
                ? ([s, u] = r)
                : r.buffer === d.HEAPU8.buffer
                ? ([s, u] = [r.byteOffset, r.byteLength])
                : ([s, u] = Kp(r));
              let p = 0,
                c = 0,
                b = 0,
                k = [],
                E = [],
                q = [];
              try {
                if (
                  (([c, k] = Gi(i)),
                  (i == null ? void 0 : i.externalData) && d.mountExternalData)
                ) {
                  let Ce = [];
                  for (let ze of i.externalData) {
                    let dt = typeof ze == "string" ? ze : ze.path;
                    Ce.push(
                      no(typeof ze == "string" ? ze : ze.data).then((lt) => {
                        d.mountExternalData(dt, lt);
                      })
                    );
                  }
                  await Promise.all(Ce);
                }
                for (let Ce of (i == null ? void 0 : i.executionProviders) ??
                  [])
                  if ((typeof Ce == "string" ? Ce : Ce.name) === "webnn") {
                    if (d.currentContext)
                      throw new Error(
                        "WebNN execution provider is already set."
                      );
                    if (typeof Ce != "string") {
                      let ze = Ce,
                        dt = ze == null ? void 0 : ze.context,
                        lt = ze == null ? void 0 : ze.gpuDevice,
                        Mt = ze == null ? void 0 : ze.deviceType,
                        Dt = ze == null ? void 0 : ze.numThreads,
                        Ut = ze == null ? void 0 : ze.powerPreference;
                      dt
                        ? (d.currentContext = dt)
                        : lt
                        ? (d.currentContext = await navigator.ml.createContext(
                            lt
                          ))
                        : (d.currentContext = await navigator.ml.createContext({
                            deviceType: Mt,
                            numThreads: Dt,
                            powerPreference: Ut
                          }));
                    } else
                      d.currentContext = await navigator.ml.createContext();
                    break;
                  }
                (p = await d._OrtCreateSession(s, u, c)),
                  p === 0 && Nr("Can't create a session."),
                  d.currentContext && (d.currentContext = void 0);
                let [Z, re] = Ny(p),
                  le = !!(i != null && i.enableGraphCapture),
                  we = [],
                  be = [],
                  me = [];
                for (let Ce = 0; Ce < Z; Ce++) {
                  let ze = d._OrtGetInputName(p, Ce);
                  ze === 0 && Nr("Can't get an input name."),
                    E.push(ze),
                    we.push(d.UTF8ToString(ze));
                }
                for (let Ce = 0; Ce < re; Ce++) {
                  let ze = d._OrtGetOutputName(p, Ce);
                  ze === 0 && Nr("Can't get an output name."), q.push(ze);
                  let dt = d.UTF8ToString(ze);
                  be.push(dt);
                  {
                    if (
                      le &&
                      (i == null ? void 0 : i.preferredOutputLocation) ===
                        void 0
                    ) {
                      me.push("gpu-buffer");
                      continue;
                    }
                    let lt =
                      typeof (i == null ? void 0 : i.preferredOutputLocation) ==
                      "string"
                        ? i.preferredOutputLocation
                        : ((H =
                            i == null ? void 0 : i.preferredOutputLocation) ==
                          null
                            ? void 0
                            : H[dt]) ?? "cpu";
                    if (
                      lt !== "cpu" &&
                      lt !== "cpu-pinned" &&
                      lt !== "gpu-buffer"
                    )
                      throw new Error(
                        `Not supported preferred output location: ${lt}.`
                      );
                    if (le && lt !== "gpu-buffer")
                      throw new Error(
                        `Not supported preferred output location: ${lt}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`
                      );
                    me.push(lt);
                  }
                }
                let Fe = null;
                return (
                  me.some((Ce) => Ce === "gpu-buffer") &&
                    ((b = d._OrtCreateBinding(p)),
                    b === 0 && Nr("Can't create IO binding."),
                    (Fe = {
                      handle: b,
                      outputPreferredLocations: me,
                      outputPreferredLocationsEncoded: me.map((Ce) => wo(Ce))
                    })),
                  rs.set(p, [p, E, q, Fe, le, !1]),
                  [p, we, be]
                );
              } catch (Z) {
                throw (
                  (E.forEach((re) => d._OrtFree(re)),
                  q.forEach((re) => d._OrtFree(re)),
                  b !== 0 && d._OrtReleaseBinding(b),
                  p !== 0 && d._OrtReleaseSession(p),
                  Z)
                );
              } finally {
                d._free(s),
                  c !== 0 && d._OrtReleaseSessionOptions(c),
                  k.forEach((Z) => d._free(Z)),
                  (w = d.unmountExternalData) == null || w.call(d);
              }
            }),
            (Um = (r) => {
              var k;
              let i = Qr(),
                s = rs.get(r);
              if (!s)
                throw new Error(
                  `cannot release session. invalid session id: ${r}`
                );
              let [u, d, p, c, b] = s;
              c &&
                (b && i._OrtClearBoundOutputs(c.handle),
                i._OrtReleaseBinding(c.handle)),
                (k = i.jsepOnReleaseSession) == null || k.call(i, r),
                d.forEach((E) => i._OrtFree(E)),
                p.forEach((E) => i._OrtFree(E)),
                i._OrtReleaseSession(u),
                rs.delete(r);
            }),
            (Vm = (r, i, s, u, d, p = !1) => {
              if (!r) {
                i.push(0);
                return;
              }
              let c = Qr(),
                b = r[0],
                k = r[1],
                E = r[3],
                q,
                H;
              if (b === "string" && E === "gpu-buffer")
                throw new Error("String tensor is not supported on GPU.");
              if (p && E !== "gpu-buffer")
                throw new Error(
                  `External buffer must be provided for input/output index ${d} when enableGraphCapture is true.`
                );
              if (E === "gpu-buffer") {
                let re = r[2].gpuBuffer;
                H = Hi(_o(b), k);
                let le = c.jsepRegisterBuffer;
                if (!le)
                  throw new Error(
                    'Tensor location "gpu-buffer" is not supported without using WebGPU.'
                  );
                q = le(u, d, re, H);
              } else {
                let re = r[2];
                if (Array.isArray(re)) {
                  (H = 4 * re.length), (q = c._malloc(H)), s.push(q);
                  let le = q / 4;
                  for (let we = 0; we < re.length; we++) {
                    if (typeof re[we] != "string")
                      throw new TypeError(
                        `tensor data at index ${we} is not a string`
                      );
                    c.HEAPU32[le++] = Yr(re[we], s);
                  }
                } else
                  (H = re.byteLength),
                    (q = c._malloc(H)),
                    s.push(q),
                    c.HEAPU8.set(
                      new Uint8Array(re.buffer, re.byteOffset, H),
                      q
                    );
              }
              let w = c.stackSave(),
                Z = c.stackAlloc(4 * k.length);
              try {
                let re = Z / 4;
                k.forEach((we) => (c.HEAP32[re++] = we));
                let le = c._OrtCreateTensor(_o(b), q, H, Z, k.length, wo(E));
                le === 0 &&
                  Nr(
                    `Can't create tensor for input/output. session=${u}, index=${d}.`
                  ),
                  i.push(le);
              } finally {
                c.stackRestore(w);
              }
            }),
            (Wm = async (r, i, s, u, d, p) => {
              var Ut, fr;
              let c = Qr(),
                b = rs.get(r);
              if (!b)
                throw new Error(
                  `cannot run inference. invalid session id: ${r}`
                );
              let k = b[0],
                E = b[1],
                q = b[2],
                H = b[3],
                w = b[4],
                Z = b[5],
                re = i.length,
                le = u.length,
                we = 0,
                be = [],
                me = [],
                Fe = [],
                Ce = [],
                ze = c.stackSave(),
                dt = c.stackAlloc(re * 4),
                lt = c.stackAlloc(re * 4),
                Mt = c.stackAlloc(le * 4),
                Dt = c.stackAlloc(le * 4);
              try {
                [we, be] = Ii(p);
                for (let tr = 0; tr < re; tr++) Vm(s[tr], me, Ce, r, i[tr], w);
                for (let tr = 0; tr < le; tr++)
                  Vm(d[tr], Fe, Ce, r, re + u[tr], w);
                let br = dt / 4,
                  rr = lt / 4,
                  Wr = Mt / 4,
                  Jr = Dt / 4;
                for (let tr = 0; tr < re; tr++)
                  (c.HEAPU32[br++] = me[tr]), (c.HEAPU32[rr++] = E[i[tr]]);
                for (let tr = 0; tr < le; tr++)
                  (c.HEAPU32[Wr++] = Fe[tr]), (c.HEAPU32[Jr++] = q[u[tr]]);
                if (H && !Z) {
                  let {
                    handle: tr,
                    outputPreferredLocations: _r,
                    outputPreferredLocationsEncoded: zr
                  } = H;
                  if (E.length !== re)
                    throw new Error(
                      `input count from feeds (${re}) is expected to be always equal to model's input count (${E.length}).`
                    );
                  for (let ut = 0; ut < re; ut++) {
                    let At = i[ut];
                    (await c._OrtBindInput(tr, E[At], me[ut])) !== 0 &&
                      Nr(`Can't bind input[${ut}] for session=${r}.`);
                  }
                  for (let ut = 0; ut < le; ut++) {
                    let At = u[ut];
                    (Ut = d[ut]) != null && Ut[3]
                      ? c._OrtBindOutput(tr, q[At], Fe[ut], 0) !== 0 &&
                        Nr(
                          `Can't bind pre-allocated output[${ut}] for session=${r}.`
                        )
                      : c._OrtBindOutput(tr, q[At], 0, zr[At]) !== 0 &&
                        Nr(
                          `Can't bind output[${ut}] to ${_r[ut]} for session=${r}.`
                        );
                  }
                  rs.set(r, [k, E, q, H, w, !0]);
                }
                (fr = c.jsepOnRunStart) == null || fr.call(c, k);
                let Sr;
                H
                  ? (Sr = await c._OrtRunWithBinding(k, H.handle, le, Mt, we))
                  : (Sr = await c._OrtRun(k, lt, dt, re, Dt, le, Mt, we)),
                  Sr !== 0 && Nr("failed to call OrtRun().");
                let Hr = [];
                for (let tr = 0; tr < le; tr++) {
                  let _r = c.HEAPU32[Mt / 4 + tr];
                  if (_r === Fe[tr]) {
                    Hr.push(d[tr]);
                    continue;
                  }
                  let zr = c.stackSave(),
                    ut = c.stackAlloc(4 * 4),
                    At = !1,
                    sr,
                    Gr = 0;
                  try {
                    c._OrtGetTensorData(_r, ut, ut + 4, ut + 8, ut + 12) !==
                      0 &&
                      Nr(`Can't access output tensor data on index ${tr}.`);
                    let gn = ut / 4,
                      Cn = c.HEAPU32[gn++];
                    Gr = c.HEAPU32[gn++];
                    let is = c.HEAPU32[gn++],
                      Yp = c.HEAPU32[gn++],
                      Ti = [];
                    for (let Vn = 0; Vn < Yp; Vn++)
                      Ti.push(c.HEAPU32[is / 4 + Vn]);
                    c._OrtFree(is);
                    let Un = Ti.reduce((Vn, ii) => Vn * ii, 1);
                    sr = vi(Cn);
                    let Mf =
                      H == null ? void 0 : H.outputPreferredLocations[u[tr]];
                    if (sr === "string") {
                      if (Mf === "gpu-buffer")
                        throw new Error(
                          "String tensor is not supported on GPU."
                        );
                      let Vn = [],
                        ii = Gr / 4;
                      for (let Oi = 0; Oi < Un; Oi++) {
                        let os = c.HEAPU32[ii++],
                          Zp = Oi === Un - 1 ? void 0 : c.HEAPU32[ii] - os;
                        Vn.push(c.UTF8ToString(os, Zp));
                      }
                      Hr.push([sr, Ti, Vn, "cpu"]);
                    } else if (Mf === "gpu-buffer" && Un > 0) {
                      let Vn = c.jsepGetBuffer;
                      if (!Vn)
                        throw new Error(
                          'preferredLocation "gpu-buffer" is not supported without using WebGPU.'
                        );
                      let ii = Vn(Gr),
                        Oi = Hi(Cn, Un);
                      if (Oi === void 0 || !yo(sr))
                        throw new Error(`Unsupported data type: ${sr}`);
                      (At = !0),
                        Hr.push([
                          sr,
                          Ti,
                          {
                            gpuBuffer: ii,
                            download: c.jsepCreateDownloader(ii, Oi, sr),
                            dispose: () => {
                              c._OrtReleaseTensor(_r);
                            }
                          },
                          "gpu-buffer"
                        ]);
                    } else {
                      let Vn = Fi(sr),
                        ii = new Vn(Un);
                      new Uint8Array(
                        ii.buffer,
                        ii.byteOffset,
                        ii.byteLength
                      ).set(c.HEAPU8.subarray(Gr, Gr + ii.byteLength)),
                        Hr.push([sr, Ti, ii, "cpu"]);
                    }
                  } finally {
                    c.stackRestore(zr),
                      sr === "string" && Gr && c._free(Gr),
                      At || c._OrtReleaseTensor(_r);
                  }
                }
                return (
                  H &&
                    !w &&
                    (c._OrtClearBoundOutputs(H.handle),
                    rs.set(r, [k, E, q, H, w, !1])),
                  Hr
                );
              } finally {
                c.stackRestore(ze),
                  me.forEach((br) => c._OrtReleaseTensor(br)),
                  Fe.forEach((br) => c._OrtReleaseTensor(br)),
                  Ce.forEach((br) => c._free(br)),
                  we !== 0 && c._OrtReleaseRunOptions(we),
                  be.forEach((br) => c._free(br));
              }
            }),
            (Gm = (r) => {
              let i = Qr(),
                s = rs.get(r);
              if (!s) throw new Error("invalid session id");
              let u = s[0],
                d = i._OrtEndProfiling(u);
              d === 0 && Nr("Can't get an profile file name."), i._OrtFree(d);
            }),
            (Hm = (r) => {
              let i = [];
              for (let s of r) {
                let u = s[2];
                !Array.isArray(u) && "buffer" in u && i.push(u.buffer);
              }
              return i;
            });
        }),
        ns,
        di,
        Nl,
        bf,
        xf,
        Qp,
        qm,
        Xp,
        Ys,
        Zs,
        Uy,
        Vy,
        Wy,
        Gy,
        Hy,
        qy,
        Ky,
        Qy,
        Xy = m(() => {
          bt(),
            jy(),
            Tn(),
            ar(),
            (ns = () => !!N.wasm.proxy && typeof document < "u"),
            (Nl = !1),
            (bf = !1),
            (xf = !1),
            (Xp = new Map()),
            (Ys = (r, i) => {
              let s = Xp.get(r);
              s ? s.push(i) : Xp.set(r, [i]);
            }),
            (Zs = () => {
              if (Nl || !bf || xf || !di) throw new Error("worker not ready");
            }),
            (Uy = (r) => {
              switch (r.data.type) {
                case "init-wasm":
                  (Nl = !1),
                    r.data.err
                      ? ((xf = !0), qm[1](r.data.err))
                      : ((bf = !0), qm[0]()),
                    Qp && (URL.revokeObjectURL(Qp), (Qp = void 0));
                  break;
                case "init-ep":
                case "copy-from":
                case "create":
                case "release":
                case "run":
                case "end-profiling": {
                  let i = Xp.get(r.data.type);
                  r.data.err
                    ? i.shift()[1](r.data.err)
                    : i.shift()[0](r.data.out);
                  break;
                }
              }
            }),
            (Vy = async () => {
              if (!bf) {
                if (Nl)
                  throw new Error("multiple calls to 'initWasm()' detected.");
                if (xf)
                  throw new Error("previous call to 'initWasm()' failed.");
                if (((Nl = !0), ns()))
                  return new Promise((r, i) => {
                    di == null || di.terminate(),
                      Wt().then(([s, u]) => {
                        try {
                          (di = u),
                            (di.onerror = (p) => i(p)),
                            (di.onmessage = Uy),
                            (qm = [r, i]);
                          let d = { type: "init-wasm", in: N };
                          di.postMessage(d), (Qp = s);
                        } catch (d) {
                          i(d);
                        }
                      }, i);
                  });
                try {
                  await Ai(N.wasm), await Rm(N), (bf = !0);
                } catch (r) {
                  throw ((xf = !0), r);
                } finally {
                  Nl = !1;
                }
              }
            }),
            (Wy = async (r) => {
              if (ns())
                return (
                  Zs(),
                  new Promise((i, s) => {
                    Ys("init-ep", [i, s]);
                    let u = { type: "init-ep", in: { epName: r, env: N } };
                    di.postMessage(u);
                  })
                );
              await Nm(N, r);
            }),
            (Gy = async (r) =>
              ns()
                ? (Zs(),
                  new Promise((i, s) => {
                    Ys("copy-from", [i, s]);
                    let u = { type: "copy-from", in: { buffer: r } };
                    di.postMessage(u, [r.buffer]);
                  }))
                : Kp(r)),
            (Hy = async (r, i) => {
              if (ns()) {
                if (i != null && i.preferredOutputLocation)
                  throw new Error(
                    'session option "preferredOutputLocation" is not supported for proxy.'
                  );
                return (
                  Zs(),
                  new Promise((s, u) => {
                    Ys("create", [s, u]);
                    let d = {
                        type: "create",
                        in: { model: r, options: { ...i } }
                      },
                      p = [];
                    r instanceof Uint8Array && p.push(r.buffer),
                      di.postMessage(d, p);
                  })
                );
              } else return jm(r, i);
            }),
            (qy = async (r) => {
              if (ns())
                return (
                  Zs(),
                  new Promise((i, s) => {
                    Ys("release", [i, s]);
                    let u = { type: "release", in: r };
                    di.postMessage(u);
                  })
                );
              Um(r);
            }),
            (Ky = async (r, i, s, u, d, p) => {
              if (ns()) {
                if (s.some((c) => c[3] !== "cpu"))
                  throw new Error(
                    "input tensor on GPU is not supported for proxy."
                  );
                if (d.some((c) => c))
                  throw new Error(
                    "pre-allocated output tensor is not supported for proxy."
                  );
                return (
                  Zs(),
                  new Promise((c, b) => {
                    Ys("run", [c, b]);
                    let k = s,
                      E = {
                        type: "run",
                        in: {
                          sessionId: r,
                          inputIndices: i,
                          inputs: k,
                          outputIndices: u,
                          options: p
                        }
                      };
                    di.postMessage(E, Hm(k));
                  })
                );
              } else return Wm(r, i, s, u, d, p);
            }),
            (Qy = async (r) => {
              if (ns())
                return (
                  Zs(),
                  new Promise((i, s) => {
                    Ys("end-profiling", [i, s]);
                    let u = { type: "end-profiling", in: r };
                    di.postMessage(u);
                  })
                );
              Gm(r);
            });
        }),
        Km,
        Yy,
        Zy,
        Ox = m(() => {
          bt(),
            Xy(),
            Yt(),
            Ke(),
            Ho(),
            (Km = (r, i) => {
              switch (r.location) {
                case "cpu":
                  return [r.type, r.dims, r.data, "cpu"];
                case "gpu-buffer":
                  return [
                    r.type,
                    r.dims,
                    { gpuBuffer: r.gpuBuffer },
                    "gpu-buffer"
                  ];
                default:
                  throw new Error(
                    `invalid data location: ${r.location} for ${i()}`
                  );
              }
            }),
            (Yy = (r) => {
              switch (r[3]) {
                case "cpu":
                  return new Ge(r[0], r[2], r[1]);
                case "gpu-buffer": {
                  let i = r[0];
                  if (!yo(i))
                    throw new Error(
                      `not supported data type: ${i} for deserializing GPU tensor`
                    );
                  let { gpuBuffer: s, download: u, dispose: d } = r[2];
                  return Ge.fromGpuBuffer(s, {
                    dataType: i,
                    dims: r[1],
                    download: u,
                    dispose: d
                  });
                }
                default:
                  throw new Error(`invalid data location: ${r[3]}`);
              }
            }),
            (Zy = class {
              async fetchModelAndCopyToWasmMemory(r) {
                return Gy(await no(r));
              }
              async loadModel(r, i) {
                et();
                let s;
                typeof r == "string"
                  ? (s = await this.fetchModelAndCopyToWasmMemory(r))
                  : (s = r),
                  ([this.sessionId, this.inputNames, this.outputNames] =
                    await Hy(s, i)),
                  A();
              }
              async dispose() {
                return qy(this.sessionId);
              }
              async run(r, i, s) {
                et();
                let u = [],
                  d = [];
                Object.entries(r).forEach((H) => {
                  let w = H[0],
                    Z = H[1],
                    re = this.inputNames.indexOf(w);
                  if (re === -1) throw new Error(`invalid input '${w}'`);
                  u.push(Z), d.push(re);
                });
                let p = [],
                  c = [];
                Object.entries(i).forEach((H) => {
                  let w = H[0],
                    Z = H[1],
                    re = this.outputNames.indexOf(w);
                  if (re === -1) throw new Error(`invalid output '${w}'`);
                  p.push(Z), c.push(re);
                });
                let b = u.map((H, w) =>
                    Km(H, () => `input "${this.inputNames[d[w]]}"`)
                  ),
                  k = p.map((H, w) =>
                    H ? Km(H, () => `output "${this.outputNames[c[w]]}"`) : null
                  ),
                  E = await Ky(this.sessionId, d, b, c, k, s),
                  q = {};
                for (let H = 0; H < E.length; H++)
                  q[this.outputNames[c[H]]] = p[H] ?? Yy(E[H]);
                return A(), q;
              }
              startProfiling() {}
              endProfiling() {
                Qy(this.sessionId);
              }
            });
        }),
        Jy,
        ew,
        Dx = m(() => {
          bt(),
            Xy(),
            Ox(),
            ar(),
            (Jy = () => {
              if (
                ((typeof N.wasm.initTimeout != "number" ||
                  N.wasm.initTimeout < 0) &&
                  (N.wasm.initTimeout = 0),
                N.wasm.simd === !1 &&
                  console.warn(
                    'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'
                  ),
                typeof N.wasm.proxy != "boolean" && (N.wasm.proxy = !1),
                typeof N.wasm.trace != "boolean" && (N.wasm.trace = !1),
                typeof N.wasm.numThreads != "number" ||
                  !Number.isInteger(N.wasm.numThreads) ||
                  N.wasm.numThreads <= 0)
              )
                if (typeof self < "u" && !self.crossOriginIsolated)
                  N.wasm.numThreads = 1;
                else {
                  let r =
                    typeof navigator > "u"
                      ? _("node:os").cpus().length
                      : navigator.hardwareConcurrency;
                  N.wasm.numThreads = Math.min(4, Math.ceil((r || 1) / 2));
                }
            }),
            (ew = class {
              async init(r) {
                Jy(), await Vy(), await Wy(r);
              }
              async createInferenceSessionHandler(r, i) {
                let s = new Zy();
                return await s.loadModel(r, i), Promise.resolve(s);
              }
            });
        }),
        tw = {};
      g(tw, { wasmBackend: () => rw });
      var rw,
        Lx = m(() => {
          Dx(), (rw = new ew());
        });
      bt(), bt(), bt();
      var Bx = "1.20.0-dev.20240827-1d059b8702",
        Rx = wt;
      {
        let r = (Lx(), v(tw)).wasmBackend;
        z("webgpu", r, 5), z("webnn", r, 5), z("cpu", r, 10), z("wasm", r, 10);
      }
      Object.defineProperty(N.versions, "web", { value: Bx, enumerable: !0 });
      /**
       * @license
       * Copyright 2021 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       * =============================================================================
       */
      /**
       * @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       * =============================================================================
       */
      /**
       * @license
       * Copyright 2019 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       * =============================================================================
       */
    },
    "./src/backends/onnx.js": (e, t, n) => {
      var o;
      n.r(t),
        n.d(t, {
          Tensor: () => _.Tensor,
          createInferenceSession: () => $,
          deviceToExecutionProviders: () => T,
          isONNXProxy: () => x,
          isONNXTensor: () => S
        });
      var a = n("./src/env.js"),
        l = n("?2ce3"),
        f = n("./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs"),
        _ = n("./node_modules/onnxruntime-common/dist/esm/index.js");
      const m = Object.freeze({
          auto: null,
          gpu: null,
          cpu: "cpu",
          wasm: "wasm",
          webgpu: "webgpu",
          cuda: "cuda",
          dml: "dml",
          webnn: { name: "webnn", deviceType: "cpu" },
          "webnn-npu": { name: "webnn", deviceType: "npu" },
          "webnn-gpu": { name: "webnn", deviceType: "gpu" },
          "webnn-cpu": { name: "webnn", deviceType: "cpu" }
        }),
        g = [];
      let M, v;
      if (a.apis.IS_NODE_ENV) {
        switch (((v = l ?? (o || (o = n.t(l, 2)))), process.platform)) {
          case "win32":
            g.push("dml");
            break;
          case "linux":
            process.arch === "x64" && g.push("cuda");
            break;
        }
        g.push("cpu"), (M = ["cpu"]);
      } else
        (v = f),
          a.apis.IS_WEBNN_AVAILABLE &&
            g.push("webnn-npu", "webnn-gpu", "webnn-cpu", "webnn"),
          a.apis.IS_WEBGPU_AVAILABLE && g.push("webgpu"),
          g.push("wasm"),
          (M = ["wasm"]);
      const C = v.InferenceSession;
      function T(I = null) {
        if (!I) return M;
        switch (I) {
          case "auto":
            return g;
          case "gpu":
            return g.filter((V) =>
              ["webgpu", "cuda", "dml", "webnn-gpu"].includes(V)
            );
        }
        if (g.includes(I)) return [m[I] ?? I];
        throw new Error(
          `Unsupported device: "${I}". Should be one of: ${g.join(", ")}.`
        );
      }
      let z = null;
      async function $(I, V) {
        z && (await z);
        const O = C.create(I, V);
        return z ?? (z = O), await O;
      }
      function S(I) {
        return I instanceof v.Tensor;
      }
      const y = v == null ? void 0 : v.env;
      y != null &&
        y.wasm &&
        ((y.wasm.wasmPaths = `https://cdn.jsdelivr.net/npm/@huggingface/transformers@${a.env.version}/dist/`),
        (y.wasm.proxy = !1),
        (typeof crossOriginIsolated > "u" || !crossOriginIsolated) &&
          (y.wasm.numThreads = 1)),
        y != null &&
          y.webgpu &&
          (y.webgpu.powerPreference = "high-performance");
      function x() {
        var I;
        return (I = y == null ? void 0 : y.wasm) == null ? void 0 : I.proxy;
      }
      a.env.backends.onnx = y;
    },
    "./src/configs.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          AutoConfig: () => g,
          PretrainedConfig: () => m,
          getKeyValueShapes: () => _
        });
      var o = n("./src/utils/core.js"),
        a = n("./src/utils/hub.js");
      async function l(M, v) {
        return await (0, a.getModelJSON)(M, "config.json", !0, v);
      }
      function f(M) {
        const v = {};
        let C = {};
        switch (M.model_type) {
          case "llava":
          case "paligemma":
          case "florence2":
            C = f(M.text_config);
            break;
          case "moondream1":
            C = f(M.phi_config);
            break;
          case "musicgen":
            C = f(M.decoder);
            break;
          case "gpt2":
          case "gptj":
          case "jais":
          case "codegen":
          case "gpt_bigcode":
            (v.num_heads = "n_head"),
              (v.num_layers = "n_layer"),
              (v.hidden_size = "n_embd");
            break;
          case "gpt_neox":
          case "stablelm":
          case "opt":
          case "phi":
          case "phi3":
          case "falcon":
            (v.num_heads = "num_attention_heads"),
              (v.num_layers = "num_hidden_layers"),
              (v.hidden_size = "hidden_size");
            break;
          case "llama":
          case "cohere":
          case "mistral":
          case "starcoder2":
          case "qwen2":
            (v.num_heads = "num_key_value_heads"),
              (v.num_layers = "num_hidden_layers"),
              (v.hidden_size = "hidden_size"),
              (v.num_attention_heads = "num_attention_heads");
            break;
          case "gemma":
          case "gemma2":
            (v.num_heads = "num_key_value_heads"),
              (v.num_layers = "num_hidden_layers"),
              (v.dim_kv = "head_dim");
            break;
          case "openelm":
            (v.num_heads = "num_kv_heads"),
              (v.num_layers = "num_transformer_layers"),
              (v.dim_kv = "head_dim");
            break;
          case "gpt_neo":
          case "donut-swin":
            (v.num_heads = "num_heads"),
              (v.num_layers = "num_layers"),
              (v.hidden_size = "hidden_size");
            break;
          case "bloom":
            (v.num_heads = "n_head"),
              (v.num_layers = "n_layer"),
              (v.hidden_size = "hidden_size");
            break;
          case "mpt":
            (v.num_heads = "n_heads"),
              (v.num_layers = "n_layers"),
              (v.hidden_size = "d_model");
            break;
          case "t5":
          case "mt5":
          case "longt5":
            (v.num_decoder_layers = "num_decoder_layers"),
              (v.num_decoder_heads = "num_heads"),
              (v.decoder_dim_kv = "d_kv"),
              (v.num_encoder_layers = "num_layers"),
              (v.num_encoder_heads = "num_heads"),
              (v.encoder_dim_kv = "d_kv");
            break;
          case "bart":
          case "mbart":
          case "marian":
          case "whisper":
          case "m2m_100":
          case "blenderbot":
          case "blenderbot-small":
          case "florence2_language":
            (v.num_decoder_layers = "decoder_layers"),
              (v.num_decoder_heads = "decoder_attention_heads"),
              (v.decoder_hidden_size = "d_model"),
              (v.num_encoder_layers = "encoder_layers"),
              (v.num_encoder_heads = "encoder_attention_heads"),
              (v.encoder_hidden_size = "d_model");
            break;
          case "speecht5":
            (v.num_decoder_layers = "decoder_layers"),
              (v.num_decoder_heads = "decoder_attention_heads"),
              (v.decoder_hidden_size = "hidden_size"),
              (v.num_encoder_layers = "encoder_layers"),
              (v.num_encoder_heads = "encoder_attention_heads"),
              (v.encoder_hidden_size = "hidden_size");
            break;
          case "trocr":
            (v.num_encoder_layers = v.num_decoder_layers = "decoder_layers"),
              (v.num_encoder_heads = v.num_decoder_heads =
                "decoder_attention_heads"),
              (v.encoder_hidden_size = v.decoder_hidden_size = "d_model");
            break;
          case "musicgen_decoder":
            (v.num_encoder_layers = v.num_decoder_layers = "num_hidden_layers"),
              (v.num_encoder_heads = v.num_decoder_heads =
                "num_attention_heads"),
              (v.encoder_hidden_size = v.decoder_hidden_size = "hidden_size");
            break;
          case "vision-encoder-decoder":
            const z = f(M.decoder),
              $ = "num_decoder_layers" in z,
              S = (0, o.pick)(M, ["model_type", "is_encoder_decoder"]);
            return (
              $
                ? ((S.num_decoder_layers = z.num_decoder_layers),
                  (S.num_decoder_heads = z.num_decoder_heads),
                  (S.decoder_hidden_size = z.decoder_hidden_size),
                  (S.num_encoder_layers = z.num_encoder_layers),
                  (S.num_encoder_heads = z.num_encoder_heads),
                  (S.encoder_hidden_size = z.encoder_hidden_size))
                : ((S.num_layers = z.num_layers),
                  (S.num_heads = z.num_heads),
                  (S.hidden_size = z.hidden_size)),
              S
            );
        }
        const T = {
          ...C,
          ...(0, o.pick)(M, ["model_type", "multi_query", "is_encoder_decoder"])
        };
        for (const z in v) T[z] = M[v[z]];
        return T;
      }
      function _(M, { prefix: v = "past_key_values" } = {}) {
        const C = {},
          T = M.normalized_config,
          z = 1;
        if (
          T.is_encoder_decoder &&
          "num_encoder_heads" in T &&
          "num_decoder_heads" in T
        ) {
          const $ =
              T.encoder_dim_kv ?? T.encoder_hidden_size / T.num_encoder_heads,
            S = T.decoder_dim_kv ?? T.decoder_hidden_size / T.num_decoder_heads,
            y = [z, T.num_encoder_heads, 0, $],
            x = [z, T.num_decoder_heads, 0, S];
          for (let I = 0; I < T.num_decoder_layers; ++I)
            (C[`${v}.${I}.encoder.key`] = y),
              (C[`${v}.${I}.encoder.value`] = y),
              (C[`${v}.${I}.decoder.key`] = x),
              (C[`${v}.${I}.decoder.value`] = x);
        } else {
          const $ = T.num_heads,
            S = T.num_layers,
            y = T.dim_kv ?? T.hidden_size / (T.num_attention_heads ?? $);
          if (T.model_type === "falcon") {
            const x = [z * $, 0, y];
            for (let I = 0; I < S; ++I)
              (C[`${v}.${I}.key`] = x), (C[`${v}.${I}.value`] = x);
          } else if (T.multi_query) {
            const x = [z * $, 0, 2 * y];
            for (let I = 0; I < S; ++I) C[`${v}.${I}.key_value`] = x;
          } else if (T.model_type === "bloom") {
            const x = [z * $, y, 0],
              I = [z * $, 0, y];
            for (let V = 0; V < S; ++V)
              (C[`${v}.${V}.key`] = x), (C[`${v}.${V}.value`] = I);
          } else if (T.model_type === "openelm")
            for (let x = 0; x < S; ++x) {
              const I = [z, $[x], 0, y];
              (C[`${v}.${x}.key`] = I), (C[`${v}.${x}.value`] = I);
            }
          else {
            const x = [z, $, 0, y];
            for (let I = 0; I < S; ++I)
              (C[`${v}.${I}.key`] = x), (C[`${v}.${I}.value`] = x);
          }
        }
        return C;
      }
      class m {
        constructor(v) {
          He(this, "max_position_embeddings");
          (this.model_type = null),
            (this.is_encoder_decoder = !1),
            Object.assign(this, v),
            (this.normalized_config = f(this));
        }
        static async from_pretrained(
          v,
          {
            progress_callback: C = null,
            config: T = null,
            cache_dir: z = null,
            local_files_only: $ = !1,
            revision: S = "main"
          } = {}
        ) {
          T && !(T instanceof m) && (T = new m(T));
          const y =
            T ??
            (await l(v, {
              progress_callback: C,
              config: T,
              cache_dir: z,
              local_files_only: $,
              revision: S
            }));
          return new this(y);
        }
      }
      class g {
        static async from_pretrained(...v) {
          return m.from_pretrained(...v);
        }
      }
    },
    "./src/env.js": (e, t, n) => {
      var N;
      n.r(t), n.d(t, { apis: () => S, env: () => B });
      var o = n("?569f"),
        a = n("?3f59"),
        l = n("?154a");
      const f = "3.0.0-alpha.13",
        _ = typeof self < "u",
        m = _ && self.constructor.name === "DedicatedWorkerGlobalScope",
        g = _ && "caches" in self,
        M = typeof navigator < "u" && "gpu" in navigator,
        v = typeof navigator < "u" && "ml" in navigator,
        C = typeof process < "u",
        T =
          C &&
          ((N = process == null ? void 0 : process.release) == null
            ? void 0
            : N.name) === "node",
        z = !j(o),
        $ = !j(a),
        S = Object.freeze({
          IS_BROWSER_ENV: _,
          IS_WEBWORKER_ENV: m,
          IS_WEB_CACHE_AVAILABLE: g,
          IS_WEBGPU_AVAILABLE: M,
          IS_WEBNN_AVAILABLE: v,
          IS_PROCESS_AVAILABLE: C,
          IS_NODE_ENV: T,
          IS_FS_AVAILABLE: z,
          IS_PATH_AVAILABLE: $
        }),
        y = z && $,
        x = y ? a.dirname(a.dirname(l.fileURLToPath(import.meta.url))) : "./",
        I = y ? a.join(x, "/.cache/") : null,
        V = "/models/",
        O = y ? a.join(x, V) : V,
        B = {
          version: f,
          backends: { onnx: {} },
          allowRemoteModels: !0,
          remoteHost: "https://huggingface.co/",
          remotePathTemplate: "{model}/resolve/{revision}/",
          allowLocalModels: !_,
          localModelPath: O,
          useFS: z,
          useBrowserCache: g,
          useFSCache: z,
          cacheDir: I,
          useCustomCache: !1,
          customCache: null
        };
      function j(se) {
        return Object.keys(se).length === 0;
      }
    },
    "./src/generation/configuration_utils.js": (e, t, n) => {
      n.r(t), n.d(t, { GenerationConfig: () => a });
      var o = n("./src/utils/core.js");
      class a {
        constructor(f) {
          He(this, "max_length", 20);
          He(this, "max_new_tokens", null);
          He(this, "min_length", 0);
          He(this, "min_new_tokens", null);
          He(this, "early_stopping", !1);
          He(this, "max_time", null);
          He(this, "do_sample", !1);
          He(this, "num_beams", 1);
          He(this, "num_beam_groups", 1);
          He(this, "penalty_alpha", null);
          He(this, "use_cache", !0);
          He(this, "temperature", 1);
          He(this, "top_k", 50);
          He(this, "top_p", 1);
          He(this, "typical_p", 1);
          He(this, "epsilon_cutoff", 0);
          He(this, "eta_cutoff", 0);
          He(this, "diversity_penalty", 0);
          He(this, "repetition_penalty", 1);
          He(this, "encoder_repetition_penalty", 1);
          He(this, "length_penalty", 1);
          He(this, "no_repeat_ngram_size", 0);
          He(this, "bad_words_ids", null);
          He(this, "force_words_ids", null);
          He(this, "renormalize_logits", !1);
          He(this, "constraints", null);
          He(this, "forced_bos_token_id", null);
          He(this, "forced_eos_token_id", null);
          He(this, "remove_invalid_values", !1);
          He(this, "exponential_decay_length_penalty", null);
          He(this, "suppress_tokens", null);
          He(this, "begin_suppress_tokens", null);
          He(this, "forced_decoder_ids", null);
          He(this, "guidance_scale", null);
          He(this, "num_return_sequences", 1);
          He(this, "output_attentions", !1);
          He(this, "output_hidden_states", !1);
          He(this, "output_scores", !1);
          He(this, "return_dict_in_generate", !1);
          He(this, "pad_token_id", null);
          He(this, "bos_token_id", null);
          He(this, "eos_token_id", null);
          He(this, "encoder_no_repeat_ngram_size", 0);
          He(this, "decoder_start_token_id", null);
          He(this, "generation_kwargs", {});
          Object.assign(this, (0, o.pick)(f, Object.getOwnPropertyNames(this)));
        }
      }
    },
    "./src/generation/logits_process.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          ClassifierFreeGuidanceLogitsProcessor: () => y,
          ForcedBOSTokenLogitsProcessor: () => m,
          ForcedEOSTokenLogitsProcessor: () => g,
          LogitsProcessor: () => l,
          LogitsProcessorList: () => _,
          LogitsWarper: () => f,
          MinLengthLogitsProcessor: () => z,
          MinNewTokensLengthLogitsProcessor: () => $,
          NoBadWordsLogitsProcessor: () => S,
          NoRepeatNGramLogitsProcessor: () => C,
          RepetitionPenaltyLogitsProcessor: () => T,
          SuppressTokensAtBeginLogitsProcessor: () => M,
          TemperatureLogitsWarper: () => x,
          TopKLogitsWarper: () => V,
          TopPLogitsWarper: () => I,
          WhisperTimeStampLogitsProcessor: () => v
        });
      var o = n("./src/utils/generic.js");
      n("./src/utils/tensor.js");
      var a = n("./src/utils/maths.js");
      class l extends o.Callable {
        _call(B, j) {
          throw Error("`_call` should be implemented in a subclass");
        }
      }
      class f extends o.Callable {
        _call(B, j) {
          throw Error("`_call` should be implemented in a subclass");
        }
      }
      class _ extends o.Callable {
        constructor() {
          super(), (this.processors = []);
        }
        push(B) {
          this.processors.push(B);
        }
        extend(B) {
          this.processors.push(...B);
        }
        _call(B, j) {
          let N = j;
          for (const se of this.processors) N = se(B, N);
          return N;
        }
        [Symbol.iterator]() {
          return this.processors.values();
        }
      }
      class m extends l {
        constructor(B) {
          super(), (this.bos_token_id = B);
        }
        _call(B, j) {
          for (let N = 0; N < B.length; ++N)
            if (B[N].length === 1) {
              const se = j[N].data;
              se.fill(-1 / 0), (se[this.bos_token_id] = 0);
            }
          return j;
        }
      }
      class g extends l {
        constructor(B, j) {
          super(),
            (this.max_length = B),
            (this.eos_token_id = Array.isArray(j) ? j : [j]);
        }
        _call(B, j) {
          for (let N = 0; N < B.length; ++N)
            if (B[N].length === this.max_length - 1) {
              const se = j[N].data;
              se.fill(-1 / 0);
              for (const de of this.eos_token_id) se[de] = 0;
            }
          return j;
        }
      }
      class M extends l {
        constructor(B, j) {
          super(), (this.begin_suppress_tokens = B), (this.begin_index = j);
        }
        _call(B, j) {
          for (let N = 0; N < B.length; ++N)
            if (B[N].length === this.begin_index) {
              const se = j[N].data;
              for (const de of this.begin_suppress_tokens) se[de] = -1 / 0;
            }
          return j;
        }
      }
      class v extends l {
        constructor(B, j) {
          super(),
            (this.eos_token_id = Array.isArray(B.eos_token_id)
              ? B.eos_token_id[0]
              : B.eos_token_id),
            (this.no_timestamps_token_id = B.no_timestamps_token_id),
            (this.timestamp_begin = this.no_timestamps_token_id + 1),
            (this.begin_index = j.length),
            j.at(-1) === this.no_timestamps_token_id && (this.begin_index -= 1),
            (this.max_initial_timestamp_index = B.max_initial_timestamp_index);
        }
        _call(B, j) {
          for (let N = 0; N < B.length; ++N) {
            const se = j[N].data;
            if (
              ((se[this.no_timestamps_token_id] = -1 / 0),
              B[N].length === this.begin_index - 1)
            ) {
              se.fill(-1 / 0), (se[this.timestamp_begin] = 0);
              continue;
            }
            const de = B[N].slice(this.begin_index),
              Me = de.length >= 1 && de[de.length - 1] >= this.timestamp_begin,
              J = de.length < 2 || de[de.length - 2] >= this.timestamp_begin;
            if (
              (Me &&
                (J
                  ? se.subarray(this.timestamp_begin).fill(-1 / 0)
                  : se.subarray(0, this.eos_token_id).fill(-1 / 0)),
              B[N].length === this.begin_index &&
                this.max_initial_timestamp_index !== null)
            ) {
              const Qe =
                this.timestamp_begin + this.max_initial_timestamp_index;
              se.subarray(Qe + 1).fill(-1 / 0);
            }
            const ye = (0, a.log_softmax)(se),
              L = Math.log(
                ye
                  .subarray(this.timestamp_begin)
                  .map(Math.exp)
                  .reduce((Qe, _e) => Qe + _e)
              ),
              Ee = (0, a.max)(ye.subarray(0, this.timestamp_begin))[0];
            L > Ee && se.subarray(0, this.timestamp_begin).fill(-1 / 0);
          }
          return j;
        }
      }
      class C extends l {
        constructor(B) {
          super(), (this.no_repeat_ngram_size = B);
        }
        getNgrams(B) {
          const j = B.length,
            N = [];
          for (let de = 0; de < j + 1 - this.no_repeat_ngram_size; ++de) {
            const Me = [];
            for (let J = 0; J < this.no_repeat_ngram_size; ++J)
              Me.push(B[de + J]);
            N.push(Me.map(Number));
          }
          const se = new Map();
          for (const de of N) {
            const Me = de.slice(0, de.length - 1),
              J = JSON.stringify(Me),
              ye = se.get(J) ?? [];
            ye.push(de[de.length - 1]), se.set(J, ye);
          }
          return se;
        }
        getGeneratedNgrams(B, j) {
          const N = j.slice(j.length + 1 - this.no_repeat_ngram_size, j.length);
          return B.get(JSON.stringify(N.map(Number))) ?? [];
        }
        calcBannedNgramTokens(B) {
          const j = [];
          if (B.length + 1 < this.no_repeat_ngram_size) return j;
          {
            const N = this.getNgrams(B);
            return this.getGeneratedNgrams(N, B);
          }
        }
        _call(B, j) {
          for (let N = 0; N < B.length; ++N) {
            const se = j[N].data,
              de = this.calcBannedNgramTokens(B[N]);
            for (const Me of de) se[Me] = -1 / 0;
          }
          return j;
        }
      }
      class T extends l {
        constructor(B) {
          super(), (this.penalty = B);
        }
        _call(B, j) {
          for (let N = 0; N < B.length; ++N) {
            const se = j[N].data;
            for (const de of B[N]) {
              const Me = Number(de);
              se[Me] < 0 ? (se[Me] *= this.penalty) : (se[Me] /= this.penalty);
            }
          }
          return j;
        }
      }
      class z extends l {
        constructor(B, j) {
          super(),
            (this.min_length = B),
            (this.eos_token_id = Array.isArray(j) ? j : [j]);
        }
        _call(B, j) {
          for (let N = 0; N < B.length; ++N)
            if (B[N].length < this.min_length) {
              const se = j[N].data;
              for (const de of this.eos_token_id) se[de] = -1 / 0;
            }
          return j;
        }
      }
      class $ extends l {
        constructor(B, j, N) {
          super(),
            (this.prompt_length_to_skip = B),
            (this.min_new_tokens = j),
            (this.eos_token_id = Array.isArray(N) ? N : [N]);
        }
        _call(B, j) {
          for (let N = 0; N < B.length; ++N)
            if (
              B[N].length - this.prompt_length_to_skip <
              this.min_new_tokens
            ) {
              const de = j[N].data;
              for (const Me of this.eos_token_id) de[Me] = -1 / 0;
            }
          return j;
        }
      }
      class S extends l {
        constructor(B, j) {
          super(),
            (this.bad_words_ids = B),
            (this.eos_token_id = Array.isArray(j) ? j : [j]);
        }
        _call(B, j) {
          for (let N = 0; N < B.length; ++N) {
            const se = j[N].data;
            for (const de of this.bad_words_ids) {
              let Me = !0;
              for (
                let J = 1;
                J <= de.length - 1 && de.length < B[J].length;
                ++J
              )
                if (de.at(-J - 1) != B[J].at(-J)) {
                  Me = !1;
                  break;
                }
              Me && (se[de.at(-1)] = -1 / 0);
            }
          }
          return j;
        }
      }
      class y extends l {
        constructor(B) {
          if ((super(), B <= 1))
            throw new Error(
              `Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${B}.`
            );
          this.guidance_scale = B;
        }
        _call(B, j) {
          if (j.dims[0] !== 2 * B.length)
            throw new Error(
              `Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${j.dims[0]} for the logits and ${B.length} for the input ids.`
            );
          const N = B.length,
            se = j.slice([0, N], null),
            de = j.slice([N, j.dims[0]], null);
          for (let Me = 0; Me < de.data.length; ++Me)
            de.data[Me] += (se.data[Me] - de.data[Me]) * this.guidance_scale;
          return de;
        }
      }
      class x extends f {
        constructor(B) {
          super(), (this.temperature = B);
        }
        _call(B, j) {
          const N = j.data;
          for (let se = 0; se < N.length; ++se) N[se] /= this.temperature;
          return j;
        }
      }
      class I extends f {
        constructor(
          B,
          { filter_value: j = -1 / 0, min_tokens_to_keep: N = 1 } = {}
        ) {
          if ((super(), B < 0 || B > 1))
            throw new Error(
              `\`top_p\` must be a float > 0 and < 1, but is ${B}`
            );
          if (!Number.isInteger(N) || N < 1)
            throw new Error(
              `\`min_tokens_to_keep\` must be a positive integer, but is ${N}`
            );
          (this.top_p = B),
            (this.filter_value = j),
            (this.min_tokens_to_keep = N);
        }
      }
      class V extends f {
        constructor(
          B,
          { filter_value: j = -1 / 0, min_tokens_to_keep: N = 1 } = {}
        ) {
          if ((super(), !Number.isInteger(B) || B < 0))
            throw new Error(
              `\`top_k\` must be a positive integer, but is ${B}`
            );
          (this.top_k = Math.max(B, N)), (this.filter_value = j);
        }
      }
    },
    "./src/generation/logits_sampler.js": (e, t, n) => {
      n.r(t), n.d(t, { LogitsSampler: () => f });
      var o = n("./src/utils/generic.js"),
        a = n("./src/utils/tensor.js"),
        l = n("./src/utils/maths.js");
      n("./src/generation/configuration_utils.js");
      class f extends o.Callable {
        constructor(v) {
          super(), (this.generation_config = v);
        }
        async _call(v) {
          return this.sample(v);
        }
        async sample(v) {
          throw Error("sample should be implemented in subclasses.");
        }
        getLogits(v, C) {
          let T = v.dims.at(-1),
            z = v.data;
          if (C === -1) z = z.slice(-T);
          else {
            let $ = C * T;
            z = z.slice($, $ + T);
          }
          return z;
        }
        randomSelect(v) {
          let C = 0;
          for (let z = 0; z < v.length; ++z) C += v[z];
          let T = Math.random() * C;
          for (let z = 0; z < v.length; ++z)
            if (((T -= v[z]), T <= 0)) return z;
          return 0;
        }
        static getSampler(v) {
          if (v.do_sample) return new m(v);
          if (v.num_beams > 1) return new g(v);
          if (v.num_return_sequences > 1)
            throw Error(
              `num_return_sequences has to be 1 when doing greedy search, but is ${v.num_return_sequences}.`
            );
          return new _(v);
        }
      }
      class _ extends f {
        async sample(v) {
          const C = (0, l.max)(v.data)[1];
          return [[BigInt(C), 0]];
        }
      }
      class m extends f {
        async sample(v) {
          let C = v.dims.at(-1);
          this.generation_config.top_k > 0 &&
            (C = Math.min(this.generation_config.top_k, C));
          const [T, z] = await (0, a.topk)(v, C),
            $ = (0, l.softmax)(T.data);
          return Array.from(
            { length: this.generation_config.num_beams },
            () => {
              const S = this.randomSelect($);
              return [z.data[S], Math.log($[S])];
            }
          );
        }
      }
      class g extends f {
        async sample(v) {
          let C = v.dims.at(-1);
          this.generation_config.top_k > 0 &&
            (C = Math.min(this.generation_config.top_k, C));
          const [T, z] = await (0, a.topk)(v, C),
            $ = (0, l.softmax)(T.data);
          return Array.from(
            { length: this.generation_config.num_beams },
            (S, y) => [z.data[y], Math.log($[y])]
          );
        }
      }
    },
    "./src/generation/stopping_criteria.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          EosTokenCriteria: () => _,
          InterruptableStoppingCriteria: () => m,
          MaxLengthCriteria: () => f,
          StoppingCriteria: () => a,
          StoppingCriteriaList: () => l
        });
      var o = n("./src/utils/generic.js");
      class a extends o.Callable {
        _call(M, v) {
          throw Error("StoppingCriteria needs to be subclassed");
        }
      }
      class l extends o.Callable {
        constructor() {
          super(), (this.criteria = []);
        }
        push(M) {
          this.criteria.push(M);
        }
        extend(M) {
          M instanceof l ? (M = M.criteria) : M instanceof a && (M = [M]),
            this.criteria.push(...M);
        }
        _call(M, v) {
          const C = new Array(M.length).fill(!1);
          for (const T of this.criteria) {
            const z = T(M, v);
            for (let $ = 0; $ < C.length; ++$) C[$] || (C[$] = z[$]);
          }
          return C;
        }
        [Symbol.iterator]() {
          return this.criteria.values();
        }
      }
      class f extends a {
        constructor(M, v = null) {
          super(), (this.max_length = M), (this.max_position_embeddings = v);
        }
        _call(M) {
          return M.map((v) => v.length >= this.max_length);
        }
      }
      class _ extends a {
        constructor(M) {
          super(), Array.isArray(M) || (M = [M]), (this.eos_token_id = M);
        }
        _call(M, v) {
          return M.map((C) => {
            const T = C.at(-1);
            return this.eos_token_id.some((z) => T == z);
          });
        }
      }
      class m extends a {
        constructor() {
          super(), (this.interrupted = !1);
        }
        interrupt() {
          this.interrupted = !0;
        }
        reset() {
          this.interrupted = !1;
        }
        _call(M, v) {
          return new Array(M.length).fill(this.interrupted);
        }
      }
    },
    "./src/generation/streamers.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          BaseStreamer: () => f,
          TextStreamer: () => m,
          WhisperTextStreamer: () => g
        });
      var o = n("./src/utils/core.js"),
        a = n("./src/tokenizers.js"),
        l = n("./src/env.js");
      class f {
        put(v) {
          throw Error("Not implemented");
        }
        end() {
          throw Error("Not implemented");
        }
      }
      const _ = l.apis.IS_PROCESS_AVAILABLE
        ? (M) => process.stdout.write(M)
        : (M) => console.log(M);
      class m extends f {
        constructor(
          v,
          {
            skip_prompt: C = !1,
            callback_function: T = null,
            token_callback_function: z = null,
            decode_kwargs: $ = {},
            ...S
          } = {}
        ) {
          super(),
            (this.tokenizer = v),
            (this.skip_prompt = C),
            (this.callback_function = T ?? _),
            (this.token_callback_function = z),
            (this.decode_kwargs = { ...$, ...S }),
            (this.token_cache = []),
            (this.print_len = 0),
            (this.next_tokens_are_prompt = !0);
        }
        put(v) {
          var $;
          if (v.length > 1)
            throw Error("TextStreamer only supports batch size of 1");
          if (this.skip_prompt && this.next_tokens_are_prompt) {
            this.next_tokens_are_prompt = !1;
            return;
          }
          const C = v[0];
          ($ = this.token_callback_function) == null || $.call(this, C),
            (this.token_cache = (0, o.mergeArrays)(this.token_cache, C));
          const T = this.tokenizer.decode(this.token_cache, this.decode_kwargs);
          let z;
          T.endsWith(`
`)
            ? ((z = T.slice(this.print_len)),
              (this.token_cache = []),
              (this.print_len = 0))
            : T.length > 0 && (0, a.is_chinese_char)(T.charCodeAt(T.length - 1))
            ? ((z = T.slice(this.print_len)), (this.print_len += z.length))
            : ((z = T.slice(this.print_len, T.lastIndexOf(" ") + 1)),
              (this.print_len += z.length)),
            this.on_finalized_text(z, !1);
        }
        end() {
          let v;
          this.token_cache.length > 0
            ? ((v = this.tokenizer
                .decode(this.token_cache, this.decode_kwargs)
                .slice(this.print_len)),
              (this.token_cache = []),
              (this.print_len = 0))
            : (v = ""),
            (this.next_tokens_are_prompt = !0),
            this.on_finalized_text(v, !0);
        }
        on_finalized_text(v, C) {
          var T, z;
          v.length > 0 &&
            ((T = this.callback_function) == null || T.call(this, v)),
            C &&
              this.callback_function === _ &&
              l.apis.IS_PROCESS_AVAILABLE &&
              ((z = this.callback_function) == null ||
                z.call(
                  this,
                  `
`
                ));
        }
      }
      class g extends m {
        constructor(
          v,
          {
            skip_prompt: C = !1,
            callback_function: T = null,
            token_callback_function: z = null,
            on_chunk_start: $ = null,
            on_chunk_end: S = null,
            on_finalize: y = null,
            time_precision: x = 0.02,
            skip_special_tokens: I = !0,
            decode_kwargs: V = {}
          } = {}
        ) {
          super(v, {
            skip_prompt: C,
            callback_function: T,
            token_callback_function: z,
            decode_kwargs: { skip_special_tokens: I, ...V }
          }),
            (this.timestamp_begin = v.timestamp_begin),
            (this.on_chunk_start = $),
            (this.on_chunk_end = S),
            (this.on_finalize = y),
            (this.time_precision = x),
            (this.waiting_for_timestamp = !1);
        }
        put(v) {
          var T, z;
          if (v.length > 1)
            throw Error("WhisperTextStreamer only supports batch size of 1");
          const C = v[0];
          if (C.length === 1) {
            const $ = Number(C[0]) - this.timestamp_begin;
            if ($ >= 0) {
              const S = $ * this.time_precision;
              this.waiting_for_timestamp
                ? (T = this.on_chunk_end) == null || T.call(this, S)
                : (z = this.on_chunk_start) == null || z.call(this, S),
                (this.waiting_for_timestamp = !this.waiting_for_timestamp),
                (v = [[]]);
            }
          }
          return super.put(v);
        }
        end() {
          var v;
          super.end(), (v = this.on_finalize) == null || v.call(this);
        }
      }
    },
    "./src/models.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          ASTForAudioClassification: () => Is,
          ASTModel: () => jt,
          ASTPreTrainedModel: () => Qn,
          AlbertForMaskedLM: () => Yt,
          AlbertForQuestionAnswering: () => wo,
          AlbertForSequenceClassification: () => yo,
          AlbertModel: () => ro,
          AlbertPreTrainedModel: () => Fi,
          AutoModel: () => Al,
          AutoModelForAudioClassification: () => Up,
          AutoModelForAudioFrameClassification: () => cf,
          AutoModelForCTC: () => lf,
          AutoModelForCausalLM: () => ef,
          AutoModelForDepthEstimation: () => pf,
          AutoModelForDocumentQuestionAnswering: () => df,
          AutoModelForImageClassification: () => nf,
          AutoModelForImageFeatureExtraction: () => mf,
          AutoModelForImageMatting: () => ff,
          AutoModelForImageSegmentation: () => of,
          AutoModelForImageToImage: () => Vp,
          AutoModelForMaskGeneration: () => Dl,
          AutoModelForMaskedLM: () => tf,
          AutoModelForNormalEstimation: () => hf,
          AutoModelForObjectDetection: () => sf,
          AutoModelForQuestionAnswering: () => zl,
          AutoModelForSemanticSegmentation: () => Ol,
          AutoModelForSeq2SeqLM: () => ts,
          AutoModelForSequenceClassification: () => Il,
          AutoModelForSpeechSeq2Seq: () => Zd,
          AutoModelForTextToSpectrogram: () => Jd,
          AutoModelForTextToWaveform: () => Fl,
          AutoModelForTokenClassification: () => Yd,
          AutoModelForVision2Seq: () => rf,
          AutoModelForXVector: () => uf,
          AutoModelForZeroShotObjectDetection: () => af,
          BartForConditionalGeneration: () => W,
          BartForSequenceClassification: () => pe,
          BartModel: () => Ue,
          BartPretrainedModel: () => qn,
          BaseModelOutput: () => qe,
          BeitForImageClassification: () => Mc,
          BeitModel: () => xc,
          BeitPreTrainedModel: () => Ba,
          BertForMaskedLM: () => We,
          BertForQuestionAnswering: () => Ge,
          BertForSequenceClassification: () => st,
          BertForTokenClassification: () => pt,
          BertModel: () => Ne,
          BertPreTrainedModel: () => Be,
          BlenderbotForConditionalGeneration: () => Ot,
          BlenderbotModel: () => Ct,
          BlenderbotPreTrainedModel: () => Pt,
          BlenderbotSmallForConditionalGeneration: () => ur,
          BlenderbotSmallModel: () => Or,
          BlenderbotSmallPreTrainedModel: () => or,
          BloomForCausalLM: () => oc,
          BloomModel: () => wp,
          BloomPreTrainedModel: () => Ds,
          CLIPModel: () => ku,
          CLIPPreTrainedModel: () => Yo,
          CLIPSegForImageSegmentation: () => Iu,
          CLIPSegModel: () => Au,
          CLIPSegPreTrainedModel: () => ba,
          CLIPTextModelWithProjection: () => bi,
          CLIPVisionModelWithProjection: () => Su,
          CamembertForMaskedLM: () => fe,
          CamembertForQuestionAnswering: () => ot,
          CamembertForSequenceClassification: () => Ie,
          CamembertForTokenClassification: () => Ve,
          CamembertModel: () => Ke,
          CamembertPreTrainedModel: () => bt,
          CausalLMOutput: () => oo,
          CausalLMOutputWithPast: () => Wp,
          ChineseCLIPModel: () => $u,
          ChineseCLIPPreTrainedModel: () => Pu,
          ClapAudioModelWithProjection: () => xd,
          ClapModel: () => vd,
          ClapPreTrainedModel: () => yl,
          ClapTextModelWithProjection: () => bd,
          CodeGenForCausalLM: () => Vu,
          CodeGenModel: () => ui,
          CodeGenPreTrainedModel: () => zs,
          CohereForCausalLM: () => qu,
          CohereModel: () => Hu,
          CoherePreTrainedModel: () => Ea,
          ConvBertForMaskedLM: () => R,
          ConvBertForQuestionAnswering: () => ce,
          ConvBertForSequenceClassification: () => te,
          ConvBertForTokenClassification: () => D,
          ConvBertModel: () => ve,
          ConvBertPreTrainedModel: () => ne,
          ConvNextForImageClassification: () => Hc,
          ConvNextModel: () => Gc,
          ConvNextPreTrainedModel: () => Za,
          ConvNextV2ForImageClassification: () => Kc,
          ConvNextV2Model: () => qc,
          ConvNextV2PreTrainedModel: () => Ja,
          DPTForDepthEstimation: () => Bc,
          DPTModel: () => Lc,
          DPTPreTrainedModel: () => Qa,
          DebertaForMaskedLM: () => xt,
          DebertaForQuestionAnswering: () => Tt,
          DebertaForSequenceClassification: () => vt,
          DebertaForTokenClassification: () => $t,
          DebertaModel: () => ft,
          DebertaPreTrainedModel: () => Xe,
          DebertaV2ForMaskedLM: () => Rt,
          DebertaV2ForQuestionAnswering: () => Wt,
          DebertaV2ForSequenceClassification: () => Kt,
          DebertaV2ForTokenClassification: () => Gt,
          DebertaV2Model: () => Nt,
          DebertaV2PreTrainedModel: () => rt,
          DeiTForImageClassification: () => Fc,
          DeiTModel: () => Ic,
          DeiTPreTrainedModel: () => Ua,
          DepthAnythingForDepthEstimation: () => Nc,
          DepthAnythingPreTrainedModel: () => Rc,
          DetrForObjectDetection: () => kc,
          DetrForSegmentation: () => Zo,
          DetrModel: () => Tc,
          DetrObjectDetectionOutput: () => Ra,
          DetrPreTrainedModel: () => Bs,
          DetrSegmentationOutput: () => Rs,
          Dinov2ForImageClassification: () => Xc,
          Dinov2Model: () => Qc,
          Dinov2PreTrainedModel: () => el,
          DistilBertForMaskedLM: () => kt,
          DistilBertForQuestionAnswering: () => mt,
          DistilBertForSequenceClassification: () => ar,
          DistilBertForTokenClassification: () => Mr,
          DistilBertModel: () => nr,
          DistilBertPreTrainedModel: () => er,
          DonutSwinModel: () => ci,
          DonutSwinPreTrainedModel: () => Wc,
          EfficientNetForImageClassification: () => Ap,
          EfficientNetModel: () => Sd,
          EfficientNetPreTrainedModel: () => xl,
          ElectraForMaskedLM: () => Re,
          ElectraForQuestionAnswering: () => wt,
          ElectraForSequenceClassification: () => ht,
          ElectraForTokenClassification: () => tt,
          ElectraModel: () => ke,
          ElectraPreTrainedModel: () => ue,
          EsmForMaskedLM: () => yi,
          EsmForSequenceClassification: () => Ai,
          EsmForTokenClassification: () => Qr,
          EsmModel: () => nn,
          EsmPreTrainedModel: () => Lt,
          FalconForCausalLM: () => _l,
          FalconModel: () => wd,
          FalconPreTrainedModel: () => yd,
          FastViTForImageClassification: () => vp,
          FastViTModel: () => fc,
          FastViTPreTrainedModel: () => za,
          Florence2ForConditionalGeneration: () => wa,
          Florence2PreTrainedModel: () => Tu,
          GLPNForDepthEstimation: () => Vc,
          GLPNModel: () => xp,
          GLPNPreTrainedModel: () => Ya,
          GPT2LMHeadModel: () => zu,
          GPT2Model: () => Fu,
          GPT2PreTrainedModel: () => xa,
          GPTBigCodeForCausalLM: () => Fs,
          GPTBigCodeModel: () => Uu,
          GPTBigCodePreTrainedModel: () => ri,
          GPTJForCausalLM: () => yp,
          GPTJModel: () => ju,
          GPTJPreTrainedModel: () => ka,
          GPTNeoForCausalLM: () => Bu,
          GPTNeoModel: () => Lu,
          GPTNeoPreTrainedModel: () => Ma,
          GPTNeoXForCausalLM: () => Nu,
          GPTNeoXModel: () => Ru,
          GPTNeoXPreTrainedModel: () => Ta,
          Gemma2ForCausalLM: () => Yu,
          Gemma2Model: () => Xu,
          Gemma2PreTrainedModel: () => ni,
          GemmaForCausalLM: () => Qu,
          GemmaModel: () => Ku,
          GemmaPreTrainedModel: () => Ca,
          HubertForCTC: () => cd,
          HubertForSequenceClassification: () => Ep,
          HubertModel: () => ud,
          HubertPreTrainedModel: () => Sp,
          ImageMattingOutput: () => _f,
          JAISLMHeadModel: () => Du,
          JAISModel: () => Ou,
          JAISPreTrainedModel: () => ti,
          LlamaForCausalLM: () => Gu,
          LlamaModel: () => Wu,
          LlamaPreTrainedModel: () => Sa,
          LlavaForConditionalGeneration: () => xo,
          LlavaPreTrainedModel: () => Mu,
          LongT5ForConditionalGeneration: () => Qo,
          LongT5Model: () => Ko,
          LongT5PreTrainedModel: () => vo,
          M2M100ForConditionalGeneration: () => nl,
          M2M100Model: () => Ki,
          M2M100PreTrainedModel: () => zi,
          MBartForCausalLM: () => Et,
          MBartForConditionalGeneration: () => Le,
          MBartForSequenceClassification: () => nt,
          MBartModel: () => Oe,
          MBartPreTrainedModel: () => Pe,
          MPNetForMaskedLM: () => Uo,
          MPNetForQuestionAnswering: () => Go,
          MPNetForSequenceClassification: () => Vo,
          MPNetForTokenClassification: () => Wo,
          MPNetModel: () => $s,
          MPNetPreTrainedModel: () => Ii,
          MT5ForConditionalGeneration: () => Kr,
          MT5Model: () => Xo,
          MT5PreTrainedModel: () => bo,
          MarianMTModel: () => qi,
          MarianModel: () => Tp,
          MarianPreTrainedModel: () => rl,
          MaskedLMOutput: () => bn,
          MistralForCausalLM: () => ml,
          MistralModel: () => md,
          MistralPreTrainedModel: () => hl,
          MobileBertForMaskedLM: () => wi,
          MobileBertForQuestionAnswering: () => Wi,
          MobileBertForSequenceClassification: () => Nr,
          MobileBertModel: () => Yr,
          MobileBertPreTrainedModel: () => Tn,
          MobileNetV1ForImageClassification: () => Qs,
          MobileNetV1Model: () => zp,
          MobileNetV1PreTrainedModel: () => kl,
          MobileNetV2ForImageClassification: () => Ed,
          MobileNetV2Model: () => Sl,
          MobileNetV2PreTrainedModel: () => So,
          MobileNetV3ForImageClassification: () => Pd,
          MobileNetV3Model: () => Cd,
          MobileNetV3PreTrainedModel: () => El,
          MobileNetV4ForImageClassification: () => Ad,
          MobileNetV4Model: () => $d,
          MobileNetV4PreTrainedModel: () => Xs,
          MobileViTForImageClassification: () => mc,
          MobileViTModel: () => bp,
          MobileViTPreTrainedModel: () => Oa,
          MobileViTV2ForImageClassification: () => _c,
          MobileViTV2Model: () => gc,
          MobileViTV2PreTrainedModel: () => Tr,
          ModelOutput: () => ge,
          Moondream1ForConditionalGeneration: () => cr,
          MptForCausalLM: () => ac,
          MptModel: () => sc,
          MptPreTrainedModel: () => Fa,
          MusicgenForCausalLM: () => Fp,
          MusicgenForConditionalGeneration: () => Tl,
          MusicgenModel: () => Ip,
          MusicgenPreTrainedModel: () => Ml,
          NomicBertModel: () => je,
          NomicBertPreTrainedModel: () => Te,
          OPTForCausalLM: () => uc,
          OPTModel: () => lc,
          OPTPreTrainedModel: () => To,
          OpenELMForCausalLM: () => Ju,
          OpenELMModel: () => Zu,
          OpenELMPreTrainedModel: () => Pa,
          OwlViTForObjectDetection: () => wc,
          OwlViTModel: () => yc,
          OwlViTPreTrainedModel: () => Da,
          Owlv2ForObjectDetection: () => bc,
          Owlv2Model: () => vc,
          Owlv2PreTrainedModel: () => La,
          Phi3ForCausalLM: () => ic,
          Phi3Model: () => nc,
          Phi3PreTrainedModel: () => Os,
          PhiForCausalLM: () => Ia,
          PhiModel: () => rc,
          PhiPreTrainedModel: () => Aa,
          PreTrainedModel: () => Y,
          PretrainedMixin: () => Dr,
          PyAnnoteForAudioFrameClassification: () => nd,
          PyAnnoteModel: () => rd,
          PyAnnotePreTrainedModel: () => sl,
          QuestionAnsweringModelOutput: () => Fn,
          Qwen2ForCausalLM: () => tc,
          Qwen2Model: () => ec,
          Qwen2PreTrainedModel: () => $a,
          RTDetrForObjectDetection: () => Ec,
          RTDetrModel: () => Sc,
          RTDetrObjectDetectionOutput: () => Cc,
          RTDetrPreTrainedModel: () => Na,
          ResNetForImageClassification: () => Oc,
          ResNetModel: () => zc,
          ResNetPreTrainedModel: () => Va,
          RoFormerForMaskedLM: () => A,
          RoFormerForQuestionAnswering: () => ae,
          RoFormerForSequenceClassification: () => Ae,
          RoFormerForTokenClassification: () => $e,
          RoFormerModel: () => et,
          RoFormerPreTrainedModel: () => Ye,
          RobertaForMaskedLM: () => An,
          RobertaForQuestionAnswering: () => ei,
          RobertaForSequenceClassification: () => vn,
          RobertaForTokenClassification: () => Ze,
          RobertaModel: () => wr,
          RobertaPreTrainedModel: () => Qt,
          SamImageSegmentationOutput: () => td,
          SamModel: () => ed,
          SamPreTrainedModel: () => Jc,
          SapiensForDepthEstimation: () => jc,
          SapiensForNormalEstimation: () => Uc,
          SapiensForSemanticSegmentation: () => Xa,
          SapiensPreTrainedModel: () => Ns,
          SegformerForImageClassification: () => Md,
          SegformerForSemanticSegmentation: () => Td,
          SegformerModel: () => Pp,
          SegformerPreTrainedModel: () => Ks,
          Seq2SeqLMOutput: () => zm,
          SequenceClassifierOutput: () => pr,
          SiglipModel: () => Mo,
          SiglipPreTrainedModel: () => va,
          SiglipTextModel: () => Eu,
          SiglipVisionModel: () => Cu,
          SpeechT5ForSpeechToText: () => Hs,
          SpeechT5ForTextToSpeech: () => hd,
          SpeechT5HifiGan: () => qs,
          SpeechT5Model: () => dl,
          SpeechT5PreTrainedModel: () => Gs,
          SqueezeBertForMaskedLM: () => _o,
          SqueezeBertForQuestionAnswering: () => Hi,
          SqueezeBertForSequenceClassification: () => vi,
          SqueezeBertModel: () => As,
          SqueezeBertPreTrainedModel: () => Gi,
          StableLmForCausalLM: () => kd,
          StableLmModel: () => $p,
          StableLmPreTrainedModel: () => bl,
          Starcoder2ForCausalLM: () => _d,
          Starcoder2Model: () => gd,
          Starcoder2PreTrainedModel: () => gl,
          Swin2SRForImageSuperResolution: () => Ka,
          Swin2SRModel: () => qa,
          Swin2SRPreTrainedModel: () => Ha,
          SwinForImageClassification: () => Ga,
          SwinModel: () => Dc,
          SwinPreTrainedModel: () => Wa,
          T5ForConditionalGeneration: () => qo,
          T5Model: () => Ho,
          T5PreTrainedModel: () => no,
          TableTransformerForObjectDetection: () => $c,
          TableTransformerModel: () => Pc,
          TableTransformerObjectDetectionOutput: () => Ac,
          TableTransformerPreTrainedModel: () => ja,
          TokenClassifierOutput: () => yn,
          TrOCRForCausalLM: () => pl,
          TrOCRPreTrainedModel: () => fl,
          UniSpeechForCTC: () => id,
          UniSpeechForSequenceClassification: () => ll,
          UniSpeechModel: () => Ws,
          UniSpeechPreTrainedModel: () => Vs,
          UniSpeechSatForAudioFrameClassification: () => ad,
          UniSpeechSatForCTC: () => sd,
          UniSpeechSatForSequenceClassification: () => kp,
          UniSpeechSatModel: () => od,
          UniSpeechSatPreTrainedModel: () => io,
          ViTForImageClassification: () => dc,
          ViTModel: () => cc,
          ViTPreTrainedModel: () => Ls,
          VisionEncoderDecoderModel: () => ya,
          VitMatteForImageMatting: () => hc,
          VitMattePreTrainedModel: () => pc,
          VitsModel: () => vl,
          VitsModelOutput: () => yf,
          VitsPreTrainedModel: () => wl,
          Wav2Vec2BertForCTC: () => ld,
          Wav2Vec2BertForSequenceClassification: () => ul,
          Wav2Vec2BertModel: () => es,
          Wav2Vec2BertPreTrainedModel: () => Jo,
          Wav2Vec2ForAudioFrameClassification: () => ol,
          Wav2Vec2ForCTC: () => il,
          Wav2Vec2ForSequenceClassification: () => js,
          Wav2Vec2Model: () => Sn,
          Wav2Vec2PreTrainedModel: () => Rn,
          WavLMForAudioFrameClassification: () => pd,
          WavLMForCTC: () => Cp,
          WavLMForSequenceClassification: () => cl,
          WavLMForXVector: () => fd,
          WavLMModel: () => dd,
          WavLMPreTrainedModel: () => ko,
          WeSpeakerResNetModel: () => al,
          WeSpeakerResNetPreTrainedModel: () => Us,
          WhisperForConditionalGeneration: () => _a,
          WhisperModel: () => Ht,
          WhisperPreTrainedModel: () => gt,
          XLMForQuestionAnswering: () => kn,
          XLMForSequenceClassification: () => Zt,
          XLMForTokenClassification: () => Kn,
          XLMModel: () => hn,
          XLMPreTrainedModel: () => Cr,
          XLMRobertaForMaskedLM: () => zt,
          XLMRobertaForQuestionAnswering: () => Zr,
          XLMRobertaForSequenceClassification: () => $r,
          XLMRobertaForTokenClassification: () => jr,
          XLMRobertaModel: () => Pr,
          XLMRobertaPreTrainedModel: () => Fr,
          XLMWithLMHeadModel: () => Bn,
          XVectorOutput: () => gf,
          YolosForObjectDetection: () => Yc,
          YolosModel: () => Mp,
          YolosObjectDetectionOutput: () => Zc,
          YolosPreTrainedModel: () => tl
        });
      var o = n("./src/configs.js"),
        a = n("./src/backends/onnx.js"),
        l = n("./src/utils/dtypes.js"),
        f = n("./src/utils/generic.js"),
        _ = n("./src/utils/core.js"),
        m = n("./src/utils/hub.js"),
        g = n("./src/generation/logits_process.js"),
        M = n("./src/generation/configuration_utils.js"),
        v = n("./src/utils/tensor.js"),
        C = n("./src/utils/maths.js"),
        T = n("./src/generation/stopping_criteria.js"),
        z = n("./src/generation/logits_sampler.js"),
        $ = n("./src/env.js"),
        S = n("./src/models/whisper/generation_whisper.js"),
        y = n("./src/models/whisper/common_whisper.js");
      const x = {
          EncoderOnly: 0,
          EncoderDecoder: 1,
          Seq2Seq: 2,
          Vision2Seq: 3,
          DecoderOnly: 4,
          MaskGeneration: 5,
          ImageTextToText: 6,
          Musicgen: 7
        },
        I = new Map(),
        V = new Map(),
        O = new Map();
      async function B(U, G, ie) {
        let Se = ie.device;
        Se &&
          typeof Se != "string" &&
          (Se.hasOwnProperty(G)
            ? (Se = Se[G])
            : (console.warn(
                `device not specified for "${G}". Using the default device.`
              ),
              (Se = null)));
        const Je = Se ?? ($.apis.IS_NODE_ENV ? "cpu" : "wasm"),
          at = (0, a.deviceToExecutionProviders)(Je);
        let _t = ie.dtype;
        typeof _t != "string" &&
          (_t && _t.hasOwnProperty(G)
            ? (_t = _t[G])
            : ((_t = l.DEFAULT_DEVICE_DTYPE_MAPPING[Je] ?? l.DATA_TYPES.fp32),
              console.warn(
                `dtype not specified for "${G}". Using the default dtype (${_t}) for this device (${Je}).`
              )));
        const It = _t;
        if (l.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(It)) {
          if (
            It === l.DATA_TYPES.fp16 &&
            Je === "webgpu" &&
            !(await (0, l.isWebGpuFp16Supported)())
          )
            throw new Error(`The device (${Je}) does not support fp16.`);
        } else
          throw new Error(
            `Invalid dtype: ${It}. Should be one of: ${Object.keys(
              l.DATA_TYPES
            ).join(", ")}`
          );
        const qt = l.DEFAULT_DTYPE_SUFFIX_MAPPING[It],
          dr = `${ie.subfolder ?? ""}/${G}${qt}.onnx`,
          mr = { ...ie.session_options };
        mr.executionProviders ?? (mr.executionProviders = at);
        const Lr = (0, m.getModelFile)(U, dr, !0, ie);
        let gr = [];
        if (
          ie.use_external_data_format &&
          (ie.use_external_data_format === !0 ||
            (typeof ie.use_external_data_format == "object" &&
              ie.use_external_data_format.hasOwnProperty(G) &&
              ie.use_external_data_format[G] === !0))
        ) {
          if ($.apis.IS_NODE_ENV)
            throw new Error(
              "External data format is not yet supported in Node.js"
            );
          const hr = `${G}${qt}.onnx_data`,
            vr = `${ie.subfolder ?? ""}/${hr}`;
          gr.push(
            new Promise(async (kr, Vr) => {
              const Nn = await (0, m.getModelFile)(U, vr, !0, ie);
              kr({ path: hr, data: Nn });
            })
          );
        } else
          mr.externalData !== void 0 &&
            (gr = mr.externalData.map(async (hr) => {
              if (typeof hr.data == "string") {
                const vr = await (0, m.getModelFile)(U, hr.data, !0, ie);
                return { ...hr, data: vr };
              }
              return hr;
            }));
        if (
          (gr.length > 0 && (mr.externalData = await Promise.all(gr)),
          Je === "webgpu")
        ) {
          const hr = (0, o.getKeyValueShapes)(ie.config, { prefix: "present" });
          if (Object.keys(hr).length > 0 && !(0, a.isONNXProxy)()) {
            const vr = {};
            for (const kr in hr) vr[kr] = "gpu-buffer";
            mr.preferredOutputLocation = vr;
          }
        }
        return { buffer: await Lr, session_options: mr };
      }
      async function j(U, G, ie) {
        return Object.fromEntries(
          await Promise.all(
            Object.keys(G).map(async (Se) => {
              const { buffer: Je, session_options: at } = await B(U, G[Se], ie),
                _t = await (0, a.createInferenceSession)(Je, at);
              return [Se, _t];
            })
          )
        );
      }
      function N(U, G) {
        const ie = Object.create(null),
          Se = [];
        for (const _t of U.inputNames) {
          const It = G[_t];
          if (!(It instanceof v.Tensor)) {
            Se.push(_t);
            continue;
          }
          ie[_t] = (0, a.isONNXProxy)() ? It.clone() : It;
        }
        if (Se.length > 0)
          throw new Error(
            `An error occurred during model execution: "Missing the following inputs: ${Se.join(
              ", "
            )}.`
          );
        const Je = Object.keys(G).length,
          at = U.inputNames.length;
        if (Je > at) {
          let _t = Object.keys(G).filter((It) => !U.inputNames.includes(It));
          console.warn(
            `WARNING: Too many inputs were provided (${Je} > ${at}). The following inputs will be ignored: "${_t.join(
              ", "
            )}".`
          );
        }
        return ie;
      }
      async function se(U, G) {
        const ie = N(U, G);
        try {
          const Se = Object.fromEntries(
            Object.entries(ie).map(([at, _t]) => [at, _t.ort_tensor])
          );
          let Je = await U.run(Se);
          return (Je = de(Je)), Je;
        } catch (Se) {
          throw (
            (console.error(
              `An error occurred during model execution: "${Se}".`
            ),
            console.error("Inputs given to model:", ie),
            Se)
          );
        }
      }
      function de(U) {
        for (let G in U)
          (0, a.isONNXTensor)(U[G])
            ? (U[G] = new v.Tensor(U[G]))
            : typeof U[G] == "object" && de(U[G]);
        return U;
      }
      function Me(U) {
        if (U instanceof v.Tensor) return U;
        if (U.length === 0) throw Error("items must be non-empty");
        if (Array.isArray(U[0])) {
          if (U.some((G) => G.length !== U[0].length))
            throw Error(
              "Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length."
            );
          return new v.Tensor(
            "int64",
            BigInt64Array.from(U.flat().map((G) => BigInt(G))),
            [U.length, U[0].length]
          );
        } else
          return new v.Tensor(
            "int64",
            BigInt64Array.from(U.map((G) => BigInt(G))),
            [1, U.length]
          );
      }
      function J(U) {
        return new v.Tensor("bool", [U], [1]);
      }
      async function ye(U, G) {
        let {
          encoder_outputs: ie,
          input_ids: Se,
          decoder_input_ids: Je,
          ...at
        } = G;
        if (!ie) {
          const It = (0, _.pick)(G, U.sessions.model.inputNames);
          ie = (await L(U, It)).last_hidden_state;
        }
        return (
          (at.input_ids = Je),
          (at.encoder_hidden_states = ie),
          U.sessions.decoder_model_merged.inputNames.includes(
            "encoder_attention_mask"
          ) && (at.encoder_attention_mask = G.attention_mask),
          await Ee(U, at, !0)
        );
      }
      async function L(U, G) {
        const ie = U.sessions.model,
          Se = (0, _.pick)(G, ie.inputNames);
        if (ie.inputNames.includes("inputs_embeds") && !Se.inputs_embeds) {
          if (!G.input_ids)
            throw new Error(
              "Both `input_ids` and `inputs_embeds` are missing in the model inputs."
            );
          Se.inputs_embeds = await U.encode_text({ input_ids: G.input_ids });
        }
        return (
          ie.inputNames.includes("token_type_ids") &&
            !Se.token_type_ids &&
            (Se.token_type_ids = new v.Tensor(
              "int64",
              new BigInt64Array(Se.input_ids.data.length),
              Se.input_ids.dims
            )),
          await se(ie, Se)
        );
      }
      async function Ee(U, G, ie = !1) {
        const Se = U.sessions[ie ? "decoder_model_merged" : "model"],
          { past_key_values: Je, ...at } = G;
        Se.inputNames.includes("use_cache_branch") &&
          (at.use_cache_branch = J(!!Je)),
          Se.inputNames.includes("position_ids") &&
            at.attention_mask &&
            !at.position_ids &&
            (at.position_ids = _e(at, Je)),
          U.addPastKeyValues(at, Je);
        const _t = (0, _.pick)(at, Se.inputNames);
        return await se(Se, _t);
      }
      async function Qe(
        U,
        {
          input_ids: G = null,
          attention_mask: ie = null,
          pixel_values: Se = null,
          position_ids: Je = null,
          inputs_embeds: at = null,
          past_key_values: _t = null,
          generation_config: It = null,
          logits_processor: qt = null,
          ...dr
        }
      ) {
        if (!at) {
          if (
            ((at = await U.encode_text({ input_ids: G })),
            Se && G.dims[1] !== 1)
          ) {
            const Lr = await U.encode_image({ pixel_values: Se });
            ({ inputs_embeds: at, attention_mask: ie } =
              U._merge_input_ids_with_image_features({
                image_features: Lr,
                inputs_embeds: at,
                input_ids: G,
                attention_mask: ie
              }));
          } else if (_t && Se && G.dims[1] === 1) {
            const Lr = G.dims[1],
              gr = Object.values(_t)[0].dims.at(-2);
            ie = (0, v.cat)(
              [
                (0, v.ones)([G.dims[0], gr]),
                ie.slice(null, [ie.dims[1] - Lr, ie.dims[1]])
              ],
              1
            );
          }
        }
        return await Ee(
          U,
          {
            inputs_embeds: at,
            past_key_values: _t,
            attention_mask: ie,
            position_ids: Je,
            generation_config: It,
            logits_processor: qt
          },
          !0
        );
      }
      function _e(U, G = null) {
        const { input_ids: ie, inputs_embeds: Se, attention_mask: Je } = U,
          [at, _t] = Je.dims,
          It = new BigInt64Array(Je.data.length);
        for (let dr = 0; dr < at; ++dr) {
          const mr = dr * _t;
          let Lr = BigInt(0);
          for (let gr = 0; gr < _t; ++gr) {
            const xr = mr + gr;
            Je.data[xr] === 0n
              ? (It[xr] = BigInt(1))
              : ((It[xr] = Lr), (Lr += Je.data[xr]));
          }
        }
        let qt = new v.Tensor("int64", It, Je.dims);
        if (G) {
          const dr = -(ie ?? Se).dims.at(1);
          qt = qt.slice(null, [dr, null]);
        }
        return qt;
      }
      function X(U, G, ie, Se) {
        if (ie.past_key_values) {
          const Je = Object.values(ie.past_key_values)[0].dims.at(-2),
            { input_ids: at, attention_mask: _t } = ie;
          if (!(_t && _t.dims[1] > at.dims[1])) {
            if (Je < at.dims[1]) ie.input_ids = at.slice(null, [Je, null]);
            else if (
              U.config.image_token_index != null &&
              at.data.some((It) => It == U.config.image_token_index)
            ) {
              const It = U.config.num_image_tokens;
              if (!It)
                throw new Error(
                  "`num_image_tokens` is missing in the model configuration."
                );
              const qt = at.dims[1] - (Je - It);
              (ie.input_ids = at.slice(null, [-qt, null])),
                (ie.attention_mask = (0, v.ones)([1, Je + qt]));
            }
          }
        }
        return ie;
      }
      function oe(U, G, ie, Se) {
        return (
          ie.past_key_values && (G = G.map((Je) => [Je.at(-1)])),
          { ...ie, decoder_input_ids: Me(G) }
        );
      }
      function xe(U, ...G) {
        return U.config.is_encoder_decoder ? oe(U, ...G) : X(U, ...G);
      }
      class Y extends f.Callable {
        constructor(ie, Se) {
          super();
          He(this, "main_input_name", "input_ids");
          He(this, "forward_params", ["input_ids", "attention_mask"]);
          (this.config = ie), (this.sessions = Se);
          const Je = O.get(this.constructor),
            at = I.get(Je);
          switch (
            ((this.can_generate = !1),
            (this._forward = null),
            (this._prepare_inputs_for_generation = null),
            at)
          ) {
            case x.DecoderOnly:
              (this.can_generate = !0),
                (this._forward = Ee),
                (this._prepare_inputs_for_generation = X);
              break;
            case x.Seq2Seq:
            case x.Vision2Seq:
            case x.Musicgen:
              (this.can_generate = !0),
                (this._forward = ye),
                (this._prepare_inputs_for_generation = oe);
              break;
            case x.EncoderDecoder:
              this._forward = ye;
              break;
            case x.ImageTextToText:
              (this.can_generate = !0),
                (this._forward = Qe),
                (this._prepare_inputs_for_generation = xe);
              break;
            default:
              this._forward = L;
              break;
          }
          this.can_generate && this.forward_params.push("past_key_values"),
            (this.custom_config = this.config["transformers.js_config"] ?? {});
        }
        async dispose() {
          var Se;
          const ie = [];
          for (const Je of Object.values(this.sessions))
            (Se = Je == null ? void 0 : Je.handler) != null &&
              Se.dispose &&
              ie.push(Je.handler.dispose());
          return await Promise.all(ie);
        }
        static async from_pretrained(
          ie,
          {
            progress_callback: Se = null,
            config: Je = null,
            cache_dir: at = null,
            local_files_only: _t = !1,
            revision: It = "main",
            model_file_name: qt = null,
            subfolder: dr = "onnx",
            device: mr = null,
            dtype: Lr = null,
            use_external_data_format: gr = null,
            session_options: xr = {}
          } = {}
        ) {
          let hr = {
            progress_callback: Se,
            config: Je,
            cache_dir: at,
            local_files_only: _t,
            revision: It,
            model_file_name: qt,
            subfolder: dr,
            device: mr,
            dtype: Lr,
            use_external_data_format: gr,
            session_options: xr
          };
          const vr = O.get(this),
            kr = I.get(vr);
          Je = hr.config = await o.AutoConfig.from_pretrained(ie, hr);
          let Vr;
          if (kr === x.DecoderOnly)
            Vr = await Promise.all([
              j(ie, { model: hr.model_file_name ?? "model" }, hr),
              (0, m.getModelJSON)(ie, "generation_config.json", !1, hr)
            ]);
          else if (kr === x.Seq2Seq || kr === x.Vision2Seq)
            Vr = await Promise.all([
              j(
                ie,
                {
                  model: "encoder_model",
                  decoder_model_merged: "decoder_model_merged"
                },
                hr
              ),
              (0, m.getModelJSON)(ie, "generation_config.json", !1, hr)
            ]);
          else if (kr === x.MaskGeneration)
            Vr = await Promise.all([
              j(
                ie,
                {
                  model: "vision_encoder",
                  prompt_encoder_mask_decoder: "prompt_encoder_mask_decoder"
                },
                hr
              )
            ]);
          else if (kr === x.EncoderDecoder)
            Vr = await Promise.all([
              j(
                ie,
                {
                  model: "encoder_model",
                  decoder_model_merged: "decoder_model_merged"
                },
                hr
              )
            ]);
          else if (kr === x.ImageTextToText) {
            const Nn = {
              embed_tokens: "embed_tokens",
              vision_encoder: "vision_encoder",
              decoder_model_merged: "decoder_model_merged"
            };
            Je.is_encoder_decoder && (Nn.model = "encoder_model"),
              (Vr = await Promise.all([
                j(ie, Nn, hr),
                (0, m.getModelJSON)(ie, "generation_config.json", !1, hr)
              ]));
          } else
            kr === x.Musicgen
              ? (Vr = await Promise.all([
                  j(
                    ie,
                    {
                      model: "text_encoder",
                      decoder_model_merged: "decoder_model_merged",
                      encodec_decode: "encodec_decode"
                    },
                    hr
                  ),
                  (0, m.getModelJSON)(ie, "generation_config.json", !1, hr)
                ]))
              : (kr !== x.EncoderOnly &&
                  console.warn(
                    `Model type for '${
                      vr ?? (Je == null ? void 0 : Je.model_type)
                    }' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`
                  ),
                (Vr = await Promise.all([
                  j(ie, { model: hr.model_file_name ?? "model" }, hr)
                ])));
          return new this(Je, ...Vr);
        }
        async _call(ie) {
          return await this.forward(ie);
        }
        async forward(ie) {
          return await this._forward(this, ie);
        }
        _get_logits_warper(ie) {
          const Se = new g.LogitsProcessorList();
          return (
            ie.temperature !== null &&
              ie.temperature !== 1 &&
              Se.push(new g.TemperatureLogitsWarper(ie.temperature)),
            ie.top_k !== null &&
              ie.top_k !== 0 &&
              Se.push(new g.TopKLogitsWarper(ie.top_k)),
            ie.top_p !== null &&
              ie.top_p < 1 &&
              Se.push(new g.TopPLogitsWarper(ie.top_p)),
            Se
          );
        }
        _get_logits_processor(ie, Se, Je = null) {
          const at = new g.LogitsProcessorList();
          if (
            (ie.repetition_penalty !== null &&
              ie.repetition_penalty !== 1 &&
              at.push(
                new g.RepetitionPenaltyLogitsProcessor(ie.repetition_penalty)
              ),
            ie.no_repeat_ngram_size !== null &&
              ie.no_repeat_ngram_size > 0 &&
              at.push(
                new g.NoRepeatNGramLogitsProcessor(ie.no_repeat_ngram_size)
              ),
            ie.bad_words_ids !== null &&
              at.push(
                new g.NoBadWordsLogitsProcessor(
                  ie.bad_words_ids,
                  ie.eos_token_id
                )
              ),
            ie.min_length !== null &&
              ie.eos_token_id !== null &&
              ie.min_length > 0 &&
              at.push(
                new g.MinLengthLogitsProcessor(ie.min_length, ie.eos_token_id)
              ),
            ie.min_new_tokens !== null &&
              ie.eos_token_id !== null &&
              ie.min_new_tokens > 0 &&
              at.push(
                new g.MinNewTokensLengthLogitsProcessor(
                  Se,
                  ie.min_new_tokens,
                  ie.eos_token_id
                )
              ),
            ie.forced_bos_token_id !== null &&
              at.push(
                new g.ForcedBOSTokenLogitsProcessor(ie.forced_bos_token_id)
              ),
            ie.forced_eos_token_id !== null &&
              at.push(
                new g.ForcedEOSTokenLogitsProcessor(
                  ie.max_length,
                  ie.forced_eos_token_id
                )
              ),
            ie.begin_suppress_tokens !== null)
          ) {
            const _t = Se > 1 || ie.forced_bos_token_id === null ? Se : Se + 1;
            at.push(
              new g.SuppressTokensAtBeginLogitsProcessor(
                ie.begin_suppress_tokens,
                _t
              )
            );
          }
          return (
            ie.guidance_scale !== null &&
              ie.guidance_scale > 1 &&
              at.push(
                new g.ClassifierFreeGuidanceLogitsProcessor(ie.guidance_scale)
              ),
            Je !== null && at.extend(Je),
            at
          );
        }
        _prepare_generation_config(ie, Se, Je = M.GenerationConfig) {
          const at = { ...this.config };
          for (const It of ["decoder", "generator", "text_config"])
            It in at && Object.assign(at, at[It]);
          const _t = new Je(at);
          return (
            "generation_config" in this &&
              Object.assign(_t, this.generation_config),
            ie && Object.assign(_t, ie),
            Se &&
              Object.assign(
                _t,
                (0, _.pick)(Se, Object.getOwnPropertyNames(_t))
              ),
            _t
          );
        }
        _get_stopping_criteria(ie, Se = null) {
          const Je = new T.StoppingCriteriaList();
          return (
            ie.max_length !== null &&
              Je.push(
                new T.MaxLengthCriteria(
                  ie.max_length,
                  this.config.max_position_embeddings ?? null
                )
              ),
            ie.eos_token_id !== null &&
              Je.push(new T.EosTokenCriteria(ie.eos_token_id)),
            Se && Je.extend(Se),
            Je
          );
        }
        _validate_model_class() {
          if (!this.can_generate) {
            const ie = [Dd, $l, Pl, Cl],
              Se = O.get(this.constructor),
              Je = new Set(),
              at = this.config.model_type;
            for (const It of ie) {
              const qt = It.get(at);
              qt && Je.add(qt[0]);
            }
            let _t = `The current model class (${Se}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;
            throw (
              (Je.size > 0 &&
                (_t += ` Please use the following class instead: ${[...Je].join(
                  ", "
                )}`),
              Error(_t))
            );
          }
        }
        prepare_inputs_for_generation(...ie) {
          return this._prepare_inputs_for_generation(this, ...ie);
        }
        _update_model_kwargs_for_generation({
          generated_input_ids: ie,
          outputs: Se,
          model_inputs: Je,
          is_encoder_decoder: at
        }) {
          return (
            (Je.past_key_values = this.getPastKeyValues(
              Se,
              Je.past_key_values
            )),
            (Je.input_ids = new v.Tensor("int64", ie.flat(), [ie.length, 1])),
            at ||
              (Je.attention_mask = (0, v.cat)(
                [
                  Je.attention_mask,
                  (0, v.ones)([Je.attention_mask.dims[0], 1])
                ],
                1
              )),
            (Je.position_ids = null),
            Je
          );
        }
        _prepare_model_inputs({
          inputs: ie,
          bos_token_id: Se,
          model_kwargs: Je
        }) {
          const at = (0, _.pick)(Je, this.forward_params),
            _t = this.main_input_name;
          if (_t in at) {
            if (ie)
              throw new Error(
                "`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=..."
              );
          } else at[_t] = ie;
          return {
            inputs_tensor: at[_t],
            model_inputs: at,
            model_input_name: _t
          };
        }
        async _prepare_encoder_decoder_kwargs_for_generation({
          inputs_tensor: ie,
          model_inputs: Se,
          model_input_name: Je,
          generation_config: at
        }) {
          if (
            this.sessions.model.inputNames.includes("inputs_embeds") &&
            !Se.inputs_embeds &&
            "_prepare_inputs_embeds" in this
          ) {
            const {
                input_ids: It,
                pixel_values: qt,
                attention_mask: dr,
                ...mr
              } = Se,
              Lr = await this._prepare_inputs_embeds(Se);
            Se = {
              ...mr,
              ...(0, _.pick)(Lr, ["inputs_embeds", "attention_mask"])
            };
          }
          let { last_hidden_state: _t } = await L(this, Se);
          if (at.guidance_scale !== null && at.guidance_scale > 1)
            (_t = (0, v.cat)([_t, (0, v.full_like)(_t, 0)], 0)),
              "attention_mask" in Se &&
                (Se.attention_mask = (0, v.cat)(
                  [Se.attention_mask, (0, v.zeros_like)(Se.attention_mask)],
                  0
                ));
          else if (Se.decoder_input_ids) {
            const It = Me(Se.decoder_input_ids).dims[0];
            if (It !== _t.dims[0]) {
              if (_t.dims[0] !== 1)
                throw new Error(
                  `The encoder outputs have a different batch size (${_t.dims[0]}) than the decoder inputs (${It}).`
                );
              _t = (0, v.cat)(
                Array.from({ length: It }, () => _t),
                0
              );
            }
          }
          return (Se.encoder_outputs = _t), Se;
        }
        _prepare_decoder_input_ids_for_generation({
          batch_size: ie,
          model_input_name: Se,
          model_kwargs: Je,
          decoder_start_token_id: at,
          bos_token_id: _t,
          generation_config: It
        }) {
          let { decoder_input_ids: qt, ...dr } = Je;
          if (qt)
            Array.isArray(qt[0]) || (qt = Array.from({ length: ie }, () => qt));
          else if ((at ?? (at = _t), this.config.model_type === "musicgen"))
            qt = Array.from(
              { length: ie * this.config.decoder.num_codebooks },
              () => [at]
            );
          else if (Array.isArray(at)) {
            if (at.length !== ie)
              throw new Error(
                `\`decoder_start_token_id\` expcted to have length ${ie} but got ${at.length}`
              );
            qt = at;
          } else qt = Array.from({ length: ie }, () => [at]);
          return (
            (qt = Me(qt)),
            (Je.decoder_attention_mask = (0, v.ones_like)(qt)),
            { input_ids: qt, model_inputs: dr }
          );
        }
        async generate({
          inputs: ie = null,
          generation_config: Se = null,
          logits_processor: Je = null,
          stopping_criteria: at = null,
          streamer: _t = null,
          ...It
        }) {
          this._validate_model_class(),
            (Se = this._prepare_generation_config(Se, It));
          let {
            inputs_tensor: qt,
            model_inputs: dr,
            model_input_name: mr
          } = this._prepare_model_inputs({ inputs: ie, model_kwargs: It });
          const Lr = this.config.is_encoder_decoder;
          Lr &&
            ("encoder_outputs" in dr ||
              (dr = await this._prepare_encoder_decoder_kwargs_for_generation({
                inputs_tensor: qt,
                model_inputs: dr,
                model_input_name: mr,
                generation_config: Se
              })));
          let gr;
          Lr
            ? ({ input_ids: gr, model_inputs: dr } =
                this._prepare_decoder_input_ids_for_generation({
                  batch_size: dr[mr].dims.at(0),
                  model_input_name: mr,
                  model_kwargs: dr,
                  decoder_start_token_id: Se.decoder_start_token_id,
                  bos_token_id: Se.bos_token_id,
                  generation_config: Se
                }))
            : (gr = dr[mr]);
          let xr = gr.dims.at(-1);
          Se.max_new_tokens !== null &&
            (Se.max_length = xr + Se.max_new_tokens);
          const hr = this._get_logits_processor(Se, xr, Je),
            vr = this._get_stopping_criteria(Se, at),
            kr = dr[mr].dims.at(0),
            Vr = z.LogitsSampler.getSampler(Se),
            Nn = new Array(kr).fill(0),
            jn = gr.tolist();
          _t && _t.put(jn);
          let xi = null,
            zn = {};
          for (;;) {
            dr = this.prepare_inputs_for_generation(jn, dr, Se);
            const En = await this.forward(dr);
            if (Se.output_attentions && Se.return_dict_in_generate) {
              const Mi = this.getAttentions(En);
              for (const Eo in Mi)
                Eo in zn || (zn[Eo] = []), zn[Eo].push(Mi[Eo]);
            }
            const Ll = En.logits.slice(null, -1, null),
              Bl = hr(jn, Ll),
              Rl = [];
            for (let Mi = 0; Mi < Bl.dims.at(0); ++Mi) {
              const Eo = Bl[Mi],
                Dm = await Vr(Eo);
              for (const [Gp, Hp] of Dm) {
                const wf = BigInt(Gp);
                (Nn[Mi] += Hp), jn[Mi].push(wf), Rl.push([wf]);
                break;
              }
            }
            if ((_t && _t.put(Rl), vr(jn).every((Mi) => Mi))) {
              Se.return_dict_in_generate &&
                (xi = this.getPastKeyValues(En, dr.past_key_values, !1));
              break;
            }
            dr = this._update_model_kwargs_for_generation({
              generated_input_ids: Rl,
              outputs: En,
              model_inputs: dr,
              is_encoder_decoder: Lr
            });
          }
          _t && _t.end();
          const mn = new v.Tensor("int64", jn.flat(), [
            jn.length,
            jn[0].length
          ]);
          return Se.return_dict_in_generate
            ? { sequences: mn, past_key_values: xi, ...zn }
            : mn;
        }
        getPastKeyValues(ie, Se, Je = !0) {
          const at = Object.create(null);
          for (const _t in ie)
            if (_t.startsWith("present")) {
              const It = _t.replace("present", "past_key_values");
              if (Se && _t.includes("encoder")) at[It] = Se[It];
              else {
                if (Je && Se) {
                  const qt = Se[It];
                  qt.location === "gpu-buffer" && qt.dispose();
                }
                at[It] = ie[_t];
              }
            }
          return at;
        }
        getAttentions(ie) {
          const Se = {};
          for (const Je of [
            "cross_attentions",
            "encoder_attentions",
            "decoder_attentions"
          ])
            for (const at in ie)
              at.startsWith(Je) &&
                (Je in Se || (Se[Je] = []), Se[Je].push(ie[at]));
          return Se;
        }
        addPastKeyValues(ie, Se) {
          if (Se) Object.assign(ie, Se);
          else {
            const Je = this.custom_config.kv_cache_dtype ?? "float32",
              at = Je === "float16" ? new Uint16Array() : [],
              _t = (0, o.getKeyValueShapes)(this.config);
            for (const It in _t) ie[It] = new v.Tensor(Je, at, _t[It]);
          }
        }
        async encode_image({ pixel_values: ie }) {
          const Se = (
            await se(this.sessions.vision_encoder, { pixel_values: ie })
          ).image_features;
          return (
            this.config.num_image_tokens ||
              (console.warn(
                `The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${Se.dims[1]}).`
              ),
              (this.config.num_image_tokens = Se.dims[1])),
            Se
          );
        }
        async encode_text({ input_ids: ie }) {
          return (await se(this.sessions.embed_tokens, { input_ids: ie }))
            .inputs_embeds;
        }
      }
      class ge {}
      class qe extends ge {
        constructor({
          last_hidden_state: G,
          hidden_states: ie = null,
          attentions: Se = null
        }) {
          super(),
            (this.last_hidden_state = G),
            (this.hidden_states = ie),
            (this.attentions = Se);
        }
      }
      class Be extends Y {}
      class Ne extends Be {}
      class We extends Be {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class st extends Be {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class pt extends Be {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class Ge extends Be {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class Te extends Y {}
      class je extends Te {}
      class Ye extends Y {}
      class et extends Ye {}
      class A extends Ye {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class Ae extends Ye {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class $e extends Ye {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class ae extends Ye {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class ne extends Y {}
      class ve extends ne {}
      class R extends ne {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class te extends ne {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class D extends ne {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class ce extends ne {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class ue extends Y {}
      class ke extends ue {}
      class Re extends ue {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class ht extends ue {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class tt extends ue {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class wt extends ue {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class bt extends Y {}
      class Ke extends bt {}
      class fe extends bt {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class Ie extends bt {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Ve extends bt {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class ot extends bt {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class Xe extends Y {}
      class ft extends Xe {}
      class xt extends Xe {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class vt extends Xe {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class $t extends Xe {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class Tt extends Xe {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class rt extends Y {}
      class Nt extends rt {}
      class Rt extends rt {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class Kt extends rt {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Gt extends rt {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class Wt extends rt {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class er extends Y {}
      class nr extends er {}
      class ar extends er {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Mr extends er {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class mt extends er {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class kt extends er {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class Lt extends Y {}
      class nn extends Lt {}
      class yi extends Lt {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class Ai extends Lt {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Qr extends Lt {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class Tn extends Y {}
      class Yr extends Tn {}
      class wi extends Tn {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class Nr extends Tn {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Wi extends Tn {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class Ii extends Y {}
      class $s extends Ii {}
      class Uo extends Ii {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class Vo extends Ii {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Wo extends Ii {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class Go extends Ii {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class Gi extends Y {}
      class As extends Gi {}
      class _o extends Gi {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class vi extends Gi {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Hi extends Gi {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class Fi extends Y {}
      class ro extends Fi {}
      class yo extends Fi {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class wo extends Fi {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class Yt extends Fi {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class no extends Y {
        constructor(ie, Se, Je) {
          super(ie, Se);
          He(this, "forward_params", [
            "input_ids",
            "attention_mask",
            "encoder_outputs",
            "decoder_input_ids",
            "decoder_attention_mask",
            "past_key_values"
          ]);
          this.generation_config = Je;
        }
      }
      class Ho extends no {}
      class qo extends no {}
      class vo extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Ko extends vo {}
      class Qo extends vo {}
      class bo extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Xo extends bo {}
      class Kr extends bo {}
      class qn extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Ue extends qn {}
      class W extends qn {}
      class pe extends qn {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Pe extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Oe extends Pe {}
      class Le extends Pe {}
      class nt extends Pe {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Et extends Pe {}
      class Pt extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Ct extends Pt {}
      class Ot extends Pt {}
      class or extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Or extends or {}
      class ur extends or {}
      class Qt extends Y {}
      class wr extends Qt {}
      class An extends Qt {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class vn extends Qt {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Ze extends Qt {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class ei extends Qt {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class Cr extends Y {}
      class hn extends Cr {}
      class Bn extends Cr {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class Zt extends Cr {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Kn extends Cr {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class kn extends Cr {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class Fr extends Y {}
      class Pr extends Fr {}
      class zt extends Fr {
        async _call(G) {
          return new bn(await super._call(G));
        }
      }
      class $r extends Fr {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class jr extends Fr {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class Zr extends Fr {
        async _call(G) {
          return new Fn(await super._call(G));
        }
      }
      class Qn extends Y {}
      class jt extends Qn {}
      class Is extends Qn {}
      class gt extends Y {
        constructor(ie, Se, Je) {
          super(ie, Se);
          He(this, "requires_attention_mask", !1);
          He(this, "main_input_name", "input_features");
          He(this, "forward_params", [
            "input_features",
            "attention_mask",
            "decoder_input_ids",
            "decoder_attention_mask",
            "past_key_values"
          ]);
          this.generation_config = Je;
        }
      }
      class Ht extends gt {}
      class _a extends gt {
        _prepare_generation_config(G, ie) {
          return super._prepare_generation_config(
            G,
            ie,
            S.WhisperGenerationConfig
          );
        }
        _retrieve_init_tokens(G) {
          const ie = [G.decoder_start_token_id];
          let Se = G.language;
          const Je = G.task;
          if (G.is_multilingual) {
            Se ||
              (console.warn(
                "No language specified - defaulting to English (en)."
              ),
              (Se = "en"));
            const _t = `<|${(0, y.whisper_language_to_code)(Se)}|>`;
            ie.push(G.lang_to_id[_t]),
              ie.push(G.task_to_id[Je ?? "transcribe"]);
          } else if (Se || Je)
            throw new Error(
              "Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config."
            );
          return (
            !G.return_timestamps &&
            G.no_timestamps_token_id &&
            ie.at(-1) !== G.no_timestamps_token_id
              ? ie.push(G.no_timestamps_token_id)
              : G.return_timestamps &&
                ie.at(-1) === G.no_timestamps_token_id &&
                (console.warn(
                  "<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."
                ),
                ie.pop()),
            ie.filter((at) => at != null)
          );
        }
        async generate({
          inputs: G = null,
          generation_config: ie = null,
          logits_processor: Se = null,
          stopping_criteria: Je = null,
          ...at
        }) {
          ie = this._prepare_generation_config(ie, at);
          const _t = at.decoder_input_ids ?? this._retrieve_init_tokens(ie);
          if (
            (ie.return_timestamps &&
              (Se ?? (Se = new g.LogitsProcessorList()),
              Se.push(new g.WhisperTimeStampLogitsProcessor(ie, _t))),
            ie.begin_suppress_tokens &&
              (Se ?? (Se = new g.LogitsProcessorList()),
              Se.push(
                new g.SuppressTokensAtBeginLogitsProcessor(
                  ie.begin_suppress_tokens,
                  _t.length
                )
              )),
            ie.return_token_timestamps)
          ) {
            if (!ie.alignment_heads)
              throw new Error(
                "Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config."
              );
            ie.task === "translate" &&
              console.warn(
                "Token-level timestamps may not be reliable for task 'translate'."
              ),
              (ie.output_attentions = !0),
              (ie.return_dict_in_generate = !0);
          }
          const It = await super.generate({
            inputs: G,
            generation_config: ie,
            logits_processor: Se,
            decoder_input_ids: _t,
            ...at
          });
          return (
            ie.return_token_timestamps &&
              (It.token_timestamps = this._extract_token_timestamps(
                It,
                ie.alignment_heads,
                ie.num_frames
              )),
            It
          );
        }
        _extract_token_timestamps(G, ie, Se = null, Je = 0.02) {
          if (!G.cross_attentions)
            throw new Error(
              "Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`."
            );
          Se == null &&
            console.warn(
              "`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds)."
            );
          let at = this.config.median_filter_width;
          at === void 0 &&
            (console.warn(
              "Model config has no `median_filter_width`, using default value of 7."
            ),
            (at = 7));
          const _t = G.cross_attentions,
            It = Array.from({ length: this.config.decoder_layers }, (vr, kr) =>
              (0, v.cat)(
                _t.map((Vr) => Vr[kr]),
                2
              )
            ),
            qt = (0, v.stack)(
              ie.map(([vr, kr]) => {
                if (vr >= It.length)
                  throw new Error(
                    `Layer index ${vr} is out of bounds for cross attentions (length ${It.length}).`
                  );
                return Se
                  ? It[vr].slice(null, kr, null, [0, Se])
                  : It[vr].slice(null, kr);
              })
            ).transpose(1, 0, 2, 3),
            [dr, mr] = (0, v.std_mean)(qt, -2, 0, !0),
            Lr = qt.clone();
          for (let vr = 0; vr < Lr.dims[0]; ++vr) {
            const kr = Lr[vr];
            for (let Vr = 0; Vr < kr.dims[0]; ++Vr) {
              const Nn = kr[Vr],
                jn = dr[vr][Vr][0].data,
                xi = mr[vr][Vr][0].data;
              for (let zn = 0; zn < Nn.dims[0]; ++zn) {
                let mn = Nn[zn].data;
                for (let En = 0; En < mn.length; ++En)
                  mn[En] = (mn[En] - xi[En]) / jn[En];
                mn.set((0, C.medianFilter)(mn, at));
              }
            }
          }
          const gr = [(0, v.mean)(Lr, 1)],
            xr = G.sequences.dims,
            hr = new v.Tensor("float32", new Float32Array(xr[0] * xr[1]), xr);
          for (let vr = 0; vr < xr[0]; ++vr) {
            const kr = gr[vr].neg().squeeze_(0),
              [Vr, Nn] = (0, C.dynamic_time_warping)(kr.tolist()),
              jn = Array.from(
                { length: Vr.length - 1 },
                (mn, En) => Vr[En + 1] - Vr[En]
              ),
              xi = (0, _.mergeArrays)([1], jn).map((mn) => !!mn),
              zn = [];
            for (let mn = 0; mn < xi.length; ++mn)
              xi[mn] && zn.push(Nn[mn] * Je);
            hr[vr].data.set(zn, 1);
          }
          return hr;
        }
      }
      class ya extends Y {
        constructor(ie, Se, Je) {
          super(ie, Se);
          He(this, "main_input_name", "pixel_values");
          He(this, "forward_params", [
            "pixel_values",
            "input_ids",
            "encoder_hidden_states",
            "past_key_values"
          ]);
          this.generation_config = Je;
        }
      }
      class Mu extends Y {
        constructor(ie, Se, Je) {
          super(ie, Se);
          He(this, "forward_params", [
            "input_ids",
            "pixel_values",
            "attention_mask",
            "position_ids",
            "past_key_values"
          ]);
          this.generation_config = Je;
        }
      }
      class xo extends Mu {
        _merge_input_ids_with_image_features({
          inputs_embeds: G,
          image_features: ie,
          input_ids: Se,
          attention_mask: Je
        }) {
          const at = this.config.image_token_index,
            It = Se.tolist().map((gr) => gr.findIndex((xr) => xr == at)),
            qt = It.every((gr) => gr === -1),
            dr = It.every((gr) => gr !== -1);
          if (!qt && !dr)
            throw new Error(
              "Every input should contain either 0 or 1 image token."
            );
          if (qt) return { inputs_embeds: G, attention_mask: Je };
          const mr = [],
            Lr = [];
          for (let gr = 0; gr < It.length; ++gr) {
            const xr = It[gr],
              hr = G[gr],
              vr = ie[gr],
              kr = Je[gr];
            mr.push(
              (0, v.cat)(
                [hr.slice([0, xr]), vr, hr.slice([xr + 1, hr.dims[0]])],
                0
              )
            ),
              Lr.push(
                (0, v.cat)(
                  [
                    kr.slice([0, xr]),
                    (0, v.ones)([vr.dims[0]]),
                    kr.slice([xr + 1, kr.dims[0]])
                  ],
                  0
                )
              );
          }
          return {
            inputs_embeds: (0, v.stack)(mr, 0),
            attention_mask: (0, v.stack)(Lr, 0)
          };
        }
      }
      class cr extends xo {}
      class Tu extends Y {
        constructor(ie, Se, Je) {
          super(ie, Se);
          He(this, "forward_params", [
            "input_ids",
            "inputs_embeds",
            "attention_mask",
            "pixel_values",
            "encoder_outputs",
            "decoder_input_ids",
            "decoder_inputs_embeds",
            "decoder_attention_mask",
            "past_key_values"
          ]);
          He(this, "main_input_name", "inputs_embeds");
          this.generation_config = Je;
        }
      }
      class wa extends Tu {
        _merge_input_ids_with_image_features({
          inputs_embeds: G,
          image_features: ie,
          input_ids: Se,
          attention_mask: Je
        }) {
          return {
            inputs_embeds: (0, v.cat)([ie, G], 1),
            attention_mask: (0, v.cat)(
              [(0, v.ones)(ie.dims.slice(0, 2)), Je],
              1
            )
          };
        }
        async _prepare_inputs_embeds({
          input_ids: G,
          pixel_values: ie,
          inputs_embeds: Se,
          attention_mask: Je
        }) {
          if (!G && !ie)
            throw new Error(
              "Either `input_ids` or `pixel_values` should be provided."
            );
          let at, _t;
          return (
            G && (at = await this.encode_text({ input_ids: G })),
            ie && (_t = await this.encode_image({ pixel_values: ie })),
            at && _t
              ? ({ inputs_embeds: Se, attention_mask: Je } =
                  this._merge_input_ids_with_image_features({
                    inputs_embeds: at,
                    image_features: _t,
                    input_ids: G,
                    attention_mask: Je
                  }))
              : (Se = at || _t),
            { inputs_embeds: Se, attention_mask: Je }
          );
        }
        async forward({
          input_ids: G,
          pixel_values: ie,
          attention_mask: Se,
          decoder_input_ids: Je,
          decoder_attention_mask: at,
          encoder_outputs: _t,
          past_key_values: It,
          inputs_embeds: qt,
          decoder_inputs_embeds: dr
        }) {
          if (
            (qt ||
              ({ inputs_embeds: qt, attention_mask: Se } =
                await this._prepare_inputs_embeds({
                  input_ids: G,
                  pixel_values: ie,
                  inputs_embeds: qt,
                  attention_mask: Se
                })),
            !_t)
          ) {
            let { last_hidden_state: gr } = await L(this, {
              inputs_embeds: qt,
              attention_mask: Se
            });
            _t = gr;
          }
          if (!dr) {
            if (!Je)
              throw new Error(
                "Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided."
              );
            dr = await this.encode_text({ input_ids: Je });
          }
          return await Ee(
            this,
            {
              inputs_embeds: dr,
              attention_mask: at,
              encoder_attention_mask: Se,
              encoder_hidden_states: _t,
              past_key_values: It
            },
            !0
          );
        }
      }
      class Yo extends Y {}
      class ku extends Yo {}
      class bi extends Yo {
        static async from_pretrained(G, ie = {}) {
          return (
            ie.model_file_name ?? (ie.model_file_name = "text_model"),
            super.from_pretrained(G, ie)
          );
        }
      }
      class Su extends Yo {
        static async from_pretrained(G, ie = {}) {
          return (
            ie.model_file_name ?? (ie.model_file_name = "vision_model"),
            super.from_pretrained(G, ie)
          );
        }
      }
      class va extends Y {}
      class Mo extends va {}
      class Eu extends va {
        static async from_pretrained(G, ie = {}) {
          return (
            ie.model_file_name ?? (ie.model_file_name = "text_model"),
            super.from_pretrained(G, ie)
          );
        }
      }
      class Cu extends Yo {
        static async from_pretrained(G, ie = {}) {
          return (
            ie.model_file_name ?? (ie.model_file_name = "vision_model"),
            super.from_pretrained(G, ie)
          );
        }
      }
      class Pu extends Y {}
      class $u extends Pu {}
      class ba extends Y {}
      class Au extends ba {}
      class Iu extends ba {}
      class xa extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Fu extends xa {}
      class zu extends xa {}
      class ti extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Ou extends ti {}
      class Du extends ti {}
      class Ma extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Lu extends Ma {}
      class Bu extends Ma {}
      class Ta extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Ru extends Ta {}
      class Nu extends Ta {}
      class ka extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class ju extends ka {}
      class yp extends ka {}
      class ri extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Uu extends ri {}
      class Fs extends ri {}
      class zs extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class ui extends zs {}
      class Vu extends zs {}
      class Sa extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Wu extends Sa {}
      class Gu extends Sa {}
      class Ea extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Hu extends Ea {}
      class qu extends Ea {}
      class Ca extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Ku extends Ca {}
      class Qu extends Ca {}
      class ni extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Xu extends ni {}
      class Yu extends ni {}
      class Pa extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Zu extends Pa {}
      class Ju extends Pa {}
      class $a extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class ec extends $a {}
      class tc extends $a {}
      class Aa extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class rc extends Aa {}
      class Ia extends Aa {}
      class Os extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class nc extends Os {}
      class ic extends Os {}
      class Ds extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class wp extends Ds {}
      class oc extends Ds {}
      class Fa extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class sc extends Fa {}
      class ac extends Fa {}
      class To extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class lc extends To {}
      class uc extends To {}
      class Ls extends Y {}
      class cc extends Ls {}
      class dc extends Ls {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class za extends Y {}
      class fc extends za {}
      class vp extends za {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class pc extends Y {}
      class hc extends pc {
        async _call(G) {
          return new _f(await super._call(G));
        }
      }
      class Oa extends Y {}
      class bp extends Oa {}
      class mc extends Oa {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Tr extends Y {}
      class gc extends Tr {}
      class _c extends Tr {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Da extends Y {}
      class yc extends Da {}
      class wc extends Da {}
      class La extends Y {}
      class vc extends La {}
      class bc extends La {}
      class Ba extends Y {}
      class xc extends Ba {}
      class Mc extends Ba {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Bs extends Y {}
      class Tc extends Bs {}
      class kc extends Bs {
        async _call(G) {
          return new Ra(await super._call(G));
        }
      }
      class Zo extends Bs {
        async _call(G) {
          return new Rs(await super._call(G));
        }
      }
      class Ra extends ge {
        constructor({ logits: G, pred_boxes: ie }) {
          super(), (this.logits = G), (this.pred_boxes = ie);
        }
      }
      class Rs extends ge {
        constructor({ logits: G, pred_boxes: ie, pred_masks: Se }) {
          super(),
            (this.logits = G),
            (this.pred_boxes = ie),
            (this.pred_masks = Se);
        }
      }
      class Na extends Y {}
      class Sc extends Na {}
      class Ec extends Na {
        async _call(G) {
          return new Cc(await super._call(G));
        }
      }
      class Cc extends ge {
        constructor({ logits: G, pred_boxes: ie }) {
          super(), (this.logits = G), (this.pred_boxes = ie);
        }
      }
      class ja extends Y {}
      class Pc extends ja {}
      class $c extends ja {
        async _call(G) {
          return new Ac(await super._call(G));
        }
      }
      class Ac extends Ra {}
      class Ua extends Y {}
      class Ic extends Ua {}
      class Fc extends Ua {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Va extends Y {}
      class zc extends Va {}
      class Oc extends Va {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Wa extends Y {}
      class Dc extends Wa {}
      class Ga extends Wa {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Ha extends Y {}
      class qa extends Ha {}
      class Ka extends Ha {}
      class Qa extends Y {}
      class Lc extends Qa {}
      class Bc extends Qa {}
      class Rc extends Y {}
      class Nc extends Rc {}
      class Ns extends Y {}
      class Xa extends Ns {}
      class jc extends Ns {}
      class Uc extends Ns {}
      class Ya extends Y {}
      class xp extends Ya {}
      class Vc extends Ya {}
      class Wc extends Y {}
      class ci extends Wc {}
      class Za extends Y {}
      class Gc extends Za {}
      class Hc extends Za {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Ja extends Y {}
      class qc extends Ja {}
      class Kc extends Ja {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class el extends Y {}
      class Qc extends el {}
      class Xc extends el {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class tl extends Y {}
      class Mp extends tl {}
      class Yc extends tl {
        async _call(G) {
          return new Zc(await super._call(G));
        }
      }
      class Zc extends ge {
        constructor({ logits: G, pred_boxes: ie }) {
          super(), (this.logits = G), (this.pred_boxes = ie);
        }
      }
      class Jc extends Y {}
      class ed extends Jc {
        async get_image_embeddings({ pixel_values: G }) {
          return await L(this, { pixel_values: G });
        }
        async forward(G) {
          if (
            ((!G.image_embeddings || !G.image_positional_embeddings) &&
              (G = { ...G, ...(await this.get_image_embeddings(G)) }),
            !G.input_labels && G.input_points)
          ) {
            const Se = G.input_points.dims.slice(0, -1),
              Je = Se.reduce((at, _t) => at * _t, 1);
            G.input_labels = new v.Tensor(
              "int64",
              new BigInt64Array(Je).fill(1n),
              Se
            );
          }
          const ie = {
            image_embeddings: G.image_embeddings,
            image_positional_embeddings: G.image_positional_embeddings
          };
          return (
            G.input_points && (ie.input_points = G.input_points),
            G.input_labels && (ie.input_labels = G.input_labels),
            G.input_boxes && (ie.input_boxes = G.input_boxes),
            await se(this.sessions.prompt_encoder_mask_decoder, ie)
          );
        }
        async _call(G) {
          return new td(await super._call(G));
        }
      }
      class td extends ge {
        constructor({ iou_scores: G, pred_masks: ie }) {
          super(), (this.iou_scores = G), (this.pred_masks = ie);
        }
      }
      class rl extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Tp extends rl {}
      class qi extends rl {}
      class zi extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class Ki extends zi {}
      class nl extends zi {}
      class Rn extends Y {}
      class Sn extends Rn {}
      class il extends Rn {
        async _call(G) {
          return new oo(await super._call(G));
        }
      }
      class js extends Rn {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class ol extends Rn {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class sl extends Y {}
      class rd extends sl {}
      class nd extends sl {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class Us extends Y {}
      class al extends Us {}
      class Vs extends Y {}
      class Ws extends Vs {}
      class id extends Vs {
        async _call(G) {
          return new oo(await super._call(G));
        }
      }
      class ll extends Vs {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class io extends Y {}
      class od extends io {}
      class sd extends io {
        async _call(G) {
          return new oo(await super._call(G));
        }
      }
      class kp extends io {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class ad extends io {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class Jo extends Y {}
      class es extends Jo {}
      class ld extends Jo {
        async _call(G) {
          return new oo(await super._call(G));
        }
      }
      class ul extends Jo {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Sp extends Y {}
      class ud extends Rn {}
      class cd extends Rn {
        async _call(G) {
          return new oo(await super._call(G));
        }
      }
      class Ep extends Rn {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class ko extends Y {}
      class dd extends ko {}
      class Cp extends ko {
        async _call(G) {
          return new oo(await super._call(G));
        }
      }
      class cl extends ko {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class fd extends ko {
        async _call(G) {
          return new gf(await super._call(G));
        }
      }
      class pd extends ko {
        async _call(G) {
          return new yn(await super._call(G));
        }
      }
      class Gs extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class dl extends Gs {}
      class Hs extends Gs {}
      class hd extends Gs {
        async generate_speech(
          G,
          ie,
          {
            threshold: Se = 0.5,
            minlenratio: Je = 0,
            maxlenratio: at = 20,
            vocoder: _t = null
          } = {}
        ) {
          const It = { input_ids: G },
            { encoder_outputs: qt, encoder_attention_mask: dr } = await L(
              this,
              It
            ),
            mr = qt.dims[1] / this.config.reduction_factor,
            Lr = Math.floor(mr * at),
            gr = Math.floor(mr * Je),
            xr = this.config.num_mel_bins;
          let hr = [],
            vr = null,
            kr = null,
            Vr = 0;
          for (;;) {
            ++Vr;
            const xi = J(!!kr);
            let zn;
            kr
              ? (zn = kr.output_sequence_out)
              : (zn = new v.Tensor("float32", new Float32Array(xr), [
                  1,
                  1,
                  xr
                ]));
            let mn = {
              use_cache_branch: xi,
              output_sequence: zn,
              encoder_attention_mask: dr,
              speaker_embeddings: ie,
              encoder_hidden_states: qt
            };
            this.addPastKeyValues(mn, vr),
              (kr = await se(this.sessions.decoder_model_merged, mn)),
              (vr = this.getPastKeyValues(kr, vr));
            const { prob: En, spectrum: Ll } = kr;
            if (
              (hr.push(Ll),
              Vr >= gr &&
                (Array.from(En.data).filter((Bl) => Bl >= Se).length > 0 ||
                  Vr >= Lr))
            )
              break;
          }
          const Nn = (0, v.cat)(hr),
            { waveform: jn } = await se(_t.sessions.model, { spectrogram: Nn });
          return { spectrogram: Nn, waveform: jn };
        }
      }
      class qs extends Y {
        constructor() {
          super(...arguments);
          He(this, "main_input_name", "spectrogram");
        }
      }
      class fl extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class pl extends fl {}
      class hl extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class md extends hl {}
      class ml extends hl {}
      class gl extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class gd extends gl {}
      class _d extends gl {}
      class yd extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class wd extends yd {}
      class _l extends yd {}
      class yl extends Y {}
      class vd extends yl {}
      class bd extends yl {
        static async from_pretrained(G, ie = {}) {
          return (
            ie.model_file_name ?? (ie.model_file_name = "text_model"),
            super.from_pretrained(G, ie)
          );
        }
      }
      class xd extends yl {
        static async from_pretrained(G, ie = {}) {
          return (
            ie.model_file_name ?? (ie.model_file_name = "audio_model"),
            super.from_pretrained(G, ie)
          );
        }
      }
      class wl extends Y {}
      class vl extends wl {
        async _call(G) {
          return new yf(await super._call(G));
        }
      }
      class Ks extends Y {}
      class Pp extends Ks {}
      class Md extends Ks {}
      class Td extends Ks {}
      class bl extends Y {
        constructor(G, ie, Se) {
          super(G, ie), (this.generation_config = Se);
        }
      }
      class $p extends bl {}
      class kd extends bl {}
      class xl extends Y {}
      class Sd extends xl {}
      class Ap extends xl {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Ml extends Y {}
      class Ip extends Ml {}
      class Fp extends Ml {}
      class Tl extends Y {
        constructor(ie, Se, Je) {
          super(ie, Se);
          He(this, "forward_params", [
            "input_ids",
            "attention_mask",
            "encoder_outputs",
            "decoder_input_ids",
            "decoder_attention_mask",
            "past_key_values"
          ]);
          this.generation_config = Je;
        }
        _apply_and_filter_by_delay_pattern_mask(ie) {
          const [Se, Je] = ie.dims,
            at = this.config.decoder.num_codebooks,
            _t = Je - at;
          let It = 0;
          for (let mr = 0; mr < ie.size; ++mr) {
            if (ie.data[mr] === this.config.decoder.pad_token_id) continue;
            const Lr = mr % Je,
              gr = Math.floor(mr / Je) % at,
              xr = Lr - gr;
            xr > 0 && xr <= _t && (ie.data[It++] = ie.data[mr]);
          }
          const qt = Math.floor(Se / at),
            dr = It / (qt * at);
          return new v.Tensor(ie.type, ie.data.slice(0, It), [qt, at, dr]);
        }
        prepare_inputs_for_generation(ie, Se, Je) {
          let at = structuredClone(ie);
          for (let It = 0; It < at.length; ++It)
            for (let qt = 0; qt < at[It].length; ++qt)
              It % this.config.decoder.num_codebooks >= qt &&
                (at[It][qt] = BigInt(this.config.decoder.pad_token_id));
          return (
            Je.guidance_scale !== null &&
              Je.guidance_scale > 1 &&
              (at = at.concat(at)),
            super.prepare_inputs_for_generation(at, Se, Je)
          );
        }
        async generate(ie) {
          const Se = await super.generate(ie),
            Je = this._apply_and_filter_by_delay_pattern_mask(Se).unsqueeze_(0),
            { audio_values: at } = await se(this.sessions.encodec_decode, {
              audio_codes: Je
            });
          return at;
        }
      }
      class kl extends Y {}
      class zp extends kl {}
      class Qs extends kl {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class So extends Y {}
      class Sl extends So {}
      class Ed extends So {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class El extends Y {}
      class Cd extends El {}
      class Pd extends El {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Xs extends Y {}
      class $d extends Xs {}
      class Ad extends Xs {
        async _call(G) {
          return new pr(await super._call(G));
        }
      }
      class Dr {
        static async from_pretrained(
          G,
          {
            progress_callback: ie = null,
            config: Se = null,
            cache_dir: Je = null,
            local_files_only: at = !1,
            revision: _t = "main",
            model_file_name: It = null,
            subfolder: qt = "onnx",
            device: dr = null,
            dtype: mr = null,
            use_external_data_format: Lr = null,
            session_options: gr = {}
          } = {}
        ) {
          let xr = {
            progress_callback: ie,
            config: Se,
            cache_dir: Je,
            local_files_only: at,
            revision: _t,
            model_file_name: It,
            subfolder: qt,
            device: dr,
            dtype: mr,
            use_external_data_format: Lr,
            session_options: gr
          };
          if (
            ((xr.config = await o.AutoConfig.from_pretrained(G, xr)),
            !this.MODEL_CLASS_MAPPINGS)
          )
            throw new Error(
              "`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: " +
                this.name
            );
          for (let hr of this.MODEL_CLASS_MAPPINGS) {
            const vr = hr.get(xr.config.model_type);
            if (vr) return await vr[1].from_pretrained(G, xr);
          }
          if (this.BASE_IF_FAIL)
            return (
              console.warn(
                `Unknown model class "${xr.config.model_type}", attempting to construct from base class.`
              ),
              await Y.from_pretrained(G, xr)
            );
          throw Error(`Unsupported model type: ${xr.config.model_type}`);
        }
      }
      He(Dr, "MODEL_CLASS_MAPPINGS", null), He(Dr, "BASE_IF_FAIL", !1);
      const Im = new Map([
          ["bert", ["BertModel", Ne]],
          ["nomic_bert", ["NomicBertModel", je]],
          ["roformer", ["RoFormerModel", et]],
          ["electra", ["ElectraModel", ke]],
          ["esm", ["EsmModel", nn]],
          ["convbert", ["ConvBertModel", ve]],
          ["camembert", ["CamembertModel", Ke]],
          ["deberta", ["DebertaModel", ft]],
          ["deberta-v2", ["DebertaV2Model", Nt]],
          ["mpnet", ["MPNetModel", $s]],
          ["albert", ["AlbertModel", ro]],
          ["distilbert", ["DistilBertModel", nr]],
          ["roberta", ["RobertaModel", wr]],
          ["xlm", ["XLMModel", hn]],
          ["xlm-roberta", ["XLMRobertaModel", Pr]],
          ["clap", ["ClapModel", vd]],
          ["clip", ["CLIPModel", ku]],
          ["clipseg", ["CLIPSegModel", Au]],
          ["chinese_clip", ["ChineseCLIPModel", $u]],
          ["siglip", ["SiglipModel", Mo]],
          ["mobilebert", ["MobileBertModel", Yr]],
          ["squeezebert", ["SqueezeBertModel", As]],
          ["wav2vec2", ["Wav2Vec2Model", Sn]],
          ["wav2vec2-bert", ["Wav2Vec2BertModel", es]],
          ["unispeech", ["UniSpeechModel", Ws]],
          ["unispeech-sat", ["UniSpeechSatModel", od]],
          ["hubert", ["HubertModel", ud]],
          ["wavlm", ["WavLMModel", dd]],
          ["audio-spectrogram-transformer", ["ASTModel", jt]],
          ["vits", ["VitsModel", vl]],
          ["pyannote", ["PyAnnoteModel", rd]],
          ["wespeaker-resnet", ["WeSpeakerResNetModel", al]],
          ["detr", ["DetrModel", Tc]],
          ["rt_detr", ["RTDetrModel", Sc]],
          ["table-transformer", ["TableTransformerModel", Pc]],
          ["vit", ["ViTModel", cc]],
          ["fastvit", ["FastViTModel", fc]],
          ["mobilevit", ["MobileViTModel", bp]],
          ["mobilevitv2", ["MobileViTV2Model", gc]],
          ["owlvit", ["OwlViTModel", yc]],
          ["owlv2", ["Owlv2Model", vc]],
          ["beit", ["BeitModel", xc]],
          ["deit", ["DeiTModel", Ic]],
          ["convnext", ["ConvNextModel", Gc]],
          ["convnextv2", ["ConvNextV2Model", qc]],
          ["dinov2", ["Dinov2Model", Qc]],
          ["resnet", ["ResNetModel", zc]],
          ["swin", ["SwinModel", Dc]],
          ["swin2sr", ["Swin2SRModel", qa]],
          ["donut-swin", ["DonutSwinModel", ci]],
          ["yolos", ["YolosModel", Mp]],
          ["dpt", ["DPTModel", Lc]],
          ["glpn", ["GLPNModel", xp]],
          ["hifigan", ["SpeechT5HifiGan", qs]],
          ["efficientnet", ["EfficientNetModel", Sd]],
          ["mobilenet_v1", ["MobileNetV1Model", zp]],
          ["mobilenet_v2", ["MobileNetV2Model", Sl]],
          ["mobilenet_v3", ["MobileNetV3Model", Cd]],
          ["mobilenet_v4", ["MobileNetV4Model", $d]]
        ]),
        Op = new Map([
          ["t5", ["T5Model", Ho]],
          ["longt5", ["LongT5Model", Ko]],
          ["mt5", ["MT5Model", Xo]],
          ["bart", ["BartModel", Ue]],
          ["mbart", ["MBartModel", Oe]],
          ["marian", ["MarianModel", Tp]],
          ["whisper", ["WhisperModel", Ht]],
          ["m2m_100", ["M2M100Model", Ki]],
          ["blenderbot", ["BlenderbotModel", Ct]],
          ["blenderbot-small", ["BlenderbotSmallModel", Or]]
        ]),
        Id = new Map([
          ["bloom", ["BloomModel", wp]],
          ["jais", ["JAISModel", Ou]],
          ["gpt2", ["GPT2Model", Fu]],
          ["gptj", ["GPTJModel", ju]],
          ["gpt_bigcode", ["GPTBigCodeModel", Uu]],
          ["gpt_neo", ["GPTNeoModel", Lu]],
          ["gpt_neox", ["GPTNeoXModel", Ru]],
          ["codegen", ["CodeGenModel", ui]],
          ["llama", ["LlamaModel", Wu]],
          ["cohere", ["CohereModel", Hu]],
          ["gemma", ["GemmaModel", Ku]],
          ["gemma2", ["Gemma2Model", Xu]],
          ["openelm", ["OpenELMModel", Zu]],
          ["qwen2", ["Qwen2Model", ec]],
          ["phi", ["PhiModel", rc]],
          ["phi3", ["Phi3Model", nc]],
          ["mpt", ["MptModel", sc]],
          ["opt", ["OPTModel", lc]],
          ["mistral", ["MistralModel", md]],
          ["starcoder2", ["Starcoder2Model", gd]],
          ["falcon", ["FalconModel", wd]],
          ["stablelm", ["StableLmModel", $p]]
        ]),
        Cl = new Map([
          ["speecht5", ["SpeechT5ForSpeechToText", Hs]],
          ["whisper", ["WhisperForConditionalGeneration", _a]]
        ]),
        Fd = new Map([["speecht5", ["SpeechT5ForTextToSpeech", hd]]]),
        zd = new Map([
          ["vits", ["VitsModel", vl]],
          ["musicgen", ["MusicgenForConditionalGeneration", Tl]]
        ]),
        Dp = new Map([
          ["bert", ["BertForSequenceClassification", st]],
          ["roformer", ["RoFormerForSequenceClassification", Ae]],
          ["electra", ["ElectraForSequenceClassification", ht]],
          ["esm", ["EsmForSequenceClassification", Ai]],
          ["convbert", ["ConvBertForSequenceClassification", te]],
          ["camembert", ["CamembertForSequenceClassification", Ie]],
          ["deberta", ["DebertaForSequenceClassification", vt]],
          ["deberta-v2", ["DebertaV2ForSequenceClassification", Kt]],
          ["mpnet", ["MPNetForSequenceClassification", Vo]],
          ["albert", ["AlbertForSequenceClassification", yo]],
          ["distilbert", ["DistilBertForSequenceClassification", ar]],
          ["roberta", ["RobertaForSequenceClassification", vn]],
          ["xlm", ["XLMForSequenceClassification", Zt]],
          ["xlm-roberta", ["XLMRobertaForSequenceClassification", $r]],
          ["bart", ["BartForSequenceClassification", pe]],
          ["mbart", ["MBartForSequenceClassification", nt]],
          ["mobilebert", ["MobileBertForSequenceClassification", Nr]],
          ["squeezebert", ["SqueezeBertForSequenceClassification", vi]]
        ]),
        Od = new Map([
          ["bert", ["BertForTokenClassification", pt]],
          ["roformer", ["RoFormerForTokenClassification", $e]],
          ["electra", ["ElectraForTokenClassification", tt]],
          ["esm", ["EsmForTokenClassification", Qr]],
          ["convbert", ["ConvBertForTokenClassification", D]],
          ["camembert", ["CamembertForTokenClassification", Ve]],
          ["deberta", ["DebertaForTokenClassification", $t]],
          ["deberta-v2", ["DebertaV2ForTokenClassification", Gt]],
          ["mpnet", ["MPNetForTokenClassification", Wo]],
          ["distilbert", ["DistilBertForTokenClassification", Mr]],
          ["roberta", ["RobertaForTokenClassification", Ze]],
          ["xlm", ["XLMForTokenClassification", Kn]],
          ["xlm-roberta", ["XLMRobertaForTokenClassification", jr]]
        ]),
        Pl = new Map([
          ["t5", ["T5ForConditionalGeneration", qo]],
          ["longt5", ["LongT5ForConditionalGeneration", Qo]],
          ["mt5", ["MT5ForConditionalGeneration", Kr]],
          ["bart", ["BartForConditionalGeneration", W]],
          ["mbart", ["MBartForConditionalGeneration", Le]],
          ["marian", ["MarianMTModel", qi]],
          ["m2m_100", ["M2M100ForConditionalGeneration", nl]],
          ["blenderbot", ["BlenderbotForConditionalGeneration", Ot]],
          ["blenderbot-small", ["BlenderbotSmallForConditionalGeneration", ur]]
        ]),
        Dd = new Map([
          ["bloom", ["BloomForCausalLM", oc]],
          ["gpt2", ["GPT2LMHeadModel", zu]],
          ["jais", ["JAISLMHeadModel", Du]],
          ["gptj", ["GPTJForCausalLM", yp]],
          ["gpt_bigcode", ["GPTBigCodeForCausalLM", Fs]],
          ["gpt_neo", ["GPTNeoForCausalLM", Bu]],
          ["gpt_neox", ["GPTNeoXForCausalLM", Nu]],
          ["codegen", ["CodeGenForCausalLM", Vu]],
          ["llama", ["LlamaForCausalLM", Gu]],
          ["cohere", ["CohereForCausalLM", qu]],
          ["gemma", ["GemmaForCausalLM", Qu]],
          ["gemma2", ["Gemma2ForCausalLM", Yu]],
          ["openelm", ["OpenELMForCausalLM", Ju]],
          ["qwen2", ["Qwen2ForCausalLM", tc]],
          ["phi", ["PhiForCausalLM", Ia]],
          ["phi3", ["Phi3ForCausalLM", ic]],
          ["mpt", ["MptForCausalLM", ac]],
          ["opt", ["OPTForCausalLM", uc]],
          ["mbart", ["MBartForCausalLM", Et]],
          ["mistral", ["MistralForCausalLM", ml]],
          ["starcoder2", ["Starcoder2ForCausalLM", _d]],
          ["falcon", ["FalconForCausalLM", _l]],
          ["trocr", ["TrOCRForCausalLM", pl]],
          ["stablelm", ["StableLmForCausalLM", kd]]
        ]),
        Ld = new Map([
          ["bert", ["BertForMaskedLM", We]],
          ["roformer", ["RoFormerForMaskedLM", A]],
          ["electra", ["ElectraForMaskedLM", Re]],
          ["esm", ["EsmForMaskedLM", yi]],
          ["convbert", ["ConvBertForMaskedLM", R]],
          ["camembert", ["CamembertForMaskedLM", fe]],
          ["deberta", ["DebertaForMaskedLM", xt]],
          ["deberta-v2", ["DebertaV2ForMaskedLM", Rt]],
          ["mpnet", ["MPNetForMaskedLM", Uo]],
          ["albert", ["AlbertForMaskedLM", Yt]],
          ["distilbert", ["DistilBertForMaskedLM", kt]],
          ["roberta", ["RobertaForMaskedLM", An]],
          ["xlm", ["XLMWithLMHeadModel", Bn]],
          ["xlm-roberta", ["XLMRobertaForMaskedLM", zt]],
          ["mobilebert", ["MobileBertForMaskedLM", wi]],
          ["squeezebert", ["SqueezeBertForMaskedLM", _o]]
        ]),
        Bd = new Map([
          ["bert", ["BertForQuestionAnswering", Ge]],
          ["roformer", ["RoFormerForQuestionAnswering", ae]],
          ["electra", ["ElectraForQuestionAnswering", wt]],
          ["convbert", ["ConvBertForQuestionAnswering", ce]],
          ["camembert", ["CamembertForQuestionAnswering", ot]],
          ["deberta", ["DebertaForQuestionAnswering", Tt]],
          ["deberta-v2", ["DebertaV2ForQuestionAnswering", Wt]],
          ["mpnet", ["MPNetForQuestionAnswering", Go]],
          ["albert", ["AlbertForQuestionAnswering", wo]],
          ["distilbert", ["DistilBertForQuestionAnswering", mt]],
          ["roberta", ["RobertaForQuestionAnswering", ei]],
          ["xlm", ["XLMForQuestionAnswering", kn]],
          ["xlm-roberta", ["XLMRobertaForQuestionAnswering", Zr]],
          ["mobilebert", ["MobileBertForQuestionAnswering", Wi]],
          ["squeezebert", ["SqueezeBertForQuestionAnswering", Hi]]
        ]),
        $l = new Map([
          ["vision-encoder-decoder", ["VisionEncoderDecoderModel", ya]]
        ]),
        Lp = new Map([
          ["llava", ["LlavaForConditionalGeneration", xo]],
          ["moondream1", ["Moondream1ForConditionalGeneration", cr]],
          ["florence2", ["Florence2ForConditionalGeneration", wa]]
        ]),
        Fm = new Map([
          ["vision-encoder-decoder", ["VisionEncoderDecoderModel", ya]]
        ]),
        Rd = new Map([
          ["vit", ["ViTForImageClassification", dc]],
          ["fastvit", ["FastViTForImageClassification", vp]],
          ["mobilevit", ["MobileViTForImageClassification", mc]],
          ["mobilevitv2", ["MobileViTV2ForImageClassification", _c]],
          ["beit", ["BeitForImageClassification", Mc]],
          ["deit", ["DeiTForImageClassification", Fc]],
          ["convnext", ["ConvNextForImageClassification", Hc]],
          ["convnextv2", ["ConvNextV2ForImageClassification", Kc]],
          ["dinov2", ["Dinov2ForImageClassification", Xc]],
          ["resnet", ["ResNetForImageClassification", Oc]],
          ["swin", ["SwinForImageClassification", Ga]],
          ["segformer", ["SegformerForImageClassification", Md]],
          ["efficientnet", ["EfficientNetForImageClassification", Ap]],
          ["mobilenet_v1", ["MobileNetV1ForImageClassification", Qs]],
          ["mobilenet_v2", ["MobileNetV2ForImageClassification", Ed]],
          ["mobilenet_v3", ["MobileNetV3ForImageClassification", Pd]],
          ["mobilenet_v4", ["MobileNetV4ForImageClassification", Ad]]
        ]),
        Nd = new Map([
          ["detr", ["DetrForObjectDetection", kc]],
          ["rt_detr", ["RTDetrForObjectDetection", Ec]],
          ["table-transformer", ["TableTransformerForObjectDetection", $c]],
          ["yolos", ["YolosForObjectDetection", Yc]]
        ]),
        jd = new Map([
          ["owlvit", ["OwlViTForObjectDetection", wc]],
          ["owlv2", ["Owlv2ForObjectDetection", bc]]
        ]),
        Ud = new Map([
          ["detr", ["DetrForSegmentation", Zo]],
          ["clipseg", ["CLIPSegForImageSegmentation", Iu]]
        ]),
        Bp = new Map([
          ["segformer", ["SegformerForSemanticSegmentation", Td]],
          ["sapiens", ["SapiensForSemanticSegmentation", Xa]]
        ]),
        Vd = new Map([["sam", ["SamModel", ed]]]),
        Wd = new Map([
          ["wav2vec2", ["Wav2Vec2ForCTC", il]],
          ["wav2vec2-bert", ["Wav2Vec2BertForCTC", ld]],
          ["unispeech", ["UniSpeechForCTC", id]],
          ["unispeech-sat", ["UniSpeechSatForCTC", sd]],
          ["wavlm", ["WavLMForCTC", Cp]],
          ["hubert", ["HubertForCTC", cd]]
        ]),
        Gd = new Map([
          ["wav2vec2", ["Wav2Vec2ForSequenceClassification", js]],
          ["wav2vec2-bert", ["Wav2Vec2BertForSequenceClassification", ul]],
          ["unispeech", ["UniSpeechForSequenceClassification", ll]],
          ["unispeech-sat", ["UniSpeechSatForSequenceClassification", kp]],
          ["wavlm", ["WavLMForSequenceClassification", cl]],
          ["hubert", ["HubertForSequenceClassification", Ep]],
          ["audio-spectrogram-transformer", ["ASTForAudioClassification", Is]]
        ]),
        Hd = new Map([["wavlm", ["WavLMForXVector", fd]]]),
        Rp = new Map([
          ["unispeech-sat", ["UniSpeechSatForAudioFrameClassification", ad]],
          ["wavlm", ["WavLMForAudioFrameClassification", pd]],
          ["wav2vec2", ["Wav2Vec2ForAudioFrameClassification", ol]],
          ["pyannote", ["PyAnnoteForAudioFrameClassification", nd]]
        ]),
        qd = new Map([["vitmatte", ["VitMatteForImageMatting", hc]]]),
        Kd = new Map([["swin2sr", ["Swin2SRForImageSuperResolution", Ka]]]),
        Qd = new Map([
          ["dpt", ["DPTForDepthEstimation", Bc]],
          ["depth_anything", ["DepthAnythingForDepthEstimation", Nc]],
          ["glpn", ["GLPNForDepthEstimation", Vc]],
          ["sapiens", ["SapiensForDepthEstimation", jc]]
        ]),
        Xd = new Map([["sapiens", ["SapiensForNormalEstimation", Uc]]]),
        Np = new Map([
          ["clip", ["CLIPVisionModelWithProjection", Su]],
          ["siglip", ["SiglipVisionModel", Cu]]
        ]),
        In = [
          [Im, x.EncoderOnly],
          [Op, x.EncoderDecoder],
          [Id, x.DecoderOnly],
          [Dp, x.EncoderOnly],
          [Od, x.EncoderOnly],
          [Pl, x.Seq2Seq],
          [Cl, x.Seq2Seq],
          [Dd, x.DecoderOnly],
          [Ld, x.EncoderOnly],
          [Bd, x.EncoderOnly],
          [$l, x.Vision2Seq],
          [Lp, x.ImageTextToText],
          [Rd, x.EncoderOnly],
          [Ud, x.EncoderOnly],
          [Bp, x.EncoderOnly],
          [qd, x.EncoderOnly],
          [Kd, x.EncoderOnly],
          [Qd, x.EncoderOnly],
          [Xd, x.EncoderOnly],
          [Nd, x.EncoderOnly],
          [jd, x.EncoderOnly],
          [Vd, x.MaskGeneration],
          [Wd, x.EncoderOnly],
          [Gd, x.EncoderOnly],
          [Fd, x.Seq2Seq],
          [zd, x.EncoderOnly],
          [Hd, x.EncoderOnly],
          [Rp, x.EncoderOnly],
          [Np, x.EncoderOnly]
        ];
      for (const [U, G] of In)
        for (const [ie, Se] of U.values())
          I.set(ie, G), O.set(Se, ie), V.set(ie, Se);
      const jp = [
        ["MusicgenForConditionalGeneration", Tl, x.Musicgen],
        ["CLIPTextModelWithProjection", bi, x.EncoderOnly],
        ["SiglipTextModel", Eu, x.EncoderOnly],
        ["ClapTextModelWithProjection", bd, x.EncoderOnly],
        ["ClapAudioModelWithProjection", xd, x.EncoderOnly]
      ];
      for (const [U, G, ie] of jp) I.set(U, ie), O.set(G, U), V.set(U, G);
      class Al extends Dr {}
      He(
        Al,
        "MODEL_CLASS_MAPPINGS",
        In.map((G) => G[0])
      ),
        He(Al, "BASE_IF_FAIL", !0);
      class Il extends Dr {}
      He(Il, "MODEL_CLASS_MAPPINGS", [Dp]);
      class Yd extends Dr {}
      He(Yd, "MODEL_CLASS_MAPPINGS", [Od]);
      class ts extends Dr {}
      He(ts, "MODEL_CLASS_MAPPINGS", [Pl]);
      class Zd extends Dr {}
      He(Zd, "MODEL_CLASS_MAPPINGS", [Cl]);
      class Jd extends Dr {}
      He(Jd, "MODEL_CLASS_MAPPINGS", [Fd]);
      class Fl extends Dr {}
      He(Fl, "MODEL_CLASS_MAPPINGS", [zd]);
      class ef extends Dr {}
      He(ef, "MODEL_CLASS_MAPPINGS", [Dd]);
      class tf extends Dr {}
      He(tf, "MODEL_CLASS_MAPPINGS", [Ld]);
      class zl extends Dr {}
      He(zl, "MODEL_CLASS_MAPPINGS", [Bd]);
      class rf extends Dr {}
      He(rf, "MODEL_CLASS_MAPPINGS", [$l]);
      class nf extends Dr {}
      He(nf, "MODEL_CLASS_MAPPINGS", [Rd]);
      class of extends Dr {}
      He(of, "MODEL_CLASS_MAPPINGS", [Ud]);
      class Ol extends Dr {}
      He(Ol, "MODEL_CLASS_MAPPINGS", [Bp]);
      class sf extends Dr {}
      He(sf, "MODEL_CLASS_MAPPINGS", [Nd]);
      class af extends Dr {}
      He(af, "MODEL_CLASS_MAPPINGS", [jd]);
      class Dl extends Dr {}
      He(Dl, "MODEL_CLASS_MAPPINGS", [Vd]);
      class lf extends Dr {}
      He(lf, "MODEL_CLASS_MAPPINGS", [Wd]);
      class Up extends Dr {}
      He(Up, "MODEL_CLASS_MAPPINGS", [Gd]);
      class uf extends Dr {}
      He(uf, "MODEL_CLASS_MAPPINGS", [Hd]);
      class cf extends Dr {}
      He(cf, "MODEL_CLASS_MAPPINGS", [Rp]);
      class df extends Dr {}
      He(df, "MODEL_CLASS_MAPPINGS", [Fm]);
      class ff extends Dr {}
      He(ff, "MODEL_CLASS_MAPPINGS", [qd]);
      class Vp extends Dr {}
      He(Vp, "MODEL_CLASS_MAPPINGS", [Kd]);
      class pf extends Dr {}
      He(pf, "MODEL_CLASS_MAPPINGS", [Qd]);
      class hf extends Dr {}
      He(hf, "MODEL_CLASS_MAPPINGS", [Xd]);
      class mf extends Dr {}
      He(mf, "MODEL_CLASS_MAPPINGS", [Np]);
      class zm extends ge {
        constructor({
          logits: G,
          past_key_values: ie,
          encoder_outputs: Se,
          decoder_attentions: Je = null,
          cross_attentions: at = null
        }) {
          super(),
            (this.logits = G),
            (this.past_key_values = ie),
            (this.encoder_outputs = Se),
            (this.decoder_attentions = Je),
            (this.cross_attentions = at);
        }
      }
      class pr extends ge {
        constructor({ logits: G }) {
          super(), (this.logits = G);
        }
      }
      class gf extends ge {
        constructor({ logits: G, embeddings: ie }) {
          super(), (this.logits = G), (this.embeddings = ie);
        }
      }
      class yn extends ge {
        constructor({ logits: G }) {
          super(), (this.logits = G);
        }
      }
      class bn extends ge {
        constructor({ logits: G }) {
          super(), (this.logits = G);
        }
      }
      class Fn extends ge {
        constructor({ start_logits: G, end_logits: ie }) {
          super(), (this.start_logits = G), (this.end_logits = ie);
        }
      }
      class oo extends ge {
        constructor({ logits: G }) {
          super(), (this.logits = G);
        }
      }
      class Wp extends ge {
        constructor({ logits: G, past_key_values: ie }) {
          super(), (this.logits = G), (this.past_key_values = ie);
        }
      }
      class _f extends ge {
        constructor({ alphas: G }) {
          super(), (this.alphas = G);
        }
      }
      class yf extends ge {
        constructor({ waveform: G, spectrogram: ie }) {
          super(), (this.waveform = G), (this.spectrogram = ie);
        }
      }
    },
    "./src/models/whisper/common_whisper.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          WHISPER_LANGUAGE_MAPPING: () => a,
          WHISPER_TO_LANGUAGE_CODE_MAPPING: () => l,
          whisper_language_to_code: () => f
        });
      const o = [
          ["en", "english"],
          ["zh", "chinese"],
          ["de", "german"],
          ["es", "spanish"],
          ["ru", "russian"],
          ["ko", "korean"],
          ["fr", "french"],
          ["ja", "japanese"],
          ["pt", "portuguese"],
          ["tr", "turkish"],
          ["pl", "polish"],
          ["ca", "catalan"],
          ["nl", "dutch"],
          ["ar", "arabic"],
          ["sv", "swedish"],
          ["it", "italian"],
          ["id", "indonesian"],
          ["hi", "hindi"],
          ["fi", "finnish"],
          ["vi", "vietnamese"],
          ["he", "hebrew"],
          ["uk", "ukrainian"],
          ["el", "greek"],
          ["ms", "malay"],
          ["cs", "czech"],
          ["ro", "romanian"],
          ["da", "danish"],
          ["hu", "hungarian"],
          ["ta", "tamil"],
          ["no", "norwegian"],
          ["th", "thai"],
          ["ur", "urdu"],
          ["hr", "croatian"],
          ["bg", "bulgarian"],
          ["lt", "lithuanian"],
          ["la", "latin"],
          ["mi", "maori"],
          ["ml", "malayalam"],
          ["cy", "welsh"],
          ["sk", "slovak"],
          ["te", "telugu"],
          ["fa", "persian"],
          ["lv", "latvian"],
          ["bn", "bengali"],
          ["sr", "serbian"],
          ["az", "azerbaijani"],
          ["sl", "slovenian"],
          ["kn", "kannada"],
          ["et", "estonian"],
          ["mk", "macedonian"],
          ["br", "breton"],
          ["eu", "basque"],
          ["is", "icelandic"],
          ["hy", "armenian"],
          ["ne", "nepali"],
          ["mn", "mongolian"],
          ["bs", "bosnian"],
          ["kk", "kazakh"],
          ["sq", "albanian"],
          ["sw", "swahili"],
          ["gl", "galician"],
          ["mr", "marathi"],
          ["pa", "punjabi"],
          ["si", "sinhala"],
          ["km", "khmer"],
          ["sn", "shona"],
          ["yo", "yoruba"],
          ["so", "somali"],
          ["af", "afrikaans"],
          ["oc", "occitan"],
          ["ka", "georgian"],
          ["be", "belarusian"],
          ["tg", "tajik"],
          ["sd", "sindhi"],
          ["gu", "gujarati"],
          ["am", "amharic"],
          ["yi", "yiddish"],
          ["lo", "lao"],
          ["uz", "uzbek"],
          ["fo", "faroese"],
          ["ht", "haitian creole"],
          ["ps", "pashto"],
          ["tk", "turkmen"],
          ["nn", "nynorsk"],
          ["mt", "maltese"],
          ["sa", "sanskrit"],
          ["lb", "luxembourgish"],
          ["my", "myanmar"],
          ["bo", "tibetan"],
          ["tl", "tagalog"],
          ["mg", "malagasy"],
          ["as", "assamese"],
          ["tt", "tatar"],
          ["haw", "hawaiian"],
          ["ln", "lingala"],
          ["ha", "hausa"],
          ["ba", "bashkir"],
          ["jw", "javanese"],
          ["su", "sundanese"]
        ],
        a = new Map(o),
        l = new Map([
          ...o.map(([_, m]) => [m, _]),
          ["burmese", "my"],
          ["valencian", "ca"],
          ["flemish", "nl"],
          ["haitian", "ht"],
          ["letzeburgesch", "lb"],
          ["pushto", "ps"],
          ["panjabi", "pa"],
          ["moldavian", "ro"],
          ["moldovan", "ro"],
          ["sinhalese", "si"],
          ["castilian", "es"]
        ]);
      function f(_) {
        _ = _.toLowerCase();
        let m = l.get(_);
        if (m === void 0)
          if (a.has(_)) m = _;
          else {
            const M = _.length === 2 ? a.keys() : a.values();
            throw new Error(
              `Language "${_}" is not supported. Must be one of: ${JSON.stringify(
                M
              )}`
            );
          }
        return m;
      }
    },
    "./src/models/whisper/generation_whisper.js": (e, t, n) => {
      n.r(t), n.d(t, { WhisperGenerationConfig: () => a });
      var o = n("./src/generation/configuration_utils.js");
      class a extends o.GenerationConfig {
        constructor() {
          super(...arguments);
          He(this, "return_timestamps", null);
          He(this, "return_token_timestamps", null);
          He(this, "num_frames", null);
          He(this, "alignment_heads", null);
          He(this, "task", null);
          He(this, "language", null);
          He(this, "no_timestamps_token_id", null);
          He(this, "prompt_ids", null);
          He(this, "is_multilingual", null);
          He(this, "lang_to_id", null);
          He(this, "task_to_id", null);
          He(this, "max_initial_timestamp_index", 1);
        }
      }
    },
    "./src/ops/registry.js": (e, t, n) => {
      n.r(t), n.d(t, { TensorOpRegistry: () => f });
      var o = n("./src/backends/onnx.js"),
        a = n("./src/utils/tensor.js");
      const l = async (_, m, g) => {
        const M = await (0, o.createInferenceSession)(new Uint8Array(_), m);
        return async (v) => {
          const C = Object.fromEntries(
              Object.entries(v).map(([z, $]) => [z, $.ort_tensor])
            ),
            T = await M.run(C);
          return Array.isArray(g)
            ? g.map((z) => new a.Tensor(T[z]))
            : new a.Tensor(T[g]);
        };
      };
      class f {
        static get bilinear_interpolate_4d() {
          return (
            this._bilinear_interpolate_4d ||
              (this._bilinear_interpolate_4d = l(
                [
                  8, 9, 18, 0, 58, 128, 1, 10, 40, 10, 1, 120, 10, 0, 10, 0, 10,
                  1, 115, 18, 1, 121, 34, 6, 82, 101, 115, 105, 122, 101, 42,
                  17, 10, 4, 109, 111, 100, 101, 34, 6, 108, 105, 110, 101, 97,
                  114, 160, 1, 3, 18, 1, 114, 90, 31, 10, 1, 120, 18, 26, 10,
                  24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3,
                  18, 1, 104, 10, 3, 18, 1, 119, 90, 15, 10, 1, 115, 18, 10, 10,
                  8, 8, 7, 18, 4, 10, 2, 8, 4, 98, 31, 10, 1, 121, 18, 26, 10,
                  24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3,
                  18, 1, 104, 10, 3, 18, 1, 119, 66, 2, 16, 20
                ],
                this.session_options,
                "y"
              )),
            this._bilinear_interpolate_4d
          );
        }
        static get bicubic_interpolate_4d() {
          return (
            this._bicubic_interpolate_4d ||
              (this._bicubic_interpolate_4d = l(
                [
                  8, 9, 18, 0, 58, 127, 10, 39, 10, 1, 120, 10, 0, 10, 0, 10, 1,
                  115, 18, 1, 121, 34, 6, 82, 101, 115, 105, 122, 101, 42, 16,
                  10, 4, 109, 111, 100, 101, 34, 5, 99, 117, 98, 105, 99, 160,
                  1, 3, 18, 1, 114, 90, 31, 10, 1, 120, 18, 26, 10, 24, 8, 1,
                  18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3, 18, 1, 104,
                  10, 3, 18, 1, 119, 90, 15, 10, 1, 115, 18, 10, 10, 8, 8, 7,
                  18, 4, 10, 2, 8, 4, 98, 31, 10, 1, 121, 18, 26, 10, 24, 8, 1,
                  18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 99, 10, 3, 18, 1, 104,
                  10, 3, 18, 1, 119, 66, 2, 16, 20
                ],
                this.session_options,
                "y"
              )),
            this._bicubic_interpolate_4d
          );
        }
        static get matmul() {
          return (
            this._matmul ||
              (this._matmul = l(
                [
                  8, 9, 18, 0, 58, 55, 10, 17, 10, 1, 97, 10, 1, 98, 18, 1, 99,
                  34, 6, 77, 97, 116, 77, 117, 108, 18, 1, 114, 90, 9, 10, 1,
                  97, 18, 4, 10, 2, 8, 1, 90, 9, 10, 1, 98, 18, 4, 10, 2, 8, 1,
                  98, 9, 10, 1, 99, 18, 4, 10, 2, 8, 1, 66, 2, 16, 20
                ],
                this.session_options,
                "c"
              )),
            this._matmul
          );
        }
        static get stft() {
          return (
            this._stft ||
              (this._stft = l(
                [
                  8, 7, 18, 0, 58, 148, 1, 10, 38, 10, 1, 115, 10, 1, 106, 10,
                  1, 119, 10, 1, 108, 18, 1, 111, 34, 4, 83, 84, 70, 84, 42, 15,
                  10, 8, 111, 110, 101, 115, 105, 100, 101, 100, 24, 1, 160, 1,
                  2, 18, 1, 115, 90, 26, 10, 1, 115, 18, 21, 10, 19, 8, 1, 18,
                  15, 10, 3, 18, 1, 98, 10, 3, 18, 1, 115, 10, 3, 18, 1, 99, 90,
                  11, 10, 1, 106, 18, 6, 10, 4, 8, 7, 18, 0, 90, 16, 10, 1, 119,
                  18, 11, 10, 9, 8, 1, 18, 5, 10, 3, 18, 1, 119, 90, 11, 10, 1,
                  108, 18, 6, 10, 4, 8, 7, 18, 0, 98, 31, 10, 1, 111, 18, 26,
                  10, 24, 8, 1, 18, 20, 10, 3, 18, 1, 98, 10, 3, 18, 1, 102, 10,
                  3, 18, 1, 100, 10, 3, 18, 1, 99, 66, 2, 16, 17
                ],
                this.session_options,
                "o"
              )),
            this._stft
          );
        }
        static get rfft() {
          return (
            this._rfft ||
              (this._rfft = l(
                [
                  8, 9, 18, 0, 58, 97, 10, 33, 10, 1, 120, 10, 0, 10, 1, 97, 18,
                  1, 121, 34, 3, 68, 70, 84, 42, 15, 10, 8, 111, 110, 101, 115,
                  105, 100, 101, 100, 24, 1, 160, 1, 2, 18, 1, 100, 90, 21, 10,
                  1, 120, 18, 16, 10, 14, 8, 1, 18, 10, 10, 3, 18, 1, 115, 10,
                  3, 18, 1, 99, 90, 11, 10, 1, 97, 18, 6, 10, 4, 8, 7, 18, 0,
                  98, 21, 10, 1, 121, 18, 16, 10, 14, 8, 1, 18, 10, 10, 3, 18,
                  1, 115, 10, 3, 18, 1, 99, 66, 2, 16, 20
                ],
                this.session_options,
                "y"
              )),
            this._rfft
          );
        }
        static get top_k() {
          return (
            this._top_k ||
              (this._top_k = l(
                [
                  8, 10, 18, 0, 58, 73, 10, 18, 10, 1, 120, 10, 1, 107, 18, 1,
                  118, 18, 1, 105, 34, 4, 84, 111, 112, 75, 18, 1, 116, 90, 9,
                  10, 1, 120, 18, 4, 10, 2, 8, 1, 90, 15, 10, 1, 107, 18, 10,
                  10, 8, 8, 7, 18, 4, 10, 2, 8, 1, 98, 9, 10, 1, 118, 18, 4, 10,
                  2, 8, 1, 98, 9, 10, 1, 105, 18, 4, 10, 2, 8, 7, 66, 2, 16, 21
                ],
                this.session_options,
                ["v", "i"]
              )),
            this._top_k
          );
        }
      }
      He(f, "session_options", {});
    },
    "./src/pipelines.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          AudioClassificationPipeline: () => J,
          AutomaticSpeechRecognitionPipeline: () => L,
          DepthEstimationPipeline: () => Be,
          DocumentQuestionAnsweringPipeline: () => Y,
          FeatureExtractionPipeline: () => de,
          FillMaskPipeline: () => I,
          ImageClassificationPipeline: () => Qe,
          ImageFeatureExtractionPipeline: () => Me,
          ImageSegmentationPipeline: () => _e,
          ImageToImagePipeline: () => qe,
          ImageToTextPipeline: () => Ee,
          ObjectDetectionPipeline: () => oe,
          Pipeline: () => $,
          QuestionAnsweringPipeline: () => x,
          SummarizationPipeline: () => O,
          Text2TextGenerationPipeline: () => V,
          TextClassificationPipeline: () => S,
          TextGenerationPipeline: () => N,
          TextToAudioPipeline: () => ge,
          TokenClassificationPipeline: () => y,
          TranslationPipeline: () => B,
          ZeroShotAudioClassificationPipeline: () => ye,
          ZeroShotClassificationPipeline: () => se,
          ZeroShotImageClassificationPipeline: () => X,
          ZeroShotObjectDetectionPipeline: () => xe,
          pipeline: () => st
        });
      var o = n("./src/tokenizers.js"),
        a = n("./src/models.js"),
        l = n("./src/processors.js"),
        f = n("./src/utils/generic.js"),
        _ = n("./src/utils/core.js"),
        m = n("./src/utils/maths.js"),
        g = n("./src/utils/audio.js"),
        M = n("./src/utils/tensor.js"),
        v = n("./src/utils/image.js");
      async function C(Ge) {
        return (
          Array.isArray(Ge) || (Ge = [Ge]),
          await Promise.all(Ge.map((Te) => v.RawImage.read(Te)))
        );
      }
      async function T(Ge, Te) {
        return (
          Array.isArray(Ge) || (Ge = [Ge]),
          await Promise.all(
            Ge.map((je) =>
              typeof je == "string" || je instanceof URL
                ? (0, g.read_audio)(je, Te)
                : je instanceof Float64Array
                ? new Float32Array(je)
                : je
            )
          )
        );
      }
      function z(Ge, Te) {
        Te && (Ge = Ge.map((Ae) => Ae | 0));
        const [je, Ye, et, A] = Ge;
        return { xmin: je, ymin: Ye, xmax: et, ymax: A };
      }
      class $ extends f.Callable {
        constructor({
          task: Te,
          model: je,
          tokenizer: Ye = null,
          processor: et = null
        }) {
          super(),
            (this.task = Te),
            (this.model = je),
            (this.tokenizer = Ye),
            (this.processor = et);
        }
        async dispose() {
          await this.model.dispose();
        }
      }
      class S extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, { top_k: je = 1 } = {}) {
          const Ye = this.tokenizer(Te, { padding: !0, truncation: !0 }),
            et = await this.model(Ye),
            A =
              this.model.config.problem_type === "multi_label_classification"
                ? (ae) => ae.sigmoid()
                : (ae) =>
                    new M.Tensor("float32", (0, m.softmax)(ae.data), ae.dims),
            Ae = this.model.config.id2label,
            $e = [];
          for (const ae of et.logits) {
            const ne = A(ae),
              ve = await (0, M.topk)(ne, je),
              R = ve[0].tolist(),
              D = ve[1]
                .tolist()
                .map((ce, ue) => ({
                  label: Ae ? Ae[ce] : `LABEL_${ce}`,
                  score: R[ue]
                }));
            je === 1 ? $e.push(...D) : $e.push(D);
          }
          return Array.isArray(Te) || je === 1 ? $e : $e[0];
        }
      }
      class y extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, { ignore_labels: je = ["O"] } = {}) {
          const Ye = Array.isArray(Te),
            et = this.tokenizer(Ye ? Te : [Te], {
              padding: !0,
              truncation: !0
            }),
            Ae = (await this.model(et)).logits,
            $e = this.model.config.id2label,
            ae = [];
          for (let ne = 0; ne < Ae.dims[0]; ++ne) {
            const ve = et.input_ids[ne],
              R = Ae[ne],
              te = [];
            for (let D = 0; D < R.dims[0]; ++D) {
              const ce = R[D],
                ue = (0, m.max)(ce.data)[1],
                ke = $e ? $e[ue] : `LABEL_${ue}`;
              if (je.includes(ke)) continue;
              const Re = this.tokenizer.decode([ve[D].item()], {
                skip_special_tokens: !0
              });
              if (Re === "") continue;
              const ht = (0, m.softmax)(ce.data);
              te.push({ entity: ke, score: ht[ue], index: D, word: Re });
            }
            ae.push(te);
          }
          return Ye ? ae : ae[0];
        }
      }
      class x extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, je, { top_k: Ye = 1 } = {}) {
          const et = this.tokenizer(Te, {
              text_pair: je,
              padding: !0,
              truncation: !0
            }),
            { start_logits: A, end_logits: Ae } = await this.model(et),
            $e = et.input_ids.tolist(),
            ae = et.attention_mask.tolist(),
            ne = this.tokenizer.all_special_ids,
            ve = [];
          for (let R = 0; R < A.dims[0]; ++R) {
            const te = $e[R],
              D = te.findIndex((tt) => tt == this.tokenizer.sep_token_id);
            ae[R].map(
              (tt, wt) =>
                tt == 1 &&
                (wt === 0 ||
                  (wt > D && ne.findIndex((bt) => bt == te[wt]) === -1))
            );
            const ce = A[R].tolist(),
              ue = Ae[R].tolist();
            for (let tt = 1; tt < ce.length; ++tt)
              (ae[R] == 0 ||
                tt <= D ||
                ne.findIndex((wt) => wt == te[tt]) !== -1) &&
                ((ce[tt] = -1 / 0), (ue[tt] = -1 / 0));
            const ke = (0, m.softmax)(ce).map((tt, wt) => [tt, wt]),
              Re = (0, m.softmax)(ue).map((tt, wt) => [tt, wt]);
            (ke[0][0] = 0), (Re[0][0] = 0);
            const ht = (0, _.product)(ke, Re)
              .filter((tt) => tt[0][1] <= tt[1][1])
              .map((tt) => [tt[0][1], tt[1][1], tt[0][0] * tt[1][0]])
              .sort((tt, wt) => wt[2] - tt[2]);
            for (let tt = 0; tt < Math.min(ht.length, Ye); ++tt) {
              const [wt, bt, Ke] = ht[tt],
                fe = te.slice(wt, bt + 1),
                Ie = this.tokenizer.decode(fe, { skip_special_tokens: !0 });
              ve.push({ answer: Ie, score: Ke });
            }
          }
          return Ye === 1 ? ve[0] : ve;
        }
      }
      class I extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, { top_k: je = 5 } = {}) {
          const Ye = this.tokenizer(Te, { padding: !0, truncation: !0 }),
            { logits: et } = await this.model(Ye),
            A = [],
            Ae = Ye.input_ids.tolist();
          for (let $e = 0; $e < Ae.length; ++$e) {
            const ae = Ae[$e],
              ne = ae.findIndex((ce) => ce == this.tokenizer.mask_token_id);
            if (ne === -1)
              throw Error(
                `Mask token (${this.tokenizer.mask_token}) not found in text.`
              );
            const ve = et[$e][ne],
              R = await (0, M.topk)(
                new M.Tensor("float32", (0, m.softmax)(ve.data), ve.dims),
                je
              ),
              te = R[0].tolist(),
              D = R[1].tolist();
            A.push(
              D.map((ce, ue) => {
                const ke = ae.slice();
                return (
                  (ke[ne] = ce),
                  {
                    score: te[ue],
                    token: Number(ce),
                    token_str: this.tokenizer.model.vocab[ce],
                    sequence: this.tokenizer.decode(ke, {
                      skip_special_tokens: !0
                    })
                  }
                );
              })
            );
          }
          return Array.isArray(Te) ? A : A[0];
        }
      }
      class V extends $ {
        constructor(je) {
          super(je);
          He(this, "_key", "generated_text");
        }
        async _call(je, Ye = {}) {
          Array.isArray(je) || (je = [je]),
            this.model.config.prefix &&
              (je = je.map((ne) => this.model.config.prefix + ne));
          const et = this.model.config.task_specific_params;
          et &&
            et[this.task] &&
            et[this.task].prefix &&
            (je = je.map((ne) => et[this.task].prefix + ne));
          const A = this.tokenizer,
            Ae = { padding: !0, truncation: !0 };
          let $e;
          this instanceof B && "_build_translation_inputs" in A
            ? ($e = A._build_translation_inputs(je, Ae, Ye))
            : ($e = A(je, Ae));
          const ae = await this.model.generate({ ...$e, ...Ye });
          return A.batch_decode(ae, { skip_special_tokens: !0 }).map((ne) => ({
            [this._key]: ne
          }));
        }
      }
      class O extends V {
        constructor(je) {
          super(je);
          He(this, "_key", "summary_text");
        }
      }
      class B extends V {
        constructor(je) {
          super(je);
          He(this, "_key", "translation_text");
        }
      }
      function j(Ge) {
        return (
          Array.isArray(Ge) && Ge.every((Te) => "role" in Te && "content" in Te)
        );
      }
      class N extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, je = {}) {
          let Ye = !1,
            et = !1,
            A;
          if (typeof Te == "string") A = Te = [Te];
          else if (Array.isArray(Te) && Te.every((D) => typeof D == "string"))
            (Ye = !0), (A = Te);
          else {
            if (j(Te)) Te = [Te];
            else if (Array.isArray(Te) && Te.every(j)) Ye = !0;
            else
              throw new Error(
                "Input must be a string, an array of strings, a Chat, or an array of Chats"
              );
            (et = !0),
              (A = Te.map((D) =>
                this.tokenizer.apply_chat_template(D, {
                  tokenize: !1,
                  add_generation_prompt: !0
                })
              ));
          }
          const Ae = je.add_special_tokens ?? !1,
            $e = et ? !1 : je.return_full_text ?? !0;
          this.tokenizer.padding_side = "left";
          const ae = this.tokenizer(A, {
              add_special_tokens: Ae,
              padding: !0,
              truncation: !0
            }),
            ne = await this.model.generate({ ...ae, ...je }),
            ve = this.tokenizer.batch_decode(ne, { skip_special_tokens: !0 });
          let R;
          !$e &&
            ae.input_ids.dims.at(-1) > 0 &&
            (R = this.tokenizer
              .batch_decode(ae.input_ids, { skip_special_tokens: !0 })
              .map((D) => D.length));
          const te = Array.from({ length: Te.length }, (D) => []);
          for (let D = 0; D < ve.length; ++D) {
            const ce = Math.floor((D / ne.dims[0]) * Te.length);
            R && (ve[D] = ve[D].slice(R[ce])),
              te[ce].push({
                generated_text: et
                  ? [...Te[ce], { role: "assistant", content: ve[D] }]
                  : ve[D]
              });
          }
          return !Ye && te.length === 1 ? te[0] : te;
        }
      }
      class se extends $ {
        constructor(Te) {
          super(Te),
            (this.label2id = Object.fromEntries(
              Object.entries(this.model.config.label2id).map(([je, Ye]) => [
                je.toLowerCase(),
                Ye
              ])
            )),
            (this.entailment_id = this.label2id.entailment),
            this.entailment_id === void 0 &&
              (console.warn(
                "Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."
              ),
              (this.entailment_id = 2)),
            (this.contradiction_id =
              this.label2id.contradiction ?? this.label2id.not_entailment),
            this.contradiction_id === void 0 &&
              (console.warn(
                "Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."
              ),
              (this.contradiction_id = 0));
        }
        async _call(
          Te,
          je,
          {
            hypothesis_template: Ye = "This example is {}.",
            multi_label: et = !1
          } = {}
        ) {
          const A = Array.isArray(Te);
          A || (Te = [Te]), Array.isArray(je) || (je = [je]);
          const Ae = je.map((ne) => Ye.replace("{}", ne)),
            $e = et || je.length === 1,
            ae = [];
          for (const ne of Te) {
            const ve = [];
            for (const D of Ae) {
              const ce = this.tokenizer(ne, {
                  text_pair: D,
                  padding: !0,
                  truncation: !0
                }),
                ue = await this.model(ce);
              $e
                ? ve.push([
                    ue.logits.data[this.contradiction_id],
                    ue.logits.data[this.entailment_id]
                  ])
                : ve.push(ue.logits.data[this.entailment_id]);
            }
            const te = (
              $e ? ve.map((D) => (0, m.softmax)(D)[1]) : (0, m.softmax)(ve)
            )
              .map((D, ce) => [D, ce])
              .sort((D, ce) => ce[0] - D[0]);
            ae.push({
              sequence: ne,
              labels: te.map((D) => je[D[1]]),
              scores: te.map((D) => D[0])
            });
          }
          return A ? ae : ae[0];
        }
      }
      class de extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(
          Te,
          {
            pooling: je = "none",
            normalize: Ye = !1,
            quantize: et = !1,
            precision: A = "binary"
          } = {}
        ) {
          const Ae = this.tokenizer(Te, { padding: !0, truncation: !0 }),
            $e = await this.model(Ae);
          let ae = $e.last_hidden_state ?? $e.logits ?? $e.token_embeddings;
          if (je !== "none")
            if (je === "mean") ae = (0, M.mean_pooling)(ae, Ae.attention_mask);
            else if (je === "cls") ae = ae.slice(null, 0);
            else throw Error(`Pooling method '${je}' not supported.`);
          return (
            Ye && (ae = ae.normalize(2, -1)),
            et && (ae = (0, M.quantize_embeddings)(ae, A)),
            ae
          );
        }
      }
      class Me extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, { pool: je = null } = {}) {
          const Ye = await C(Te),
            { pixel_values: et } = await this.processor(Ye),
            A = await this.model({ pixel_values: et });
          let Ae;
          if (je) {
            if (!("pooler_output" in A))
              throw Error(
                "No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option."
              );
            Ae = A.pooler_output;
          } else Ae = A.last_hidden_state ?? A.logits ?? A.image_embeds;
          return Ae;
        }
      }
      class J extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, { top_k: je = 5 } = {}) {
          const Ye = this.processor.feature_extractor.config.sampling_rate,
            et = await T(Te, Ye),
            A = this.model.config.id2label,
            Ae = [];
          for (const $e of et) {
            const ae = await this.processor($e),
              ve = (await this.model(ae)).logits[0],
              R = await (0, M.topk)(
                new M.Tensor("float32", (0, m.softmax)(ve.data), ve.dims),
                je
              ),
              te = R[0].tolist(),
              ce = R[1]
                .tolist()
                .map((ue, ke) => ({
                  label: A ? A[ue] : `LABEL_${ue}`,
                  score: te[ke]
                }));
            Ae.push(ce);
          }
          return Array.isArray(Te) ? Ae : Ae[0];
        }
      }
      class ye extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(
          Te,
          je,
          { hypothesis_template: Ye = "This is a sound of {}." } = {}
        ) {
          const et = !Array.isArray(Te);
          et && (Te = [Te]);
          const A = je.map((ve) => Ye.replace("{}", ve)),
            Ae = this.tokenizer(A, { padding: !0, truncation: !0 }),
            $e = this.processor.feature_extractor.config.sampling_rate,
            ae = await T(Te, $e),
            ne = [];
          for (const ve of ae) {
            const R = await this.processor(ve),
              te = await this.model({ ...Ae, ...R }),
              D = (0, m.softmax)(te.logits_per_audio.data);
            ne.push([...D].map((ce, ue) => ({ score: ce, label: je[ue] })));
          }
          return et ? ne[0] : ne;
        }
      }
      class L extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, je = {}) {
          switch (this.model.config.model_type) {
            case "whisper":
              return this._call_whisper(Te, je);
            case "wav2vec2":
            case "wav2vec2-bert":
            case "unispeech":
            case "unispeech-sat":
            case "hubert":
              return this._call_wav2vec2(Te, je);
            default:
              throw new Error(
                `AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`
              );
          }
        }
        async _call_wav2vec2(Te, je) {
          je.language &&
            console.warn(
              '`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'
            ),
            je.task &&
              console.warn(
                '`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".'
              );
          const Ye = !Array.isArray(Te);
          Ye && (Te = [Te]);
          const et = this.processor.feature_extractor.config.sampling_rate,
            A = await T(Te, et),
            Ae = [];
          for (const $e of A) {
            const ae = await this.processor($e),
              ve = (await this.model(ae)).logits[0],
              R = [];
            for (const D of ve) R.push((0, m.max)(D.data)[1]);
            const te = this.tokenizer.decode(R);
            Ae.push({ text: te });
          }
          return Ye ? Ae[0] : Ae;
        }
        async _call_whisper(Te, je) {
          const Ye = je.return_timestamps ?? !1,
            et = je.chunk_length_s ?? 0,
            A = je.force_full_sequences ?? !1;
          let Ae = je.stride_length_s ?? null;
          const $e = { ...je };
          Ye === "word" &&
            (($e.return_token_timestamps = !0), ($e.return_timestamps = !1));
          const ae = !Array.isArray(Te);
          ae && (Te = [Te]);
          const ne =
              this.processor.feature_extractor.config.chunk_length /
              this.model.config.max_source_positions,
            ve = this.processor.feature_extractor.config.hop_length,
            R = this.processor.feature_extractor.config.sampling_rate,
            te = await T(Te, R),
            D = [];
          for (const ce of te) {
            let ue = [];
            if (et > 0) {
              if (Ae === null) Ae = et / 6;
              else if (et <= Ae)
                throw Error(
                  "`chunk_length_s` must be larger than `stride_length_s`."
                );
              const ht = R * et,
                tt = R * Ae,
                wt = ht - 2 * tt;
              let bt = 0;
              for (;;) {
                const Ke = bt + ht,
                  fe = ce.subarray(bt, Ke),
                  Ie = await this.processor(fe),
                  Ve = bt === 0,
                  ot = Ke >= ce.length;
                if (
                  (ue.push({
                    stride: [fe.length, Ve ? 0 : tt, ot ? 0 : tt],
                    input_features: Ie.input_features,
                    is_last: ot
                  }),
                  ot)
                )
                  break;
                bt += wt;
              }
            } else
              ue = [
                {
                  stride: [ce.length, 0, 0],
                  input_features: (await this.processor(ce)).input_features,
                  is_last: !0
                }
              ];
            for (const ht of ue) {
              $e.num_frames = Math.floor(ht.stride[0] / ve);
              const tt = await this.model.generate({
                inputs: ht.input_features,
                ...$e
              });
              Ye === "word"
                ? ((ht.tokens = tt.sequences.tolist()[0]),
                  (ht.token_timestamps = tt.token_timestamps
                    .tolist()[0]
                    .map((wt) => (0, m.round)(wt, 2))))
                : (ht.tokens = tt[0].tolist()),
                (ht.stride = ht.stride.map((wt) => wt / R));
            }
            const [ke, Re] = this.tokenizer._decode_asr(ue, {
              time_precision: ne,
              return_timestamps: Ye,
              force_full_sequences: A
            });
            D.push({ text: ke, ...Re });
          }
          return ae ? D[0] : D;
        }
      }
      class Ee extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, je = {}) {
          const Ye = Array.isArray(Te),
            et = await C(Te),
            { pixel_values: A } = await this.processor(et),
            Ae = [];
          for (const $e of A) {
            $e.dims = [1, ...$e.dims];
            const ae = await this.model.generate({ inputs: $e, ...je }),
              ne = this.tokenizer
                .batch_decode(ae, { skip_special_tokens: !0 })
                .map((ve) => ({ generated_text: ve.trim() }));
            Ae.push(ne);
          }
          return Ye ? Ae : Ae[0];
        }
      }
      class Qe extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, { top_k: je = 5 } = {}) {
          const Ye = await C(Te),
            { pixel_values: et } = await this.processor(Ye),
            A = await this.model({ pixel_values: et }),
            Ae = this.model.config.id2label,
            $e = [];
          for (const ae of A.logits) {
            const ne = await (0, M.topk)(
                new M.Tensor("float32", (0, m.softmax)(ae.data), ae.dims),
                je
              ),
              ve = ne[0].tolist(),
              te = ne[1]
                .tolist()
                .map((D, ce) => ({
                  label: Ae ? Ae[D] : `LABEL_${D}`,
                  score: ve[ce]
                }));
            $e.push(te);
          }
          return Array.isArray(Te) ? $e : $e[0];
        }
      }
      class _e extends $ {
        constructor(Te) {
          super(Te),
            (this.subtasks_mapping = {
              panoptic: "post_process_panoptic_segmentation",
              instance: "post_process_instance_segmentation",
              semantic: "post_process_semantic_segmentation"
            });
        }
        async _call(
          Te,
          {
            threshold: je = 0.5,
            mask_threshold: Ye = 0.5,
            overlap_mask_area_threshold: et = 0.8,
            label_ids_to_fuse: A = null,
            target_sizes: Ae = null,
            subtask: $e = null
          } = {}
        ) {
          if (Array.isArray(Te) && Te.length !== 1)
            throw Error(
              "Image segmentation pipeline currently only supports a batch size of 1."
            );
          const ne = await C(Te),
            ve = ne.map((Re) => [Re.height, Re.width]),
            { pixel_values: R, pixel_mask: te } = await this.processor(ne),
            D = await this.model({ pixel_values: R, pixel_mask: te });
          let ce = null;
          if ($e !== null) ce = this.subtasks_mapping[$e];
          else
            for (let [Re, ht] of Object.entries(this.subtasks_mapping))
              if (ht in this.processor.feature_extractor) {
                (ce = this.processor.feature_extractor[ht].bind(
                  this.processor.feature_extractor
                )),
                  ($e = Re);
                break;
              }
          const ue = this.model.config.id2label,
            ke = [];
          if ($e === "panoptic" || $e === "instance") {
            const Re = ce(D, je, Ye, et, A, Ae ?? ve)[0],
              ht = Re.segmentation;
            for (const tt of Re.segments_info) {
              const wt = new Uint8ClampedArray(ht.data.length);
              for (let Ke = 0; Ke < ht.data.length; ++Ke)
                ht.data[Ke] === tt.id && (wt[Ke] = 255);
              const bt = new v.RawImage(wt, ht.dims[1], ht.dims[0], 1);
              ke.push({ score: tt.score, label: ue[tt.label_id], mask: bt });
            }
          } else if ($e === "semantic") {
            const { segmentation: Re, labels: ht } = ce(D, Ae ?? ve)[0];
            for (const tt of ht) {
              const wt = new Uint8ClampedArray(Re.data.length);
              for (let Ke = 0; Ke < Re.data.length; ++Ke)
                Re.data[Ke] === tt && (wt[Ke] = 255);
              const bt = new v.RawImage(wt, Re.dims[1], Re.dims[0], 1);
              ke.push({ score: null, label: ue[tt], mask: bt });
            }
          } else throw Error(`Subtask ${$e} not supported.`);
          return ke;
        }
      }
      class X extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(
          Te,
          je,
          { hypothesis_template: Ye = "This is a photo of {}" } = {}
        ) {
          const et = Array.isArray(Te),
            A = await C(Te),
            Ae = je.map((te) => Ye.replace("{}", te)),
            $e = this.tokenizer(Ae, {
              padding:
                this.model.config.model_type === "siglip" ? "max_length" : !0,
              truncation: !0
            }),
            { pixel_values: ae } = await this.processor(A),
            ne = await this.model({ ...$e, pixel_values: ae }),
            ve =
              this.model.config.model_type === "siglip"
                ? (te) => te.sigmoid().data
                : (te) => (0, m.softmax)(te.data),
            R = [];
          for (const te of ne.logits_per_image) {
            const ce = [...ve(te)].map((ue, ke) => ({
              score: ue,
              label: je[ke]
            }));
            ce.sort((ue, ke) => ke.score - ue.score), R.push(ce);
          }
          return et ? R : R[0];
        }
      }
      class oe extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, { threshold: je = 0.9, percentage: Ye = !1 } = {}) {
          const et = Array.isArray(Te);
          if (et && Te.length !== 1)
            throw Error(
              "Object detection pipeline currently only supports a batch size of 1."
            );
          const A = await C(Te),
            Ae = Ye ? null : A.map((D) => [D.height, D.width]),
            { pixel_values: $e, pixel_mask: ae } = await this.processor(A),
            ne = await this.model({ pixel_values: $e, pixel_mask: ae }),
            ve = this.processor.feature_extractor.post_process_object_detection(
              ne,
              je,
              Ae
            ),
            R = this.model.config.id2label,
            te = ve.map((D) =>
              D.boxes.map((ce, ue) => ({
                score: D.scores[ue],
                label: R[D.classes[ue]],
                box: z(ce, !Ye)
              }))
            );
          return et ? te : te[0];
        }
      }
      class xe extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(
          Te,
          je,
          { threshold: Ye = 0.1, top_k: et = null, percentage: A = !1 } = {}
        ) {
          const Ae = Array.isArray(Te),
            $e = await C(Te),
            ae = this.tokenizer(je, { padding: !0, truncation: !0 }),
            ne = await this.processor($e),
            ve = [];
          for (let R = 0; R < $e.length; ++R) {
            const te = $e[R],
              D = A ? null : [[te.height, te.width]],
              ce = ne.pixel_values[R].unsqueeze_(0),
              ue = await this.model({ ...ae, pixel_values: ce }),
              ke =
                this.processor.feature_extractor.post_process_object_detection(
                  ue,
                  Ye,
                  D,
                  !0
                )[0];
            let Re = ke.boxes
              .map((ht, tt) => ({
                score: ke.scores[tt],
                label: je[ke.classes[tt]],
                box: z(ht, !A)
              }))
              .sort((ht, tt) => tt.score - ht.score);
            et !== null && (Re = Re.slice(0, et)), ve.push(Re);
          }
          return Ae ? ve : ve[0];
        }
      }
      class Y extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te, je, Ye = {}) {
          throw new Error(
            "This pipeline is not yet supported in Transformers.js v3."
          );
        }
      }
      class ge extends $ {
        constructor(je) {
          super(je);
          He(this, "DEFAULT_VOCODER_ID", "Xenova/speecht5_hifigan");
          this.vocoder = je.vocoder ?? null;
        }
        async _call(je, { speaker_embeddings: Ye = null } = {}) {
          return this.processor
            ? this._call_text_to_spectrogram(je, { speaker_embeddings: Ye })
            : this._call_text_to_waveform(je);
        }
        async _call_text_to_waveform(je) {
          const Ye = this.tokenizer(je, { padding: !0, truncation: !0 }),
            { waveform: et } = await this.model(Ye),
            A = this.model.config.sampling_rate;
          return { audio: et.data, sampling_rate: A };
        }
        async _call_text_to_spectrogram(je, { speaker_embeddings: Ye }) {
          if (
            (this.vocoder ||
              (console.log(
                "No vocoder specified, using default HifiGan vocoder."
              ),
              (this.vocoder = await a.AutoModel.from_pretrained(
                this.DEFAULT_VOCODER_ID,
                { dtype: "fp32" }
              ))),
            (typeof Ye == "string" || Ye instanceof URL) &&
              (Ye = new Float32Array(await (await fetch(Ye)).arrayBuffer())),
            Ye instanceof Float32Array)
          )
            Ye = new M.Tensor("float32", Ye, [1, Ye.length]);
          else if (!(Ye instanceof M.Tensor))
            throw new Error(
              "Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`."
            );
          const { input_ids: et } = this.tokenizer(je, {
              padding: !0,
              truncation: !0
            }),
            { waveform: A } = await this.model.generate_speech(et, Ye, {
              vocoder: this.vocoder
            }),
            Ae = this.processor.feature_extractor.config.sampling_rate;
          return { audio: A.data, sampling_rate: Ae };
        }
      }
      class qe extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te) {
          const je = await C(Te),
            Ye = await this.processor(je),
            et = await this.model(Ye),
            A = [];
          for (const Ae of et.reconstruction) {
            const $e = Ae.squeeze().clamp_(0, 1).mul_(255).round_().to("uint8");
            A.push(v.RawImage.fromTensor($e));
          }
          return A.length > 1 ? A : A[0];
        }
      }
      class Be extends $ {
        constructor(Te) {
          super(Te);
        }
        async _call(Te) {
          const je = await C(Te),
            Ye = await this.processor(je),
            { predicted_depth: et } = await this.model(Ye),
            A = [];
          for (let Ae = 0; Ae < je.length; ++Ae) {
            const $e = (0, M.interpolate)(
                et[Ae],
                je[Ae].size.reverse(),
                "bilinear",
                !1
              ),
              ae = $e.mul_(255 / (0, m.max)($e.data)[0]).to("uint8");
            A.push({
              predicted_depth: et[Ae],
              depth: v.RawImage.fromTensor(ae)
            });
          }
          return A.length > 1 ? A : A[0];
        }
      }
      const Ne = Object.freeze({
          "text-classification": {
            tokenizer: o.AutoTokenizer,
            pipeline: S,
            model: a.AutoModelForSequenceClassification,
            default: {
              model: "Xenova/distilbert-base-uncased-finetuned-sst-2-english"
            },
            type: "text"
          },
          "token-classification": {
            tokenizer: o.AutoTokenizer,
            pipeline: y,
            model: a.AutoModelForTokenClassification,
            default: { model: "Xenova/bert-base-multilingual-cased-ner-hrl" },
            type: "text"
          },
          "question-answering": {
            tokenizer: o.AutoTokenizer,
            pipeline: x,
            model: a.AutoModelForQuestionAnswering,
            default: { model: "Xenova/distilbert-base-cased-distilled-squad" },
            type: "text"
          },
          "fill-mask": {
            tokenizer: o.AutoTokenizer,
            pipeline: I,
            model: a.AutoModelForMaskedLM,
            default: { model: "Xenova/bert-base-uncased" },
            type: "text"
          },
          summarization: {
            tokenizer: o.AutoTokenizer,
            pipeline: O,
            model: a.AutoModelForSeq2SeqLM,
            default: { model: "Xenova/distilbart-cnn-6-6" },
            type: "text"
          },
          translation: {
            tokenizer: o.AutoTokenizer,
            pipeline: B,
            model: a.AutoModelForSeq2SeqLM,
            default: { model: "Xenova/t5-small" },
            type: "text"
          },
          "text2text-generation": {
            tokenizer: o.AutoTokenizer,
            pipeline: V,
            model: a.AutoModelForSeq2SeqLM,
            default: { model: "Xenova/flan-t5-small" },
            type: "text"
          },
          "text-generation": {
            tokenizer: o.AutoTokenizer,
            pipeline: N,
            model: a.AutoModelForCausalLM,
            default: { model: "Xenova/gpt2" },
            type: "text"
          },
          "zero-shot-classification": {
            tokenizer: o.AutoTokenizer,
            pipeline: se,
            model: a.AutoModelForSequenceClassification,
            default: { model: "Xenova/distilbert-base-uncased-mnli" },
            type: "text"
          },
          "audio-classification": {
            pipeline: J,
            model: a.AutoModelForAudioClassification,
            processor: l.AutoProcessor,
            default: { model: "Xenova/wav2vec2-base-superb-ks" },
            type: "audio"
          },
          "zero-shot-audio-classification": {
            tokenizer: o.AutoTokenizer,
            pipeline: ye,
            model: a.AutoModel,
            processor: l.AutoProcessor,
            default: { model: "Xenova/clap-htsat-unfused" },
            type: "multimodal"
          },
          "automatic-speech-recognition": {
            tokenizer: o.AutoTokenizer,
            pipeline: L,
            model: [a.AutoModelForSpeechSeq2Seq, a.AutoModelForCTC],
            processor: l.AutoProcessor,
            default: { model: "Xenova/whisper-tiny.en" },
            type: "multimodal"
          },
          "text-to-audio": {
            tokenizer: o.AutoTokenizer,
            pipeline: ge,
            model: [
              a.AutoModelForTextToWaveform,
              a.AutoModelForTextToSpectrogram
            ],
            processor: [l.AutoProcessor, null],
            default: { model: "Xenova/speecht5_tts" },
            type: "text"
          },
          "image-to-text": {
            tokenizer: o.AutoTokenizer,
            pipeline: Ee,
            model: a.AutoModelForVision2Seq,
            processor: l.AutoProcessor,
            default: { model: "Xenova/vit-gpt2-image-captioning" },
            type: "multimodal"
          },
          "image-classification": {
            pipeline: Qe,
            model: a.AutoModelForImageClassification,
            processor: l.AutoProcessor,
            default: { model: "Xenova/vit-base-patch16-224" },
            type: "multimodal"
          },
          "image-segmentation": {
            pipeline: _e,
            model: [
              a.AutoModelForImageSegmentation,
              a.AutoModelForSemanticSegmentation
            ],
            processor: l.AutoProcessor,
            default: { model: "Xenova/detr-resnet-50-panoptic" },
            type: "multimodal"
          },
          "zero-shot-image-classification": {
            tokenizer: o.AutoTokenizer,
            pipeline: X,
            model: a.AutoModel,
            processor: l.AutoProcessor,
            default: { model: "Xenova/clip-vit-base-patch32" },
            type: "multimodal"
          },
          "object-detection": {
            pipeline: oe,
            model: a.AutoModelForObjectDetection,
            processor: l.AutoProcessor,
            default: { model: "Xenova/detr-resnet-50" },
            type: "multimodal"
          },
          "zero-shot-object-detection": {
            tokenizer: o.AutoTokenizer,
            pipeline: xe,
            model: a.AutoModelForZeroShotObjectDetection,
            processor: l.AutoProcessor,
            default: { model: "Xenova/owlvit-base-patch32" },
            type: "multimodal"
          },
          "document-question-answering": {
            tokenizer: o.AutoTokenizer,
            pipeline: Y,
            model: a.AutoModelForDocumentQuestionAnswering,
            processor: l.AutoProcessor,
            default: { model: "Xenova/donut-base-finetuned-docvqa" },
            type: "multimodal"
          },
          "image-to-image": {
            pipeline: qe,
            model: a.AutoModelForImageToImage,
            processor: l.AutoProcessor,
            default: { model: "Xenova/swin2SR-classical-sr-x2-64" },
            type: "image"
          },
          "depth-estimation": {
            pipeline: Be,
            model: a.AutoModelForDepthEstimation,
            processor: l.AutoProcessor,
            default: { model: "Xenova/dpt-large" },
            type: "image"
          },
          "feature-extraction": {
            tokenizer: o.AutoTokenizer,
            pipeline: de,
            model: a.AutoModel,
            default: { model: "Xenova/all-MiniLM-L6-v2" },
            type: "text"
          },
          "image-feature-extraction": {
            processor: l.AutoProcessor,
            pipeline: Me,
            model: [a.AutoModelForImageFeatureExtraction, a.AutoModel],
            default: { model: "Xenova/vit-base-patch16-224-in21k" },
            type: "image"
          }
        }),
        We = Object.freeze({
          "sentiment-analysis": "text-classification",
          ner: "token-classification",
          asr: "automatic-speech-recognition",
          "text-to-speech": "text-to-audio",
          embeddings: "feature-extraction"
        });
      async function st(
        Ge,
        Te = null,
        {
          progress_callback: je = null,
          config: Ye = null,
          cache_dir: et = null,
          local_files_only: A = !1,
          revision: Ae = "main",
          device: $e = null,
          dtype: ae = null,
          model_file_name: ne = null,
          session_options: ve = {}
        } = {}
      ) {
        Ge = We[Ge] ?? Ge;
        const R = Ne[Ge.split("_", 1)[0]];
        if (!R)
          throw Error(
            `Unsupported pipeline: ${Ge}. Must be one of [${Object.keys(Ne)}]`
          );
        Te ||
          ((Te = R.default.model),
          console.log(`No model specified. Using default model: "${Te}".`));
        const te = {
            progress_callback: je,
            config: Ye,
            cache_dir: et,
            local_files_only: A,
            revision: Ae,
            device: $e,
            dtype: ae,
            model_file_name: ne,
            session_options: ve
          },
          D = new Map([
            ["tokenizer", R.tokenizer],
            ["model", R.model],
            ["processor", R.processor]
          ]),
          ce = await pt(D, Te, te);
        (ce.task = Ge),
          (0, _.dispatchCallback)(je, { status: "ready", task: Ge, model: Te });
        const ue = R.pipeline;
        return new ue(ce);
      }
      async function pt(Ge, Te, je) {
        const Ye = Object.create(null),
          et = [];
        for (let [A, Ae] of Ge.entries()) {
          if (!Ae) continue;
          let $e;
          Array.isArray(Ae)
            ? ($e = new Promise(async (ae, ne) => {
                var R, te;
                let ve;
                for (let D of Ae) {
                  if (D === null) {
                    ae(null);
                    return;
                  }
                  try {
                    ae(await D.from_pretrained(Te, je));
                    return;
                  } catch (ce) {
                    if (
                      (R = ce.message) != null &&
                      R.includes("Unsupported model type")
                    )
                      ve = ce;
                    else if (
                      (te = ce.message) != null &&
                      te.includes("Could not locate file")
                    )
                      ve = ce;
                    else {
                      ne(ce);
                      return;
                    }
                  }
                }
                ne(ve);
              }))
            : ($e = Ae.from_pretrained(Te, je)),
            (Ye[A] = $e),
            et.push($e);
        }
        await Promise.all(et);
        for (let [A, Ae] of Object.entries(Ye)) Ye[A] = await Ae;
        return Ye;
      }
    },
    "./src/processors.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          ASTFeatureExtractor: () => ae,
          AutoProcessor: () => bt,
          BeitFeatureExtractor: () => We,
          BitImageProcessor: () => O,
          CLIPFeatureExtractor: () => j,
          CLIPImageProcessor: () => N,
          ChineseCLIPFeatureExtractor: () => se,
          ClapFeatureExtractor: () => ne,
          ConvNextFeatureExtractor: () => Me,
          ConvNextImageProcessor: () => J,
          DPTFeatureExtractor: () => I,
          DPTImageProcessor: () => V,
          DeiTFeatureExtractor: () => Ne,
          DetrFeatureExtractor: () => Ge,
          DonutFeatureExtractor: () => st,
          EfficientNetImageProcessor: () => Ee,
          FeatureExtractor: () => $,
          Florence2Processor: () => wt,
          GLPNFeatureExtractor: () => B,
          ImageFeatureExtractor: () => S,
          MobileNetV1FeatureExtractor: () => Qe,
          MobileNetV2FeatureExtractor: () => _e,
          MobileNetV3FeatureExtractor: () => X,
          MobileNetV4FeatureExtractor: () => oe,
          MobileViTFeatureExtractor: () => xe,
          MobileViTImageProcessor: () => Y,
          NougatImageProcessor: () => pt,
          OwlViTFeatureExtractor: () => ge,
          OwlViTProcessor: () => tt,
          Owlv2ImageProcessor: () => qe,
          Processor: () => D,
          PyAnnoteFeatureExtractor: () => ve,
          PyAnnoteProcessor: () => Re,
          RTDetrImageProcessor: () => Be,
          SamImageProcessor: () => je,
          SamProcessor: () => ce,
          SapiensFeatureExtractor: () => y,
          SeamlessM4TFeatureExtractor: () => $e,
          SegformerFeatureExtractor: () => x,
          SiglipImageProcessor: () => de,
          SpeechT5FeatureExtractor: () => te,
          SpeechT5Processor: () => ht,
          Swin2SRImageProcessor: () => Ye,
          ViTFeatureExtractor: () => ye,
          ViTImageProcessor: () => L,
          VitMatteImageProcessor: () => et,
          Wav2Vec2FeatureExtractor: () => Ae,
          Wav2Vec2ProcessorWithLM: () => ke,
          WeSpeakerFeatureExtractor: () => R,
          WhisperFeatureExtractor: () => A,
          WhisperProcessor: () => ue,
          YolosFeatureExtractor: () => Te
        });
      var o = n("./src/utils/generic.js"),
        a = n("./src/utils/core.js"),
        l = n("./src/utils/hub.js"),
        f = n("./src/utils/maths.js"),
        _ = n("./src/utils/tensor.js");
      n("./src/utils/image.js");
      var m = n("./src/utils/audio.js");
      function g([Ke, fe, Ie, Ve]) {
        return [Ke - Ie / 2, fe - Ve / 2, Ke + Ie / 2, fe + Ve / 2];
      }
      function M(Ke, fe = 0.5, Ie = null, Ve = !1) {
        const ot = Ke.logits,
          Xe = Ke.pred_boxes,
          [ft, xt, vt] = ot.dims;
        if (Ie !== null && Ie.length !== ft)
          throw Error(
            "Make sure that you pass in as many target sizes as the batch dimension of the logits"
          );
        let $t = [];
        for (let Tt = 0; Tt < ft; ++Tt) {
          let rt = Ie !== null ? Ie[Tt] : null,
            Nt = { boxes: [], classes: [], scores: [] },
            Rt = ot[Tt],
            Kt = Xe[Tt];
          for (let Gt = 0; Gt < xt; ++Gt) {
            let Wt = Rt[Gt],
              er = [],
              nr;
            if (Ve) {
              nr = Wt.sigmoid().data;
              for (let ar = 0; ar < nr.length; ++ar) nr[ar] > fe && er.push(ar);
            } else {
              let ar = (0, f.max)(Wt.data)[1];
              if (
                ar === vt - 1 ||
                ((nr = (0, f.softmax)(Wt.data)), nr[ar] < fe)
              )
                continue;
              er.push(ar);
            }
            for (const ar of er) {
              let Mr = Kt[Gt].data;
              (Mr = g(Mr)),
                rt !== null && (Mr = Mr.map((mt, kt) => mt * rt[(kt + 1) % 2])),
                Nt.boxes.push(Mr),
                Nt.classes.push(ar),
                Nt.scores.push(nr[ar]);
            }
          }
          $t.push(Nt);
        }
        return $t;
      }
      function v(Ke, fe = null) {
        const Ie = Ke.logits,
          Ve = Ie.dims[0];
        if (fe !== null && fe.length !== Ve)
          throw Error(
            "Make sure that you pass in as many target sizes as the batch dimension of the logits"
          );
        const ot = [];
        for (let Xe = 0; Xe < Ve; ++Xe) {
          const ft = fe !== null ? fe[Xe] : null;
          let xt = Ie[Xe];
          ft !== null && (xt = (0, _.interpolate)(xt, ft, "bilinear", !1));
          const [vt, $t] = ft ?? xt.dims.slice(-2),
            Tt = new _.Tensor("int32", new Int32Array(vt * $t), [vt, $t]),
            rt = xt[0].data,
            Nt = Tt.data;
          for (let Wt = 1; Wt < xt.dims[0]; ++Wt) {
            const er = xt[Wt].data;
            for (let nr = 0; nr < er.length; ++nr)
              er[nr] > rt[nr] && ((rt[nr] = er[nr]), (Nt[nr] = Wt));
          }
          const Rt = new Array(xt.dims[0]),
            Kt = Tt.data;
          for (let Wt = 0; Wt < Kt.length; ++Wt) {
            const er = Kt[Wt];
            Rt[er] = er;
          }
          const Gt = Rt.filter((Wt) => Wt !== void 0);
          ot.push({ segmentation: Tt, labels: Gt });
        }
        return ot;
      }
      function C(Ke, fe) {
        var Ie;
        if (!(Ke instanceof Float32Array || Ke instanceof Float64Array))
          throw new Error(
            `${fe} expects input to be a Float32Array or a Float64Array, but got ${
              ((Ie = Ke == null ? void 0 : Ke.constructor) == null
                ? void 0
                : Ie.name) ?? typeof Ke
            } instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`
          );
      }
      function T(Ke, fe, Ie = 0, Ve = null) {
        const ot = Ke / fe;
        let Xe = (0, f.bankers_round)(ot) * fe;
        return (
          Ve !== null && Xe > Ve && (Xe = Math.floor(ot) * fe),
          Xe < Ie && (Xe = Math.ceil(ot) * fe),
          Xe
        );
      }
      function z([Ke, fe], Ie) {
        return [
          Math.max(Math.floor(Ke / Ie), 1) * Ie,
          Math.max(Math.floor(fe / Ie), 1) * Ie
        ];
      }
      class $ extends o.Callable {
        constructor(fe) {
          super(), (this.config = fe);
        }
      }
      class S extends $ {
        constructor(fe) {
          super(fe),
            (this.image_mean = this.config.image_mean ?? this.config.mean),
            (this.image_std = this.config.image_std ?? this.config.std),
            (this.resample = this.config.resample ?? 2),
            (this.do_rescale = this.config.do_rescale ?? !0),
            (this.rescale_factor = this.config.rescale_factor ?? 1 / 255),
            (this.do_normalize = this.config.do_normalize),
            (this.do_resize = this.config.do_resize),
            (this.do_thumbnail = this.config.do_thumbnail),
            (this.size = this.config.size),
            (this.size_divisibility =
              this.config.size_divisibility ?? this.config.size_divisor),
            (this.do_center_crop = this.config.do_center_crop),
            (this.crop_size = this.config.crop_size),
            (this.do_convert_rgb = this.config.do_convert_rgb ?? !0),
            (this.do_crop_margin = this.config.do_crop_margin),
            (this.pad_size = this.config.pad_size),
            (this.do_pad = this.config.do_pad),
            this.do_pad &&
              !this.pad_size &&
              this.size &&
              this.size.width !== void 0 &&
              this.size.height !== void 0 &&
              (this.pad_size = this.size),
            (this.do_flip_channel_order =
              this.config.do_flip_channel_order ?? !1);
        }
        async thumbnail(fe, Ie, Ve = 2) {
          const ot = fe.height,
            Xe = fe.width,
            ft = Ie.height,
            xt = Ie.width;
          let vt = Math.min(ot, ft),
            $t = Math.min(Xe, xt);
          return vt === ot && $t === Xe
            ? fe
            : (ot > Xe
                ? ($t = Math.floor((Xe * vt) / ot))
                : Xe > ot && (vt = Math.floor((ot * $t) / Xe)),
              await fe.resize($t, vt, { resample: Ve }));
        }
        async crop_margin(fe, Ie = 200) {
          const Ve = fe.clone().grayscale(),
            ot = (0, f.min)(Ve.data)[0],
            ft = (0, f.max)(Ve.data)[0] - ot;
          if (ft === 0) return fe;
          const xt = Ie / 255;
          let vt = Ve.width,
            $t = Ve.height,
            Tt = 0,
            rt = 0;
          const Nt = Ve.data;
          for (let Rt = 0; Rt < Ve.height; ++Rt) {
            const Kt = Rt * Ve.width;
            for (let Gt = 0; Gt < Ve.width; ++Gt)
              (Nt[Kt + Gt] - ot) / ft < xt &&
                ((vt = Math.min(vt, Gt)),
                ($t = Math.min($t, Rt)),
                (Tt = Math.max(Tt, Gt)),
                (rt = Math.max(rt, Rt)));
          }
          return (fe = await fe.crop([vt, $t, Tt, rt])), fe;
        }
        pad_image(
          fe,
          Ie,
          Ve,
          {
            mode: ot = "constant",
            center: Xe = !1,
            constant_values: ft = 0
          } = {}
        ) {
          const [xt, vt, $t] = Ie;
          let Tt, rt;
          if (
            (typeof Ve == "number"
              ? ((Tt = Ve), (rt = Ve))
              : ((Tt = Ve.width), (rt = Ve.height)),
            Tt !== vt || rt !== xt)
          ) {
            const Nt = new Float32Array(Tt * rt * $t);
            if (Array.isArray(ft))
              for (let Gt = 0; Gt < Nt.length; ++Gt) Nt[Gt] = ft[Gt % $t];
            else ft !== 0 && Nt.fill(ft);
            const [Rt, Kt] = Xe
              ? [Math.floor((Tt - vt) / 2), Math.floor((rt - xt) / 2)]
              : [0, 0];
            for (let Gt = 0; Gt < xt; ++Gt) {
              const Wt = (Gt + Kt) * Tt,
                er = Gt * vt;
              for (let nr = 0; nr < vt; ++nr) {
                const ar = (Wt + nr + Rt) * $t,
                  Mr = (er + nr) * $t;
                for (let mt = 0; mt < $t; ++mt) Nt[ar + mt] = fe[Mr + mt];
              }
            }
            if (ot === "symmetric") {
              if (Xe)
                throw new Error(
                  "`center` padding is not supported when `mode` is set to `symmetric`."
                );
              const Gt = xt - 1,
                Wt = vt - 1;
              for (let er = 0; er < rt; ++er) {
                const nr = er * Tt,
                  ar = (0, a.calculateReflectOffset)(er, Gt) * vt;
                for (let Mr = 0; Mr < Tt; ++Mr) {
                  if (er < xt && Mr < vt) continue;
                  const mt = (nr + Mr) * $t,
                    kt = (ar + (0, a.calculateReflectOffset)(Mr, Wt)) * $t;
                  for (let Lt = 0; Lt < $t; ++Lt) Nt[mt + Lt] = fe[kt + Lt];
                }
              }
            }
            (fe = Nt), (Ie = [rt, Tt, $t]);
          }
          return [fe, Ie];
        }
        rescale(fe) {
          for (let Ie = 0; Ie < fe.length; ++Ie)
            fe[Ie] = this.rescale_factor * fe[Ie];
        }
        get_resize_output_image_size(fe, Ie) {
          const [Ve, ot] = fe.size;
          let Xe, ft;
          if (this.do_thumbnail) {
            const { height: xt, width: vt } = Ie;
            Xe = Math.min(xt, vt);
          } else
            Number.isInteger(Ie)
              ? ((Xe = Ie), (ft = this.config.max_size ?? Xe))
              : Ie !== void 0 &&
                ((Xe = Ie.shortest_edge), (ft = Ie.longest_edge));
          if (Xe !== void 0 || ft !== void 0) {
            const xt = Xe === void 0 ? 1 : Math.max(Xe / Ve, Xe / ot),
              vt = Ve * xt,
              $t = ot * xt,
              Tt = ft === void 0 ? 1 : Math.min(ft / vt, ft / $t);
            let rt = Math.floor(Number((vt * Tt).toFixed(2))),
              Nt = Math.floor(Number(($t * Tt).toFixed(2)));
            return (
              this.size_divisibility !== void 0 &&
                ([rt, Nt] = z([rt, Nt], this.size_divisibility)),
              [rt, Nt]
            );
          } else if (
            Ie !== void 0 &&
            Ie.width !== void 0 &&
            Ie.height !== void 0
          ) {
            let xt = Ie.width,
              vt = Ie.height;
            if (
              this.config.keep_aspect_ratio &&
              this.config.ensure_multiple_of
            ) {
              let $t = vt / ot,
                Tt = xt / Ve;
              Math.abs(1 - Tt) < Math.abs(1 - $t) ? ($t = Tt) : (Tt = $t),
                (vt = T($t * ot, this.config.ensure_multiple_of)),
                (xt = T(Tt * Ve, this.config.ensure_multiple_of));
            }
            return [xt, vt];
          } else {
            if (this.size_divisibility !== void 0)
              return z([Ve, ot], this.size_divisibility);
            throw new Error(
              `Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(
                Ie
              )}`
            );
          }
        }
        async resize(fe) {
          const [Ie, Ve] = this.get_resize_output_image_size(fe, this.size);
          return await fe.resize(Ie, Ve, { resample: this.resample });
        }
        async preprocess(
          fe,
          {
            do_normalize: Ie = null,
            do_pad: Ve = null,
            do_convert_rgb: ot = null,
            do_convert_grayscale: Xe = null,
            do_flip_channel_order: ft = null
          } = {}
        ) {
          this.do_crop_margin && (fe = await this.crop_margin(fe));
          const [xt, vt] = fe.size;
          if (
            (ot ?? this.do_convert_rgb
              ? (fe = fe.rgb())
              : Xe && (fe = fe.grayscale()),
            this.do_resize && (fe = await this.resize(fe)),
            this.do_thumbnail &&
              (fe = await this.thumbnail(fe, this.size, this.resample)),
            this.do_center_crop)
          ) {
            let Rt, Kt;
            Number.isInteger(this.crop_size)
              ? ((Rt = this.crop_size), (Kt = this.crop_size))
              : ((Rt = this.crop_size.width), (Kt = this.crop_size.height)),
              (fe = await fe.center_crop(Rt, Kt));
          }
          const $t = [fe.height, fe.width];
          let Tt = Float32Array.from(fe.data),
            rt = [fe.height, fe.width, fe.channels];
          if ((this.do_rescale && this.rescale(Tt), Ie ?? this.do_normalize)) {
            let Rt = this.image_mean;
            Array.isArray(this.image_mean) ||
              (Rt = new Array(fe.channels).fill(Rt));
            let Kt = this.image_std;
            if (
              (Array.isArray(this.image_std) ||
                (Kt = new Array(fe.channels).fill(Rt)),
              Rt.length !== fe.channels || Kt.length !== fe.channels)
            )
              throw new Error(
                `When set to arrays, the length of \`image_mean\` (${Rt.length}) and \`image_std\` (${Kt.length}) must match the number of channels in the image (${fe.channels}).`
              );
            for (let Gt = 0; Gt < Tt.length; Gt += fe.channels)
              for (let Wt = 0; Wt < fe.channels; ++Wt)
                Tt[Gt + Wt] = (Tt[Gt + Wt] - Rt[Wt]) / Kt[Wt];
          }
          if (Ve ?? this.do_pad) {
            if (this.pad_size)
              [Tt, rt] = this.pad_image(
                Tt,
                [fe.height, fe.width, fe.channels],
                this.pad_size
              );
            else if (this.size_divisibility) {
              const [Rt, Kt] = z([rt[1], rt[0]], this.size_divisibility);
              [Tt, rt] = this.pad_image(Tt, rt, { width: Rt, height: Kt });
            }
          }
          if (ft ?? this.do_flip_channel_order) {
            if (rt[2] !== 3)
              throw new Error(
                "Flipping channel order is only supported for RGB images."
              );
            for (let Rt = 0; Rt < Tt.length; Rt += 3) {
              const Kt = Tt[Rt];
              (Tt[Rt] = Tt[Rt + 2]), (Tt[Rt + 2] = Kt);
            }
          }
          const Nt = new _.Tensor("float32", Tt, rt).permute(2, 0, 1);
          return {
            original_size: [vt, xt],
            reshaped_input_size: $t,
            pixel_values: Nt
          };
        }
        async _call(fe, ...Ie) {
          Array.isArray(fe) || (fe = [fe]);
          const Ve = await Promise.all(fe.map((Xe) => this.preprocess(Xe)));
          return {
            pixel_values: (0, _.stack)(
              Ve.map((Xe) => Xe.pixel_values),
              0
            ),
            original_sizes: Ve.map((Xe) => Xe.original_size),
            reshaped_input_sizes: Ve.map((Xe) => Xe.reshaped_input_size)
          };
        }
      }
      class y extends S {
        post_process_semantic_segmentation(...fe) {
          return v(...fe);
        }
      }
      class x extends S {
        post_process_semantic_segmentation(...fe) {
          return v(...fe);
        }
      }
      class I extends S {}
      class V extends I {}
      class O extends S {}
      class B extends S {}
      class j extends S {}
      class N extends j {}
      class se extends S {}
      class de extends S {}
      class Me extends S {
        constructor(fe) {
          super(fe), (this.crop_pct = this.config.crop_pct ?? 224 / 256);
        }
        async resize(fe) {
          var Ve;
          const Ie = (Ve = this.size) == null ? void 0 : Ve.shortest_edge;
          if (Ie === void 0)
            throw new Error(
              "Size dictionary must contain 'shortest_edge' key."
            );
          if (Ie < 384) {
            const ot = Math.floor(Ie / this.crop_pct),
              [Xe, ft] = this.get_resize_output_image_size(fe, {
                shortest_edge: ot
              });
            (fe = await fe.resize(Xe, ft, { resample: this.resample })),
              (fe = await fe.center_crop(Ie, Ie));
          } else fe = await fe.resize(Ie, Ie, { resample: this.resample });
          return fe;
        }
      }
      class J extends Me {}
      class ye extends S {}
      class L extends S {}
      class Ee extends S {
        constructor(fe) {
          super(fe),
            (this.include_top = this.config.include_top ?? !0),
            this.include_top &&
              (this.image_std = this.image_std.map((Ie) => Ie * Ie));
        }
      }
      class Qe extends S {}
      class _e extends S {}
      class X extends S {}
      class oe extends S {}
      class xe extends S {}
      class Y extends xe {}
      class ge extends S {
        post_process_object_detection(...fe) {
          return M(...fe);
        }
      }
      class qe extends ge {}
      class Be extends S {
        post_process_object_detection(...fe) {
          return M(...fe);
        }
      }
      class Ne extends S {}
      class We extends S {}
      class st extends S {
        pad_image(fe, Ie, Ve, ot = {}) {
          const [Xe, ft, xt] = Ie;
          let vt = this.image_mean;
          Array.isArray(this.image_mean) || (vt = new Array(xt).fill(vt));
          let $t = this.image_std;
          Array.isArray($t) || ($t = new Array(xt).fill(vt));
          const Tt = vt.map((rt, Nt) => -rt / $t[Nt]);
          return super.pad_image(fe, Ie, Ve, {
            center: !0,
            constant_values: Tt,
            ...ot
          });
        }
      }
      class pt extends st {}
      class Ge extends S {
        async _call(fe) {
          const Ie = await super._call(fe),
            Ve = [Ie.pixel_values.dims[0], 64, 64],
            ot = new _.Tensor(
              "int64",
              new BigInt64Array(Ve.reduce((Xe, ft) => Xe * ft)).fill(1n),
              Ve
            );
          return { ...Ie, pixel_mask: ot };
        }
        post_process_object_detection(...fe) {
          return M(...fe);
        }
        remove_low_and_no_objects(fe, Ie, Ve, ot) {
          let Xe = [],
            ft = [],
            xt = [];
          for (let vt = 0; vt < fe.dims[0]; ++vt) {
            let $t = fe[vt],
              Tt = Ie[vt],
              rt = (0, f.max)($t.data)[1];
            if (rt === ot) continue;
            let Rt = (0, f.softmax)($t.data)[rt];
            Rt > Ve && (Xe.push(Tt), ft.push(Rt), xt.push(rt));
          }
          return [Xe, ft, xt];
        }
        check_segment_validity(fe, Ie, Ve, ot = 0.5, Xe = 0.8) {
          let ft = [],
            xt = 0,
            vt = 0;
          const $t = Ie[Ve].data;
          for (let rt = 0; rt < fe.length; ++rt)
            fe[rt] === Ve && (ft.push(rt), ++xt), $t[rt] >= ot && ++vt;
          let Tt = xt > 0 && vt > 0;
          return Tt && (Tt = xt / vt > Xe), [Tt, ft];
        }
        compute_segments(fe, Ie, Ve, ot, Xe, ft = null, xt = null) {
          let [vt, $t] = xt ?? fe[0].dims,
            Tt = new _.Tensor("int32", new Int32Array(vt * $t), [vt, $t]),
            rt = [];
          if (xt !== null)
            for (let Wt = 0; Wt < fe.length; ++Wt)
              fe[Wt] = (0, _.interpolate)(fe[Wt], xt, "bilinear", !1);
          let Nt = new Int32Array(fe[0].data.length),
            Rt = new Float32Array(fe[0].data.length);
          for (let Wt = 0; Wt < fe.length; ++Wt) {
            let er = Ie[Wt];
            const nr = fe[Wt].data;
            for (let ar = 0; ar < nr.length; ++ar)
              (nr[ar] *= er),
                nr[ar] > Rt[ar] && ((Nt[ar] = Wt), (Rt[ar] = nr[ar]));
          }
          let Kt = 0;
          const Gt = Tt.data;
          for (let Wt = 0; Wt < Ve.length; ++Wt) {
            let er = Ve[Wt],
              [nr, ar] = this.check_segment_validity(Nt, fe, Wt, ot, Xe);
            if (nr) {
              ++Kt;
              for (let Mr of ar) Gt[Mr] = Kt;
              rt.push({ id: Kt, label_id: er, score: Ie[Wt] });
            }
          }
          return [Tt, rt];
        }
        post_process_panoptic_segmentation(
          fe,
          Ie = 0.5,
          Ve = 0.5,
          ot = 0.8,
          Xe = null,
          ft = null
        ) {
          Xe === null &&
            (console.warn(
              "`label_ids_to_fuse` unset. No instance will be fused."
            ),
            (Xe = new Set()));
          const xt = fe.logits,
            $t = fe.pred_masks.sigmoid();
          let [Tt, rt, Nt] = xt.dims;
          if (((Nt -= 1), ft !== null && ft.length !== Tt))
            throw Error(
              "Make sure that you pass in as many target sizes as the batch dimension of the logits"
            );
          let Rt = [];
          for (let Kt = 0; Kt < Tt; ++Kt) {
            let Gt = ft !== null ? ft[Kt] : null,
              Wt = xt[Kt],
              er = $t[Kt],
              [nr, ar, Mr] = this.remove_low_and_no_objects(Wt, er, Ie, Nt);
            if (Mr.length === 0) {
              let [Lt, nn] = Gt ?? er.dims.slice(-2),
                yi = new _.Tensor("int32", new Int32Array(Lt * nn).fill(-1), [
                  Lt,
                  nn
                ]);
              Rt.push({ segmentation: yi, segments_info: [] });
              continue;
            }
            let [mt, kt] = this.compute_segments(nr, ar, Mr, Ve, ot, Xe, Gt);
            Rt.push({ segmentation: mt, segments_info: kt });
          }
          return Rt;
        }
        post_process_instance_segmentation() {
          throw Error("Not implemented yet");
        }
      }
      class Te extends S {
        post_process_object_detection(...fe) {
          return M(...fe);
        }
      }
      class je extends S {
        reshape_input_points(fe, Ie, Ve, ot = !1) {
          fe = structuredClone(fe);
          let Xe = (0, a.calculateDimensions)(fe);
          if (Xe.length === 3) ot || (Xe = [1, ...Xe]), (fe = [fe]);
          else if (Xe.length !== 4)
            throw Error(
              "The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`."
            );
          for (let ft = 0; ft < fe.length; ++ft) {
            let xt = Ie[ft],
              vt = Ve[ft],
              $t = [vt[0] / xt[0], vt[1] / xt[1]];
            for (let Tt = 0; Tt < fe[ft].length; ++Tt)
              for (let rt = 0; rt < fe[ft][Tt].length; ++rt)
                for (let Nt = 0; Nt < fe[ft][Tt][rt].length; ++Nt)
                  fe[ft][Tt][rt][Nt] *= $t[Nt % 2];
          }
          return new _.Tensor("float32", Float32Array.from(fe.flat(1 / 0)), Xe);
        }
        add_input_labels(fe, Ie) {
          let Ve = (0, a.calculateDimensions)(fe);
          if (Ve.length === 2) (Ve = [1, ...Ve]), (fe = [fe]);
          else if (Ve.length !== 3)
            throw Error(
              "The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`."
            );
          if (Ve.some((ot, Xe) => ot !== Ie.dims[Xe]))
            throw Error(
              `The first ${Ve.length} dimensions of 'input_points' and 'input_labels' must be the same.`
            );
          return new _.Tensor("int64", fe.flat(1 / 0).map(BigInt), Ve);
        }
        async _call(
          fe,
          {
            input_points: Ie = null,
            input_labels: Ve = null,
            input_boxes: ot = null
          } = {}
        ) {
          const Xe = await super._call(fe);
          if (
            (Ie &&
              (Xe.input_points = this.reshape_input_points(
                Ie,
                Xe.original_sizes,
                Xe.reshaped_input_sizes
              )),
            Ve)
          ) {
            if (!Xe.input_points)
              throw Error(
                "`input_points` must be provided if `input_labels` are provided."
              );
            Xe.input_labels = this.add_input_labels(Ve, Xe.input_points);
          }
          return (
            ot &&
              (Xe.input_boxes = this.reshape_input_points(
                ot,
                Xe.original_sizes,
                Xe.reshaped_input_sizes,
                !0
              )),
            Xe
          );
        }
        async post_process_masks(
          fe,
          Ie,
          Ve,
          {
            mask_threshold: ot = 0,
            binarize: Xe = !0,
            pad_size: ft = null
          } = {}
        ) {
          const xt = [];
          ft = ft ?? this.pad_size;
          const vt = [ft.height, ft.width];
          for (let $t = 0; $t < Ie.length; ++$t) {
            const Tt = Ie[$t],
              rt = Ve[$t];
            let Nt = await (0, _.interpolate_4d)(fe[$t], {
              mode: "bilinear",
              size: vt
            });
            if (
              ((Nt = Nt.slice(null, null, [0, rt[0]], [0, rt[1]])),
              (Nt = await (0, _.interpolate_4d)(Nt, {
                mode: "bilinear",
                size: Tt
              })),
              Xe)
            ) {
              const Rt = Nt.data,
                Kt = new Uint8Array(Rt.length);
              for (let Gt = 0; Gt < Rt.length; ++Gt)
                Rt[Gt] > ot && (Kt[Gt] = 1);
              Nt = new _.Tensor("bool", Kt, Nt.dims);
            }
            xt.push(Nt);
          }
          return xt;
        }
        generate_crop_boxes(
          fe,
          Ie,
          {
            crop_n_layers: Ve = 0,
            overlap_ratio: ot = 512 / 1500,
            points_per_crop: Xe = 32,
            crop_n_points_downscale_factor: ft = 1
          } = {}
        ) {}
      }
      class Ye extends S {
        pad_image(fe, Ie, Ve, ot = {}) {
          const [Xe, ft, xt] = Ie;
          return super.pad_image(
            fe,
            Ie,
            {
              width: ft + ((Ve - (ft % Ve)) % Ve),
              height: Xe + ((Ve - (Xe % Ve)) % Ve)
            },
            { mode: "symmetric", center: !1, constant_values: -1, ...ot }
          );
        }
      }
      class et extends S {
        async _call(fe, Ie) {
          Array.isArray(fe) || (fe = [fe]), Array.isArray(Ie) || (Ie = [Ie]);
          const Ve = await Promise.all(fe.map((ft) => this.preprocess(ft))),
            ot = await Promise.all(
              Ie.map((ft) =>
                this.preprocess(ft, {
                  do_normalize: !1,
                  do_convert_rgb: !1,
                  do_convert_grayscale: !0
                })
              )
            );
          return {
            pixel_values: (0, _.stack)(
              Ve.map((ft, xt) =>
                (0, _.cat)([ft.pixel_values, ot[xt].pixel_values], 0)
              ),
              0
            ),
            original_sizes: Ve.map((ft) => ft.original_size),
            reshaped_input_sizes: Ve.map((ft) => ft.reshaped_input_size)
          };
        }
      }
      class A extends $ {
        constructor(fe) {
          var Ie;
          super(fe),
            (Ie = this.config).mel_filters ??
              (Ie.mel_filters = (0, m.mel_filter_bank)(
                Math.floor(1 + this.config.n_fft / 2),
                this.config.feature_size,
                0,
                8e3,
                this.config.sampling_rate,
                "slaney",
                "slaney"
              )),
            (this.window = (0, m.window_function)(this.config.n_fft, "hann"));
        }
        async _extract_fbank_features(fe) {
          const Ie = await (0, m.spectrogram)(
              fe,
              this.window,
              this.config.n_fft,
              this.config.hop_length,
              {
                power: 2,
                mel_filters: this.config.mel_filters,
                log_mel: "log10",
                max_num_frames: this.config.nb_max_frames
              }
            ),
            Ve = Ie.data,
            ot = (0, f.max)(Ve)[0];
          for (let Xe = 0; Xe < Ve.length; ++Xe)
            Ve[Xe] = (Math.max(Ve[Xe], ot - 8) + 4) / 4;
          return Ie;
        }
        async _call(fe) {
          C(fe, "WhisperFeatureExtractor");
          let Ie;
          return (
            fe.length > this.config.n_samples
              ? (console.warn(
                  "Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."
                ),
                (Ie = fe.slice(0, this.config.n_samples)))
              : ((Ie = new Float32Array(this.config.n_samples)), Ie.set(fe)),
            {
              input_features: (
                await this._extract_fbank_features(Ie)
              ).unsqueeze_(0)
            }
          );
        }
      }
      class Ae extends $ {
        _zero_mean_unit_var_norm(fe) {
          const Ve = fe.reduce((Xe, ft) => Xe + ft, 0) / fe.length,
            ot = fe.reduce((Xe, ft) => Xe + (ft - Ve) ** 2, 0) / fe.length;
          return fe.map((Xe) => (Xe - Ve) / Math.sqrt(ot + 1e-7));
        }
        async _call(fe) {
          C(fe, "Wav2Vec2FeatureExtractor"),
            fe instanceof Float64Array && (fe = new Float32Array(fe));
          let Ie = fe;
          this.config.do_normalize && (Ie = this._zero_mean_unit_var_norm(Ie));
          const Ve = [1, Ie.length];
          return {
            input_values: new _.Tensor("float32", Ie, Ve),
            attention_mask: new _.Tensor(
              "int64",
              new BigInt64Array(Ie.length).fill(1n),
              Ve
            )
          };
        }
      }
      class $e extends $ {
        constructor(fe) {
          super(fe);
          const Ie = this.config.sampling_rate,
            Ve = (0, m.mel_filter_bank)(
              256,
              this.config.num_mel_bins,
              20,
              Math.floor(Ie / 2),
              Ie,
              null,
              "kaldi",
              !0
            );
          for (let ot = 0; ot < Ve.length; ++ot) Ve[ot].push(0);
          (this.mel_filters = Ve),
            (this.window = (0, m.window_function)(400, "povey", {
              periodic: !1
            }));
        }
        async _extract_fbank_features(fe, Ie) {
          return (
            (fe = fe.map((Ve) => Ve * 32768)),
            (0, m.spectrogram)(fe, this.window, 400, 160, {
              fft_length: 512,
              power: 2,
              center: !1,
              preemphasis: 0.97,
              mel_filters: this.mel_filters,
              log_mel: "log",
              mel_floor: 1192092955078125e-22,
              remove_dc_offset: !0,
              max_num_frames: Ie,
              transpose: !0
            })
          );
        }
        async _call(
          fe,
          {
            padding: Ie = !0,
            pad_to_multiple_of: Ve = 2,
            do_normalize_per_mel_bins: ot = !0,
            return_attention_mask: Xe = !0
          } = {}
        ) {
          C(fe, "SeamlessM4TFeatureExtractor");
          let ft = await this._extract_fbank_features(
            fe,
            this.config.max_length
          );
          if (ot) {
            const [Kt, Gt] = ft.dims,
              Wt = ft.data;
            for (let er = 0; er < Gt; ++er) {
              let nr = 0;
              for (let kt = 0; kt < Kt; ++kt) nr += Wt[kt * Gt + er];
              const ar = nr / Kt;
              let Mr = 0;
              for (let kt = 0; kt < Kt; ++kt)
                Mr += (Wt[kt * Gt + er] - ar) ** 2;
              Mr /= Kt - 1;
              const mt = Math.sqrt(Mr + 1e-7);
              for (let kt = 0; kt < Kt; ++kt) {
                const Lt = kt * Gt + er;
                Wt[Lt] = (Wt[Lt] - ar) / mt;
              }
            }
          }
          let xt;
          if (Ie) {
            const [Kt, Gt] = ft.dims,
              Wt = ft.data,
              er = Kt % Ve;
            if (er > 0) {
              const nr = new Float32Array(Gt * (Kt + er));
              nr.set(Wt), nr.fill(this.config.padding_value, Wt.length);
              const ar = Kt + er;
              (ft = new _.Tensor(ft.type, nr, [ar, Gt])),
                Xe &&
                  ((xt = new _.Tensor("int64", new BigInt64Array(ar), [1, ar])),
                  xt.data.fill(1n, 0, Kt));
            }
          }
          const [vt, $t] = ft.dims,
            Tt = this.config.stride;
          if (vt % Tt !== 0)
            throw new Error(
              `The number of frames (${vt}) must be a multiple of the stride (${Tt}).`
            );
          const Nt = ft.view(1, Math.floor(vt / Tt), $t * Tt),
            Rt = { input_features: Nt };
          if (Xe) {
            const Kt = Nt.dims[1],
              Gt = new BigInt64Array(Kt);
            if (xt) {
              const Wt = xt.data;
              for (let er = 1, nr = 0; er < vt; er += Tt, ++nr) Gt[nr] = Wt[er];
            } else Gt.fill(1n);
            Rt.attention_mask = new _.Tensor("int64", Gt, [1, Kt]);
          }
          return Rt;
        }
      }
      class ae extends $ {
        constructor(fe) {
          super(fe);
          const Ie = this.config.sampling_rate,
            Ve = (0, m.mel_filter_bank)(
              256,
              this.config.num_mel_bins,
              20,
              Math.floor(Ie / 2),
              Ie,
              null,
              "kaldi",
              !0
            );
          for (let ot = 0; ot < Ve.length; ++ot) Ve[ot].push(0);
          (this.mel_filters = Ve),
            (this.window = (0, m.window_function)(400, "hann", {
              periodic: !1
            })),
            (this.mean = this.config.mean),
            (this.std = this.config.std);
        }
        async _extract_fbank_features(fe, Ie) {
          return (0, m.spectrogram)(fe, this.window, 400, 160, {
            fft_length: 512,
            power: 2,
            center: !1,
            preemphasis: 0.97,
            mel_filters: this.mel_filters,
            log_mel: "log",
            mel_floor: 1192092955078125e-22,
            remove_dc_offset: !0,
            max_num_frames: Ie,
            transpose: !0
          });
        }
        async _call(fe) {
          C(fe, "ASTFeatureExtractor");
          const Ie = await this._extract_fbank_features(
            fe,
            this.config.max_length
          );
          if (this.config.do_normalize) {
            const Ve = this.std * 2,
              ot = Ie.data;
            for (let Xe = 0; Xe < ot.length; ++Xe)
              ot[Xe] = (ot[Xe] - this.mean) / Ve;
          }
          return { input_values: Ie.unsqueeze_(0) };
        }
      }
      class ne extends $ {
        constructor(fe) {
          super(fe),
            (this.mel_filters = (0, m.mel_filter_bank)(
              this.config.nb_frequency_bins,
              this.config.feature_size,
              this.config.frequency_min,
              this.config.frequency_max,
              this.config.sampling_rate,
              null,
              "htk"
            )),
            (this.mel_filters_slaney = (0, m.mel_filter_bank)(
              this.config.nb_frequency_bins,
              this.config.feature_size,
              this.config.frequency_min,
              this.config.frequency_max,
              this.config.sampling_rate,
              "slaney",
              "slaney"
            )),
            (this.window = (0, m.window_function)(
              this.config.fft_window_size,
              "hann"
            ));
        }
        async _get_input_mel(fe, Ie, Ve, ot) {
          let Xe;
          const ft = fe.length - Ie;
          if (ft > 0)
            if (Ve === "rand_trunc") {
              const xt = Math.floor(Math.random() * (ft + 1));
              (fe = fe.subarray(xt, xt + Ie)),
                (Xe = await this._extract_fbank_features(
                  fe,
                  this.mel_filters_slaney,
                  this.config.nb_max_samples
                ));
            } else
              throw new Error(`Truncation strategy "${Ve}" not implemented`);
          else {
            if (ft < 0) {
              let xt = new Float64Array(Ie);
              if ((xt.set(fe), ot === "repeat"))
                for (let vt = fe.length; vt < Ie; vt += fe.length)
                  xt.set(fe.subarray(0, Math.min(fe.length, Ie - vt)), vt);
              else if (ot === "repeatpad")
                for (let vt = fe.length; vt < -ft; vt += fe.length)
                  xt.set(fe, vt);
              fe = xt;
            }
            if (Ve === "fusion")
              throw new Error(`Truncation strategy "${Ve}" not implemented`);
            Xe = await this._extract_fbank_features(
              fe,
              this.mel_filters_slaney,
              this.config.nb_max_samples
            );
          }
          return Xe.unsqueeze_(0);
        }
        async _extract_fbank_features(fe, Ie, Ve = null) {
          return (0, m.spectrogram)(
            fe,
            this.window,
            this.config.fft_window_size,
            this.config.hop_length,
            {
              power: 2,
              mel_filters: Ie,
              log_mel: "dB",
              max_num_frames: Ve,
              do_pad: !1,
              transpose: !0
            }
          );
        }
        async _call(fe, { max_length: Ie = null } = {}) {
          return (
            C(fe, "ClapFeatureExtractor"),
            {
              input_features: (
                await this._get_input_mel(
                  fe,
                  Ie ?? this.config.nb_max_samples,
                  this.config.truncation,
                  this.config.padding
                )
              ).unsqueeze_(0)
            }
          );
        }
      }
      class ve extends $ {
        async _call(fe) {
          C(fe, "PyAnnoteFeatureExtractor"),
            fe instanceof Float64Array && (fe = new Float32Array(fe));
          const Ie = [1, 1, fe.length];
          return { input_values: new _.Tensor("float32", fe, Ie) };
        }
        samples_to_frames(fe) {
          return (fe - this.config.offset) / this.config.step;
        }
        post_process_speaker_diarization(fe, Ie) {
          const Ve =
              Ie / this.samples_to_frames(Ie) / this.config.sampling_rate,
            ot = [];
          for (const Xe of fe.tolist()) {
            const ft = [];
            let xt = -1;
            for (let vt = 0; vt < Xe.length; ++vt) {
              const $t = (0, f.softmax)(Xe[vt]),
                [Tt, rt] = (0, f.max)($t),
                [Nt, Rt] = [vt, vt + 1];
              rt !== xt
                ? ((xt = rt),
                  ft.push({ id: rt, start: Nt, end: Rt, score: Tt }))
                : ((ft.at(-1).end = Rt), (ft.at(-1).score += Tt));
            }
            ot.push(
              ft.map(({ id: vt, start: $t, end: Tt, score: rt }) => ({
                id: vt,
                start: $t * Ve,
                end: Tt * Ve,
                confidence: rt / (Tt - $t)
              }))
            );
          }
          return ot;
        }
      }
      class R extends $ {
        constructor(fe) {
          super(fe);
          const Ie = this.config.sampling_rate,
            Ve = (0, m.mel_filter_bank)(
              256,
              this.config.num_mel_bins,
              20,
              Math.floor(Ie / 2),
              Ie,
              null,
              "kaldi",
              !0
            );
          for (let ot = 0; ot < Ve.length; ++ot) Ve[ot].push(0);
          (this.mel_filters = Ve),
            (this.window = (0, m.window_function)(400, "hamming", {
              periodic: !1
            })),
            (this.min_num_frames = this.config.min_num_frames);
        }
        async _extract_fbank_features(fe) {
          return (
            (fe = fe.map((Ie) => Ie * 32768)),
            (0, m.spectrogram)(fe, this.window, 400, 160, {
              fft_length: 512,
              power: 2,
              center: !1,
              preemphasis: 0.97,
              mel_filters: this.mel_filters,
              log_mel: "log",
              mel_floor: 1192092955078125e-22,
              remove_dc_offset: !0,
              transpose: !0,
              min_num_frames: this.min_num_frames
            })
          );
        }
        async _call(fe) {
          C(fe, "WeSpeakerFeatureExtractor");
          const Ie = (await this._extract_fbank_features(fe)).unsqueeze_(0);
          if (this.config.fbank_centering_span === null) {
            const Ve = Ie.mean(1).data,
              ot = Ie.data,
              [Xe, ft, xt] = Ie.dims;
            for (let vt = 0; vt < Xe; ++vt) {
              const $t = vt * ft * xt,
                Tt = vt * xt;
              for (let rt = 0; rt < ft; ++rt) {
                const Nt = $t + rt * xt;
                for (let Rt = 0; Rt < xt; ++Rt) ot[Nt + Rt] -= Ve[Tt + Rt];
              }
            }
          }
          return { input_features: Ie };
        }
      }
      class te extends $ {}
      class D extends o.Callable {
        constructor(fe) {
          super(), (this.feature_extractor = fe);
        }
        async _call(fe, ...Ie) {
          return await this.feature_extractor(fe, ...Ie);
        }
      }
      class ce extends D {
        async _call(...fe) {
          return await this.feature_extractor(...fe);
        }
        post_process_masks(...fe) {
          return this.feature_extractor.post_process_masks(...fe);
        }
        reshape_input_points(...fe) {
          return this.feature_extractor.reshape_input_points(...fe);
        }
      }
      class ue extends D {
        async _call(fe) {
          return await this.feature_extractor(fe);
        }
      }
      class ke extends D {
        async _call(fe) {
          return await this.feature_extractor(fe);
        }
      }
      class Re extends D {
        async _call(fe) {
          return await this.feature_extractor(fe);
        }
        post_process_speaker_diarization(...fe) {
          return this.feature_extractor.post_process_speaker_diarization(...fe);
        }
      }
      class ht extends D {
        async _call(fe) {
          return await this.feature_extractor(fe);
        }
      }
      class tt extends D {}
      class wt extends D {
        constructor(fe) {
          super(fe);
          const {
            tasks_answer_post_processing_type: Ie,
            task_prompts_without_inputs: Ve,
            task_prompts_with_input: ot
          } = fe.config;
          (this.tasks_answer_post_processing_type = new Map(
            Object.entries(Ie ?? {})
          )),
            (this.task_prompts_without_inputs = new Map(
              Object.entries(Ve ?? {})
            )),
            (this.task_prompts_with_input = new Map(Object.entries(ot ?? {}))),
            (this.regexes = {
              quad_boxes:
                /(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,
              bboxes: /([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm
            }),
            (this.size_per_bin = 1e3);
        }
        construct_prompts(fe) {
          typeof fe == "string" && (fe = [fe]);
          const Ie = [];
          for (const Ve of fe)
            if (this.task_prompts_without_inputs.has(Ve))
              Ie.push(this.task_prompts_without_inputs.get(Ve));
            else {
              for (const [ot, Xe] of this.task_prompts_with_input)
                if (Ve.includes(ot)) {
                  Ie.push(Xe.replaceAll("{input}", Ve).replaceAll(ot, ""));
                  break;
                }
              Ie.length !== fe.length && Ie.push(Ve);
            }
          return Ie;
        }
        post_process_generation(fe, Ie, Ve) {
          const ot =
            this.tasks_answer_post_processing_type.get(Ie) ?? "pure_text";
          fe = fe.replaceAll("<s>", "").replaceAll("</s>", "");
          let Xe;
          switch (ot) {
            case "pure_text":
              Xe = fe;
              break;
            case "description_with_bboxes":
            case "bboxes":
            case "phrase_grounding":
            case "ocr":
              const ft = ot === "ocr" ? "quad_boxes" : "bboxes",
                xt = fe.matchAll(this.regexes[ft]),
                vt = [],
                $t = [];
              for (const [Tt, rt, ...Nt] of xt)
                vt.push(rt ? rt.trim() : vt.at(-1) ?? ""),
                  $t.push(
                    Nt.map(
                      (Rt, Kt) =>
                        ((Number(Rt) + 0.5) / this.size_per_bin) * Ve[Kt % 2]
                    )
                  );
              Xe = { labels: vt, [ft]: $t };
              break;
            default:
              throw new Error(
                `Task "${Ie}" (of type "${ot}") not yet implemented.`
              );
          }
          return { [Ie]: Xe };
        }
      }
      class bt {
        static async from_pretrained(
          fe,
          {
            progress_callback: Ie = null,
            config: Ve = null,
            cache_dir: ot = null,
            local_files_only: Xe = !1,
            revision: ft = "main"
          } = {}
        ) {
          let xt =
              Ve ??
              (await (0, l.getModelJSON)(fe, "preprocessor_config.json", !0, {
                progress_callback: Ie,
                config: Ve,
                cache_dir: ot,
                local_files_only: Xe,
                revision: ft
              })),
            vt = xt.feature_extractor_type ?? xt.image_processor_type,
            $t = this.FEATURE_EXTRACTOR_CLASS_MAPPING[vt];
          if (!$t)
            if (xt.size !== void 0)
              console.warn(
                `Feature extractor type "${vt}" not found, assuming ImageFeatureExtractor due to size parameter in config.`
              ),
                ($t = S);
            else throw new Error(`Unknown Feature Extractor type: ${vt}`);
          let Tt = this.PROCESSOR_CLASS_MAPPING[xt.processor_class] ?? D,
            rt = new $t(xt);
          return new Tt(rt);
        }
      }
      He(bt, "FEATURE_EXTRACTOR_CLASS_MAPPING", {
        ImageFeatureExtractor: S,
        WhisperFeatureExtractor: A,
        ViTFeatureExtractor: ye,
        MobileViTFeatureExtractor: xe,
        MobileViTImageProcessor: Y,
        MobileNetV1FeatureExtractor: Qe,
        MobileNetV2FeatureExtractor: _e,
        MobileNetV3FeatureExtractor: X,
        MobileNetV4FeatureExtractor: oe,
        OwlViTFeatureExtractor: ge,
        Owlv2ImageProcessor: qe,
        CLIPFeatureExtractor: j,
        CLIPImageProcessor: N,
        Florence2Processor: wt,
        ChineseCLIPFeatureExtractor: se,
        SiglipImageProcessor: de,
        ConvNextFeatureExtractor: Me,
        ConvNextImageProcessor: J,
        SegformerFeatureExtractor: x,
        SapiensFeatureExtractor: y,
        BitImageProcessor: O,
        DPTImageProcessor: V,
        DPTFeatureExtractor: I,
        GLPNFeatureExtractor: B,
        BeitFeatureExtractor: We,
        DeiTFeatureExtractor: Ne,
        DetrFeatureExtractor: Ge,
        RTDetrImageProcessor: Be,
        YolosFeatureExtractor: Te,
        DonutFeatureExtractor: st,
        NougatImageProcessor: pt,
        EfficientNetImageProcessor: Ee,
        ViTImageProcessor: L,
        VitMatteImageProcessor: et,
        SamImageProcessor: je,
        Swin2SRImageProcessor: Ye,
        Wav2Vec2FeatureExtractor: Ae,
        SeamlessM4TFeatureExtractor: $e,
        SpeechT5FeatureExtractor: te,
        ASTFeatureExtractor: ae,
        ClapFeatureExtractor: ne,
        PyAnnoteFeatureExtractor: ve,
        WeSpeakerFeatureExtractor: R
      }),
        He(bt, "PROCESSOR_CLASS_MAPPING", {
          WhisperProcessor: ue,
          Wav2Vec2ProcessorWithLM: ke,
          PyAnnoteProcessor: Re,
          SamProcessor: ce,
          SpeechT5Processor: ht,
          OwlViTProcessor: tt,
          Florence2Processor: wt
        });
    },
    "./src/tokenizers.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          AlbertTokenizer: () => Rt,
          AutoTokenizer: () => qn,
          BartTokenizer: () => Qr,
          BertTokenizer: () => Nt,
          BlenderbotSmallTokenizer: () => Ko,
          BlenderbotTokenizer: () => vo,
          BloomTokenizer: () => Nr,
          CLIPTokenizer: () => Yt,
          CamembertTokenizer: () => kt,
          CodeGenTokenizer: () => wo,
          CodeLlamaTokenizer: () => $s,
          CohereTokenizer: () => Kr,
          ConvBertTokenizer: () => ar,
          DebertaTokenizer: () => Wt,
          DebertaV2Tokenizer: () => er,
          DistilBertTokenizer: () => mt,
          ElectraTokenizer: () => nn,
          EsmTokenizer: () => Gi,
          FalconTokenizer: () => Wo,
          GPT2Tokenizer: () => Ai,
          GPTNeoXTokenizer: () => Go,
          GemmaTokenizer: () => _o,
          Grok1Tokenizer: () => vi,
          HerbertTokenizer: () => nr,
          LlamaTokenizer: () => Ii,
          M2M100Tokenizer: () => ro,
          MBart50Tokenizer: () => Yr,
          MBartTokenizer: () => Tn,
          MPNetTokenizer: () => Vo,
          MarianTokenizer: () => Ho,
          MobileBertTokenizer: () => Kt,
          NllbTokenizer: () => Fi,
          NougatTokenizer: () => bo,
          PreTrainedTokenizer: () => rt,
          Qwen2Tokenizer: () => As,
          RoFormerTokenizer: () => Mr,
          RobertaTokenizer: () => wi,
          SiglipTokenizer: () => no,
          SpeechT5Tokenizer: () => Qo,
          SqueezeBertTokenizer: () => Gt,
          T5Tokenizer: () => yi,
          TokenizerModel: () => Me,
          VitsTokenizer: () => Xo,
          Wav2Vec2CTCTokenizer: () => qo,
          WhisperTokenizer: () => yo,
          XLMRobertaTokenizer: () => Uo,
          XLMTokenizer: () => Lt,
          is_chinese_char: () => V
        });
      var o = n("./src/utils/generic.js"),
        a = n("./src/utils/core.js"),
        l = n("./src/utils/hub.js"),
        f = n("./src/utils/maths.js"),
        _ = n("./src/utils/tensor.js"),
        m = n("./src/utils/data-structures.js"),
        g = n("./node_modules/@huggingface/jinja/dist/index.js"),
        M = n("./src/models/whisper/common_whisper.js"),
        v = n("./src/utils/constants.js");
      async function C(Ue, W) {
        const pe = await Promise.all([
          (0, l.getModelJSON)(Ue, "tokenizer.json", !0, W),
          (0, l.getModelJSON)(Ue, "tokenizer_config.json", !0, W)
        ]);
        return W.legacy !== null && (pe[1].legacy = W.legacy), pe;
      }
      function T(Ue, W) {
        const pe = [];
        let Pe = 0;
        for (const Oe of Ue.matchAll(W)) {
          const Le = Oe[0];
          Pe < Oe.index && pe.push(Ue.slice(Pe, Oe.index)),
            Le.length > 0 && pe.push(Le),
            (Pe = Oe.index + Le.length);
        }
        return Pe < Ue.length && pe.push(Ue.slice(Pe)), pe;
      }
      function z(Ue, W = !0) {
        if (Ue.Regex !== void 0) {
          let pe = Ue.Regex.replace(/\\([#&~])/g, "$1");
          for (const [Pe, Oe] of se) pe = pe.replaceAll(Pe, Oe);
          return new RegExp(pe, "gu");
        } else if (Ue.String !== void 0) {
          const pe = (0, a.escapeRegExp)(Ue.String);
          return new RegExp(W ? pe : `(${pe})`, "gu");
        } else return console.warn("Unknown pattern type:", Ue), null;
      }
      function $(Ue) {
        return new Map(Object.entries(Ue));
      }
      function S(Ue) {
        const W = Ue.dims;
        switch (W.length) {
          case 1:
            return Ue.tolist();
          case 2:
            if (W[0] !== 1)
              throw new Error(
                "Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs."
              );
            return Ue.tolist()[0];
          default:
            throw new Error(
              `Expected tensor to have 1-2 dimensions, got ${W.length}.`
            );
        }
      }
      function y(Ue) {
        return Ue.replace(/ \./g, ".")
          .replace(/ \?/g, "?")
          .replace(/ \!/g, "!")
          .replace(/ ,/g, ",")
          .replace(/ \' /g, "'")
          .replace(/ n\'t/g, "n't")
          .replace(/ \'m/g, "'m")
          .replace(/ \'s/g, "'s")
          .replace(/ \'ve/g, "'ve")
          .replace(/ \'re/g, "'re");
      }
      function x(Ue) {
        return Ue.replace(/[\u0300-\u036f]/g, "");
      }
      function I(Ue) {
        return x(Ue.toLowerCase());
      }
      function V(Ue) {
        return (
          (Ue >= 19968 && Ue <= 40959) ||
          (Ue >= 13312 && Ue <= 19903) ||
          (Ue >= 131072 && Ue <= 173791) ||
          (Ue >= 173824 && Ue <= 177983) ||
          (Ue >= 177984 && Ue <= 178207) ||
          (Ue >= 178208 && Ue <= 183983) ||
          (Ue >= 63744 && Ue <= 64255) ||
          (Ue >= 194560 && Ue <= 195103)
        );
      }
      function O(Ue, W, pe) {
        const Pe = [];
        let Oe = 0;
        for (; Oe < Ue.length; ) {
          if ((Pe.push(Ue[Oe]), (pe.get(Ue[Oe]) ?? W) !== W)) {
            ++Oe;
            continue;
          }
          for (; Oe < Ue.length && (pe.get(Ue[Oe]) ?? W) === W; ) ++Oe;
        }
        return Pe;
      }
      function B(Ue) {
        return Ue.match(/\S+/g) || [];
      }
      const j =
          "\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",
        N = new RegExp(`^[${j}]+$`, "gu"),
        se = new Map([
          [
            "(?i:'s|'t|'re|'ve|'m|'ll|'d)",
            "(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"
          ]
        ]);
      class de {
        constructor(W) {
          (this.content = W.content),
            (this.id = W.id),
            (this.single_word = W.single_word ?? !1),
            (this.lstrip = W.lstrip ?? !1),
            (this.rstrip = W.rstrip ?? !1),
            (this.special = W.special ?? !1),
            (this.normalized = W.normalized ?? null);
        }
      }
      class Me extends o.Callable {
        constructor(W) {
          super(),
            (this.config = W),
            (this.vocab = []),
            (this.tokens_to_ids = new Map()),
            (this.unk_token_id = void 0),
            (this.unk_token = void 0),
            (this.end_of_word_suffix = void 0),
            (this.fuse_unk = this.config.fuse_unk ?? !1);
        }
        static fromConfig(W, ...pe) {
          switch (W.type) {
            case "WordPiece":
              return new J(W);
            case "Unigram":
              return new ye(W, ...pe);
            case "BPE":
              return new Qe(W);
            default:
              if (W.vocab) return new _e(W, ...pe);
              throw new Error(`Unknown TokenizerModel type: ${W.type}`);
          }
        }
        _call(W) {
          let pe = this.encode(W);
          return (
            this.fuse_unk &&
              (pe = O(pe, this.unk_token_id, this.tokens_to_ids)),
            pe
          );
        }
        encode(W) {
          throw Error("encode should be implemented in subclass.");
        }
        convert_tokens_to_ids(W) {
          return W.map((pe) => this.tokens_to_ids.get(pe) ?? this.unk_token_id);
        }
        convert_ids_to_tokens(W) {
          return W.map((pe) => this.vocab[pe] ?? this.unk_token);
        }
      }
      class J extends Me {
        constructor(W) {
          super(W),
            (this.tokens_to_ids = $(W.vocab)),
            (this.unk_token_id = this.tokens_to_ids.get(W.unk_token)),
            (this.unk_token = W.unk_token),
            (this.max_input_chars_per_word = W.max_input_chars_per_word ?? 100),
            (this.vocab = new Array(this.tokens_to_ids.size));
          for (const [pe, Pe] of this.tokens_to_ids) this.vocab[Pe] = pe;
        }
        encode(W) {
          const pe = [];
          for (const Pe of W) {
            const Oe = [...Pe];
            if (Oe.length > this.max_input_chars_per_word) {
              pe.push(this.unk_token);
              continue;
            }
            let Le = !1,
              nt = 0;
            const Et = [];
            for (; nt < Oe.length; ) {
              let Pt = Oe.length,
                Ct = null;
              for (; nt < Pt; ) {
                let Ot = Oe.slice(nt, Pt).join("");
                if (
                  (nt > 0 && (Ot = this.config.continuing_subword_prefix + Ot),
                  this.tokens_to_ids.has(Ot))
                ) {
                  Ct = Ot;
                  break;
                }
                --Pt;
              }
              if (Ct === null) {
                Le = !0;
                break;
              }
              Et.push(Ct), (nt = Pt);
            }
            Le ? pe.push(this.unk_token) : pe.push(...Et);
          }
          return pe;
        }
      }
      class ye extends Me {
        constructor(W, pe) {
          super(W);
          const Pe = W.vocab.length;
          (this.vocab = new Array(Pe)), (this.scores = new Array(Pe));
          for (let Oe = 0; Oe < Pe; ++Oe) {
            const Le = W.vocab[Oe];
            (this.vocab[Oe] = Le[0]), (this.scores[Oe] = Le[1]);
          }
          (this.unk_token_id = W.unk_id),
            (this.unk_token = this.vocab[W.unk_id]),
            (this.tokens_to_ids = new Map(
              this.vocab.map((Oe, Le) => [Oe, Le])
            )),
            (this.bosToken = " "),
            (this.bosTokenId = this.tokens_to_ids.get(this.bosToken)),
            (this.eosToken = pe.eos_token),
            (this.eosTokenId = this.tokens_to_ids.get(this.eosToken)),
            (this.unkToken = this.vocab[this.unk_token_id]),
            (this.minScore = (0, f.min)(this.scores)[0]),
            (this.unkScore = this.minScore - 10),
            (this.scores[this.unk_token_id] = this.unkScore),
            (this.trie = new m.CharTrie()),
            this.trie.extend(this.vocab),
            (this.fuse_unk = !0);
        }
        populateNodes(W) {
          const pe = W.sentence,
            Pe = pe.length;
          let Oe = 0;
          for (; Oe < Pe; ) {
            let nt = !1;
            for (let Et of this.trie.commonPrefixSearch(pe.slice(Oe))) {
              const Pt = this.tokens_to_ids.get(Et),
                Ct = this.scores[Pt],
                Ot = Et.length;
              W.insert(Oe, Ot, Ct, Pt), !nt && Ot === 1 && (nt = !0);
            }
            nt || W.insert(Oe, 1, this.unkScore, this.unk_token_id), (Oe += 1);
          }
        }
        tokenize(W) {
          const pe = new m.TokenLattice(W, this.bosTokenId, this.eosTokenId);
          return this.populateNodes(pe), pe.tokens();
        }
        encode(W) {
          const pe = [];
          for (const Pe of W) {
            const Oe = this.tokenize(Pe);
            pe.push(...Oe);
          }
          return pe;
        }
      }
      const L = (() => {
          const Ue = [
              ...Array.from({ length: 94 }, (Oe, Le) => Le + 33),
              ...Array.from({ length: 12 }, (Oe, Le) => Le + 161),
              ...Array.from({ length: 82 }, (Oe, Le) => Le + 174)
            ],
            W = Ue.slice();
          let pe = 0;
          for (let Oe = 0; Oe < 256; ++Oe)
            Ue.includes(Oe) || (Ue.push(Oe), W.push(256 + pe), (pe += 1));
          const Pe = W.map((Oe) => String.fromCharCode(Oe));
          return Object.fromEntries(Ue.map((Oe, Le) => [Oe, Pe[Le]]));
        })(),
        Ee = (0, a.reverseDictionary)(L);
      class Qe extends Me {
        constructor(W) {
          super(W),
            (this.BPE_SPLIT_TOKEN = " "),
            (this.tokens_to_ids = $(W.vocab)),
            (this.unk_token_id = this.tokens_to_ids.get(W.unk_token)),
            (this.unk_token = W.unk_token),
            (this.vocab = new Array(this.tokens_to_ids.size));
          for (const [pe, Pe] of this.tokens_to_ids) this.vocab[Pe] = pe;
          (this.bpe_ranks = new Map(W.merges.map((pe, Pe) => [pe, Pe]))),
            (this.merges = W.merges.map((pe) =>
              pe.split(this.BPE_SPLIT_TOKEN)
            )),
            (this.end_of_word_suffix = W.end_of_word_suffix),
            (this.continuing_subword_suffix =
              W.continuing_subword_suffix ?? null),
            (this.byte_fallback = this.config.byte_fallback ?? !1),
            this.byte_fallback && (this.text_encoder = new TextEncoder()),
            (this.ignore_merges = this.config.ignore_merges ?? !1),
            (this.cache = new Map());
        }
        bpe(W) {
          if (W.length === 0) return [];
          const pe = this.cache.get(W);
          if (pe !== void 0) return pe;
          const Pe = Array.from(W);
          this.end_of_word_suffix &&
            (Pe[Pe.length - 1] += this.end_of_word_suffix);
          let Oe = [];
          if (Pe.length > 1) {
            const Le = new m.PriorityQueue((Pt, Ct) => Pt.score < Ct.score);
            let nt = { token: Pe[0], bias: 0, prev: null, next: null },
              Et = nt;
            for (let Pt = 1; Pt < Pe.length; ++Pt) {
              const Ct = {
                bias: Pt / Pe.length,
                token: Pe[Pt],
                prev: Et,
                next: null
              };
              (Et.next = Ct), this._add_node(Le, Et), (Et = Ct);
            }
            for (; !Le.isEmpty(); ) {
              const Pt = Le.pop();
              if (Pt.deleted || !Pt.next || Pt.next.deleted) continue;
              if (((Pt.deleted = !0), (Pt.next.deleted = !0), Pt.prev)) {
                const Ot = { ...Pt.prev };
                (Pt.prev.deleted = !0),
                  (Pt.prev = Ot),
                  Ot.prev ? (Ot.prev.next = Ot) : (nt = Ot);
              }
              const Ct = {
                token: Pt.token + Pt.next.token,
                bias: Pt.bias,
                prev: Pt.prev,
                next: Pt.next.next
              };
              Ct.prev
                ? ((Ct.prev.next = Ct), this._add_node(Le, Ct.prev))
                : (nt = Ct),
                Ct.next && ((Ct.next.prev = Ct), this._add_node(Le, Ct));
            }
            for (let Pt = nt; Pt !== null; Pt = Pt.next) Oe.push(Pt.token);
          } else Oe = Pe;
          if (this.continuing_subword_suffix)
            for (let Le = 0; Le < Oe.length - 1; ++Le)
              Oe[Le] += this.continuing_subword_suffix;
          return this.cache.set(W, Oe), Oe;
        }
        _add_node(W, pe) {
          const Pe = this.bpe_ranks.get(
            pe.token + this.BPE_SPLIT_TOKEN + pe.next.token
          );
          Pe !== void 0 && ((pe.score = Pe + pe.bias), W.push(pe));
        }
        encode(W) {
          const pe = [];
          for (const Pe of W) {
            if (this.ignore_merges && this.tokens_to_ids.has(Pe)) {
              pe.push(Pe);
              continue;
            }
            const Oe = this.bpe(Pe);
            for (const Le of Oe)
              this.tokens_to_ids.has(Le)
                ? pe.push(Le)
                : this.byte_fallback
                ? pe.push(
                    ...Array.from(this.text_encoder.encode(Le)).map(
                      (nt) =>
                        `<0x${nt.toString(16).toUpperCase().padStart(2, "0")}>`
                    )
                  )
                : pe.push(this.unk_token);
          }
          return pe;
        }
      }
      class _e extends Me {
        constructor(W, pe) {
          super(W),
            (this.tokens_to_ids = $(
              pe.target_lang ? W.vocab[pe.target_lang] : W.vocab
            )),
            (this.bos_token = pe.bos_token),
            (this.bos_token_id = this.tokens_to_ids.get(this.bos_token)),
            (this.eos_token = pe.eos_token),
            (this.eos_token_id = this.tokens_to_ids.get(this.eos_token)),
            (this.pad_token = pe.pad_token),
            (this.pad_token_id = this.tokens_to_ids.get(this.pad_token)),
            (this.unk_token = pe.unk_token),
            (this.unk_token_id = this.tokens_to_ids.get(this.unk_token)),
            (this.vocab = new Array(this.tokens_to_ids.size));
          for (const [Pe, Oe] of this.tokens_to_ids) this.vocab[Oe] = Pe;
        }
        encode(W) {
          return W;
        }
      }
      class X extends o.Callable {
        constructor(W) {
          super(), (this.config = W);
        }
        static fromConfig(W) {
          if (W === null) return null;
          switch (W.type) {
            case "BertNormalizer":
              return new pt(W);
            case "Precompiled":
              return new Ve(W);
            case "Sequence":
              return new st(W);
            case "Replace":
              return new oe(W);
            case "NFC":
              return new xe(W);
            case "NFKC":
              return new Y(W);
            case "NFKD":
              return new ge(W);
            case "Strip":
              return new qe(W);
            case "StripAccents":
              return new Be(W);
            case "Lowercase":
              return new Ne(W);
            case "Prepend":
              return new We(W);
            default:
              throw new Error(`Unknown Normalizer type: ${W.type}`);
          }
        }
        normalize(W) {
          throw Error("normalize should be implemented in subclass.");
        }
        _call(W) {
          return this.normalize(W);
        }
      }
      class oe extends X {
        normalize(W) {
          const pe = z(this.config.pattern);
          return pe === null ? W : W.replaceAll(pe, this.config.content);
        }
      }
      class xe extends X {
        normalize(W) {
          return (W = W.normalize("NFC")), W;
        }
      }
      class Y extends X {
        normalize(W) {
          return (W = W.normalize("NFKC")), W;
        }
      }
      class ge extends X {
        normalize(W) {
          return (W = W.normalize("NFKD")), W;
        }
      }
      class qe extends X {
        normalize(W) {
          return (
            this.config.strip_left && this.config.strip_right
              ? (W = W.trim())
              : (this.config.strip_left && (W = W.trimStart()),
                this.config.strip_right && (W = W.trimEnd())),
            W
          );
        }
      }
      class Be extends X {
        normalize(W) {
          return (W = x(W)), W;
        }
      }
      class Ne extends X {
        normalize(W) {
          return (W = W.toLowerCase()), W;
        }
      }
      class We extends X {
        normalize(W) {
          return (W = this.config.prepend + W), W;
        }
      }
      class st extends X {
        constructor(W) {
          super(W),
            (this.normalizers = W.normalizers.map((pe) => X.fromConfig(pe)));
        }
        normalize(W) {
          return this.normalizers.reduce((pe, Pe) => Pe.normalize(pe), W);
        }
      }
      class pt extends X {
        _tokenize_chinese_chars(W) {
          const pe = [];
          for (let Pe = 0; Pe < W.length; ++Pe) {
            const Oe = W[Pe],
              Le = Oe.charCodeAt(0);
            V(Le) ? (pe.push(" "), pe.push(Oe), pe.push(" ")) : pe.push(Oe);
          }
          return pe.join("");
        }
        stripAccents(W) {
          return W.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }
        _is_control(W) {
          switch (W) {
            case "	":
            case `
`:
            case "\r":
              return !1;
            default:
              return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$", "u").test(
                W
              );
          }
        }
        _clean_text(W) {
          const pe = [];
          for (const Pe of W) {
            const Oe = Pe.charCodeAt(0);
            Oe === 0 ||
              Oe === 65533 ||
              this._is_control(Pe) ||
              (/^\s$/.test(Pe) ? pe.push(" ") : pe.push(Pe));
          }
          return pe.join("");
        }
        normalize(W) {
          return (
            this.config.clean_text && (W = this._clean_text(W)),
            this.config.handle_chinese_chars &&
              (W = this._tokenize_chinese_chars(W)),
            this.config.lowercase
              ? ((W = W.toLowerCase()),
                this.config.strip_accents !== !1 && (W = this.stripAccents(W)))
              : this.config.strip_accents && (W = this.stripAccents(W)),
            W
          );
        }
      }
      class Ge extends o.Callable {
        static fromConfig(W) {
          if (W === null) return null;
          switch (W.type) {
            case "BertPreTokenizer":
              return new Te(W);
            case "Sequence":
              return new ot(W);
            case "Whitespace":
              return new Xe(W);
            case "WhitespaceSplit":
              return new ft(W);
            case "Metaspace":
              return new fe(W);
            case "ByteLevel":
              return new je(W);
            case "Split":
              return new Ye(W);
            case "Punctuation":
              return new et(W);
            case "Digits":
              return new A(W);
            case "Replace":
              return new xt(W);
            default:
              throw new Error(`Unknown PreTokenizer type: ${W.type}`);
          }
        }
        pre_tokenize_text(W, pe) {
          throw Error("pre_tokenize_text should be implemented in subclass.");
        }
        pre_tokenize(W, pe) {
          return (
            Array.isArray(W)
              ? W.map((Pe) => this.pre_tokenize_text(Pe, pe))
              : this.pre_tokenize_text(W, pe)
          ).flat();
        }
        _call(W, pe) {
          return this.pre_tokenize(W, pe);
        }
      }
      class Te extends Ge {
        constructor(W) {
          super(), (this.pattern = new RegExp(`[^\\s${j}]+|[${j}]`, "gu"));
        }
        pre_tokenize_text(W, pe) {
          return W.trim().match(this.pattern) || [];
        }
      }
      class je extends Ge {
        constructor(W) {
          super(),
            (this.config = W),
            (this.add_prefix_space = this.config.add_prefix_space),
            (this.trim_offsets = this.config.trim_offsets),
            (this.use_regex = this.config.use_regex ?? !0),
            (this.pattern = new RegExp(
              "'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+",
              "gu"
            )),
            (this.byte_encoder = L),
            (this.text_encoder = new TextEncoder());
        }
        pre_tokenize_text(W, pe) {
          return (
            this.add_prefix_space && !W.startsWith(" ") && (W = " " + W),
            (this.use_regex ? W.match(this.pattern) || [] : [W]).map((Oe) =>
              Array.from(
                this.text_encoder.encode(Oe),
                (Le) => this.byte_encoder[Le]
              ).join("")
            )
          );
        }
      }
      class Ye extends Ge {
        constructor(W) {
          super(),
            (this.config = W),
            (this.pattern = z(this.config.pattern, this.config.invert));
        }
        pre_tokenize_text(W, pe) {
          return this.pattern === null
            ? []
            : this.config.invert
            ? W.match(this.pattern) || []
            : T(W, this.pattern);
        }
      }
      class et extends Ge {
        constructor(W) {
          super(),
            (this.config = W),
            (this.pattern = new RegExp(`[^${j}]+|[${j}]+`, "gu"));
        }
        pre_tokenize_text(W, pe) {
          return W.match(this.pattern) || [];
        }
      }
      class A extends Ge {
        constructor(W) {
          super(), (this.config = W);
          const pe = `[^\\d]+|\\d${this.config.individual_digits ? "" : "+"}`;
          this.pattern = new RegExp(pe, "gu");
        }
        pre_tokenize_text(W, pe) {
          return W.match(this.pattern) || [];
        }
      }
      class Ae extends o.Callable {
        constructor(W) {
          super(), (this.config = W);
        }
        static fromConfig(W) {
          if (W === null) return null;
          switch (W.type) {
            case "TemplateProcessing":
              return new ne(W);
            case "ByteLevel":
              return new ve(W);
            case "RobertaProcessing":
              return new ae(W);
            case "BertProcessing":
              return new $e(W);
            case "Sequence":
              return new R(W);
            default:
              throw new Error(`Unknown PostProcessor type: ${W.type}`);
          }
        }
        post_process(W, ...pe) {
          throw Error("post_process should be implemented in subclass.");
        }
        _call(W, ...pe) {
          return this.post_process(W, ...pe);
        }
      }
      class $e extends Ae {
        constructor(W) {
          super(W), (this.cls = W.cls[0]), (this.sep = W.sep[0]);
        }
        post_process(W, pe = null, { add_special_tokens: Pe = !0 } = {}) {
          Pe && (W = (0, a.mergeArrays)([this.cls], W, [this.sep]));
          let Oe = new Array(W.length).fill(0);
          if (pe !== null) {
            const Le = Pe && this instanceof ae ? [this.sep] : [],
              nt = Pe ? [this.sep] : [];
            (W = (0, a.mergeArrays)(W, Le, pe, nt)),
              (Oe = (0, a.mergeArrays)(
                Oe,
                new Array(pe.length + Le.length + nt.length).fill(1)
              ));
          }
          return { tokens: W, token_type_ids: Oe };
        }
      }
      class ae extends $e {}
      class ne extends Ae {
        constructor(W) {
          super(W), (this.single = W.single), (this.pair = W.pair);
        }
        post_process(W, pe = null, { add_special_tokens: Pe = !0 } = {}) {
          const Oe = pe === null ? this.single : this.pair;
          let Le = [],
            nt = [];
          for (const Et of Oe)
            "SpecialToken" in Et
              ? Pe &&
                (Le.push(Et.SpecialToken.id), nt.push(Et.SpecialToken.type_id))
              : "Sequence" in Et &&
                (Et.Sequence.id === "A"
                  ? ((Le = (0, a.mergeArrays)(Le, W)),
                    (nt = (0, a.mergeArrays)(
                      nt,
                      new Array(W.length).fill(Et.Sequence.type_id)
                    )))
                  : Et.Sequence.id === "B" &&
                    ((Le = (0, a.mergeArrays)(Le, pe)),
                    (nt = (0, a.mergeArrays)(
                      nt,
                      new Array(pe.length).fill(Et.Sequence.type_id)
                    ))));
          return { tokens: Le, token_type_ids: nt };
        }
      }
      class ve extends Ae {
        post_process(W, pe = null) {
          return pe && (W = (0, a.mergeArrays)(W, pe)), { tokens: W };
        }
      }
      class R extends Ae {
        constructor(W) {
          super(W),
            (this.processors = W.processors.map((pe) => Ae.fromConfig(pe)));
        }
        post_process(W, pe = null, Pe = {}) {
          let Oe;
          for (const Le of this.processors)
            if (Le instanceof ve)
              (W = Le.post_process(W).tokens),
                pe && (pe = Le.post_process(pe).tokens);
            else {
              const nt = Le.post_process(W, pe, Pe);
              (W = nt.tokens), (Oe = nt.token_type_ids);
            }
          return { tokens: W, token_type_ids: Oe };
        }
      }
      class te extends o.Callable {
        constructor(W) {
          super(),
            (this.config = W),
            (this.added_tokens = []),
            (this.end_of_word_suffix = null),
            (this.trim_offsets = W.trim_offsets);
        }
        static fromConfig(W) {
          if (W === null) return null;
          switch (W.type) {
            case "WordPiece":
              return new Re(W);
            case "Metaspace":
              return new Ie(W);
            case "ByteLevel":
              return new ht(W);
            case "Replace":
              return new D(W);
            case "ByteFallback":
              return new ce(W);
            case "Fuse":
              return new ue(W);
            case "Strip":
              return new ke(W);
            case "Sequence":
              return new wt(W);
            case "CTC":
              return new tt(W);
            case "BPEDecoder":
              return new bt(W);
            default:
              throw new Error(`Unknown Decoder type: ${W.type}`);
          }
        }
        _call(W) {
          return this.decode(W);
        }
        decode(W) {
          return this.decode_chain(W).join("");
        }
        decode_chain(W) {
          throw Error("`decode_chain` should be implemented in subclass.");
        }
      }
      class D extends te {
        decode_chain(W) {
          const pe = z(this.config.pattern);
          return pe === null
            ? W
            : W.map((Pe) => Pe.replaceAll(pe, this.config.content));
        }
      }
      class ce extends te {
        constructor(W) {
          super(W), (this.text_decoder = new TextDecoder());
        }
        decode_chain(W) {
          const pe = [];
          let Pe = [];
          for (const Oe of W) {
            let Le = null;
            if (Oe.length === 6 && Oe.startsWith("<0x") && Oe.endsWith(">")) {
              const nt = parseInt(Oe.slice(3, 5), 16);
              isNaN(nt) || (Le = nt);
            }
            if (Le !== null) Pe.push(Le);
            else {
              if (Pe.length > 0) {
                const nt = this.text_decoder.decode(Uint8Array.from(Pe));
                pe.push(nt), (Pe = []);
              }
              pe.push(Oe);
            }
          }
          if (Pe.length > 0) {
            const Oe = this.text_decoder.decode(Uint8Array.from(Pe));
            pe.push(Oe), (Pe = []);
          }
          return pe;
        }
      }
      class ue extends te {
        decode_chain(W) {
          return [W.join("")];
        }
      }
      class ke extends te {
        constructor(W) {
          super(W),
            (this.content = this.config.content),
            (this.start = this.config.start),
            (this.stop = this.config.stop);
        }
        decode_chain(W) {
          return W.map((pe) => {
            let Pe = 0;
            for (let Le = 0; Le < this.start && pe[Le] === this.content; ++Le) {
              Pe = Le + 1;
              continue;
            }
            let Oe = pe.length;
            for (let Le = 0; Le < this.stop; ++Le) {
              const nt = pe.length - Le - 1;
              if (pe[nt] === this.content) {
                Oe = nt;
                continue;
              } else break;
            }
            return pe.slice(Pe, Oe);
          });
        }
      }
      class Re extends te {
        constructor(W) {
          super(W), (this.cleanup = W.cleanup);
        }
        decode_chain(W) {
          return W.map(
            (pe, Pe) => (
              Pe !== 0 &&
                (pe.startsWith(this.config.prefix)
                  ? (pe = pe.replace(this.config.prefix, ""))
                  : (pe = " " + pe)),
              this.cleanup && (pe = y(pe)),
              pe
            )
          );
        }
      }
      class ht extends te {
        constructor(W) {
          super(W),
            (this.byte_decoder = Ee),
            (this.text_decoder = new TextDecoder("utf-8", {
              fatal: !1,
              ignoreBOM: !0
            })),
            (this.end_of_word_suffix = null);
        }
        convert_tokens_to_string(W) {
          const pe = W.join(""),
            Pe = new Uint8Array([...pe].map((Le) => this.byte_decoder[Le]));
          return this.text_decoder.decode(Pe);
        }
        decode_chain(W) {
          const pe = [];
          let Pe = [];
          for (const Oe of W)
            this.added_tokens.find((Le) => Le.content === Oe) !== void 0
              ? (Pe.length > 0 &&
                  (pe.push(this.convert_tokens_to_string(Pe)), (Pe = [])),
                pe.push(Oe))
              : Pe.push(Oe);
          return (
            Pe.length > 0 && pe.push(this.convert_tokens_to_string(Pe)), pe
          );
        }
      }
      class tt extends te {
        constructor(W) {
          super(W),
            (this.pad_token = this.config.pad_token),
            (this.word_delimiter_token = this.config.word_delimiter_token),
            (this.cleanup = this.config.cleanup);
        }
        convert_tokens_to_string(W) {
          if (W.length === 0) return "";
          const pe = [W[0]];
          for (let Le = 1; Le < W.length; ++Le)
            W[Le] !== pe.at(-1) && pe.push(W[Le]);
          let Oe = pe.filter((Le) => Le !== this.pad_token).join("");
          return (
            this.cleanup &&
              (Oe = y(Oe).replaceAll(this.word_delimiter_token, " ").trim()),
            Oe
          );
        }
        decode_chain(W) {
          return [this.convert_tokens_to_string(W)];
        }
      }
      class wt extends te {
        constructor(W) {
          super(W), (this.decoders = W.decoders.map((pe) => te.fromConfig(pe)));
        }
        decode_chain(W) {
          return this.decoders.reduce((pe, Pe) => Pe.decode_chain(pe), W);
        }
      }
      class bt extends te {
        constructor(W) {
          super(W), (this.suffix = this.config.suffix);
        }
        decode_chain(W) {
          return W.map((pe, Pe) =>
            pe.replaceAll(this.suffix, Pe === W.length - 1 ? "" : " ")
          );
        }
      }
      class Ke extends te {
        decode_chain(W) {
          let pe = "";
          for (let Pe = 1; Pe < W.length; Pe += 2) pe += W[Pe];
          return [pe];
        }
      }
      class fe extends Ge {
        constructor(W) {
          super(),
            (this.addPrefixSpace = W.add_prefix_space),
            (this.replacement = W.replacement),
            (this.strRep = W.str_rep || this.replacement),
            (this.prepend_scheme = W.prepend_scheme ?? "always");
        }
        pre_tokenize_text(W, { section_index: pe = void 0 } = {}) {
          let Pe = W.replaceAll(" ", this.strRep);
          return (
            this.addPrefixSpace &&
              !Pe.startsWith(this.replacement) &&
              (this.prepend_scheme === "always" ||
                (this.prepend_scheme === "first" && pe === 0)) &&
              (Pe = this.strRep + Pe),
            [Pe]
          );
        }
      }
      class Ie extends te {
        constructor(W) {
          super(W),
            (this.addPrefixSpace = W.add_prefix_space),
            (this.replacement = W.replacement);
        }
        decode_chain(W) {
          const pe = [];
          for (let Pe = 0; Pe < W.length; ++Pe) {
            let Oe = W[Pe].replaceAll(this.replacement, " ");
            this.addPrefixSpace &&
              Pe == 0 &&
              Oe.startsWith(" ") &&
              (Oe = Oe.substring(1)),
              pe.push(Oe);
          }
          return pe;
        }
      }
      class Ve extends X {
        constructor(W) {
          super(W), (this.charsmap = W.precompiled_charsmap);
        }
        normalize(W) {
          return (
            (W = W.replace(
              /[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,
              ""
            )),
            (W = W.replace(
              /[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm,
              " "
            )),
            W.includes("～")
              ? (W = W.split("～")
                  .map((Pe) => Pe.normalize("NFKC"))
                  .join("～"))
              : (W = W.normalize("NFKC")),
            W
          );
        }
      }
      class ot extends Ge {
        constructor(W) {
          super(),
            (this.tokenizers = W.pretokenizers.map((pe) => Ge.fromConfig(pe)));
        }
        pre_tokenize_text(W, pe) {
          return this.tokenizers.reduce(
            (Pe, Oe) => Oe.pre_tokenize(Pe, pe),
            [W]
          );
        }
      }
      class Xe extends Ge {
        constructor(W) {
          super();
        }
        pre_tokenize_text(W, pe) {
          return W.match(/\w+|[^\w\s]+/g) || [];
        }
      }
      class ft extends Ge {
        constructor(W) {
          super();
        }
        pre_tokenize_text(W, pe) {
          return B(W);
        }
      }
      class xt extends Ge {
        constructor(W) {
          super(),
            (this.config = W),
            (this.pattern = z(this.config.pattern)),
            (this.content = this.config.content);
        }
        pre_tokenize_text(W, pe) {
          return this.pattern === null
            ? [W]
            : [W.replaceAll(this.pattern, this.config.content)];
        }
      }
      const vt = [
        "bos_token",
        "eos_token",
        "unk_token",
        "sep_token",
        "pad_token",
        "cls_token",
        "mask_token"
      ];
      function $t(Ue, W, pe, Pe) {
        for (const Oe of Object.keys(Ue)) {
          const Le = W - Ue[Oe].length,
            nt = pe(Oe),
            Et = new Array(Le).fill(nt);
          Ue[Oe] =
            Pe === "right"
              ? (0, a.mergeArrays)(Ue[Oe], Et)
              : (0, a.mergeArrays)(Et, Ue[Oe]);
        }
      }
      function Tt(Ue, W) {
        for (const pe of Object.keys(Ue)) Ue[pe].length = W;
      }
      class rt extends o.Callable {
        constructor(pe, Pe) {
          super();
          He(this, "return_token_type_ids", !1);
          He(this, "padding_side", "right");
          (this._tokenizer_config = Pe),
            (this.normalizer = X.fromConfig(pe.normalizer)),
            (this.pre_tokenizer = Ge.fromConfig(pe.pre_tokenizer)),
            (this.model = Me.fromConfig(pe.model, Pe)),
            (this.post_processor = Ae.fromConfig(pe.post_processor)),
            (this.decoder = te.fromConfig(pe.decoder)),
            (this.special_tokens = []),
            (this.all_special_ids = []),
            (this.added_tokens = []);
          for (const Oe of pe.added_tokens) {
            const Le = new de(Oe);
            this.added_tokens.push(Le),
              this.model.tokens_to_ids.set(Le.content, Le.id),
              (this.model.vocab[Le.id] = Le.content),
              Le.special &&
                (this.special_tokens.push(Le.content),
                this.all_special_ids.push(Le.id));
          }
          if (
            ((this.additional_special_tokens =
              Pe.additional_special_tokens ?? []),
            this.special_tokens.push(...this.additional_special_tokens),
            (this.special_tokens = [...new Set(this.special_tokens)]),
            this.decoder &&
              ((this.decoder.added_tokens = this.added_tokens),
              (this.decoder.end_of_word_suffix =
                this.model.end_of_word_suffix)),
            (this.added_tokens_regex =
              this.added_tokens.length > 0
                ? new RegExp(
                    this.added_tokens
                      .toSorted(
                        (Oe, Le) => Le.content.length - Oe.content.length
                      )
                      .map(
                        (Oe) =>
                          `${Oe.lstrip ? "\\s*" : ""}(${(0, a.escapeRegExp)(
                            Oe.content
                          )})${Oe.rstrip ? "\\s*" : ""}`
                      )
                      .join("|")
                  )
                : null),
            (this.mask_token = this.getToken("mask_token")),
            (this.mask_token_id = this.model.tokens_to_ids.get(
              this.mask_token
            )),
            (this.pad_token = this.getToken("pad_token", "eos_token")),
            (this.pad_token_id = this.model.tokens_to_ids.get(this.pad_token)),
            (this.sep_token = this.getToken("sep_token")),
            (this.sep_token_id = this.model.tokens_to_ids.get(this.sep_token)),
            (this.unk_token = this.getToken("unk_token")),
            (this.unk_token_id = this.model.tokens_to_ids.get(this.unk_token)),
            (this.model_max_length = Pe.model_max_length),
            (this.remove_space = Pe.remove_space),
            (this.clean_up_tokenization_spaces =
              Pe.clean_up_tokenization_spaces ?? !0),
            (this.do_lowercase_and_remove_accent =
              Pe.do_lowercase_and_remove_accent ?? !1),
            Pe.padding_side && (this.padding_side = Pe.padding_side),
            (this.legacy = !1),
            (this.chat_template = Pe.chat_template ?? null),
            Array.isArray(this.chat_template))
          ) {
            const Oe = Object.create(null);
            for (const { name: Le, template: nt } of this.chat_template) {
              if (typeof Le != "string" || typeof nt != "string")
                throw new Error(
                  'Chat template must be a list of objects with "name" and "template" properties'
                );
              Oe[Le] = nt;
            }
            this.chat_template = Oe;
          }
          this._compiled_template_cache = new Map();
        }
        getToken(...pe) {
          for (const Pe of pe) {
            const Oe = this._tokenizer_config[Pe];
            if (Oe)
              if (typeof Oe == "object") {
                if (Oe.__type === "AddedToken") return Oe.content;
                throw Error(`Unknown token: ${Oe}`);
              } else return Oe;
          }
          return null;
        }
        static async from_pretrained(
          pe,
          {
            progress_callback: Pe = null,
            config: Oe = null,
            cache_dir: Le = null,
            local_files_only: nt = !1,
            revision: Et = "main",
            legacy: Pt = null
          } = {}
        ) {
          const Ct = await C(pe, {
            progress_callback: Pe,
            config: Oe,
            cache_dir: Le,
            local_files_only: nt,
            revision: Et,
            legacy: Pt
          });
          return new this(...Ct);
        }
        _call(
          pe,
          {
            text_pair: Pe = null,
            add_special_tokens: Oe = !0,
            padding: Le = !1,
            truncation: nt = null,
            max_length: Et = null,
            return_tensor: Pt = !0,
            return_token_type_ids: Ct = null
          } = {}
        ) {
          const Ot = Array.isArray(pe);
          let or;
          if (Ot) {
            if (pe.length === 0) throw Error("text array must be non-empty");
            if (Pe !== null) {
              if (Array.isArray(Pe)) {
                if (pe.length !== Pe.length)
                  throw Error("text and text_pair must have the same length");
              } else throw Error("text_pair must also be an array");
              or = pe.map((ur, Qt) =>
                this._encode_plus(ur, {
                  text_pair: Pe[Qt],
                  add_special_tokens: Oe,
                  return_token_type_ids: Ct
                })
              );
            } else
              or = pe.map((ur) =>
                this._encode_plus(ur, {
                  add_special_tokens: Oe,
                  return_token_type_ids: Ct
                })
              );
          } else {
            if (pe == null) throw Error("text may not be null or undefined");
            if (Array.isArray(Pe))
              throw Error(
                "When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array)."
              );
            or = [
              this._encode_plus(pe, {
                text_pair: Pe,
                add_special_tokens: Oe,
                return_token_type_ids: Ct
              })
            ];
          }
          if (
            (Et === null
              ? Le === "max_length"
                ? (Et = this.model_max_length)
                : (Et = (0, f.max)(or.map((ur) => ur.input_ids.length))[0])
              : nt ||
                console.warn(
                  "Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."
                ),
            (Et = Math.min(Et, this.model_max_length ?? 1 / 0)),
            Le || nt)
          )
            for (let ur = 0; ur < or.length; ++ur)
              or[ur].input_ids.length !== Et &&
                (or[ur].input_ids.length > Et
                  ? nt && Tt(or[ur], Et)
                  : Le &&
                    $t(
                      or[ur],
                      Et,
                      (Qt) => (Qt === "input_ids" ? this.pad_token_id : 0),
                      this.padding_side
                    ));
          const Or = {};
          if (Pt) {
            if (
              !(Le && nt) &&
              or.some((Qt) => {
                var wr;
                for (const An of Object.keys(Qt))
                  if (
                    Qt[An].length !==
                    ((wr = or[0][An]) == null ? void 0 : wr.length)
                  )
                    return !0;
                return !1;
              })
            )
              throw Error(
                "Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length."
              );
            const ur = [or.length, or[0].input_ids.length];
            for (const Qt of Object.keys(or[0]))
              Or[Qt] = new _.Tensor(
                "int64",
                BigInt64Array.from(or.flatMap((wr) => wr[Qt]).map(BigInt)),
                ur
              );
          } else {
            for (const ur of Object.keys(or[0]))
              Or[ur] = or.map((Qt) => Qt[ur]);
            if (!Ot) for (const ur of Object.keys(Or)) Or[ur] = Or[ur][0];
          }
          return Or;
        }
        _encode_text(pe) {
          return pe === null
            ? null
            : (this.added_tokens_regex
                ? pe.split(this.added_tokens_regex).filter((Le) => Le)
                : [pe]
              )
                .map((Le, nt) => {
                  if (
                    this.added_tokens.find((Pt) => Pt.content === Le) !== void 0
                  )
                    return Le;
                  {
                    if (
                      (this.remove_space === !0 &&
                        (Le = Le.trim().split(/\s+/).join(" ")),
                      this.do_lowercase_and_remove_accent && (Le = I(Le)),
                      this.normalizer !== null && (Le = this.normalizer(Le)),
                      Le.length === 0)
                    )
                      return [];
                    const Pt =
                      this.pre_tokenizer !== null
                        ? this.pre_tokenizer(Le, { section_index: nt })
                        : [Le];
                    return this.model(Pt);
                  }
                })
                .flat();
        }
        _encode_plus(
          pe,
          {
            text_pair: Pe = null,
            add_special_tokens: Oe = !0,
            return_token_type_ids: Le = null
          } = {}
        ) {
          const { tokens: nt, token_type_ids: Et } = this._tokenize_helper(pe, {
              pair: Pe,
              add_special_tokens: Oe
            }),
            Pt = this.model.convert_tokens_to_ids(nt),
            Ct = {
              input_ids: Pt,
              attention_mask: new Array(Pt.length).fill(1)
            };
          return (
            (Le ?? this.return_token_type_ids) &&
              Et &&
              (Ct.token_type_ids = Et),
            Ct
          );
        }
        _tokenize_helper(
          pe,
          { pair: Pe = null, add_special_tokens: Oe = !1 } = {}
        ) {
          const Le = this._encode_text(pe),
            nt = this._encode_text(Pe);
          return this.post_processor
            ? this.post_processor(Le, nt, { add_special_tokens: Oe })
            : { tokens: (0, a.mergeArrays)(Le ?? [], nt ?? []) };
        }
        tokenize(pe, { pair: Pe = null, add_special_tokens: Oe = !1 } = {}) {
          return this._tokenize_helper(pe, { pair: Pe, add_special_tokens: Oe })
            .tokens;
        }
        encode(
          pe,
          {
            text_pair: Pe = null,
            add_special_tokens: Oe = !0,
            return_token_type_ids: Le = null
          } = {}
        ) {
          return this._encode_plus(pe, {
            text_pair: Pe,
            add_special_tokens: Oe,
            return_token_type_ids: Le
          }).input_ids;
        }
        batch_decode(pe, Pe = {}) {
          return (
            pe instanceof _.Tensor && (pe = pe.tolist()),
            pe.map((Oe) => this.decode(Oe, Pe))
          );
        }
        decode(pe, Pe = {}) {
          if (
            (pe instanceof _.Tensor && (pe = S(pe)),
            !Array.isArray(pe) ||
              pe.length === 0 ||
              !(0, a.isIntegralNumber)(pe[0]))
          )
            throw Error("token_ids must be a non-empty array of integers.");
          return this.decode_single(pe, Pe);
        }
        decode_single(
          pe,
          {
            skip_special_tokens: Pe = !1,
            clean_up_tokenization_spaces: Oe = null
          }
        ) {
          let Le = this.model.convert_ids_to_tokens(pe);
          Pe && (Le = Le.filter((Et) => !this.special_tokens.includes(Et)));
          let nt = this.decoder ? this.decoder(Le) : Le.join(" ");
          return (
            this.decoder &&
              this.decoder.end_of_word_suffix &&
              ((nt = nt.replaceAll(this.decoder.end_of_word_suffix, " ")),
              Pe && (nt = nt.trim())),
            (Oe ?? this.clean_up_tokenization_spaces) && (nt = y(nt)),
            nt
          );
        }
        apply_chat_template(
          pe,
          {
            tools: Pe = null,
            documents: Oe = null,
            chat_template: Le = null,
            add_generation_prompt: nt = !1,
            tokenize: Et = !0,
            padding: Pt = !1,
            truncation: Ct = !1,
            max_length: Ot = null,
            return_tensor: or = !0,
            return_dict: Or = !1,
            tokenizer_kwargs: ur = {},
            ...Qt
          } = {}
        ) {
          if (
            (this.chat_template && typeof this.chat_template == "object") ||
            this.chat_template === null
          ) {
            const Ze = this.chat_template;
            if (Le !== null && Object.hasOwn(Ze, Le)) Le = Ze[Le];
            else if (Le === null && "default" in Ze) Le = Ze.default;
            else if (Le === null)
              throw Error(
                `This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(
                  Ze
                ).sort()}.`
              );
          } else if (this.chat_template) Le = this.chat_template;
          else
            throw Error(
              "Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating"
            );
          if (typeof Le != "string")
            throw Error(`chat_template must be a string, but got ${typeof Le}`);
          let wr = this._compiled_template_cache.get(Le);
          wr === void 0 &&
            ((wr = new g.Template(Le)),
            this._compiled_template_cache.set(Le, wr));
          const An = Object.create(null);
          for (const Ze of vt) {
            const ei = this.getToken(Ze);
            ei && (An[Ze] = ei);
          }
          const vn = wr.render({
            messages: pe,
            add_generation_prompt: nt,
            tools: Pe,
            documents: Oe,
            ...An,
            ...Qt
          });
          if (Et) {
            const Ze = this._call(vn, {
              add_special_tokens: !1,
              padding: Pt,
              truncation: Ct,
              max_length: Ot,
              return_tensor: or,
              ...ur
            });
            return Or ? Ze : Ze.input_ids;
          }
          return vn;
        }
      }
      class Nt extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class Rt extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class Kt extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class Gt extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class Wt extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class er extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class nr extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class ar extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class Mr extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class mt extends rt {}
      class kt extends rt {}
      class Lt extends rt {
        constructor(pe, Pe) {
          super(pe, Pe);
          He(this, "return_token_type_ids", !0);
          console.warn(
            'WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.'
          );
        }
      }
      class nn extends rt {
        constructor() {
          super(...arguments);
          He(this, "return_token_type_ids", !0);
        }
      }
      class yi extends rt {}
      class Ai extends rt {}
      class Qr extends rt {}
      class Tn extends rt {
        constructor(W, pe) {
          super(W, pe),
            (this.languageRegex = /^[a-z]{2}_[A-Z]{2}$/),
            (this.language_codes = this.special_tokens.filter((Pe) =>
              this.languageRegex.test(Pe)
            )),
            (this.lang_to_token = (Pe) => Pe);
        }
        _build_translation_inputs(W, pe, Pe) {
          return Hi(this, W, pe, Pe);
        }
      }
      class Yr extends Tn {}
      class wi extends rt {}
      class Nr extends rt {
        constructor(W, pe) {
          var Le, nt;
          const Pe = ".,!?…。，、।۔،",
            Oe =
              (nt =
                (Le = W.pre_tokenizer) == null
                  ? void 0
                  : Le.pretokenizers[0]) == null
                ? void 0
                : nt.pattern;
          Oe &&
            Oe.Regex === ` ?[^(\\s|[${Pe}])]+` &&
            (Oe.Regex = ` ?[^\\s${Pe}]+`),
            super(W, pe);
        }
      }
      const Wi = "▁";
      class Ii extends rt {
        constructor(pe, Pe) {
          super(pe, Pe);
          He(this, "padding_side", "left");
          (this.legacy = Pe.legacy ?? !0),
            this.legacy ||
              ((this.normalizer = null),
              (this.pre_tokenizer = new fe({
                replacement: Wi,
                add_prefix_space: !0,
                prepend_scheme: "first"
              })));
        }
        _encode_text(pe) {
          if (pe === null) return null;
          if (this.legacy || pe.length === 0) return super._encode_text(pe);
          let Pe = super._encode_text(Wi + pe.replaceAll(Wi, " "));
          return (
            Pe.length > 1 &&
              Pe[0] === Wi &&
              this.special_tokens.includes(Pe[1]) &&
              (Pe = Pe.slice(1)),
            Pe
          );
        }
      }
      class $s extends rt {}
      class Uo extends rt {}
      class Vo extends rt {}
      class Wo extends rt {}
      class Go extends rt {}
      class Gi extends rt {}
      class As extends rt {}
      class _o extends rt {}
      class vi extends rt {}
      function Hi(Ue, W, pe, Pe) {
        if (!("language_codes" in Ue) || !Array.isArray(Ue.language_codes))
          throw new Error(
            "Tokenizer must have `language_codes` attribute set and it should be an array of language ids."
          );
        if (!("languageRegex" in Ue) || !(Ue.languageRegex instanceof RegExp))
          throw new Error(
            "Tokenizer must have `languageRegex` attribute set and it should be a regular expression."
          );
        if (!("lang_to_token" in Ue) || typeof Ue.lang_to_token != "function")
          throw new Error(
            "Tokenizer must have `lang_to_token` attribute set and it should be a function."
          );
        const Oe = Pe.src_lang,
          Le = Pe.tgt_lang;
        if (!Ue.language_codes.includes(Le))
          throw new Error(
            `Target language code "${Le}" is not valid. Must be one of: {${Ue.language_codes.join(
              ", "
            )}}`
          );
        if (Oe !== void 0) {
          if (!Ue.language_codes.includes(Oe))
            throw new Error(
              `Source language code "${Oe}" is not valid. Must be one of: {${Ue.language_codes.join(
                ", "
              )}}`
            );
          for (const nt of Ue.post_processor.config.single)
            if (
              "SpecialToken" in nt &&
              Ue.languageRegex.test(nt.SpecialToken.id)
            ) {
              nt.SpecialToken.id = Ue.lang_to_token(Oe);
              break;
            }
        }
        return (
          (Pe.forced_bos_token_id = Ue.model.convert_tokens_to_ids([
            Ue.lang_to_token(Le)
          ])[0]),
          Ue._call(W, pe)
        );
      }
      class Fi extends rt {
        constructor(W, pe) {
          super(W, pe),
            (this.languageRegex = /^[a-z]{3}_[A-Z][a-z]{3}$/),
            (this.language_codes = this.special_tokens.filter((Pe) =>
              this.languageRegex.test(Pe)
            )),
            (this.lang_to_token = (Pe) => Pe);
        }
        _build_translation_inputs(W, pe, Pe) {
          return Hi(this, W, pe, Pe);
        }
      }
      class ro extends rt {
        constructor(W, pe) {
          super(W, pe),
            (this.languageRegex = /^__[a-z]{2,3}__$/),
            (this.language_codes = this.special_tokens
              .filter((Pe) => this.languageRegex.test(Pe))
              .map((Pe) => Pe.slice(2, -2))),
            (this.lang_to_token = (Pe) => `__${Pe}__`);
        }
        _build_translation_inputs(W, pe, Pe) {
          return Hi(this, W, pe, Pe);
        }
      }
      class yo extends rt {
        get timestamp_begin() {
          return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0] + 1;
        }
        _decode_asr(
          W,
          {
            return_timestamps: pe = !1,
            return_language: Pe = !1,
            time_precision: Oe = null,
            force_full_sequences: Le = !0
          } = {}
        ) {
          if (Oe === null) throw Error("Must specify time_precision");
          let nt = null;
          const Et = pe === "word";
          function Pt() {
            return { language: nt, timestamp: [null, null], text: "" };
          }
          const Ct = [];
          let Ot = Pt(),
            or = 0;
          const Or = this.timestamp_begin;
          let ur = [],
            Qt = [],
            wr = !1,
            An = null;
          const vn = new Set(this.all_special_ids);
          for (const Cr of W) {
            const hn = Cr.tokens,
              Bn = Et ? Cr.token_timestamps : null;
            let Zt = null,
              Kn = Or;
            if ("stride" in Cr) {
              const [Pr, zt, $r] = Cr.stride;
              if (((or -= zt), (An = Pr - $r), zt && (Kn = zt / Oe + Or), $r))
                for (let jr = hn.length - 1; jr >= 0; --jr) {
                  const Zr = Number(hn[jr]);
                  if (Zr >= Or) {
                    if (Zt !== null && (Zr - Or) * Oe < An) break;
                    Zt = Zr;
                  }
                }
            }
            let kn = [],
              Fr = [];
            for (let Pr = 0; Pr < hn.length; ++Pr) {
              const zt = Number(hn[Pr]);
              if (vn.has(zt)) {
                const $r = this.decode([zt]),
                  jr = M.WHISPER_LANGUAGE_MAPPING.get($r.slice(2, -2));
                if (jr !== void 0) {
                  if (nt !== null && jr !== nt && !pe) {
                    ur.push(kn);
                    const Zr = this.findLongestCommonSequence(ur)[0],
                      Qn = this.decode(Zr);
                    (Ot.text = Qn),
                      Ct.push(Ot),
                      (ur = []),
                      (kn = []),
                      (Ot = Pt());
                  }
                  nt = Ot.language = jr;
                }
              } else if (zt >= Or) {
                const $r = (zt - Or) * Oe + or,
                  jr = (0, f.round)($r, 2);
                if (Zt !== null && zt >= Zt) wr = !0;
                else if (wr || (ur.length > 0 && zt < Kn)) wr = !1;
                else if (Ot.timestamp[0] === null) Ot.timestamp[0] = jr;
                else if (jr !== Ot.timestamp[0]) {
                  (Ot.timestamp[1] = jr), ur.push(kn), Et && Qt.push(Fr);
                  const [Zr, Qn] = this.findLongestCommonSequence(ur, Qt),
                    jt = this.decode(Zr);
                  (Ot.text = jt),
                    Et && (Ot.words = this.collateWordTimestamps(Zr, Qn, nt)),
                    Ct.push(Ot),
                    (ur = []),
                    (kn = []),
                    (Qt = []),
                    (Fr = []),
                    (Ot = Pt());
                }
              } else if ((kn.push(zt), Et)) {
                let $r = (0, f.round)(Bn[Pr] + or, 2),
                  jr;
                if (Pr + 1 < Bn.length) {
                  jr = (0, f.round)(Bn[Pr + 1] + or, 2);
                  const Zr = this.decode([zt]);
                  N.test(Zr) && (jr = (0, f.round)(Math.min($r + Oe, jr), 2));
                } else jr = null;
                Fr.push([$r, jr]);
              }
            }
            if ("stride" in Cr) {
              const [Pr, zt, $r] = Cr.stride;
              or += Pr - $r;
            }
            kn.length > 0
              ? (ur.push(kn), Et && Qt.push(Fr))
              : ur.every((Pr) => Pr.length === 0) &&
                ((Ot = Pt()), (ur = []), (kn = []), (Qt = []), (Fr = []));
          }
          if (ur.length > 0) {
            if (Le && pe)
              throw new Error(
                "Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation."
              );
            const [Cr, hn] = this.findLongestCommonSequence(ur, Qt),
              Bn = this.decode(Cr);
            (Ot.text = Bn),
              Et && (Ot.words = this.collateWordTimestamps(Cr, hn, nt)),
              Ct.push(Ot);
          }
          let Ze = Object.create(null);
          const ei = Ct.map((Cr) => Cr.text).join("");
          if (pe || Pe) {
            for (let Cr = 0; Cr < Ct.length; ++Cr) {
              const hn = Ct[Cr];
              pe || delete hn.timestamp, Pe || delete hn.language;
            }
            if (Et) {
              const Cr = [];
              for (const hn of Ct) for (const Bn of hn.words) Cr.push(Bn);
              Ze = { chunks: Cr };
            } else Ze = { chunks: Ct };
          }
          return [ei, Ze];
        }
        findLongestCommonSequence(W, pe = null) {
          let Pe = W[0],
            Oe = Pe.length,
            Le = [];
          const nt = Array.isArray(pe) && pe.length > 0;
          let Et = nt ? [] : null,
            Pt = nt ? pe[0] : null;
          for (let Ct = 1; Ct < W.length; ++Ct) {
            const Ot = W[Ct];
            let or = 0,
              Or = [Oe, Oe, 0, 0];
            const ur = Ot.length;
            for (let Cr = 1; Cr < Oe + ur; ++Cr) {
              const hn = Math.max(0, Oe - Cr),
                Bn = Math.min(Oe, Oe + ur - Cr),
                Zt = Pe.slice(hn, Bn),
                Kn = Math.max(0, Cr - Oe),
                kn = Math.min(ur, Cr),
                Fr = Ot.slice(Kn, kn);
              if (Zt.length !== Fr.length)
                throw new Error(
                  "There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference."
                );
              let Pr;
              nt
                ? (Pr = Zt.filter(
                    (jr, Zr) => jr === Fr[Zr] && Pt[hn + Zr] <= pe[Ct][Kn + Zr]
                  ).length)
                : (Pr = Zt.filter((jr, Zr) => jr === Fr[Zr]).length);
              const zt = Cr / 1e4,
                $r = Pr / Cr + zt;
              Pr > 1 && $r > or && ((or = $r), (Or = [hn, Bn, Kn, kn]));
            }
            const [Qt, wr, An, vn] = Or,
              Ze = Math.floor((wr + Qt) / 2),
              ei = Math.floor((vn + An) / 2);
            Le.push(...Pe.slice(0, Ze)),
              (Pe = Ot.slice(ei)),
              (Oe = Pe.length),
              nt && (Et.push(...Pt.slice(0, Ze)), (Pt = pe[Ct].slice(ei)));
          }
          return Le.push(...Pe), nt ? (Et.push(...Pt), [Le, Et]) : [Le, []];
        }
        collateWordTimestamps(W, pe, Pe) {
          const [Oe, Le, nt] = this.combineTokensIntoWords(W, Pe),
            Et = [];
          for (let Pt = 0; Pt < Oe.length; ++Pt) {
            const Ct = nt[Pt];
            Et.push({
              text: Oe[Pt],
              timestamp: [pe[Ct.at(0)][0], pe[Ct.at(-1)][1]]
            });
          }
          return Et;
        }
        combineTokensIntoWords(
          W,
          pe,
          Pe = `"'“¡¿([{-`,
          Oe = `"'.。,，!！?？:：”)]}、`
        ) {
          pe = pe ?? "english";
          let Le, nt, Et;
          return (
            ["chinese", "japanese", "thai", "lao", "myanmar"].includes(pe)
              ? ([Le, nt, Et] = this.splitTokensOnUnicode(W))
              : ([Le, nt, Et] = this.splitTokensOnSpaces(W)),
            this.mergePunctuations(Le, nt, Et, Pe, Oe)
          );
        }
        decode(W, pe) {
          let Pe;
          return (
            pe != null && pe.decode_with_timestamps
              ? (W instanceof _.Tensor && (W = S(W)),
                (Pe = this.decodeWithTimestamps(W, pe)))
              : (Pe = super.decode(W, pe)),
            Pe
          );
        }
        decodeWithTimestamps(W, pe) {
          const Pe = (pe == null ? void 0 : pe.time_precision) ?? 0.02,
            Oe = Array.from(this.all_special_ids).at(-1) + 1;
          let Le = [[]];
          for (let nt of W)
            if (((nt = Number(nt)), nt >= Oe)) {
              const Et = ((nt - Oe) * Pe).toFixed(2);
              Le.push(`<|${Et}|>`), Le.push([]);
            } else Le[Le.length - 1].push(nt);
          return (
            (Le = Le.map((nt) =>
              typeof nt == "string" ? nt : super.decode(nt, pe)
            )),
            Le.join("")
          );
        }
        splitTokensOnUnicode(W) {
          const pe = this.decode(W, { decode_with_timestamps: !0 }),
            Pe = "�",
            Oe = [],
            Le = [],
            nt = [];
          let Et = [],
            Pt = [],
            Ct = 0;
          for (let Ot = 0; Ot < W.length; ++Ot) {
            const or = W[Ot];
            Et.push(or), Pt.push(Ot);
            const Or = this.decode(Et, { decode_with_timestamps: !0 });
            (!Or.includes(Pe) || pe[Ct + Or.indexOf(Pe)] === Pe) &&
              (Oe.push(Or),
              Le.push(Et),
              nt.push(Pt),
              (Et = []),
              (Pt = []),
              (Ct += Or.length));
          }
          return [Oe, Le, nt];
        }
        splitTokensOnSpaces(W) {
          const [pe, Pe, Oe] = this.splitTokensOnUnicode(W),
            Le = [],
            nt = [],
            Et = [],
            Pt = new RegExp(`^[${j}]$`, "gu");
          for (let Ct = 0; Ct < pe.length; ++Ct) {
            const Ot = pe[Ct],
              or = Pe[Ct],
              Or = Oe[Ct],
              ur = or[0] >= this.model.tokens_to_ids.get("<|endoftext|>"),
              Qt = Ot.startsWith(" "),
              wr = Ot.trim(),
              An = Pt.test(wr);
            if (ur || Qt || An || Le.length === 0)
              Le.push(Ot), nt.push(or), Et.push(Or);
            else {
              const vn = Le.length - 1;
              (Le[vn] += Ot), nt[vn].push(...or), Et[vn].push(...Or);
            }
          }
          return [Le, nt, Et];
        }
        mergePunctuations(W, pe, Pe, Oe, Le) {
          const nt = structuredClone(W),
            Et = structuredClone(pe),
            Pt = structuredClone(Pe);
          let Ct = nt.length - 2,
            Ot = nt.length - 1;
          for (; Ct >= 0; )
            nt[Ct].startsWith(" ") && Oe.includes(nt[Ct].trim())
              ? ((nt[Ot] = nt[Ct] + nt[Ot]),
                (Et[Ot] = (0, a.mergeArrays)(Et[Ct], Et[Ot])),
                (Pt[Ot] = (0, a.mergeArrays)(Pt[Ct], Pt[Ot])),
                (nt[Ct] = ""),
                (Et[Ct] = []),
                (Pt[Ct] = []))
              : (Ot = Ct),
              --Ct;
          for (Ct = 0, Ot = 1; Ot < nt.length; )
            !nt[Ct].endsWith(" ") && Le.includes(nt[Ot])
              ? ((nt[Ct] += nt[Ot]),
                (Et[Ct] = (0, a.mergeArrays)(Et[Ct], Et[Ot])),
                (Pt[Ct] = (0, a.mergeArrays)(Pt[Ct], Pt[Ot])),
                (nt[Ot] = ""),
                (Et[Ot] = []),
                (Pt[Ot] = []))
              : (Ct = Ot),
              ++Ot;
          return [
            nt.filter((or) => or),
            Et.filter((or) => or.length > 0),
            Pt.filter((or) => or.length > 0)
          ];
        }
        get_decoder_prompt_ids({
          language: W = null,
          task: pe = null,
          no_timestamps: Pe = !0
        } = {}) {
          const Oe = [];
          if (W) {
            const Le = (0, M.whisper_language_to_code)(W),
              nt = this.model.tokens_to_ids.get(`<|${Le}|>`);
            if (nt === void 0)
              throw new Error(
                `Unable to find language "${Le}" in model vocabulary. Please report this issue at ${v.GITHUB_ISSUE_URL}.`
              );
            Oe.push(nt);
          } else Oe.push(null);
          if (pe) {
            if (
              ((pe = pe.toLowerCase()),
              pe !== "transcribe" && pe !== "translate")
            )
              throw new Error(
                `Task "${pe}" is not supported. Must be one of: ["transcribe", "translate"]`
              );
            const Le = this.model.tokens_to_ids.get(`<|${pe}|>`);
            if (Le === void 0)
              throw new Error(
                `Unable to find task "${pe}" in model vocabulary. Please report this issue at ${v.GITHUB_ISSUE_URL}.`
              );
            Oe.push(Le);
          } else Oe.push(null);
          if (Pe) {
            const Le = this.model.tokens_to_ids.get("<|notimestamps|>");
            if (Le === void 0)
              throw new Error(
                `Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at ${v.GITHUB_ISSUE_URL}.`
              );
            Oe.push(Le);
          }
          return Oe.map((Le, nt) => [nt + 1, Le]).filter(
            (Le) => Le[1] !== null
          );
        }
      }
      class wo extends rt {}
      class Yt extends rt {}
      class no extends rt {}
      class Ho extends rt {
        constructor(W, pe) {
          super(W, pe),
            (this.languageRegex = /^(>>\w+<<)\s*/g),
            (this.supported_language_codes = this.model.vocab.filter((Pe) =>
              this.languageRegex.test(Pe)
            )),
            console.warn(
              'WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.'
            );
        }
        _encode_text(W) {
          if (W === null) return null;
          const [pe, ...Pe] = W.trim().split(this.languageRegex);
          if (Pe.length === 0) return super._encode_text(pe);
          if (Pe.length === 2) {
            const [Oe, Le] = Pe;
            return (
              this.supported_language_codes.includes(Oe) ||
                console.warn(
                  `Unsupported language code "${Oe}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(
                    this.supported_language_codes
                  )}`
                ),
              (0, a.mergeArrays)([Oe], super._encode_text(Le))
            );
          }
        }
      }
      class qo extends rt {}
      class vo extends rt {}
      class Ko extends rt {}
      class Qo extends rt {}
      class bo extends rt {}
      class Xo extends rt {
        constructor(W, pe) {
          super(W, pe), (this.decoder = new Ke({}));
        }
      }
      class Kr extends rt {}
      class qn {
        static async from_pretrained(
          W,
          {
            progress_callback: pe = null,
            config: Pe = null,
            cache_dir: Oe = null,
            local_files_only: Le = !1,
            revision: nt = "main",
            legacy: Et = null
          } = {}
        ) {
          var Or;
          const [Pt, Ct] = await C(W, {
              progress_callback: pe,
              config: Pe,
              cache_dir: Oe,
              local_files_only: Le,
              revision: nt,
              legacy: Et
            }),
            Ot =
              ((Or = Ct.tokenizer_class) == null
                ? void 0
                : Or.replace(/Fast$/, "")) ?? "PreTrainedTokenizer";
          let or = this.TOKENIZER_CLASS_MAPPING[Ot];
          return (
            or ||
              (console.warn(
                `Unknown tokenizer class "${Ot}", attempting to construct from base class.`
              ),
              (or = rt)),
            new or(Pt, Ct)
          );
        }
      }
      He(qn, "TOKENIZER_CLASS_MAPPING", {
        T5Tokenizer: yi,
        DistilBertTokenizer: mt,
        CamembertTokenizer: kt,
        DebertaTokenizer: Wt,
        DebertaV2Tokenizer: er,
        BertTokenizer: Nt,
        HerbertTokenizer: nr,
        ConvBertTokenizer: ar,
        RoFormerTokenizer: Mr,
        XLMTokenizer: Lt,
        ElectraTokenizer: nn,
        MobileBertTokenizer: Kt,
        SqueezeBertTokenizer: Gt,
        AlbertTokenizer: Rt,
        GPT2Tokenizer: Ai,
        BartTokenizer: Qr,
        MBartTokenizer: Tn,
        MBart50Tokenizer: Yr,
        RobertaTokenizer: wi,
        WhisperTokenizer: yo,
        CodeGenTokenizer: wo,
        CLIPTokenizer: Yt,
        SiglipTokenizer: no,
        MarianTokenizer: Ho,
        BloomTokenizer: Nr,
        NllbTokenizer: Fi,
        M2M100Tokenizer: ro,
        LlamaTokenizer: Ii,
        CodeLlamaTokenizer: $s,
        XLMRobertaTokenizer: Uo,
        MPNetTokenizer: Vo,
        FalconTokenizer: Wo,
        GPTNeoXTokenizer: Go,
        EsmTokenizer: Gi,
        Wav2Vec2CTCTokenizer: qo,
        BlenderbotTokenizer: vo,
        BlenderbotSmallTokenizer: Ko,
        SpeechT5Tokenizer: Qo,
        NougatTokenizer: bo,
        VitsTokenizer: Xo,
        Qwen2Tokenizer: As,
        GemmaTokenizer: _o,
        Grok1Tokenizer: vi,
        CohereTokenizer: Kr,
        PreTrainedTokenizer: rt
      });
    },
    "./src/utils/audio.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          hamming: () => M,
          hanning: () => g,
          mel_filter_bank: () => y,
          read_audio: () => _,
          spectrogram: () => B,
          window_function: () => j
        });
      var o = n("./src/utils/hub.js"),
        a = n("./src/utils/maths.js"),
        l = n("./src/utils/core.js"),
        f = n("./src/utils/tensor.js");
      async function _(N, se) {
        if (typeof AudioContext > "u")
          throw Error(
            "Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing."
          );
        const de = await (await (0, o.getFile)(N)).arrayBuffer(),
          Me = new AudioContext({ sampleRate: se });
        typeof se > "u" &&
          console.warn(
            `No sampling rate provided, using default of ${Me.sampleRate}Hz.`
          );
        const J = await Me.decodeAudioData(de);
        let ye;
        if (J.numberOfChannels === 2) {
          const L = Math.sqrt(2),
            Ee = J.getChannelData(0),
            Qe = J.getChannelData(1);
          ye = new Float32Array(Ee.length);
          for (let _e = 0; _e < J.length; ++_e)
            ye[_e] = (L * (Ee[_e] + Qe[_e])) / 2;
        } else ye = J.getChannelData(0);
        return ye;
      }
      function m(N, se) {
        if (N < 1) return new Float64Array();
        if (N === 1) return new Float64Array([1]);
        const de = 1 - se,
          Me = (2 * Math.PI) / (N - 1),
          J = new Float64Array(N);
        for (let ye = 0; ye < N; ++ye) J[ye] = se - de * Math.cos(ye * Me);
        return J;
      }
      function g(N) {
        return m(N, 0.5);
      }
      function M(N) {
        return m(N, 0.54);
      }
      const v = {
        htk: (N) => 2595 * Math.log10(1 + N / 700),
        kaldi: (N) => 1127 * Math.log(1 + N / 700),
        slaney: (N, se = 1e3, de = 15, Me = 27 / Math.log(6.4)) =>
          N >= se ? de + Math.log(N / se) * Me : (3 * N) / 200
      };
      function C(N, se = "htk") {
        const de = v[se];
        if (!de)
          throw new Error(
            'mel_scale should be one of "htk", "slaney" or "kaldi".'
          );
        return typeof N == "number" ? de(N) : N.map((Me) => de(Me));
      }
      const T = {
        htk: (N) => 700 * (10 ** (N / 2595) - 1),
        kaldi: (N) => 700 * (Math.exp(N / 1127) - 1),
        slaney: (N, se = 1e3, de = 15, Me = Math.log(6.4) / 27) =>
          N >= de ? se * Math.exp(Me * (N - de)) : (200 * N) / 3
      };
      function z(N, se = "htk") {
        const de = T[se];
        if (!de)
          throw new Error(
            'mel_scale should be one of "htk", "slaney" or "kaldi".'
          );
        return typeof N == "number" ? de(N) : N.map((Me) => de(Me));
      }
      function $(N, se) {
        const de = Float64Array.from(
            { length: se.length - 1 },
            (L, Ee) => se[Ee + 1] - se[Ee]
          ),
          Me = Array.from({ length: N.length }, () => new Array(se.length));
        for (let L = 0; L < N.length; ++L) {
          const Ee = Me[L];
          for (let Qe = 0; Qe < se.length; ++Qe) Ee[Qe] = se[Qe] - N[L];
        }
        const J = se.length - 2,
          ye = Array.from({ length: J }, () => new Array(N.length));
        for (let L = 0; L < N.length; ++L) {
          const Ee = Me[L];
          for (let Qe = 0; Qe < J; ++Qe) {
            const _e = -Ee[Qe] / de[Qe],
              X = Ee[Qe + 2] / de[Qe + 1];
            ye[Qe][L] = Math.max(0, Math.min(_e, X));
          }
        }
        return ye;
      }
      function S(N, se, de) {
        const Me = (se - N) / (de - 1);
        return Float64Array.from({ length: de }, (J, ye) => N + Me * ye);
      }
      function y(N, se, de, Me, J, ye = null, L = "htk", Ee = !1) {
        if (ye !== null && ye !== "slaney")
          throw new Error('norm must be one of null or "slaney"');
        const Qe = C(de, L),
          _e = C(Me, L),
          X = S(Qe, _e, se + 2);
        let oe = z(X, L),
          xe;
        if (Ee) {
          const ge = J / (N * 2);
          (xe = C(
            Float64Array.from({ length: N }, (qe, Be) => Be * ge),
            L
          )),
            (oe = X);
        } else xe = S(0, Math.floor(J / 2), N);
        const Y = $(xe, oe);
        if (ye !== null && ye === "slaney")
          for (let ge = 0; ge < se; ++ge) {
            const qe = Y[ge],
              Be = 2 / (oe[ge + 2] - oe[ge]);
            for (let Ne = 0; Ne < N; ++Ne) qe[Ne] *= Be;
          }
        return Y;
      }
      function x(N, se, de) {
        const Me = new N.constructor(N.length + se + de),
          J = N.length - 1;
        for (let ye = 0; ye < N.length; ++ye) Me[se + ye] = N[ye];
        for (let ye = 1; ye <= se; ++ye)
          Me[se - ye] = N[(0, l.calculateReflectOffset)(ye, J)];
        for (let ye = 1; ye <= de; ++ye)
          Me[J + se + ye] = N[(0, l.calculateReflectOffset)(J - ye, J)];
        return Me;
      }
      function I(N, se, de, Me, J) {
        if (de <= 0) throw new Error("reference must be greater than zero");
        if (Me <= 0) throw new Error("min_value must be greater than zero");
        de = Math.max(Me, de);
        const ye = Math.log10(de);
        for (let L = 0; L < N.length; ++L)
          N[L] = se * Math.log10(Math.max(Me, N[L]) - ye);
        if (J !== null) {
          if (J <= 0) throw new Error("db_range must be greater than zero");
          const L = (0, a.max)(N)[0] - J;
          for (let Ee = 0; Ee < N.length; ++Ee) N[Ee] = Math.max(N[Ee], L);
        }
        return N;
      }
      function V(N, se = 1, de = 1e-5, Me = null) {
        return I(N, 20, se, de, Me);
      }
      function O(N, se = 1, de = 1e-10, Me = null) {
        return I(N, 10, se, de, Me);
      }
      async function B(
        N,
        se,
        de,
        Me,
        {
          fft_length: J = null,
          power: ye = 1,
          center: L = !0,
          pad_mode: Ee = "reflect",
          onesided: Qe = !0,
          preemphasis: _e = null,
          mel_filters: X = null,
          mel_floor: oe = 1e-10,
          log_mel: xe = null,
          reference: Y = 1,
          min_value: ge = 1e-10,
          db_range: qe = null,
          remove_dc_offset: Be = null,
          min_num_frames: Ne = null,
          max_num_frames: We = null,
          do_pad: st = !0,
          transpose: pt = !1
        } = {}
      ) {
        const Ge = se.length;
        if ((J === null && (J = de), de > J))
          throw Error(
            `frame_length (${de}) may not be larger than fft_length (${J})`
          );
        if (Ge !== de)
          throw new Error(
            `Length of the window (${Ge}) must equal frame_length (${de})`
          );
        if (Me <= 0) throw new Error("hop_length must be greater than zero");
        if (ye === null && X !== null)
          throw new Error(
            "You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue."
          );
        if (L) {
          if (Ee !== "reflect")
            throw new Error(`pad_mode="${Ee}" not implemented yet.`);
          const te = Math.floor((J - 1) / 2) + 1;
          N = x(N, te, te);
        }
        let Te = Math.floor(1 + Math.floor((N.length - de) / Me));
        Ne !== null && Te < Ne && (Te = Ne);
        const je = Qe ? Math.floor(J / 2) + 1 : J;
        let Ye = Te,
          et = Te;
        We !== null && (We > Te ? st && (et = We) : (et = Ye = We));
        const A = new a.FFT(J),
          Ae = new Float64Array(J),
          $e = new Float64Array(A.outputBufferSize),
          ae = new Float32Array(je * et);
        for (let te = 0; te < Ye; ++te) {
          const D = te * Me,
            ce = Math.min(N.length - D, de);
          ce !== de && Ae.fill(0, 0, de);
          for (let ue = 0; ue < ce; ++ue) Ae[ue] = N[D + ue];
          if (Be) {
            let ue = 0;
            for (let Re = 0; Re < ce; ++Re) ue += Ae[Re];
            const ke = ue / ce;
            for (let Re = 0; Re < ce; ++Re) Ae[Re] -= ke;
          }
          if (_e !== null) {
            for (let ue = ce - 1; ue >= 1; --ue) Ae[ue] -= _e * Ae[ue - 1];
            Ae[0] *= 1 - _e;
          }
          for (let ue = 0; ue < se.length; ++ue) Ae[ue] *= se[ue];
          A.realTransform($e, Ae);
          for (let ue = 0; ue < je; ++ue) {
            const ke = ue << 1;
            ae[ue * et + te] = $e[ke] ** 2 + $e[ke + 1] ** 2;
          }
        }
        if (ye !== null && ye !== 2) {
          const te = 2 / ye;
          for (let D = 0; D < ae.length; ++D) ae[D] **= te;
        }
        const ne = X.length;
        let ve = await (0, f.matmul)(
          new f.Tensor("float32", X.flat(), [ne, je]),
          new f.Tensor("float32", ae, [je, et])
        );
        pt && (ve = ve.transpose(1, 0));
        const R = ve.data;
        for (let te = 0; te < R.length; ++te) R[te] = Math.max(oe, R[te]);
        if (ye !== null && xe !== null) {
          const te = Math.min(R.length, Ye * ne);
          switch (xe) {
            case "log":
              for (let D = 0; D < te; ++D) R[D] = Math.log(R[D]);
              break;
            case "log10":
              for (let D = 0; D < te; ++D) R[D] = Math.log10(R[D]);
              break;
            case "dB":
              if (ye === 1) V(R, Y, ge, qe);
              else if (ye === 2) O(R, Y, ge, qe);
              else
                throw new Error(
                  `Cannot use log_mel option '${xe}' with power ${ye}`
                );
              break;
            default:
              throw new Error(
                `log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${xe}'`
              );
          }
        }
        return ve;
      }
      function j(
        N,
        se,
        { periodic: de = !0, frame_length: Me = null, center: J = !0 } = {}
      ) {
        const ye = de ? N + 1 : N;
        let L;
        switch (se) {
          case "boxcar":
            L = new Float64Array(ye).fill(1);
            break;
          case "hann":
          case "hann_window":
            L = g(ye);
            break;
          case "hamming":
            L = M(ye);
            break;
          case "povey":
            L = g(ye).map((Ee) => Math.pow(Ee, 0.85));
            break;
          default:
            throw new Error(`Unknown window type ${se}.`);
        }
        if ((de && (L = L.subarray(0, N)), Me === null)) return L;
        if (N > Me)
          throw new Error(
            `Length of the window (${N}) may not be larger than frame_length (${Me})`
          );
        return L;
      }
    },
    "./src/utils/constants.js": (e, t, n) => {
      n.r(t), n.d(t, { GITHUB_ISSUE_URL: () => o });
      const o = "https://github.com/xenova/transformers.js/issues/new/choose";
    },
    "./src/utils/core.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          calculateDimensions: () => m,
          calculateReflectOffset: () => C,
          dispatchCallback: () => o,
          escapeRegExp: () => l,
          isIntegralNumber: () => _,
          isTypedArray: () => f,
          mergeArrays: () => M,
          pick: () => T,
          pop: () => g,
          product: () => v,
          reverseDictionary: () => a
        });
      function o(z, $) {
        z && z($);
      }
      function a(z) {
        return Object.fromEntries(Object.entries(z).map(([$, S]) => [S, $]));
      }
      function l(z) {
        return z.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function f(z) {
        var $, S, y;
        return (
          ((y =
            (S =
              ($ = z == null ? void 0 : z.prototype) == null
                ? void 0
                : $.__proto__) == null
              ? void 0
              : S.constructor) == null
            ? void 0
            : y.name) === "TypedArray"
        );
      }
      function _(z) {
        return Number.isInteger(z) || typeof z == "bigint";
      }
      function m(z) {
        const $ = [];
        let S = z;
        for (; Array.isArray(S); ) $.push(S.length), (S = S[0]);
        return $;
      }
      function g(z, $, S = void 0) {
        const y = z[$];
        if (y !== void 0) return delete z[$], y;
        if (S === void 0) throw Error(`Key ${$} does not exist in object.`);
        return S;
      }
      function M(...z) {
        return Array.prototype.concat.apply([], z);
      }
      function v(...z) {
        return z.reduce(($, S) => $.flatMap((y) => S.map((x) => [y, x])));
      }
      function C(z, $) {
        return Math.abs(((z + $) % (2 * $)) - $);
      }
      function T(z, $) {
        return Object.assign(
          {},
          ...$.map((S) => {
            if (z[S] !== void 0) return { [S]: z[S] };
          })
        );
      }
    },
    "./src/utils/data-structures.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          CharTrie: () => a,
          PriorityQueue: () => o,
          TokenLattice: () => f
        });
      class o {
        constructor(g = (v, C) => v > C, M = 1 / 0) {
          (this._heap = []), (this._comparator = g), (this._maxSize = M);
        }
        get size() {
          return this._heap.length;
        }
        isEmpty() {
          return this.size === 0;
        }
        peek() {
          return this._heap[0];
        }
        push(...g) {
          return this.extend(g);
        }
        extend(g) {
          for (const M of g)
            if (this.size < this._maxSize) this._heap.push(M), this._siftUp();
            else {
              const v = this._smallest();
              this._comparator(M, this._heap[v]) &&
                ((this._heap[v] = M), this._siftUpFrom(v));
            }
          return this.size;
        }
        pop() {
          const g = this.peek(),
            M = this.size - 1;
          return (
            M > 0 && this._swap(0, M), this._heap.pop(), this._siftDown(), g
          );
        }
        replace(g) {
          const M = this.peek();
          return (this._heap[0] = g), this._siftDown(), M;
        }
        _parent(g) {
          return ((g + 1) >>> 1) - 1;
        }
        _left(g) {
          return (g << 1) + 1;
        }
        _right(g) {
          return (g + 1) << 1;
        }
        _greater(g, M) {
          return this._comparator(this._heap[g], this._heap[M]);
        }
        _swap(g, M) {
          const v = this._heap[g];
          (this._heap[g] = this._heap[M]), (this._heap[M] = v);
        }
        _siftUp() {
          this._siftUpFrom(this.size - 1);
        }
        _siftUpFrom(g) {
          for (; g > 0 && this._greater(g, this._parent(g)); )
            this._swap(g, this._parent(g)), (g = this._parent(g));
        }
        _siftDown() {
          let g = 0;
          for (
            ;
            (this._left(g) < this.size && this._greater(this._left(g), g)) ||
            (this._right(g) < this.size && this._greater(this._right(g), g));

          ) {
            const M =
              this._right(g) < this.size &&
              this._greater(this._right(g), this._left(g))
                ? this._right(g)
                : this._left(g);
            this._swap(g, M), (g = M);
          }
        }
        _smallest() {
          return 2 ** Math.floor(Math.log2(this.size)) - 1;
        }
      }
      class a {
        constructor() {
          this.root = l.default();
        }
        extend(g) {
          for (let M of g) this.push(M);
        }
        push(g) {
          let M = this.root;
          for (let v of g) {
            let C = M.children.get(v);
            C === void 0 && ((C = l.default()), M.children.set(v, C)), (M = C);
          }
          M.isLeaf = !0;
        }
        *commonPrefixSearch(g) {
          let M = this.root,
            v = "";
          for (let C = 0; C < g.length && M !== void 0; ++C) {
            const T = g[C];
            (v += T),
              (M = M.children.get(T)),
              M !== void 0 && M.isLeaf && (yield v);
          }
        }
      }
      class l {
        constructor(g, M) {
          (this.isLeaf = g), (this.children = M);
        }
        static default() {
          return new l(!1, new Map());
        }
      }
      class f {
        constructor(g, M, v) {
          (this.sentence = g),
            (this.len = g.length),
            (this.bosTokenId = M),
            (this.eosTokenId = v),
            (this.nodes = []),
            (this.beginNodes = Array.from({ length: this.len + 1 }, () => [])),
            (this.endNodes = Array.from({ length: this.len + 1 }, () => []));
          const C = new _(this.bosTokenId, 0, 0, 0, 0),
            T = new _(this.eosTokenId, 1, this.len, 0, 0);
          this.nodes.push(C.clone()),
            this.nodes.push(T.clone()),
            this.beginNodes[this.len].push(T),
            this.endNodes[0].push(C);
        }
        insert(g, M, v, C) {
          const T = this.nodes.length,
            z = new _(C, T, g, M, v);
          this.beginNodes[g].push(z),
            this.endNodes[g + M].push(z),
            this.nodes.push(z);
        }
        viterbi() {
          const g = this.len;
          let M = 0;
          for (; M <= g; ) {
            if (this.beginNodes[M].length == 0) return [];
            for (let $ of this.beginNodes[M]) {
              $.prev = null;
              let S = 0,
                y = null;
              for (let x of this.endNodes[M]) {
                const I = x.backtraceScore + $.score;
                (y === null || I > S) && ((y = x.clone()), (S = I));
              }
              if (y !== null) ($.prev = y), ($.backtraceScore = S);
              else return [];
            }
            ++M;
          }
          const v = [],
            T = this.beginNodes[g][0].prev;
          if (T === null) return [];
          let z = T.clone();
          for (; z.prev !== null; )
            v.push(z.clone()), (z = z.clone().prev.clone());
          return v.reverse(), v;
        }
        piece(g) {
          return this.sentence.slice(g.pos, g.pos + g.length);
        }
        tokens() {
          return this.viterbi().map((M) => this.piece(M));
        }
        tokenIds() {
          return this.viterbi().map((M) => M.tokenId);
        }
      }
      class _ {
        constructor(g, M, v, C, T) {
          (this.tokenId = g),
            (this.nodeId = M),
            (this.pos = v),
            (this.length = C),
            (this.score = T),
            (this.prev = null),
            (this.backtraceScore = 0);
        }
        clone() {
          const g = new _(
            this.tokenId,
            this.nodeId,
            this.pos,
            this.length,
            this.score
          );
          return (
            (g.prev = this.prev), (g.backtraceScore = this.backtraceScore), g
          );
        }
      }
    },
    "./src/utils/devices.js": (e, t, n) => {
      n.r(t), n.d(t, { DEVICE_TYPES: () => o });
      const o = Object.freeze({
        auto: "auto",
        gpu: "gpu",
        cpu: "cpu",
        wasm: "wasm",
        webgpu: "webgpu",
        cuda: "cuda",
        dml: "dml",
        webnn: "webnn",
        "webnn-npu": "webnn-npu",
        "webnn-gpu": "webnn-gpu",
        "webnn-cpu": "webnn-cpu"
      });
    },
    "./src/utils/dtypes.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          DATA_TYPES: () => f,
          DEFAULT_DEVICE_DTYPE_MAPPING: () => _,
          DEFAULT_DTYPE_SUFFIX_MAPPING: () => m,
          isWebGpuFp16Supported: () => l
        });
      var o = n("./src/env.js"),
        a = n("./src/utils/devices.js");
      const l = (function () {
          let g;
          return async function () {
            if (g === void 0)
              if (!o.apis.IS_WEBGPU_AVAILABLE) g = !1;
              else
                try {
                  g = (await navigator.gpu.requestAdapter()).features.has(
                    "shader-f16"
                  );
                } catch {
                  g = !1;
                }
            return g;
          };
        })(),
        f = Object.freeze({
          fp32: "fp32",
          fp16: "fp16",
          q8: "q8",
          int8: "int8",
          uint8: "uint8",
          q4: "q4",
          bnb4: "bnb4",
          q4f16: "q4f16"
        }),
        _ = Object.freeze({ [a.DEVICE_TYPES.wasm]: f.q8 }),
        m = Object.freeze({
          [f.fp32]: "",
          [f.fp16]: "_fp16",
          [f.int8]: "_int8",
          [f.uint8]: "_uint8",
          [f.q8]: "_quantized",
          [f.q4]: "_q4",
          [f.q4f16]: "_q4f16",
          [f.bnb4]: "_bnb4"
        });
    },
    "./src/utils/generic.js": (e, t, n) => {
      n.r(t), n.d(t, { Callable: () => o });
      const o = class {
        constructor() {
          let a = function (...l) {
            return a._call(...l);
          };
          return Object.setPrototypeOf(a, new.target.prototype);
        }
        _call(...a) {
          throw Error("Must implement _call method in subclass");
        }
      };
    },
    "./src/utils/hub.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          getFile: () => M,
          getModelFile: () => $,
          getModelJSON: () => S
        });
      var o = n("?7a2c"),
        a = n("?a42a"),
        l = n("./src/env.js"),
        f = n("./src/utils/core.js");
      const _ = {
        txt: "text/plain",
        html: "text/html",
        css: "text/css",
        js: "text/javascript",
        json: "application/json",
        png: "image/png",
        jpg: "image/jpeg",
        jpeg: "image/jpeg",
        gif: "image/gif"
      };
      class m {
        constructor(V) {
          if (
            ((this.filePath = V),
            (this.headers = new Headers()),
            (this.exists = o.existsSync(V)),
            this.exists)
          ) {
            (this.status = 200), (this.statusText = "OK");
            let O = o.statSync(V);
            this.headers.set("content-length", O.size.toString()),
              this.updateContentType();
            let B = this;
            this.body = new ReadableStream({
              start(j) {
                B.arrayBuffer().then((N) => {
                  j.enqueue(new Uint8Array(N)), j.close();
                });
              }
            });
          } else
            (this.status = 404),
              (this.statusText = "Not Found"),
              (this.body = null);
        }
        updateContentType() {
          const V = this.filePath.toString().split(".").pop().toLowerCase();
          this.headers.set("content-type", _[V] ?? "application/octet-stream");
        }
        clone() {
          let V = new m(this.filePath);
          return (
            (V.exists = this.exists),
            (V.status = this.status),
            (V.statusText = this.statusText),
            (V.headers = new Headers(this.headers)),
            V
          );
        }
        async arrayBuffer() {
          return (await o.promises.readFile(this.filePath)).buffer;
        }
        async blob() {
          const V = await o.promises.readFile(this.filePath);
          return new Blob([V], { type: this.headers.get("content-type") });
        }
        async text() {
          return await o.promises.readFile(this.filePath, "utf8");
        }
        async json() {
          return JSON.parse(await this.text());
        }
      }
      function g(I, V = null, O = null) {
        let B;
        try {
          B = new URL(I);
        } catch {
          return !1;
        }
        return !(
          (V && !V.includes(B.protocol)) ||
          (O && !O.includes(B.hostname))
        );
      }
      async function M(I) {
        var V;
        if (l.env.useFS && !g(I, ["http:", "https:", "blob:"])) return new m(I);
        if (
          typeof process < "u" &&
          ((V = process == null ? void 0 : process.release) == null
            ? void 0
            : V.name) === "node"
        ) {
          const O = !!($o != null && $o.TESTING_REMOTELY),
            B = l.env.version,
            j = new Headers();
          if (
            (j.set("User-Agent", `transformers.js/${B}; is_ci/${O};`),
            g(I, ["http:", "https:"], ["huggingface.co", "hf.co"]))
          ) {
            const se =
              ($o == null ? void 0 : $o.HF_TOKEN) ??
              ($o == null ? void 0 : $o.HF_ACCESS_TOKEN);
            se && j.set("Authorization", `Bearer ${se}`);
          }
          return fetch(I, { headers: j });
        } else return fetch(I);
      }
      const v = {
        400: "Bad request error occurred while trying to load file",
        401: "Unauthorized access to file",
        403: "Forbidden access to file",
        404: "Could not locate file",
        408: "Request timeout error occurred while trying to load file",
        500: "Internal server error error occurred while trying to load file",
        502: "Bad gateway error occurred while trying to load file",
        503: "Service unavailable error occurred while trying to load file",
        504: "Gateway timeout error occurred while trying to load file"
      };
      function C(I, V, O) {
        if (!O) return null;
        const B = v[I] ?? `Error (${I}) occurred while trying to load file`;
        throw Error(`${B}: "${V}".`);
      }
      class T {
        constructor(V) {
          this.path = V;
        }
        async match(V) {
          let O = a.join(this.path, V),
            B = new m(O);
          if (B.exists) return B;
        }
        async put(V, O) {
          const B = Buffer.from(await O.arrayBuffer());
          let j = a.join(this.path, V);
          try {
            await o.promises.mkdir(a.dirname(j), { recursive: !0 }),
              await o.promises.writeFile(j, B);
          } catch (N) {
            console.warn(
              "An error occurred while writing the file to cache:",
              N
            );
          }
        }
      }
      async function z(I, ...V) {
        for (let O of V)
          try {
            let B = await I.match(O);
            if (B) return B;
          } catch {
            continue;
          }
      }
      async function $(I, V, O = !0, B = {}) {
        if (!l.env.allowLocalModels) {
          if (B.local_files_only)
            throw Error(
              "Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`)."
            );
          if (!l.env.allowRemoteModels)
            throw Error(
              "Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`."
            );
        }
        (0, f.dispatchCallback)(B.progress_callback, {
          status: "initiate",
          name: I,
          file: V
        });
        let j;
        if (!j && l.env.useBrowserCache) {
          if (typeof caches > "u")
            throw Error("Browser cache is not available in this environment.");
          try {
            j = await caches.open("transformers-cache");
          } catch (xe) {
            console.warn(
              "An error occurred while opening the browser cache:",
              xe
            );
          }
        }
        if (
          (!j && l.env.useFSCache && (j = new T(B.cache_dir ?? l.env.cacheDir)),
          !j && l.env.useCustomCache)
        ) {
          if (!l.env.customCache)
            throw Error(
              "`env.useCustomCache=true`, but `env.customCache` is not defined."
            );
          if (!l.env.customCache.match || !l.env.customCache.put)
            throw new Error(
              "`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache"
            );
          j = l.env.customCache;
        }
        const N = B.revision ?? "main";
        let se = x(I, V),
          de = x(l.env.localModelPath, se),
          Me = x(
            l.env.remoteHost,
            l.env.remotePathTemplate
              .replaceAll("{model}", I)
              .replaceAll("{revision}", encodeURIComponent(N)),
            V
          ),
          J = N === "main" ? se : x(I, N, V),
          ye,
          L = j instanceof T ? J : Me,
          Ee = !1,
          Qe;
        j && (Qe = await z(j, de, L));
        const _e = Qe !== void 0;
        if (Qe === void 0) {
          if (l.env.allowLocalModels)
            if (g(se, ["http:", "https:"])) {
              if (B.local_files_only)
                throw new Error(
                  `\`local_files_only=true\`, but attempted to load a remote file from: ${se}.`
                );
              if (!l.env.allowRemoteModels)
                throw new Error(
                  `\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${se}.`
                );
            } else
              try {
                (Qe = await M(de)), (ye = de);
              } catch (Y) {
                console.warn(`Unable to load from local path "${de}": "${Y}"`);
              }
          if (Qe === void 0 || Qe.status === 404) {
            if (B.local_files_only || !l.env.allowRemoteModels) {
              if (O)
                throw Error(
                  `\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${de}".`
                );
              return null;
            }
            if (((Qe = await M(Me)), Qe.status !== 200))
              return C(Qe.status, Me, O);
            ye = L;
          }
          Ee =
            j &&
            typeof Response < "u" &&
            Qe instanceof Response &&
            Qe.status === 200;
        }
        (0, f.dispatchCallback)(B.progress_callback, {
          status: "download",
          name: I,
          file: V
        });
        const X = { status: "progress", name: I, file: V };
        let oe;
        return (
          B.progress_callback
            ? _e &&
              typeof navigator < "u" &&
              /firefox/i.test(navigator.userAgent)
              ? ((oe = new Uint8Array(await Qe.arrayBuffer())),
                (0, f.dispatchCallback)(B.progress_callback, {
                  ...X,
                  progress: 100,
                  loaded: oe.length,
                  total: oe.length
                }))
              : (oe = await y(Qe, (xe) => {
                  (0, f.dispatchCallback)(B.progress_callback, { ...X, ...xe });
                }))
            : (oe = new Uint8Array(await Qe.arrayBuffer())),
          Ee &&
            ye &&
            (await j.match(ye)) === void 0 &&
            (await j
              .put(ye, new Response(oe, { headers: Qe.headers }))
              .catch((xe) => {
                console.warn(`Unable to add response to browser cache: ${xe}.`);
              })),
          (0, f.dispatchCallback)(B.progress_callback, {
            status: "done",
            name: I,
            file: V
          }),
          oe
        );
      }
      async function S(I, V, O = !0, B = {}) {
        let j = await $(I, V, O, B);
        if (j === null) return {};
        let se = new TextDecoder("utf-8").decode(j);
        return JSON.parse(se);
      }
      async function y(I, V) {
        const O = I.headers.get("Content-Length");
        O === null &&
          console.warn(
            "Unable to determine content-length from response headers. Will expand buffer when needed."
          );
        let B = parseInt(O ?? "0"),
          j = new Uint8Array(B),
          N = 0;
        const se = I.body.getReader();
        async function de() {
          const { done: Me, value: J } = await se.read();
          if (Me) return;
          let ye = N + J.length;
          if (ye > B) {
            B = ye;
            let Ee = new Uint8Array(B);
            Ee.set(j), (j = Ee);
          }
          j.set(J, N), (N = ye);
          const L = (N / B) * 100;
          return V({ progress: L, loaded: N, total: B }), de();
        }
        return await de(), j;
      }
      function x(...I) {
        return (
          (I = I.map(
            (V, O) => (
              O && (V = V.replace(new RegExp("^/"), "")),
              O !== I.length - 1 && (V = V.replace(new RegExp("/$"), "")),
              V
            )
          )),
          I.join("/")
        );
      }
    },
    "./src/utils/image.js": (e, t, n) => {
      n.r(t), n.d(t, { RawImage: () => z });
      var o = n("./src/utils/hub.js"),
        a = n("./src/env.js"),
        l = n("./src/utils/tensor.js"),
        f = n("?2b25");
      const _ = typeof self < "u",
        m = _ && self.constructor.name === "DedicatedWorkerGlobalScope";
      let g, M, v;
      if (_)
        (g = ($, S) => {
          if (!self.OffscreenCanvas)
            throw new Error("OffscreenCanvas not supported by this browser.");
          return new self.OffscreenCanvas($, S);
        }),
          (v = self.createImageBitmap),
          (M = self.ImageData);
      else if (f)
        v = async ($) => {
          const y = (await $.metadata()).channels,
            { data: x, info: I } = await $.rotate()
              .raw()
              .toBuffer({ resolveWithObject: !0 }),
            V = new z(new Uint8ClampedArray(x), I.width, I.height, I.channels);
          return y !== void 0 && y !== I.channels && V.convert(y), V;
        };
      else throw new Error("Unable to load image processing library.");
      const C = {
          0: "nearest",
          1: "lanczos",
          2: "bilinear",
          3: "bicubic",
          4: "box",
          5: "hamming"
        },
        T = new Map([
          ["png", "image/png"],
          ["jpg", "image/jpeg"],
          ["jpeg", "image/jpeg"],
          ["gif", "image/gif"]
        ]);
      class z {
        constructor(S, y, x, I) {
          (this.data = S),
            (this.width = y),
            (this.height = x),
            (this.channels = I);
        }
        get size() {
          return [this.width, this.height];
        }
        static async read(S) {
          if (S instanceof z) return S;
          if (typeof S == "string" || S instanceof URL)
            return await this.fromURL(S);
          throw new Error(`Unsupported input type: ${typeof S}`);
        }
        static fromCanvas(S) {
          if (!_)
            throw new Error(
              "fromCanvas() is only supported in browser environments."
            );
          const x = S.getContext("2d").getImageData(
            0,
            0,
            S.width,
            S.height
          ).data;
          return new z(x, S.width, S.height, 4);
        }
        static async fromURL(S) {
          const y = await (0, o.getFile)(S);
          if (y.status !== 200)
            throw new Error(
              `Unable to read image from "${S}" (${y.status} ${y.statusText})`
            );
          const x = await y.blob();
          return this.fromBlob(x);
        }
        static async fromBlob(S) {
          if (_) {
            const y = await v(S),
              x = g(y.width, y.height).getContext("2d");
            return (
              x.drawImage(y, 0, 0),
              new this(
                x.getImageData(0, 0, y.width, y.height).data,
                y.width,
                y.height,
                4
              )
            );
          } else {
            const y = f(await S.arrayBuffer());
            return await v(y);
          }
        }
        static fromTensor(S, y = "CHW") {
          if (S.dims.length !== 3)
            throw new Error(
              `Tensor should have 3 dimensions, but has ${S.dims.length} dimensions.`
            );
          if (y === "CHW") S = S.transpose(1, 2, 0);
          else if (y !== "HWC")
            throw new Error(`Unsupported channel format: ${y}`);
          if (
            !(
              S.data instanceof Uint8ClampedArray ||
              S.data instanceof Uint8Array
            )
          )
            throw new Error(`Unsupported tensor type: ${S.type}`);
          switch (S.dims[2]) {
            case 1:
            case 2:
            case 3:
            case 4:
              return new z(S.data, S.dims[1], S.dims[0], S.dims[2]);
            default:
              throw new Error(`Unsupported number of channels: ${S.dims[2]}`);
          }
        }
        grayscale() {
          if (this.channels === 1) return this;
          const S = new Uint8ClampedArray(this.width * this.height * 1);
          switch (this.channels) {
            case 3:
            case 4:
              for (let y = 0, x = 0; y < this.data.length; y += this.channels) {
                const I = this.data[y],
                  V = this.data[y + 1],
                  O = this.data[y + 2];
                S[x++] = Math.round(0.2989 * I + 0.587 * V + 0.114 * O);
              }
              break;
            default:
              throw new Error(
                `Conversion failed due to unsupported number of channels: ${this.channels}`
              );
          }
          return this._update(S, this.width, this.height, 1);
        }
        rgb() {
          if (this.channels === 3) return this;
          const S = new Uint8ClampedArray(this.width * this.height * 3);
          switch (this.channels) {
            case 1:
              for (let y = 0, x = 0; y < this.data.length; ++y)
                (S[x++] = this.data[y]),
                  (S[x++] = this.data[y]),
                  (S[x++] = this.data[y]);
              break;
            case 4:
              for (let y = 0, x = 0; y < this.data.length; y += 4)
                (S[x++] = this.data[y]),
                  (S[x++] = this.data[y + 1]),
                  (S[x++] = this.data[y + 2]);
              break;
            default:
              throw new Error(
                `Conversion failed due to unsupported number of channels: ${this.channels}`
              );
          }
          return this._update(S, this.width, this.height, 3);
        }
        rgba() {
          if (this.channels === 4) return this;
          const S = new Uint8ClampedArray(this.width * this.height * 4);
          switch (this.channels) {
            case 1:
              for (let y = 0, x = 0; y < this.data.length; ++y)
                (S[x++] = this.data[y]),
                  (S[x++] = this.data[y]),
                  (S[x++] = this.data[y]),
                  (S[x++] = 255);
              break;
            case 3:
              for (let y = 0, x = 0; y < this.data.length; y += 3)
                (S[x++] = this.data[y]),
                  (S[x++] = this.data[y + 1]),
                  (S[x++] = this.data[y + 2]),
                  (S[x++] = 255);
              break;
            default:
              throw new Error(
                `Conversion failed due to unsupported number of channels: ${this.channels}`
              );
          }
          return this._update(S, this.width, this.height, 4);
        }
        async resize(S, y, { resample: x = 2 } = {}) {
          let I = C[x] ?? x;
          if (_) {
            const V = this.channels,
              O = this.toCanvas(),
              B = g(S, y).getContext("2d");
            return (
              B.drawImage(O, 0, 0, S, y),
              new z(B.getImageData(0, 0, S, y).data, S, y, 4).convert(V)
            );
          } else {
            let V = this.toSharp();
            switch (I) {
              case "box":
              case "hamming":
                (I === "box" || I === "hamming") &&
                  (console.warn(
                    `Resampling method ${I} is not yet supported. Using bilinear instead.`
                  ),
                  (I = "bilinear"));
              case "nearest":
              case "bilinear":
              case "bicubic":
                V = V.affine([S / this.width, 0, 0, y / this.height], {
                  interpolator: I
                });
                break;
              case "lanczos":
                V = V.resize({
                  width: S,
                  height: y,
                  fit: "fill",
                  kernel: "lanczos3"
                });
                break;
              default:
                throw new Error(`Resampling method ${I} is not supported.`);
            }
            return await v(V);
          }
        }
        async pad([S, y, x, I]) {
          if (
            ((S = Math.max(S, 0)),
            (y = Math.max(y, 0)),
            (x = Math.max(x, 0)),
            (I = Math.max(I, 0)),
            S === 0 && y === 0 && x === 0 && I === 0)
          )
            return this;
          if (_) {
            const V = this.channels,
              O = this.toCanvas(),
              B = this.width + S + y,
              j = this.height + x + I,
              N = g(B, j).getContext("2d");
            return (
              N.drawImage(O, 0, 0, this.width, this.height, S, x, B, j),
              new z(N.getImageData(0, 0, B, j).data, B, j, 4).convert(V)
            );
          } else {
            const V = this.toSharp().extend({
              left: S,
              right: y,
              top: x,
              bottom: I
            });
            return await v(V);
          }
        }
        async crop([S, y, x, I]) {
          if (
            ((S = Math.max(S, 0)),
            (y = Math.max(y, 0)),
            (x = Math.min(x, this.width - 1)),
            (I = Math.min(I, this.height - 1)),
            S === 0 && y === 0 && x === this.width - 1 && I === this.height - 1)
          )
            return this;
          const V = x - S + 1,
            O = I - y + 1;
          if (_) {
            const B = this.channels,
              j = this.toCanvas(),
              N = g(V, O).getContext("2d");
            return (
              N.drawImage(j, S, y, V, O, 0, 0, V, O),
              new z(N.getImageData(0, 0, V, O).data, V, O, 4).convert(B)
            );
          } else {
            const B = this.toSharp().extract({
              left: S,
              top: y,
              width: V,
              height: O
            });
            return await v(B);
          }
        }
        async center_crop(S, y) {
          if (this.width === S && this.height === y) return this;
          const x = (this.width - S) / 2,
            I = (this.height - y) / 2;
          if (_) {
            const V = this.channels,
              O = this.toCanvas(),
              B = g(S, y).getContext("2d");
            let j = 0,
              N = 0,
              se = 0,
              de = 0;
            return (
              x >= 0 ? (j = x) : (se = -x),
              I >= 0 ? (N = I) : (de = -I),
              B.drawImage(O, j, N, S, y, se, de, S, y),
              new z(B.getImageData(0, 0, S, y).data, S, y, 4).convert(V)
            );
          } else {
            let V = this.toSharp();
            if (x >= 0 && I >= 0)
              V = V.extract({
                left: Math.floor(x),
                top: Math.floor(I),
                width: S,
                height: y
              });
            else if (x <= 0 && I <= 0) {
              const O = Math.floor(-I),
                B = Math.floor(-x);
              V = V.extend({
                top: O,
                left: B,
                right: S - this.width - B,
                bottom: y - this.height - O
              });
            } else {
              let O = [0, 0],
                B = 0;
              I < 0
                ? ((O[0] = Math.floor(-I)), (O[1] = y - this.height - O[0]))
                : (B = Math.floor(I));
              let j = [0, 0],
                N = 0;
              x < 0
                ? ((j[0] = Math.floor(-x)), (j[1] = S - this.width - j[0]))
                : (N = Math.floor(x)),
                (V = V.extend({
                  top: O[0],
                  bottom: O[1],
                  left: j[0],
                  right: j[1]
                }).extract({ left: N, top: B, width: S, height: y }));
            }
            return await v(V);
          }
        }
        async toBlob(S = "image/png", y = 1) {
          if (!_)
            throw new Error(
              "toBlob() is only supported in browser environments."
            );
          return await this.toCanvas().convertToBlob({ type: S, quality: y });
        }
        toTensor(S = "CHW") {
          let y = new l.Tensor("uint8", new Uint8Array(this.data), [
            this.height,
            this.width,
            this.channels
          ]);
          if (S !== "HWC")
            if (S === "CHW") y = y.permute(2, 0, 1);
            else throw new Error(`Unsupported channel format: ${S}`);
          return y;
        }
        toCanvas() {
          if (!_)
            throw new Error(
              "toCanvas() is only supported in browser environments."
            );
          const S = this.clone().rgba(),
            y = g(S.width, S.height),
            x = new M(S.data, S.width, S.height);
          return y.getContext("2d").putImageData(x, 0, 0), y;
        }
        _update(S, y, x, I = null) {
          return (
            (this.data = S),
            (this.width = y),
            (this.height = x),
            I !== null && (this.channels = I),
            this
          );
        }
        clone() {
          return new z(
            this.data.slice(),
            this.width,
            this.height,
            this.channels
          );
        }
        convert(S) {
          if (this.channels === S) return this;
          switch (S) {
            case 1:
              this.grayscale();
              break;
            case 3:
              this.rgb();
              break;
            case 4:
              this.rgba();
              break;
            default:
              throw new Error(
                `Conversion failed due to unsupported number of channels: ${this.channels}`
              );
          }
          return this;
        }
        async save(S) {
          if (_) {
            if (m)
              throw new Error("Unable to save an image from a Web Worker.");
            const y = S.split(".").pop().toLowerCase(),
              x = T.get(y) ?? "image/png",
              I = await this.toBlob(x),
              V = URL.createObjectURL(I),
              O = document.createElement("a");
            (O.href = V), (O.download = S), O.click(), O.remove();
          } else {
            if (a.env.useFS) return await this.toSharp().toFile(S);
            throw new Error(
              "Unable to save the image because filesystem is disabled in this environment."
            );
          }
        }
        toSharp() {
          if (_)
            throw new Error(
              "toSharp() is only supported in server-side environments."
            );
          return f(this.data, {
            raw: {
              width: this.width,
              height: this.height,
              channels: this.channels
            }
          });
        }
      }
    },
    "./src/utils/maths.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          FFT: () => $,
          bankers_round: () => x,
          cos_sim: () => m,
          dot: () => _,
          dynamic_time_warping: () => I,
          interpolate_data: () => o,
          log_softmax: () => f,
          magnitude: () => g,
          max: () => v,
          medianFilter: () => S,
          min: () => M,
          permute_data: () => a,
          round: () => y,
          softmax: () => l
        });
      function o(V, [O, B, j], [N, se], de = "bilinear", Me = !1) {
        const J = se / j,
          ye = N / B,
          L = new V.constructor(N * se * O),
          Ee = B * j,
          Qe = N * se;
        for (let _e = 0; _e < N; ++_e)
          for (let X = 0; X < se; ++X) {
            const oe = _e * se + X,
              xe = (X + 0.5) / J - 0.5,
              Y = (_e + 0.5) / ye - 0.5;
            let ge = Math.floor(xe),
              qe = Math.floor(Y);
            const Be = Math.min(ge + 1, j - 1),
              Ne = Math.min(qe + 1, B - 1);
            (ge = Math.max(ge, 0)), (qe = Math.max(qe, 0));
            const We = xe - ge,
              st = Y - qe,
              pt = (1 - We) * (1 - st),
              Ge = We * (1 - st),
              Te = (1 - We) * st,
              je = We * st,
              Ye = qe * j,
              et = Ne * j,
              A = Ye + ge,
              Ae = Ye + Be,
              $e = et + ge,
              ae = et + Be;
            for (let ne = 0; ne < O; ++ne) {
              const ve = ne * Ee;
              L[ne * Qe + oe] =
                pt * V[ve + A] +
                Ge * V[ve + Ae] +
                Te * V[ve + $e] +
                je * V[ve + ae];
            }
          }
        return L;
      }
      function a(V, O, B) {
        const j = new Array(B.length),
          N = new Array(B.length);
        for (let Me = B.length - 1, J = 1; Me >= 0; --Me)
          (N[Me] = J), (j[Me] = O[B[Me]]), (J *= j[Me]);
        const se = B.map((Me, J) => N[B.indexOf(J)]),
          de = new V.constructor(V.length);
        for (let Me = 0; Me < V.length; ++Me) {
          let J = 0;
          for (let ye = O.length - 1, L = Me; ye >= 0; --ye)
            (J += (L % O[ye]) * se[ye]), (L = Math.floor(L / O[ye]));
          de[J] = V[Me];
        }
        return [de, j];
      }
      function l(V) {
        const O = v(V)[0],
          B = V.map((se) => Math.exp(se - O)),
          j = B.reduce((se, de) => se + de, 0);
        return B.map((se) => se / j);
      }
      function f(V) {
        return l(V).map((j) => Math.log(j));
      }
      function _(V, O) {
        let B = 0;
        for (let j = 0; j < V.length; ++j) B += V[j] * O[j];
        return B;
      }
      function m(V, O) {
        const B = _(V, O),
          j = g(V),
          N = g(O);
        return B / (j * N);
      }
      function g(V) {
        return Math.sqrt(V.reduce((O, B) => O + B * B, 0));
      }
      function M(V) {
        if (V.length === 0) throw Error("Array must not be empty");
        let O = V[0],
          B = 0;
        for (let j = 1; j < V.length; ++j) V[j] < O && ((O = V[j]), (B = j));
        return [O, B];
      }
      function v(V) {
        if (V.length === 0) throw Error("Array must not be empty");
        let O = V[0],
          B = 0;
        for (let j = 1; j < V.length; ++j) V[j] > O && ((O = V[j]), (B = j));
        return [Number(O), B];
      }
      function C(V) {
        return V > 0 && (V & (V - 1)) === 0;
      }
      class T {
        constructor(O) {
          if (((this.size = O | 0), this.size <= 1 || !C(this.size)))
            throw new Error("FFT size must be a power of two larger than 1");
          (this._csize = O << 1),
            (this.table = new Float64Array(this.size * 2));
          for (let j = 0; j < this.table.length; j += 2) {
            const N = (Math.PI * j) / this.size;
            (this.table[j] = Math.cos(N)), (this.table[j + 1] = -Math.sin(N));
          }
          let B = 0;
          for (let j = 1; this.size > j; j <<= 1) ++B;
          (this._width = B % 2 === 0 ? B - 1 : B),
            (this._bitrev = new Int32Array(1 << this._width));
          for (let j = 0; j < this._bitrev.length; ++j) {
            this._bitrev[j] = 0;
            for (let N = 0; N < this._width; N += 2) {
              const se = this._width - N - 2;
              this._bitrev[j] |= ((j >>> N) & 3) << se;
            }
          }
        }
        createComplexArray() {
          return new Float64Array(this._csize);
        }
        fromComplexArray(O, B) {
          const j = B || new Array(O.length >>> 1);
          for (let N = 0; N < O.length; N += 2) j[N >>> 1] = O[N];
          return j;
        }
        toComplexArray(O, B) {
          const j = B || this.createComplexArray();
          for (let N = 0; N < j.length; N += 2)
            (j[N] = O[N >>> 1]), (j[N + 1] = 0);
          return j;
        }
        transform(O, B) {
          if (O === B)
            throw new Error("Input and output buffers must be different");
          this._transform4(O, B, 1);
        }
        realTransform(O, B) {
          if (O === B)
            throw new Error("Input and output buffers must be different");
          this._realTransform4(O, B, 1);
        }
        inverseTransform(O, B) {
          if (O === B)
            throw new Error("Input and output buffers must be different");
          this._transform4(O, B, -1);
          for (let j = 0; j < O.length; ++j) O[j] /= this.size;
        }
        _transform4(O, B, j) {
          const N = this._csize;
          let de = 1 << this._width,
            Me = (N / de) << 1,
            J,
            ye;
          const L = this._bitrev;
          if (Me === 4)
            for (J = 0, ye = 0; J < N; J += Me, ++ye) {
              const Qe = L[ye];
              this._singleTransform2(B, O, J, Qe, de);
            }
          else
            for (J = 0, ye = 0; J < N; J += Me, ++ye) {
              const Qe = L[ye];
              this._singleTransform4(B, O, J, Qe, de, j);
            }
          const Ee = this.table;
          for (de >>= 2; de >= 2; de >>= 2) {
            Me = (N / de) << 1;
            const Qe = Me >>> 2;
            for (J = 0; J < N; J += Me) {
              const _e = J + Qe - 1;
              for (let X = J, oe = 0; X < _e; X += 2, oe += de) {
                const xe = X,
                  Y = xe + Qe,
                  ge = Y + Qe,
                  qe = ge + Qe,
                  Be = O[xe],
                  Ne = O[xe + 1],
                  We = O[Y],
                  st = O[Y + 1],
                  pt = O[ge],
                  Ge = O[ge + 1],
                  Te = O[qe],
                  je = O[qe + 1],
                  Ye = Ee[oe],
                  et = j * Ee[oe + 1],
                  A = We * Ye - st * et,
                  Ae = We * et + st * Ye,
                  $e = Ee[2 * oe],
                  ae = j * Ee[2 * oe + 1],
                  ne = pt * $e - Ge * ae,
                  ve = pt * ae + Ge * $e,
                  R = Ee[3 * oe],
                  te = j * Ee[3 * oe + 1],
                  D = Te * R - je * te,
                  ce = Te * te + je * R,
                  ue = Be + ne,
                  ke = Ne + ve,
                  Re = Be - ne,
                  ht = Ne - ve,
                  tt = A + D,
                  wt = Ae + ce,
                  bt = j * (A - D),
                  Ke = j * (Ae - ce);
                (O[xe] = ue + tt),
                  (O[xe + 1] = ke + wt),
                  (O[Y] = Re + Ke),
                  (O[Y + 1] = ht - bt),
                  (O[ge] = ue - tt),
                  (O[ge + 1] = ke - wt),
                  (O[qe] = Re - Ke),
                  (O[qe + 1] = ht + bt);
              }
            }
          }
        }
        _singleTransform2(O, B, j, N, se) {
          const de = O[N],
            Me = O[N + 1],
            J = O[N + se],
            ye = O[N + se + 1];
          (B[j] = de + J),
            (B[j + 1] = Me + ye),
            (B[j + 2] = de - J),
            (B[j + 3] = Me - ye);
        }
        _singleTransform4(O, B, j, N, se, de) {
          const Me = se * 2,
            J = se * 3,
            ye = O[N],
            L = O[N + 1],
            Ee = O[N + se],
            Qe = O[N + se + 1],
            _e = O[N + Me],
            X = O[N + Me + 1],
            oe = O[N + J],
            xe = O[N + J + 1],
            Y = ye + _e,
            ge = L + X,
            qe = ye - _e,
            Be = L - X,
            Ne = Ee + oe,
            We = Qe + xe,
            st = de * (Ee - oe),
            pt = de * (Qe - xe);
          (B[j] = Y + Ne),
            (B[j + 1] = ge + We),
            (B[j + 2] = qe + pt),
            (B[j + 3] = Be - st),
            (B[j + 4] = Y - Ne),
            (B[j + 5] = ge - We),
            (B[j + 6] = qe - pt),
            (B[j + 7] = Be + st);
        }
        _realTransform4(O, B, j) {
          const N = this._csize;
          let de = 1 << this._width,
            Me = (N / de) << 1,
            J,
            ye;
          const L = this._bitrev;
          if (Me === 4)
            for (J = 0, ye = 0; J < N; J += Me, ++ye) {
              const _e = L[ye];
              this._singleRealTransform2(B, O, J, _e >>> 1, de >>> 1);
            }
          else
            for (J = 0, ye = 0; J < N; J += Me, ++ye) {
              const _e = L[ye];
              this._singleRealTransform4(B, O, J, _e >>> 1, de >>> 1, j);
            }
          const Ee = this.table;
          for (de >>= 2; de >= 2; de >>= 2) {
            Me = (N / de) << 1;
            const _e = Me >>> 1,
              X = _e >>> 1,
              oe = X >>> 1;
            for (J = 0; J < N; J += Me)
              for (let xe = 0, Y = 0; xe <= oe; xe += 2, Y += de) {
                const ge = J + xe,
                  qe = ge + X,
                  Be = qe + X,
                  Ne = Be + X,
                  We = O[ge],
                  st = O[ge + 1],
                  pt = O[qe],
                  Ge = O[qe + 1],
                  Te = O[Be],
                  je = O[Be + 1],
                  Ye = O[Ne],
                  et = O[Ne + 1],
                  A = We,
                  Ae = st,
                  $e = Ee[Y],
                  ae = j * Ee[Y + 1],
                  ne = pt * $e - Ge * ae,
                  ve = pt * ae + Ge * $e,
                  R = Ee[2 * Y],
                  te = j * Ee[2 * Y + 1],
                  D = Te * R - je * te,
                  ce = Te * te + je * R,
                  ue = Ee[3 * Y],
                  ke = j * Ee[3 * Y + 1],
                  Re = Ye * ue - et * ke,
                  ht = Ye * ke + et * ue,
                  tt = A + D,
                  wt = Ae + ce,
                  bt = A - D,
                  Ke = Ae - ce,
                  fe = ne + Re,
                  Ie = ve + ht,
                  Ve = j * (ne - Re),
                  ot = j * (ve - ht);
                if (
                  ((O[ge] = tt + fe),
                  (O[ge + 1] = wt + Ie),
                  (O[qe] = bt + ot),
                  (O[qe + 1] = Ke - Ve),
                  xe === 0)
                ) {
                  (O[Be] = tt - fe), (O[Be + 1] = wt - Ie);
                  continue;
                }
                if (xe === oe) continue;
                const Xe = J + X - xe,
                  ft = J + _e - xe;
                (O[Xe] = bt - j * ot),
                  (O[Xe + 1] = -Ke - j * Ve),
                  (O[ft] = tt - j * fe),
                  (O[ft + 1] = -wt + j * Ie);
              }
          }
          const Qe = N >>> 1;
          for (let _e = 2; _e < Qe; _e += 2)
            (O[N - _e] = O[_e]), (O[N - _e + 1] = -O[_e + 1]);
        }
        _singleRealTransform2(O, B, j, N, se) {
          const de = O[N],
            Me = O[N + se];
          (B[j] = de + Me),
            (B[j + 1] = 0),
            (B[j + 2] = de - Me),
            (B[j + 3] = 0);
        }
        _singleRealTransform4(O, B, j, N, se, de) {
          const Me = se * 2,
            J = se * 3,
            ye = O[N],
            L = O[N + se],
            Ee = O[N + Me],
            Qe = O[N + J],
            _e = ye + Ee,
            X = ye - Ee,
            oe = L + Qe,
            xe = de * (L - Qe);
          (B[j] = _e + oe),
            (B[j + 1] = 0),
            (B[j + 2] = X),
            (B[j + 3] = -xe),
            (B[j + 4] = _e - oe),
            (B[j + 5] = 0),
            (B[j + 6] = X),
            (B[j + 7] = xe);
        }
      }
      class z {
        constructor(O) {
          const B = 2 * (O - 1),
            j = 2 * (2 * O - 1),
            N = 2 ** Math.ceil(Math.log2(j));
          (this.bufferSize = N), (this._a = B);
          const se = new Float64Array(j),
            de = new Float64Array(N);
          (this._chirpBuffer = new Float64Array(N)),
            (this._buffer1 = new Float64Array(N)),
            (this._buffer2 = new Float64Array(N)),
            (this._outBuffer1 = new Float64Array(N)),
            (this._outBuffer2 = new Float64Array(N));
          const Me = (-2 * Math.PI) / O,
            J = Math.cos(Me),
            ye = Math.sin(Me);
          for (let L = 0; L < j >> 1; ++L) {
            const Ee = (L + 1 - O) ** 2 / 2,
              Qe = Math.sqrt(J ** 2 + ye ** 2) ** Ee,
              _e = Ee * Math.atan2(ye, J),
              X = 2 * L;
            (se[X] = Qe * Math.cos(_e)),
              (se[X + 1] = Qe * Math.sin(_e)),
              (de[X] = se[X]),
              (de[X + 1] = -se[X + 1]);
          }
          (this._slicedChirpBuffer = se.subarray(B, j)),
            (this._f = new T(N >> 1)),
            this._f.transform(this._chirpBuffer, de);
        }
        _transform(O, B, j) {
          const N = this._buffer1,
            se = this._buffer2,
            de = this._outBuffer1,
            Me = this._outBuffer2,
            J = this._chirpBuffer,
            ye = this._slicedChirpBuffer,
            L = this._a;
          if (j)
            for (let Ee = 0; Ee < ye.length; Ee += 2) {
              const Qe = Ee + 1,
                _e = Ee >> 1,
                X = B[_e];
              (N[Ee] = X * ye[Ee]), (N[Qe] = X * ye[Qe]);
            }
          else
            for (let Ee = 0; Ee < ye.length; Ee += 2) {
              const Qe = Ee + 1;
              (N[Ee] = B[Ee] * ye[Ee] - B[Qe] * ye[Qe]),
                (N[Qe] = B[Ee] * ye[Qe] + B[Qe] * ye[Ee]);
            }
          this._f.transform(de, N);
          for (let Ee = 0; Ee < J.length; Ee += 2) {
            const Qe = Ee + 1;
            (se[Ee] = de[Ee] * J[Ee] - de[Qe] * J[Qe]),
              (se[Qe] = de[Ee] * J[Qe] + de[Qe] * J[Ee]);
          }
          this._f.inverseTransform(Me, se);
          for (let Ee = 0; Ee < Me.length; Ee += 2) {
            const Qe = Me[Ee + L],
              _e = Me[Ee + L + 1],
              X = ye[Ee],
              oe = ye[Ee + 1];
            (O[Ee] = Qe * X - _e * oe), (O[Ee + 1] = Qe * oe + _e * X);
          }
        }
        transform(O, B) {
          this._transform(O, B, !1);
        }
        realTransform(O, B) {
          this._transform(O, B, !0);
        }
      }
      class $ {
        constructor(O) {
          (this.fft_length = O),
            (this.isPowerOfTwo = C(O)),
            this.isPowerOfTwo
              ? ((this.fft = new T(O)), (this.outputBufferSize = 2 * O))
              : ((this.fft = new z(O)),
                (this.outputBufferSize = this.fft.bufferSize));
        }
        realTransform(O, B) {
          this.fft.realTransform(O, B);
        }
        transform(O, B) {
          this.fft.transform(O, B);
        }
      }
      function S(V, O) {
        if (O % 2 === 0 || O <= 0)
          throw new Error("Window size must be a positive odd number");
        const B = new V.constructor(V.length),
          j = new V.constructor(O),
          N = Math.floor(O / 2);
        for (let se = 0; se < V.length; ++se) {
          let de = 0;
          for (let Me = -N; Me <= N; ++Me) {
            let J = se + Me;
            J < 0
              ? (J = Math.abs(J))
              : J >= V.length && (J = 2 * (V.length - 1) - J),
              (j[de++] = V[J]);
          }
          j.sort(), (B[se] = j[N]);
        }
        return B;
      }
      function y(V, O) {
        const B = Math.pow(10, O);
        return Math.round(V * B) / B;
      }
      function x(V) {
        const O = Math.round(V);
        return Math.abs(V) % 1 === 0.5 ? (O % 2 === 0 ? O : O - 1) : O;
      }
      function I(V) {
        const O = V.length,
          B = V[0].length,
          j = [O + 1, B + 1],
          N = Array.from({ length: j[0] }, () => Array(j[1]).fill(1 / 0));
        N[0][0] = 0;
        const se = Array.from({ length: j[0] }, () => Array(j[1]).fill(-1));
        for (let L = 1; L < j[1]; ++L)
          for (let Ee = 1; Ee < j[0]; ++Ee) {
            const Qe = N[Ee - 1][L - 1],
              _e = N[Ee - 1][L],
              X = N[Ee][L - 1];
            let oe, xe;
            Qe < _e && Qe < X
              ? ((oe = Qe), (xe = 0))
              : _e < Qe && _e < X
              ? ((oe = _e), (xe = 1))
              : ((oe = X), (xe = 2)),
              (N[Ee][L] = V[Ee - 1][L - 1] + oe),
              (se[Ee][L] = xe);
          }
        for (let L = 0; L < j[1]; ++L) se[0][L] = 2;
        for (let L = 0; L < j[0]; ++L) se[L][0] = 1;
        let de = O,
          Me = B,
          J = [],
          ye = [];
        for (; de > 0 || Me > 0; )
          switch ((J.push(de - 1), ye.push(Me - 1), se[de][Me])) {
            case 0:
              --de, --Me;
              break;
            case 1:
              --de;
              break;
            case 2:
              --Me;
              break;
            default:
              throw new Error(
                `Internal error in dynamic time warping. Unexpected trace[${de}, ${Me}]. Please file a bug report.`
              );
          }
        return J.reverse(), ye.reverse(), [J, ye];
      }
    },
    "./src/utils/tensor.js": (e, t, n) => {
      n.r(t),
        n.d(t, {
          Tensor: () => _,
          cat: () => V,
          full: () => de,
          full_like: () => Me,
          interpolate: () => M,
          interpolate_4d: () => v,
          layer_norm: () => S,
          matmul: () => C,
          mean: () => j,
          mean_pooling: () => $,
          ones: () => J,
          ones_like: () => ye,
          permute: () => g,
          quantize_embeddings: () => Qe,
          rfft: () => T,
          stack: () => O,
          std_mean: () => B,
          topk: () => z,
          zeros: () => L,
          zeros_like: () => Ee
        });
      var o = n("./src/utils/maths.js"),
        a = n("./src/backends/onnx.js"),
        l = n("./src/ops/registry.js");
      const f = Object.freeze({
        float32: Float32Array,
        float16: Uint16Array,
        float64: Float64Array,
        string: Array,
        int8: Int8Array,
        uint8: Uint8Array,
        int16: Int16Array,
        uint16: Uint16Array,
        int32: Int32Array,
        uint32: Uint32Array,
        int64: BigInt64Array,
        uint64: BigUint64Array,
        bool: Uint8Array
      });
      class _ {
        constructor(...X) {
          He(this, "ort_tensor");
          return (
            (0, a.isONNXTensor)(X[0])
              ? (this.ort_tensor = X[0])
              : (this.ort_tensor = new a.Tensor(X[0], X[1], X[2])),
            new Proxy(this, {
              get: (oe, xe) => {
                if (typeof xe == "string") {
                  let Y = Number(xe);
                  if (Number.isInteger(Y)) return oe._getitem(Y);
                }
                return oe[xe];
              },
              set: (oe, xe, Y) => (oe[xe] = Y)
            })
          );
        }
        get dims() {
          return this.ort_tensor.dims;
        }
        set dims(X) {
          this.ort_tensor.dims = X;
        }
        get type() {
          return this.ort_tensor.type;
        }
        get data() {
          return this.ort_tensor.data;
        }
        get size() {
          return this.ort_tensor.size;
        }
        get location() {
          return this.ort_tensor.location;
        }
        dispose() {
          this.ort_tensor.dispose();
        }
        *[Symbol.iterator]() {
          const [X, ...oe] = this.dims;
          if (oe.length > 0) {
            const xe = oe.reduce((Y, ge) => Y * ge);
            for (let Y = 0; Y < X; ++Y) yield this._subarray(Y, xe, oe);
          } else yield* this.data;
        }
        _getitem(X) {
          const [oe, ...xe] = this.dims;
          if (((X = I(X, oe)), xe.length > 0)) {
            const Y = xe.reduce((ge, qe) => ge * qe);
            return this._subarray(X, Y, xe);
          } else return new _(this.type, [this.data[X]], xe);
        }
        indexOf(X) {
          const oe = this.data;
          for (let xe = 0; xe < oe.length; ++xe) if (oe[xe] == X) return xe;
          return -1;
        }
        _subarray(X, oe, xe) {
          const Y = X * oe,
            ge = (X + 1) * oe,
            qe =
              "subarray" in this.data
                ? this.data.subarray(Y, ge)
                : this.data.slice(Y, ge);
          return new _(this.type, qe, xe);
        }
        item() {
          const X = this.data;
          if (X.length !== 1)
            throw new Error(
              `a Tensor with ${X.length} elements cannot be converted to Scalar`
            );
          return X[0];
        }
        tolist() {
          return m(this.data, this.dims);
        }
        sigmoid() {
          return this.clone().sigmoid_();
        }
        sigmoid_() {
          const X = this.data;
          for (let oe = 0; oe < X.length; ++oe)
            X[oe] = 1 / (1 + Math.exp(-X[oe]));
          return this;
        }
        mul(X) {
          return this.clone().mul_(X);
        }
        mul_(X) {
          const oe = this.data;
          for (let xe = 0; xe < oe.length; ++xe) oe[xe] *= X;
          return this;
        }
        div(X) {
          return this.clone().div_(X);
        }
        div_(X) {
          const oe = this.data;
          for (let xe = 0; xe < oe.length; ++xe) oe[xe] /= X;
          return this;
        }
        add(X) {
          return this.clone().add_(X);
        }
        add_(X) {
          const oe = this.data;
          for (let xe = 0; xe < oe.length; ++xe) oe[xe] += X;
          return this;
        }
        sub(X) {
          return this.clone().sub_(X);
        }
        sub_(X) {
          const oe = this.data;
          for (let xe = 0; xe < oe.length; ++xe) oe[xe] -= X;
          return this;
        }
        clone() {
          return new _(this.type, this.data.slice(), this.dims.slice());
        }
        slice(...X) {
          const oe = [],
            xe = [];
          for (let We = 0; We < this.dims.length; ++We) {
            let st = X[We];
            if (st == null) xe.push([0, this.dims[We]]), oe.push(this.dims[We]);
            else if (typeof st == "number")
              (st = I(st, this.dims[We], We)), xe.push([st, st + 1]);
            else if (Array.isArray(st) && st.length === 2) {
              let [pt, Ge] = st;
              if (
                ((pt = pt === null ? 0 : I(pt, this.dims[We], We, !1)),
                (Ge =
                  Ge === null ? this.dims[We] : I(Ge, this.dims[We], We, !1)),
                pt > Ge)
              )
                throw new Error(`Invalid slice: ${st}`);
              const Te = [Math.max(pt, 0), Math.min(Ge, this.dims[We])];
              xe.push(Te), oe.push(Te[1] - Te[0]);
            } else throw new Error(`Invalid slice: ${st}`);
          }
          const Y = xe.map(([We, st]) => st - We),
            ge = Y.reduce((We, st) => We * st),
            qe = this.data,
            Be = new qe.constructor(ge),
            Ne = this.stride();
          for (let We = 0; We < ge; ++We) {
            let st = 0;
            for (let pt = Y.length - 1, Ge = We; pt >= 0; --pt) {
              const Te = Y[pt];
              (st += ((Ge % Te) + xe[pt][0]) * Ne[pt]),
                (Ge = Math.floor(Ge / Te));
            }
            Be[We] = qe[st];
          }
          return new _(this.type, Be, oe);
        }
        permute(...X) {
          return g(this, X);
        }
        transpose(...X) {
          return this.permute(...X);
        }
        sum(X = null, oe = !1) {
          return this.norm(1, X, oe);
        }
        norm(X = "fro", oe = null, xe = !1) {
          if (X === "fro") X = 2;
          else if (typeof X == "string") throw Error(`Unsupported norm: ${X}`);
          const Y = this.data;
          if (oe === null) {
            let Be = Y.reduce((Ne, We) => Ne + We ** X, 0) ** (1 / X);
            return new _(this.type, [Be], []);
          }
          oe = I(oe, this.dims.length);
          const ge = this.dims.slice();
          ge[oe] = 1;
          const qe = new Y.constructor(Y.length / this.dims[oe]);
          for (let Be = 0; Be < Y.length; ++Be) {
            let Ne = 0;
            for (
              let We = this.dims.length - 1, st = Be, pt = 1;
              We >= 0;
              --We
            ) {
              const Ge = this.dims[We];
              if (We !== oe) {
                const Te = st % Ge;
                (Ne += Te * pt), (pt *= ge[We]);
              }
              st = Math.floor(st / Ge);
            }
            qe[Ne] += Y[Be] ** X;
          }
          if (X !== 1)
            for (let Be = 0; Be < qe.length; ++Be) qe[Be] = qe[Be] ** (1 / X);
          return xe || ge.splice(oe, 1), new _(this.type, qe, ge);
        }
        normalize_(X = 2, oe = 1) {
          oe = I(oe, this.dims.length);
          const xe = this.norm(X, oe, !0),
            Y = this.data,
            ge = xe.data;
          for (let qe = 0; qe < Y.length; ++qe) {
            let Be = 0;
            for (
              let Ne = this.dims.length - 1, We = qe, st = 1;
              Ne >= 0;
              --Ne
            ) {
              const pt = this.dims[Ne];
              if (Ne !== oe) {
                const Ge = We % pt;
                (Be += Ge * st), (st *= this.dims[Ne]);
              }
              We = Math.floor(We / pt);
            }
            Y[qe] /= ge[Be];
          }
          return this;
        }
        normalize(X = 2, oe = 1) {
          return this.clone().normalize_(X, oe);
        }
        stride() {
          return N(this.dims);
        }
        squeeze(X = null) {
          return new _(this.type, this.data, y(this.dims, X));
        }
        squeeze_(X = null) {
          return (this.dims = y(this.dims, X)), this;
        }
        unsqueeze(X = null) {
          return new _(this.type, this.data, x(this.dims, X));
        }
        unsqueeze_(X = null) {
          return (this.dims = x(this.dims, X)), this;
        }
        flatten_(X = 0, oe = -1) {
          oe = (oe + this.dims.length) % this.dims.length;
          let xe = this.dims.slice(0, X),
            Y = this.dims.slice(X, oe + 1),
            ge = this.dims.slice(oe + 1);
          return (
            (this.dims = [...xe, Y.reduce((qe, Be) => qe * Be, 1), ...ge]), this
          );
        }
        flatten(X = 0, oe = -1) {
          return this.clone().flatten_(X, oe);
        }
        view(...X) {
          let oe = -1;
          for (let Y = 0; Y < X.length; ++Y)
            if (X[Y] === -1) {
              if (oe !== -1)
                throw new Error("Only one dimension can be inferred");
              oe = Y;
            }
          const xe = this.data;
          if (oe !== -1) {
            const Y = X.reduce((ge, qe, Be) => (Be !== oe ? ge * qe : ge), 1);
            X[oe] = xe.length / Y;
          }
          return new _(this.type, xe, X);
        }
        neg_() {
          const X = this.data;
          for (let oe = 0; oe < X.length; ++oe) X[oe] = -X[oe];
          return this;
        }
        neg() {
          return this.clone().neg_();
        }
        clamp_(X, oe) {
          const xe = this.data;
          for (let Y = 0; Y < xe.length; ++Y)
            xe[Y] = Math.min(Math.max(xe[Y], X), oe);
          return this;
        }
        clamp(X, oe) {
          return this.clone().clamp_(X, oe);
        }
        round_() {
          const X = this.data;
          for (let oe = 0; oe < X.length; ++oe) X[oe] = Math.round(X[oe]);
          return this;
        }
        round() {
          return this.clone().round_();
        }
        mean(X = null, oe = !1) {
          return j(this, X, oe);
        }
        to(X) {
          if (this.type === X) return this;
          if (!f.hasOwnProperty(X)) throw new Error(`Unsupported type: ${X}`);
          return new _(X, f[X].from(this.data), this.dims);
        }
      }
      function m(_e, X) {
        const oe = _e.length,
          xe = X.reduce((ge, qe) => ge * qe);
        if (oe !== xe)
          throw Error(`cannot reshape array of size ${oe} into shape (${X})`);
        let Y = _e;
        for (let ge = X.length - 1; ge >= 0; ge--)
          Y = Y.reduce(
            (qe, Be) => {
              let Ne = qe[qe.length - 1];
              return Ne.length < X[ge] ? Ne.push(Be) : qe.push([Be]), qe;
            },
            [[]]
          );
        return Y[0];
      }
      function g(_e, X) {
        const [oe, xe] = (0, o.permute_data)(_e.data, _e.dims, X);
        return new _(_e.type, oe, xe);
      }
      function M(_e, [X, oe], xe = "bilinear", Y = !1) {
        const ge = _e.dims.at(-3) ?? 1,
          qe = _e.dims.at(-2),
          Be = _e.dims.at(-1);
        let Ne = (0, o.interpolate_data)(_e.data, [ge, qe, Be], [X, oe], xe, Y);
        return new _(_e.type, Ne, [ge, X, oe]);
      }
      async function v(_e, { size: X = null, mode: oe = "bilinear" } = {}) {
        if (_e.dims.length !== 4)
          throw new Error("`interpolate_4d` currently only supports 4D input.");
        if (!X) throw new Error("`interpolate_4d` requires a `size` argument.");
        let xe;
        if (X.length === 2) xe = [..._e.dims.slice(0, 2), ...X];
        else if (X.length === 3) xe = [_e.dims[0], ...X];
        else if (X.length === 4) xe = X;
        else throw new Error("`size` must be of length 2, 3, or 4.");
        let Y;
        if (oe === "bilinear")
          Y = await l.TensorOpRegistry.bilinear_interpolate_4d;
        else if (oe === "bicubic")
          Y = await l.TensorOpRegistry.bicubic_interpolate_4d;
        else throw new Error(`Unsupported mode: ${oe}`);
        const ge = new _("int64", new BigInt64Array(xe.map(BigInt)), [
          xe.length
        ]);
        return await Y({ x: _e, s: ge });
      }
      async function C(_e, X) {
        return await (
          await l.TensorOpRegistry.matmul
        )({ a: _e, b: X });
      }
      async function T(_e, X) {
        return await (
          await l.TensorOpRegistry.rfft
        )({ x: _e, a: X });
      }
      async function z(_e, X) {
        const oe = await l.TensorOpRegistry.top_k;
        return (
          X === null ? (X = _e.dims.at(-1)) : (X = Math.min(X, _e.dims.at(-1))),
          await oe({ x: _e, k: new _("int64", [BigInt(X)], [1]) })
        );
      }
      function $(_e, X) {
        const oe = _e.data,
          xe = X.data,
          Y = [_e.dims[0], _e.dims[2]],
          ge = new oe.constructor(Y[0] * Y[1]),
          [qe, Be, Ne] = _e.dims;
        let We = 0;
        for (let st = 0; st < qe; ++st) {
          const pt = st * Ne * Be;
          for (let Ge = 0; Ge < Ne; ++Ge) {
            let Te = 0,
              je = 0;
            const Ye = st * Be,
              et = pt + Ge;
            for (let Ae = 0; Ae < Be; ++Ae) {
              const $e = Number(xe[Ye + Ae]);
              (je += $e), (Te += oe[et + Ae * Ne] * $e);
            }
            const A = Te / je;
            ge[We++] = A;
          }
        }
        return new _(_e.type, ge, Y);
      }
      function S(_e, X, { eps: oe = 1e-5 } = {}) {
        if (_e.dims.length !== 2)
          throw new Error("`layer_norm` currently only supports 2D input.");
        const [xe, Y] = _e.dims;
        if (X.length !== 1 && X[0] !== Y)
          throw new Error(
            "`normalized_shape` must be a 1D array with shape `[input.dims[1]]`."
          );
        const [ge, qe] = B(_e, 1, 0, !0),
          Be = ge.data,
          Ne = qe.data,
          We = _e.data,
          st = new We.constructor(We.length);
        for (let pt = 0; pt < xe; ++pt) {
          const Ge = pt * Y;
          for (let Te = 0; Te < Y; ++Te) {
            const je = Ge + Te;
            st[je] = (We[je] - Ne[pt]) / (Be[pt] + oe);
          }
        }
        return new _(_e.type, st, _e.dims);
      }
      function y(_e, X) {
        return (
          (_e = _e.slice()),
          X === null
            ? (_e = _e.filter((oe) => oe !== 1))
            : typeof X == "number"
            ? _e[X] === 1 && _e.splice(X, 1)
            : Array.isArray(X) &&
              (_e = _e.filter((oe, xe) => oe !== 1 || !X.includes(xe))),
          _e
        );
      }
      function x(_e, X) {
        return (
          (X = I(X, _e.length + 1)), (_e = _e.slice()), _e.splice(X, 0, 1), _e
        );
      }
      function I(_e, X, oe = null, xe = !0) {
        if (xe && (_e < -X || _e >= X))
          throw new Error(
            `IndexError: index ${_e} is out of bounds for dimension${
              oe === null ? "" : " " + oe
            } with size ${X}`
          );
        return _e < 0 && (_e = ((_e % X) + X) % X), _e;
      }
      function V(_e, X = 0) {
        X = I(X, _e[0].dims.length);
        const oe = _e[0].dims.slice();
        oe[X] = _e.reduce((qe, Be) => qe + Be.dims[X], 0);
        const xe = oe.reduce((qe, Be) => qe * Be, 1),
          Y = new _e[0].data.constructor(xe),
          ge = _e[0].type;
        if (X === 0) {
          let qe = 0;
          for (const Be of _e) {
            const Ne = Be.data;
            Y.set(Ne, qe), (qe += Ne.length);
          }
        } else {
          let qe = 0;
          for (let Be = 0; Be < _e.length; ++Be) {
            const { data: Ne, dims: We } = _e[Be];
            for (let st = 0; st < Ne.length; ++st) {
              let pt = 0;
              for (let Ge = We.length - 1, Te = st, je = 1; Ge >= 0; --Ge) {
                const Ye = We[Ge];
                let et = Te % Ye;
                Ge === X && (et += qe),
                  (pt += et * je),
                  (je *= oe[Ge]),
                  (Te = Math.floor(Te / Ye));
              }
              Y[pt] = Ne[st];
            }
            qe += We[X];
          }
        }
        return new _(ge, Y, oe);
      }
      function O(_e, X = 0) {
        return V(
          _e.map((oe) => oe.unsqueeze(X)),
          X
        );
      }
      function B(_e, X = null, oe = 1, xe = !1) {
        const Y = _e.data,
          ge = _e.dims;
        if (X === null) {
          const Ge = Y.reduce((et, A) => et + A, 0) / Y.length,
            Te = Math.sqrt(
              Y.reduce((et, A) => et + (A - Ge) ** 2, 0) / (Y.length - oe)
            ),
            je = new _(_e.type, [Ge], []);
          return [new _(_e.type, [Te], []), je];
        }
        X = I(X, ge.length);
        const qe = j(_e, X, xe),
          Be = qe.data,
          Ne = ge.slice();
        Ne[X] = 1;
        const We = new Y.constructor(Y.length / ge[X]);
        for (let pt = 0; pt < Y.length; ++pt) {
          let Ge = 0;
          for (let Te = ge.length - 1, je = pt, Ye = 1; Te >= 0; --Te) {
            const et = ge[Te];
            if (Te !== X) {
              const A = je % et;
              (Ge += A * Ye), (Ye *= Ne[Te]);
            }
            je = Math.floor(je / et);
          }
          We[Ge] += (Y[pt] - Be[Ge]) ** 2;
        }
        for (let pt = 0; pt < We.length; ++pt)
          We[pt] = Math.sqrt(We[pt] / (ge[X] - oe));
        return xe || Ne.splice(X, 1), [new _(_e.type, We, Ne), qe];
      }
      function j(_e, X = null, oe = !1) {
        const xe = _e.data;
        if (X === null) {
          const Be = xe.reduce((Ne, We) => Ne + We, 0);
          return new _(_e.type, [Be / xe.length], []);
        }
        const Y = _e.dims;
        X = I(X, Y.length);
        const ge = Y.slice();
        ge[X] = 1;
        const qe = new xe.constructor(xe.length / Y[X]);
        for (let Be = 0; Be < xe.length; ++Be) {
          let Ne = 0;
          for (let We = Y.length - 1, st = Be, pt = 1; We >= 0; --We) {
            const Ge = Y[We];
            if (We !== X) {
              const Te = st % Ge;
              (Ne += Te * pt), (pt *= ge[We]);
            }
            st = Math.floor(st / Ge);
          }
          qe[Ne] += xe[Be];
        }
        if (Y[X] !== 1)
          for (let Be = 0; Be < qe.length; ++Be) qe[Be] = qe[Be] / Y[X];
        return oe || ge.splice(X, 1), new _(_e.type, qe, ge);
      }
      function N(_e) {
        const X = new Array(_e.length);
        for (let oe = _e.length - 1, xe = 1; oe >= 0; --oe)
          (X[oe] = xe), (xe *= _e[oe]);
        return X;
      }
      function se(_e, X, oe, xe) {
        const Y = _e.reduce((ge, qe) => ge * qe, 1);
        return new _(oe, new xe(Y).fill(X), _e);
      }
      function de(_e, X) {
        let oe, xe;
        if (typeof X == "number") (oe = "float32"), (xe = Float32Array);
        else if (typeof X == "bigint") (oe = "int64"), (xe = BigInt64Array);
        else throw new Error(`Unsupported data type: ${typeof X}`);
        return se(_e, X, oe, xe);
      }
      function Me(_e, X) {
        return de(_e.dims, X);
      }
      function J(_e) {
        return se(_e, 1n, "int64", BigInt64Array);
      }
      function ye(_e) {
        return J(_e.dims);
      }
      function L(_e) {
        return se(_e, 0n, "int64", BigInt64Array);
      }
      function Ee(_e) {
        return L(_e.dims);
      }
      function Qe(_e, X) {
        if (_e.dims.length !== 2)
          throw new Error("The tensor must have 2 dimensions");
        if (_e.dims.at(-1) % 8 !== 0)
          throw new Error(
            "The last dimension of the tensor must be a multiple of 8"
          );
        if (!["binary", "ubinary"].includes(X))
          throw new Error("The precision must be either 'binary' or 'ubinary'");
        const oe = X === "binary",
          xe = oe ? "int8" : "uint8",
          Y = oe ? Int8Array : Uint8Array,
          ge = _e.data,
          qe = new Y(ge.length / 8);
        for (let Be = 0; Be < ge.length; ++Be) {
          const Ne = ge[Be] > 0 ? 1 : 0,
            We = Math.floor(Be / 8),
            st = Be % 8;
          (qe[We] |= Ne << (7 - st)), oe && st === 0 && (qe[We] -= 128);
        }
        return new _(xe, qe, [_e.dims[0], _e.dims[1] / 8]);
      }
    }
  },
  U1 = {};
function rn(e) {
  var t = U1[e];
  if (t !== void 0) return t.exports;
  var n = (U1[e] = { exports: {} });
  return _x[e](n, n.exports, rn), n.exports;
}
rn.m = _x;
(() => {
  var e = Object.getPrototypeOf
      ? (n) => Object.getPrototypeOf(n)
      : (n) => n.__proto__,
    t;
  rn.t = function (n, o) {
    if (
      (o & 1 && (n = this(n)),
      o & 8 ||
        (typeof n == "object" &&
          n &&
          ((o & 4 && n.__esModule) || (o & 16 && typeof n.then == "function"))))
    )
      return n;
    var a = Object.create(null);
    rn.r(a);
    var l = {};
    t = t || [null, e({}), e([]), e(e)];
    for (var f = o & 2 && n; typeof f == "object" && !~t.indexOf(f); f = e(f))
      Object.getOwnPropertyNames(f).forEach((_) => (l[_] = () => n[_]));
    return (l.default = () => n), rn.d(a, l), a;
  };
})();
rn.d = (e, t) => {
  for (var n in t)
    rn.o(t, n) &&
      !rn.o(e, n) &&
      Object.defineProperty(e, n, { enumerable: !0, get: t[n] });
};
rn.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
rn.r = (e) => {
  typeof Symbol < "u" &&
    Symbol.toStringTag &&
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
    Object.defineProperty(e, "__esModule", { value: !0 });
};
(() => {
  var e;
  if ((typeof import.meta.url == "string" && (e = import.meta.url), !e))
    throw new Error("Automatic publicPath is not supported in this browser");
  (e = e
    .replace(/#.*$/, "")
    .replace(/\?.*$/, "")
    .replace(/\/[^\/]+$/, "/")),
    (rn.p = e);
})();
rn.b = new URL("./", import.meta.url);
var P = {};
/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/ rn.r(P);
rn.d(P, {
  ASTFeatureExtractor: () => ir.ASTFeatureExtractor,
  ASTForAudioClassification: () => Q.ASTForAudioClassification,
  ASTModel: () => Q.ASTModel,
  ASTPreTrainedModel: () => Q.ASTPreTrainedModel,
  AlbertForMaskedLM: () => Q.AlbertForMaskedLM,
  AlbertForQuestionAnswering: () => Q.AlbertForQuestionAnswering,
  AlbertForSequenceClassification: () => Q.AlbertForSequenceClassification,
  AlbertModel: () => Q.AlbertModel,
  AlbertPreTrainedModel: () => Q.AlbertPreTrainedModel,
  AlbertTokenizer: () => lr.AlbertTokenizer,
  AudioClassificationPipeline: () => en.AudioClassificationPipeline,
  AutoConfig: () => Gg.AutoConfig,
  AutoModel: () => Q.AutoModel,
  AutoModelForAudioClassification: () => Q.AutoModelForAudioClassification,
  AutoModelForAudioFrameClassification: () =>
    Q.AutoModelForAudioFrameClassification,
  AutoModelForCTC: () => Q.AutoModelForCTC,
  AutoModelForCausalLM: () => Q.AutoModelForCausalLM,
  AutoModelForDepthEstimation: () => Q.AutoModelForDepthEstimation,
  AutoModelForDocumentQuestionAnswering: () =>
    Q.AutoModelForDocumentQuestionAnswering,
  AutoModelForImageClassification: () => Q.AutoModelForImageClassification,
  AutoModelForImageFeatureExtraction: () =>
    Q.AutoModelForImageFeatureExtraction,
  AutoModelForImageMatting: () => Q.AutoModelForImageMatting,
  AutoModelForImageSegmentation: () => Q.AutoModelForImageSegmentation,
  AutoModelForImageToImage: () => Q.AutoModelForImageToImage,
  AutoModelForMaskGeneration: () => Q.AutoModelForMaskGeneration,
  AutoModelForMaskedLM: () => Q.AutoModelForMaskedLM,
  AutoModelForNormalEstimation: () => Q.AutoModelForNormalEstimation,
  AutoModelForObjectDetection: () => Q.AutoModelForObjectDetection,
  AutoModelForQuestionAnswering: () => Q.AutoModelForQuestionAnswering,
  AutoModelForSemanticSegmentation: () => Q.AutoModelForSemanticSegmentation,
  AutoModelForSeq2SeqLM: () => Q.AutoModelForSeq2SeqLM,
  AutoModelForSequenceClassification: () =>
    Q.AutoModelForSequenceClassification,
  AutoModelForSpeechSeq2Seq: () => Q.AutoModelForSpeechSeq2Seq,
  AutoModelForTextToSpectrogram: () => Q.AutoModelForTextToSpectrogram,
  AutoModelForTextToWaveform: () => Q.AutoModelForTextToWaveform,
  AutoModelForTokenClassification: () => Q.AutoModelForTokenClassification,
  AutoModelForVision2Seq: () => Q.AutoModelForVision2Seq,
  AutoModelForXVector: () => Q.AutoModelForXVector,
  AutoModelForZeroShotObjectDetection: () =>
    Q.AutoModelForZeroShotObjectDetection,
  AutoProcessor: () => ir.AutoProcessor,
  AutoTokenizer: () => lr.AutoTokenizer,
  AutomaticSpeechRecognitionPipeline: () =>
    en.AutomaticSpeechRecognitionPipeline,
  BartForConditionalGeneration: () => Q.BartForConditionalGeneration,
  BartForSequenceClassification: () => Q.BartForSequenceClassification,
  BartModel: () => Q.BartModel,
  BartPretrainedModel: () => Q.BartPretrainedModel,
  BartTokenizer: () => lr.BartTokenizer,
  BaseModelOutput: () => Q.BaseModelOutput,
  BaseStreamer: () => Hg.BaseStreamer,
  BeitFeatureExtractor: () => ir.BeitFeatureExtractor,
  BeitForImageClassification: () => Q.BeitForImageClassification,
  BeitModel: () => Q.BeitModel,
  BeitPreTrainedModel: () => Q.BeitPreTrainedModel,
  BertForMaskedLM: () => Q.BertForMaskedLM,
  BertForQuestionAnswering: () => Q.BertForQuestionAnswering,
  BertForSequenceClassification: () => Q.BertForSequenceClassification,
  BertForTokenClassification: () => Q.BertForTokenClassification,
  BertModel: () => Q.BertModel,
  BertPreTrainedModel: () => Q.BertPreTrainedModel,
  BertTokenizer: () => lr.BertTokenizer,
  BitImageProcessor: () => ir.BitImageProcessor,
  BlenderbotForConditionalGeneration: () =>
    Q.BlenderbotForConditionalGeneration,
  BlenderbotModel: () => Q.BlenderbotModel,
  BlenderbotPreTrainedModel: () => Q.BlenderbotPreTrainedModel,
  BlenderbotSmallForConditionalGeneration: () =>
    Q.BlenderbotSmallForConditionalGeneration,
  BlenderbotSmallModel: () => Q.BlenderbotSmallModel,
  BlenderbotSmallPreTrainedModel: () => Q.BlenderbotSmallPreTrainedModel,
  BlenderbotSmallTokenizer: () => lr.BlenderbotSmallTokenizer,
  BlenderbotTokenizer: () => lr.BlenderbotTokenizer,
  BloomForCausalLM: () => Q.BloomForCausalLM,
  BloomModel: () => Q.BloomModel,
  BloomPreTrainedModel: () => Q.BloomPreTrainedModel,
  BloomTokenizer: () => lr.BloomTokenizer,
  CLIPFeatureExtractor: () => ir.CLIPFeatureExtractor,
  CLIPImageProcessor: () => ir.CLIPImageProcessor,
  CLIPModel: () => Q.CLIPModel,
  CLIPPreTrainedModel: () => Q.CLIPPreTrainedModel,
  CLIPSegForImageSegmentation: () => Q.CLIPSegForImageSegmentation,
  CLIPSegModel: () => Q.CLIPSegModel,
  CLIPSegPreTrainedModel: () => Q.CLIPSegPreTrainedModel,
  CLIPTextModelWithProjection: () => Q.CLIPTextModelWithProjection,
  CLIPTokenizer: () => lr.CLIPTokenizer,
  CLIPVisionModelWithProjection: () => Q.CLIPVisionModelWithProjection,
  CamembertForMaskedLM: () => Q.CamembertForMaskedLM,
  CamembertForQuestionAnswering: () => Q.CamembertForQuestionAnswering,
  CamembertForSequenceClassification: () =>
    Q.CamembertForSequenceClassification,
  CamembertForTokenClassification: () => Q.CamembertForTokenClassification,
  CamembertModel: () => Q.CamembertModel,
  CamembertPreTrainedModel: () => Q.CamembertPreTrainedModel,
  CamembertTokenizer: () => lr.CamembertTokenizer,
  CausalLMOutput: () => Q.CausalLMOutput,
  CausalLMOutputWithPast: () => Q.CausalLMOutputWithPast,
  ChineseCLIPFeatureExtractor: () => ir.ChineseCLIPFeatureExtractor,
  ChineseCLIPModel: () => Q.ChineseCLIPModel,
  ChineseCLIPPreTrainedModel: () => Q.ChineseCLIPPreTrainedModel,
  ClapAudioModelWithProjection: () => Q.ClapAudioModelWithProjection,
  ClapFeatureExtractor: () => ir.ClapFeatureExtractor,
  ClapModel: () => Q.ClapModel,
  ClapPreTrainedModel: () => Q.ClapPreTrainedModel,
  ClapTextModelWithProjection: () => Q.ClapTextModelWithProjection,
  CodeGenForCausalLM: () => Q.CodeGenForCausalLM,
  CodeGenModel: () => Q.CodeGenModel,
  CodeGenPreTrainedModel: () => Q.CodeGenPreTrainedModel,
  CodeGenTokenizer: () => lr.CodeGenTokenizer,
  CodeLlamaTokenizer: () => lr.CodeLlamaTokenizer,
  CohereForCausalLM: () => Q.CohereForCausalLM,
  CohereModel: () => Q.CohereModel,
  CoherePreTrainedModel: () => Q.CoherePreTrainedModel,
  CohereTokenizer: () => lr.CohereTokenizer,
  ConvBertForMaskedLM: () => Q.ConvBertForMaskedLM,
  ConvBertForQuestionAnswering: () => Q.ConvBertForQuestionAnswering,
  ConvBertForSequenceClassification: () => Q.ConvBertForSequenceClassification,
  ConvBertForTokenClassification: () => Q.ConvBertForTokenClassification,
  ConvBertModel: () => Q.ConvBertModel,
  ConvBertPreTrainedModel: () => Q.ConvBertPreTrainedModel,
  ConvBertTokenizer: () => lr.ConvBertTokenizer,
  ConvNextFeatureExtractor: () => ir.ConvNextFeatureExtractor,
  ConvNextForImageClassification: () => Q.ConvNextForImageClassification,
  ConvNextImageProcessor: () => ir.ConvNextImageProcessor,
  ConvNextModel: () => Q.ConvNextModel,
  ConvNextPreTrainedModel: () => Q.ConvNextPreTrainedModel,
  ConvNextV2ForImageClassification: () => Q.ConvNextV2ForImageClassification,
  ConvNextV2Model: () => Q.ConvNextV2Model,
  ConvNextV2PreTrainedModel: () => Q.ConvNextV2PreTrainedModel,
  DPTFeatureExtractor: () => ir.DPTFeatureExtractor,
  DPTForDepthEstimation: () => Q.DPTForDepthEstimation,
  DPTImageProcessor: () => ir.DPTImageProcessor,
  DPTModel: () => Q.DPTModel,
  DPTPreTrainedModel: () => Q.DPTPreTrainedModel,
  DebertaForMaskedLM: () => Q.DebertaForMaskedLM,
  DebertaForQuestionAnswering: () => Q.DebertaForQuestionAnswering,
  DebertaForSequenceClassification: () => Q.DebertaForSequenceClassification,
  DebertaForTokenClassification: () => Q.DebertaForTokenClassification,
  DebertaModel: () => Q.DebertaModel,
  DebertaPreTrainedModel: () => Q.DebertaPreTrainedModel,
  DebertaTokenizer: () => lr.DebertaTokenizer,
  DebertaV2ForMaskedLM: () => Q.DebertaV2ForMaskedLM,
  DebertaV2ForQuestionAnswering: () => Q.DebertaV2ForQuestionAnswering,
  DebertaV2ForSequenceClassification: () =>
    Q.DebertaV2ForSequenceClassification,
  DebertaV2ForTokenClassification: () => Q.DebertaV2ForTokenClassification,
  DebertaV2Model: () => Q.DebertaV2Model,
  DebertaV2PreTrainedModel: () => Q.DebertaV2PreTrainedModel,
  DebertaV2Tokenizer: () => lr.DebertaV2Tokenizer,
  DeiTFeatureExtractor: () => ir.DeiTFeatureExtractor,
  DeiTForImageClassification: () => Q.DeiTForImageClassification,
  DeiTModel: () => Q.DeiTModel,
  DeiTPreTrainedModel: () => Q.DeiTPreTrainedModel,
  DepthAnythingForDepthEstimation: () => Q.DepthAnythingForDepthEstimation,
  DepthAnythingPreTrainedModel: () => Q.DepthAnythingPreTrainedModel,
  DepthEstimationPipeline: () => en.DepthEstimationPipeline,
  DetrFeatureExtractor: () => ir.DetrFeatureExtractor,
  DetrForObjectDetection: () => Q.DetrForObjectDetection,
  DetrForSegmentation: () => Q.DetrForSegmentation,
  DetrModel: () => Q.DetrModel,
  DetrObjectDetectionOutput: () => Q.DetrObjectDetectionOutput,
  DetrPreTrainedModel: () => Q.DetrPreTrainedModel,
  DetrSegmentationOutput: () => Q.DetrSegmentationOutput,
  Dinov2ForImageClassification: () => Q.Dinov2ForImageClassification,
  Dinov2Model: () => Q.Dinov2Model,
  Dinov2PreTrainedModel: () => Q.Dinov2PreTrainedModel,
  DistilBertForMaskedLM: () => Q.DistilBertForMaskedLM,
  DistilBertForQuestionAnswering: () => Q.DistilBertForQuestionAnswering,
  DistilBertForSequenceClassification: () =>
    Q.DistilBertForSequenceClassification,
  DistilBertForTokenClassification: () => Q.DistilBertForTokenClassification,
  DistilBertModel: () => Q.DistilBertModel,
  DistilBertPreTrainedModel: () => Q.DistilBertPreTrainedModel,
  DistilBertTokenizer: () => lr.DistilBertTokenizer,
  DocumentQuestionAnsweringPipeline: () => en.DocumentQuestionAnsweringPipeline,
  DonutFeatureExtractor: () => ir.DonutFeatureExtractor,
  DonutSwinModel: () => Q.DonutSwinModel,
  DonutSwinPreTrainedModel: () => Q.DonutSwinPreTrainedModel,
  EfficientNetForImageClassification: () =>
    Q.EfficientNetForImageClassification,
  EfficientNetImageProcessor: () => ir.EfficientNetImageProcessor,
  EfficientNetModel: () => Q.EfficientNetModel,
  EfficientNetPreTrainedModel: () => Q.EfficientNetPreTrainedModel,
  ElectraForMaskedLM: () => Q.ElectraForMaskedLM,
  ElectraForQuestionAnswering: () => Q.ElectraForQuestionAnswering,
  ElectraForSequenceClassification: () => Q.ElectraForSequenceClassification,
  ElectraForTokenClassification: () => Q.ElectraForTokenClassification,
  ElectraModel: () => Q.ElectraModel,
  ElectraPreTrainedModel: () => Q.ElectraPreTrainedModel,
  ElectraTokenizer: () => lr.ElectraTokenizer,
  EosTokenCriteria: () => Ff.EosTokenCriteria,
  EsmForMaskedLM: () => Q.EsmForMaskedLM,
  EsmForSequenceClassification: () => Q.EsmForSequenceClassification,
  EsmForTokenClassification: () => Q.EsmForTokenClassification,
  EsmModel: () => Q.EsmModel,
  EsmPreTrainedModel: () => Q.EsmPreTrainedModel,
  EsmTokenizer: () => lr.EsmTokenizer,
  FFT: () => fi.FFT,
  FalconForCausalLM: () => Q.FalconForCausalLM,
  FalconModel: () => Q.FalconModel,
  FalconPreTrainedModel: () => Q.FalconPreTrainedModel,
  FalconTokenizer: () => lr.FalconTokenizer,
  FastViTForImageClassification: () => Q.FastViTForImageClassification,
  FastViTModel: () => Q.FastViTModel,
  FastViTPreTrainedModel: () => Q.FastViTPreTrainedModel,
  FeatureExtractionPipeline: () => en.FeatureExtractionPipeline,
  FeatureExtractor: () => ir.FeatureExtractor,
  FillMaskPipeline: () => en.FillMaskPipeline,
  Florence2ForConditionalGeneration: () => Q.Florence2ForConditionalGeneration,
  Florence2PreTrainedModel: () => Q.Florence2PreTrainedModel,
  Florence2Processor: () => ir.Florence2Processor,
  GLPNFeatureExtractor: () => ir.GLPNFeatureExtractor,
  GLPNForDepthEstimation: () => Q.GLPNForDepthEstimation,
  GLPNModel: () => Q.GLPNModel,
  GLPNPreTrainedModel: () => Q.GLPNPreTrainedModel,
  GPT2LMHeadModel: () => Q.GPT2LMHeadModel,
  GPT2Model: () => Q.GPT2Model,
  GPT2PreTrainedModel: () => Q.GPT2PreTrainedModel,
  GPT2Tokenizer: () => lr.GPT2Tokenizer,
  GPTBigCodeForCausalLM: () => Q.GPTBigCodeForCausalLM,
  GPTBigCodeModel: () => Q.GPTBigCodeModel,
  GPTBigCodePreTrainedModel: () => Q.GPTBigCodePreTrainedModel,
  GPTJForCausalLM: () => Q.GPTJForCausalLM,
  GPTJModel: () => Q.GPTJModel,
  GPTJPreTrainedModel: () => Q.GPTJPreTrainedModel,
  GPTNeoForCausalLM: () => Q.GPTNeoForCausalLM,
  GPTNeoModel: () => Q.GPTNeoModel,
  GPTNeoPreTrainedModel: () => Q.GPTNeoPreTrainedModel,
  GPTNeoXForCausalLM: () => Q.GPTNeoXForCausalLM,
  GPTNeoXModel: () => Q.GPTNeoXModel,
  GPTNeoXPreTrainedModel: () => Q.GPTNeoXPreTrainedModel,
  GPTNeoXTokenizer: () => lr.GPTNeoXTokenizer,
  Gemma2ForCausalLM: () => Q.Gemma2ForCausalLM,
  Gemma2Model: () => Q.Gemma2Model,
  Gemma2PreTrainedModel: () => Q.Gemma2PreTrainedModel,
  GemmaForCausalLM: () => Q.GemmaForCausalLM,
  GemmaModel: () => Q.GemmaModel,
  GemmaPreTrainedModel: () => Q.GemmaPreTrainedModel,
  GemmaTokenizer: () => lr.GemmaTokenizer,
  Grok1Tokenizer: () => lr.Grok1Tokenizer,
  HerbertTokenizer: () => lr.HerbertTokenizer,
  HubertForCTC: () => Q.HubertForCTC,
  HubertForSequenceClassification: () => Q.HubertForSequenceClassification,
  HubertModel: () => Q.HubertModel,
  HubertPreTrainedModel: () => Q.HubertPreTrainedModel,
  ImageClassificationPipeline: () => en.ImageClassificationPipeline,
  ImageFeatureExtractionPipeline: () => en.ImageFeatureExtractionPipeline,
  ImageFeatureExtractor: () => ir.ImageFeatureExtractor,
  ImageMattingOutput: () => Q.ImageMattingOutput,
  ImageSegmentationPipeline: () => en.ImageSegmentationPipeline,
  ImageToImagePipeline: () => en.ImageToImagePipeline,
  ImageToTextPipeline: () => en.ImageToTextPipeline,
  InterruptableStoppingCriteria: () => Ff.InterruptableStoppingCriteria,
  JAISLMHeadModel: () => Q.JAISLMHeadModel,
  JAISModel: () => Q.JAISModel,
  JAISPreTrainedModel: () => Q.JAISPreTrainedModel,
  LlamaForCausalLM: () => Q.LlamaForCausalLM,
  LlamaModel: () => Q.LlamaModel,
  LlamaPreTrainedModel: () => Q.LlamaPreTrainedModel,
  LlamaTokenizer: () => lr.LlamaTokenizer,
  LlavaForConditionalGeneration: () => Q.LlavaForConditionalGeneration,
  LlavaPreTrainedModel: () => Q.LlavaPreTrainedModel,
  LongT5ForConditionalGeneration: () => Q.LongT5ForConditionalGeneration,
  LongT5Model: () => Q.LongT5Model,
  LongT5PreTrainedModel: () => Q.LongT5PreTrainedModel,
  M2M100ForConditionalGeneration: () => Q.M2M100ForConditionalGeneration,
  M2M100Model: () => Q.M2M100Model,
  M2M100PreTrainedModel: () => Q.M2M100PreTrainedModel,
  M2M100Tokenizer: () => lr.M2M100Tokenizer,
  MBart50Tokenizer: () => lr.MBart50Tokenizer,
  MBartForCausalLM: () => Q.MBartForCausalLM,
  MBartForConditionalGeneration: () => Q.MBartForConditionalGeneration,
  MBartForSequenceClassification: () => Q.MBartForSequenceClassification,
  MBartModel: () => Q.MBartModel,
  MBartPreTrainedModel: () => Q.MBartPreTrainedModel,
  MBartTokenizer: () => lr.MBartTokenizer,
  MPNetForMaskedLM: () => Q.MPNetForMaskedLM,
  MPNetForQuestionAnswering: () => Q.MPNetForQuestionAnswering,
  MPNetForSequenceClassification: () => Q.MPNetForSequenceClassification,
  MPNetForTokenClassification: () => Q.MPNetForTokenClassification,
  MPNetModel: () => Q.MPNetModel,
  MPNetPreTrainedModel: () => Q.MPNetPreTrainedModel,
  MPNetTokenizer: () => lr.MPNetTokenizer,
  MT5ForConditionalGeneration: () => Q.MT5ForConditionalGeneration,
  MT5Model: () => Q.MT5Model,
  MT5PreTrainedModel: () => Q.MT5PreTrainedModel,
  MarianMTModel: () => Q.MarianMTModel,
  MarianModel: () => Q.MarianModel,
  MarianPreTrainedModel: () => Q.MarianPreTrainedModel,
  MarianTokenizer: () => lr.MarianTokenizer,
  MaskedLMOutput: () => Q.MaskedLMOutput,
  MaxLengthCriteria: () => Ff.MaxLengthCriteria,
  MistralForCausalLM: () => Q.MistralForCausalLM,
  MistralModel: () => Q.MistralModel,
  MistralPreTrainedModel: () => Q.MistralPreTrainedModel,
  MobileBertForMaskedLM: () => Q.MobileBertForMaskedLM,
  MobileBertForQuestionAnswering: () => Q.MobileBertForQuestionAnswering,
  MobileBertForSequenceClassification: () =>
    Q.MobileBertForSequenceClassification,
  MobileBertModel: () => Q.MobileBertModel,
  MobileBertPreTrainedModel: () => Q.MobileBertPreTrainedModel,
  MobileBertTokenizer: () => lr.MobileBertTokenizer,
  MobileNetV1FeatureExtractor: () => ir.MobileNetV1FeatureExtractor,
  MobileNetV1ForImageClassification: () => Q.MobileNetV1ForImageClassification,
  MobileNetV1Model: () => Q.MobileNetV1Model,
  MobileNetV1PreTrainedModel: () => Q.MobileNetV1PreTrainedModel,
  MobileNetV2FeatureExtractor: () => ir.MobileNetV2FeatureExtractor,
  MobileNetV2ForImageClassification: () => Q.MobileNetV2ForImageClassification,
  MobileNetV2Model: () => Q.MobileNetV2Model,
  MobileNetV2PreTrainedModel: () => Q.MobileNetV2PreTrainedModel,
  MobileNetV3FeatureExtractor: () => ir.MobileNetV3FeatureExtractor,
  MobileNetV3ForImageClassification: () => Q.MobileNetV3ForImageClassification,
  MobileNetV3Model: () => Q.MobileNetV3Model,
  MobileNetV3PreTrainedModel: () => Q.MobileNetV3PreTrainedModel,
  MobileNetV4FeatureExtractor: () => ir.MobileNetV4FeatureExtractor,
  MobileNetV4ForImageClassification: () => Q.MobileNetV4ForImageClassification,
  MobileNetV4Model: () => Q.MobileNetV4Model,
  MobileNetV4PreTrainedModel: () => Q.MobileNetV4PreTrainedModel,
  MobileViTFeatureExtractor: () => ir.MobileViTFeatureExtractor,
  MobileViTForImageClassification: () => Q.MobileViTForImageClassification,
  MobileViTImageProcessor: () => ir.MobileViTImageProcessor,
  MobileViTModel: () => Q.MobileViTModel,
  MobileViTPreTrainedModel: () => Q.MobileViTPreTrainedModel,
  MobileViTV2ForImageClassification: () => Q.MobileViTV2ForImageClassification,
  MobileViTV2Model: () => Q.MobileViTV2Model,
  MobileViTV2PreTrainedModel: () => Q.MobileViTV2PreTrainedModel,
  ModelOutput: () => Q.ModelOutput,
  Moondream1ForConditionalGeneration: () =>
    Q.Moondream1ForConditionalGeneration,
  MptForCausalLM: () => Q.MptForCausalLM,
  MptModel: () => Q.MptModel,
  MptPreTrainedModel: () => Q.MptPreTrainedModel,
  MusicgenForCausalLM: () => Q.MusicgenForCausalLM,
  MusicgenForConditionalGeneration: () => Q.MusicgenForConditionalGeneration,
  MusicgenModel: () => Q.MusicgenModel,
  MusicgenPreTrainedModel: () => Q.MusicgenPreTrainedModel,
  NllbTokenizer: () => lr.NllbTokenizer,
  NomicBertModel: () => Q.NomicBertModel,
  NomicBertPreTrainedModel: () => Q.NomicBertPreTrainedModel,
  NougatImageProcessor: () => ir.NougatImageProcessor,
  NougatTokenizer: () => lr.NougatTokenizer,
  OPTForCausalLM: () => Q.OPTForCausalLM,
  OPTModel: () => Q.OPTModel,
  OPTPreTrainedModel: () => Q.OPTPreTrainedModel,
  ObjectDetectionPipeline: () => en.ObjectDetectionPipeline,
  OpenELMForCausalLM: () => Q.OpenELMForCausalLM,
  OpenELMModel: () => Q.OpenELMModel,
  OpenELMPreTrainedModel: () => Q.OpenELMPreTrainedModel,
  OwlViTFeatureExtractor: () => ir.OwlViTFeatureExtractor,
  OwlViTForObjectDetection: () => Q.OwlViTForObjectDetection,
  OwlViTModel: () => Q.OwlViTModel,
  OwlViTPreTrainedModel: () => Q.OwlViTPreTrainedModel,
  OwlViTProcessor: () => ir.OwlViTProcessor,
  Owlv2ForObjectDetection: () => Q.Owlv2ForObjectDetection,
  Owlv2ImageProcessor: () => ir.Owlv2ImageProcessor,
  Owlv2Model: () => Q.Owlv2Model,
  Owlv2PreTrainedModel: () => Q.Owlv2PreTrainedModel,
  Phi3ForCausalLM: () => Q.Phi3ForCausalLM,
  Phi3Model: () => Q.Phi3Model,
  Phi3PreTrainedModel: () => Q.Phi3PreTrainedModel,
  PhiForCausalLM: () => Q.PhiForCausalLM,
  PhiModel: () => Q.PhiModel,
  PhiPreTrainedModel: () => Q.PhiPreTrainedModel,
  Pipeline: () => en.Pipeline,
  PreTrainedModel: () => Q.PreTrainedModel,
  PreTrainedTokenizer: () => lr.PreTrainedTokenizer,
  PretrainedConfig: () => Gg.PretrainedConfig,
  PretrainedMixin: () => Q.PretrainedMixin,
  Processor: () => ir.Processor,
  PyAnnoteFeatureExtractor: () => ir.PyAnnoteFeatureExtractor,
  PyAnnoteForAudioFrameClassification: () =>
    Q.PyAnnoteForAudioFrameClassification,
  PyAnnoteModel: () => Q.PyAnnoteModel,
  PyAnnotePreTrainedModel: () => Q.PyAnnotePreTrainedModel,
  PyAnnoteProcessor: () => ir.PyAnnoteProcessor,
  QuestionAnsweringModelOutput: () => Q.QuestionAnsweringModelOutput,
  QuestionAnsweringPipeline: () => en.QuestionAnsweringPipeline,
  Qwen2ForCausalLM: () => Q.Qwen2ForCausalLM,
  Qwen2Model: () => Q.Qwen2Model,
  Qwen2PreTrainedModel: () => Q.Qwen2PreTrainedModel,
  Qwen2Tokenizer: () => lr.Qwen2Tokenizer,
  RTDetrForObjectDetection: () => Q.RTDetrForObjectDetection,
  RTDetrImageProcessor: () => ir.RTDetrImageProcessor,
  RTDetrModel: () => Q.RTDetrModel,
  RTDetrObjectDetectionOutput: () => Q.RTDetrObjectDetectionOutput,
  RTDetrPreTrainedModel: () => Q.RTDetrPreTrainedModel,
  RawImage: () => AE.RawImage,
  ResNetForImageClassification: () => Q.ResNetForImageClassification,
  ResNetModel: () => Q.ResNetModel,
  ResNetPreTrainedModel: () => Q.ResNetPreTrainedModel,
  RoFormerForMaskedLM: () => Q.RoFormerForMaskedLM,
  RoFormerForQuestionAnswering: () => Q.RoFormerForQuestionAnswering,
  RoFormerForSequenceClassification: () => Q.RoFormerForSequenceClassification,
  RoFormerForTokenClassification: () => Q.RoFormerForTokenClassification,
  RoFormerModel: () => Q.RoFormerModel,
  RoFormerPreTrainedModel: () => Q.RoFormerPreTrainedModel,
  RoFormerTokenizer: () => lr.RoFormerTokenizer,
  RobertaForMaskedLM: () => Q.RobertaForMaskedLM,
  RobertaForQuestionAnswering: () => Q.RobertaForQuestionAnswering,
  RobertaForSequenceClassification: () => Q.RobertaForSequenceClassification,
  RobertaForTokenClassification: () => Q.RobertaForTokenClassification,
  RobertaModel: () => Q.RobertaModel,
  RobertaPreTrainedModel: () => Q.RobertaPreTrainedModel,
  RobertaTokenizer: () => lr.RobertaTokenizer,
  SamImageProcessor: () => ir.SamImageProcessor,
  SamImageSegmentationOutput: () => Q.SamImageSegmentationOutput,
  SamModel: () => Q.SamModel,
  SamPreTrainedModel: () => Q.SamPreTrainedModel,
  SamProcessor: () => ir.SamProcessor,
  SapiensFeatureExtractor: () => ir.SapiensFeatureExtractor,
  SapiensForDepthEstimation: () => Q.SapiensForDepthEstimation,
  SapiensForNormalEstimation: () => Q.SapiensForNormalEstimation,
  SapiensForSemanticSegmentation: () => Q.SapiensForSemanticSegmentation,
  SapiensPreTrainedModel: () => Q.SapiensPreTrainedModel,
  SeamlessM4TFeatureExtractor: () => ir.SeamlessM4TFeatureExtractor,
  SegformerFeatureExtractor: () => ir.SegformerFeatureExtractor,
  SegformerForImageClassification: () => Q.SegformerForImageClassification,
  SegformerForSemanticSegmentation: () => Q.SegformerForSemanticSegmentation,
  SegformerModel: () => Q.SegformerModel,
  SegformerPreTrainedModel: () => Q.SegformerPreTrainedModel,
  Seq2SeqLMOutput: () => Q.Seq2SeqLMOutput,
  SequenceClassifierOutput: () => Q.SequenceClassifierOutput,
  SiglipImageProcessor: () => ir.SiglipImageProcessor,
  SiglipModel: () => Q.SiglipModel,
  SiglipPreTrainedModel: () => Q.SiglipPreTrainedModel,
  SiglipTextModel: () => Q.SiglipTextModel,
  SiglipTokenizer: () => lr.SiglipTokenizer,
  SiglipVisionModel: () => Q.SiglipVisionModel,
  SpeechT5FeatureExtractor: () => ir.SpeechT5FeatureExtractor,
  SpeechT5ForSpeechToText: () => Q.SpeechT5ForSpeechToText,
  SpeechT5ForTextToSpeech: () => Q.SpeechT5ForTextToSpeech,
  SpeechT5HifiGan: () => Q.SpeechT5HifiGan,
  SpeechT5Model: () => Q.SpeechT5Model,
  SpeechT5PreTrainedModel: () => Q.SpeechT5PreTrainedModel,
  SpeechT5Processor: () => ir.SpeechT5Processor,
  SpeechT5Tokenizer: () => lr.SpeechT5Tokenizer,
  SqueezeBertForMaskedLM: () => Q.SqueezeBertForMaskedLM,
  SqueezeBertForQuestionAnswering: () => Q.SqueezeBertForQuestionAnswering,
  SqueezeBertForSequenceClassification: () =>
    Q.SqueezeBertForSequenceClassification,
  SqueezeBertModel: () => Q.SqueezeBertModel,
  SqueezeBertPreTrainedModel: () => Q.SqueezeBertPreTrainedModel,
  SqueezeBertTokenizer: () => lr.SqueezeBertTokenizer,
  StableLmForCausalLM: () => Q.StableLmForCausalLM,
  StableLmModel: () => Q.StableLmModel,
  StableLmPreTrainedModel: () => Q.StableLmPreTrainedModel,
  Starcoder2ForCausalLM: () => Q.Starcoder2ForCausalLM,
  Starcoder2Model: () => Q.Starcoder2Model,
  Starcoder2PreTrainedModel: () => Q.Starcoder2PreTrainedModel,
  StoppingCriteria: () => Ff.StoppingCriteria,
  StoppingCriteriaList: () => Ff.StoppingCriteriaList,
  SummarizationPipeline: () => en.SummarizationPipeline,
  Swin2SRForImageSuperResolution: () => Q.Swin2SRForImageSuperResolution,
  Swin2SRImageProcessor: () => ir.Swin2SRImageProcessor,
  Swin2SRModel: () => Q.Swin2SRModel,
  Swin2SRPreTrainedModel: () => Q.Swin2SRPreTrainedModel,
  SwinForImageClassification: () => Q.SwinForImageClassification,
  SwinModel: () => Q.SwinModel,
  SwinPreTrainedModel: () => Q.SwinPreTrainedModel,
  T5ForConditionalGeneration: () => Q.T5ForConditionalGeneration,
  T5Model: () => Q.T5Model,
  T5PreTrainedModel: () => Q.T5PreTrainedModel,
  T5Tokenizer: () => lr.T5Tokenizer,
  TableTransformerForObjectDetection: () =>
    Q.TableTransformerForObjectDetection,
  TableTransformerModel: () => Q.TableTransformerModel,
  TableTransformerObjectDetectionOutput: () =>
    Q.TableTransformerObjectDetectionOutput,
  TableTransformerPreTrainedModel: () => Q.TableTransformerPreTrainedModel,
  Tensor: () => xn.Tensor,
  Text2TextGenerationPipeline: () => en.Text2TextGenerationPipeline,
  TextClassificationPipeline: () => en.TextClassificationPipeline,
  TextGenerationPipeline: () => en.TextGenerationPipeline,
  TextStreamer: () => Hg.TextStreamer,
  TextToAudioPipeline: () => en.TextToAudioPipeline,
  TokenClassificationPipeline: () => en.TokenClassificationPipeline,
  TokenClassifierOutput: () => Q.TokenClassifierOutput,
  TokenizerModel: () => lr.TokenizerModel,
  TrOCRForCausalLM: () => Q.TrOCRForCausalLM,
  TrOCRPreTrainedModel: () => Q.TrOCRPreTrainedModel,
  TranslationPipeline: () => en.TranslationPipeline,
  UniSpeechForCTC: () => Q.UniSpeechForCTC,
  UniSpeechForSequenceClassification: () =>
    Q.UniSpeechForSequenceClassification,
  UniSpeechModel: () => Q.UniSpeechModel,
  UniSpeechPreTrainedModel: () => Q.UniSpeechPreTrainedModel,
  UniSpeechSatForAudioFrameClassification: () =>
    Q.UniSpeechSatForAudioFrameClassification,
  UniSpeechSatForCTC: () => Q.UniSpeechSatForCTC,
  UniSpeechSatForSequenceClassification: () =>
    Q.UniSpeechSatForSequenceClassification,
  UniSpeechSatModel: () => Q.UniSpeechSatModel,
  UniSpeechSatPreTrainedModel: () => Q.UniSpeechSatPreTrainedModel,
  ViTFeatureExtractor: () => ir.ViTFeatureExtractor,
  ViTForImageClassification: () => Q.ViTForImageClassification,
  ViTImageProcessor: () => ir.ViTImageProcessor,
  ViTModel: () => Q.ViTModel,
  ViTPreTrainedModel: () => Q.ViTPreTrainedModel,
  VisionEncoderDecoderModel: () => Q.VisionEncoderDecoderModel,
  VitMatteForImageMatting: () => Q.VitMatteForImageMatting,
  VitMatteImageProcessor: () => ir.VitMatteImageProcessor,
  VitMattePreTrainedModel: () => Q.VitMattePreTrainedModel,
  VitsModel: () => Q.VitsModel,
  VitsModelOutput: () => Q.VitsModelOutput,
  VitsPreTrainedModel: () => Q.VitsPreTrainedModel,
  VitsTokenizer: () => lr.VitsTokenizer,
  Wav2Vec2BertForCTC: () => Q.Wav2Vec2BertForCTC,
  Wav2Vec2BertForSequenceClassification: () =>
    Q.Wav2Vec2BertForSequenceClassification,
  Wav2Vec2BertModel: () => Q.Wav2Vec2BertModel,
  Wav2Vec2BertPreTrainedModel: () => Q.Wav2Vec2BertPreTrainedModel,
  Wav2Vec2CTCTokenizer: () => lr.Wav2Vec2CTCTokenizer,
  Wav2Vec2FeatureExtractor: () => ir.Wav2Vec2FeatureExtractor,
  Wav2Vec2ForAudioFrameClassification: () =>
    Q.Wav2Vec2ForAudioFrameClassification,
  Wav2Vec2ForCTC: () => Q.Wav2Vec2ForCTC,
  Wav2Vec2ForSequenceClassification: () => Q.Wav2Vec2ForSequenceClassification,
  Wav2Vec2Model: () => Q.Wav2Vec2Model,
  Wav2Vec2PreTrainedModel: () => Q.Wav2Vec2PreTrainedModel,
  Wav2Vec2ProcessorWithLM: () => ir.Wav2Vec2ProcessorWithLM,
  WavLMForAudioFrameClassification: () => Q.WavLMForAudioFrameClassification,
  WavLMForCTC: () => Q.WavLMForCTC,
  WavLMForSequenceClassification: () => Q.WavLMForSequenceClassification,
  WavLMForXVector: () => Q.WavLMForXVector,
  WavLMModel: () => Q.WavLMModel,
  WavLMPreTrainedModel: () => Q.WavLMPreTrainedModel,
  WeSpeakerFeatureExtractor: () => ir.WeSpeakerFeatureExtractor,
  WeSpeakerResNetModel: () => Q.WeSpeakerResNetModel,
  WeSpeakerResNetPreTrainedModel: () => Q.WeSpeakerResNetPreTrainedModel,
  WhisperFeatureExtractor: () => ir.WhisperFeatureExtractor,
  WhisperForConditionalGeneration: () => Q.WhisperForConditionalGeneration,
  WhisperModel: () => Q.WhisperModel,
  WhisperPreTrainedModel: () => Q.WhisperPreTrainedModel,
  WhisperProcessor: () => ir.WhisperProcessor,
  WhisperTextStreamer: () => Hg.WhisperTextStreamer,
  WhisperTokenizer: () => lr.WhisperTokenizer,
  XLMForQuestionAnswering: () => Q.XLMForQuestionAnswering,
  XLMForSequenceClassification: () => Q.XLMForSequenceClassification,
  XLMForTokenClassification: () => Q.XLMForTokenClassification,
  XLMModel: () => Q.XLMModel,
  XLMPreTrainedModel: () => Q.XLMPreTrainedModel,
  XLMRobertaForMaskedLM: () => Q.XLMRobertaForMaskedLM,
  XLMRobertaForQuestionAnswering: () => Q.XLMRobertaForQuestionAnswering,
  XLMRobertaForSequenceClassification: () =>
    Q.XLMRobertaForSequenceClassification,
  XLMRobertaForTokenClassification: () => Q.XLMRobertaForTokenClassification,
  XLMRobertaModel: () => Q.XLMRobertaModel,
  XLMRobertaPreTrainedModel: () => Q.XLMRobertaPreTrainedModel,
  XLMRobertaTokenizer: () => lr.XLMRobertaTokenizer,
  XLMTokenizer: () => lr.XLMTokenizer,
  XLMWithLMHeadModel: () => Q.XLMWithLMHeadModel,
  XVectorOutput: () => Q.XVectorOutput,
  YolosFeatureExtractor: () => ir.YolosFeatureExtractor,
  YolosForObjectDetection: () => Q.YolosForObjectDetection,
  YolosModel: () => Q.YolosModel,
  YolosObjectDetectionOutput: () => Q.YolosObjectDetectionOutput,
  YolosPreTrainedModel: () => Q.YolosPreTrainedModel,
  ZeroShotAudioClassificationPipeline: () =>
    en.ZeroShotAudioClassificationPipeline,
  ZeroShotClassificationPipeline: () => en.ZeroShotClassificationPipeline,
  ZeroShotImageClassificationPipeline: () =>
    en.ZeroShotImageClassificationPipeline,
  ZeroShotObjectDetectionPipeline: () => en.ZeroShotObjectDetectionPipeline,
  bankers_round: () => fi.bankers_round,
  cat: () => xn.cat,
  cos_sim: () => fi.cos_sim,
  dot: () => fi.dot,
  dynamic_time_warping: () => fi.dynamic_time_warping,
  env: () => $E.env,
  full: () => xn.full,
  full_like: () => xn.full_like,
  getKeyValueShapes: () => Gg.getKeyValueShapes,
  hamming: () => Hl.hamming,
  hanning: () => Hl.hanning,
  interpolate: () => xn.interpolate,
  interpolate_4d: () => xn.interpolate_4d,
  interpolate_data: () => fi.interpolate_data,
  is_chinese_char: () => lr.is_chinese_char,
  layer_norm: () => xn.layer_norm,
  log_softmax: () => fi.log_softmax,
  magnitude: () => fi.magnitude,
  matmul: () => xn.matmul,
  max: () => fi.max,
  mean: () => xn.mean,
  mean_pooling: () => xn.mean_pooling,
  medianFilter: () => fi.medianFilter,
  mel_filter_bank: () => Hl.mel_filter_bank,
  min: () => fi.min,
  ones: () => xn.ones,
  ones_like: () => xn.ones_like,
  permute: () => xn.permute,
  permute_data: () => fi.permute_data,
  pipeline: () => en.pipeline,
  quantize_embeddings: () => xn.quantize_embeddings,
  read_audio: () => Hl.read_audio,
  rfft: () => xn.rfft,
  round: () => fi.round,
  softmax: () => fi.softmax,
  spectrogram: () => Hl.spectrogram,
  stack: () => xn.stack,
  std_mean: () => xn.std_mean,
  topk: () => xn.topk,
  window_function: () => Hl.window_function,
  zeros: () => xn.zeros,
  zeros_like: () => xn.zeros_like
});
var $E = rn("./src/env.js"),
  en = rn("./src/pipelines.js"),
  Q = rn("./src/models.js"),
  lr = rn("./src/tokenizers.js"),
  ir = rn("./src/processors.js"),
  Gg = rn("./src/configs.js"),
  Hl = rn("./src/utils/audio.js"),
  AE = rn("./src/utils/image.js"),
  xn = rn("./src/utils/tensor.js"),
  fi = rn("./src/utils/maths.js"),
  Hg = rn("./src/generation/streamers.js"),
  Ff = rn("./src/generation/stopping_criteria.js");
P.ASTFeatureExtractor;
P.ASTForAudioClassification;
P.ASTModel;
P.ASTPreTrainedModel;
P.AlbertForMaskedLM;
P.AlbertForQuestionAnswering;
P.AlbertForSequenceClassification;
P.AlbertModel;
P.AlbertPreTrainedModel;
P.AlbertTokenizer;
P.AudioClassificationPipeline;
P.AutoConfig;
var IE = P.AutoModel;
P.AutoModelForAudioClassification;
P.AutoModelForAudioFrameClassification;
P.AutoModelForCTC;
P.AutoModelForCausalLM;
P.AutoModelForDepthEstimation;
P.AutoModelForDocumentQuestionAnswering;
P.AutoModelForImageClassification;
P.AutoModelForImageFeatureExtraction;
P.AutoModelForImageMatting;
P.AutoModelForImageSegmentation;
P.AutoModelForImageToImage;
P.AutoModelForMaskGeneration;
P.AutoModelForMaskedLM;
P.AutoModelForNormalEstimation;
P.AutoModelForObjectDetection;
P.AutoModelForQuestionAnswering;
P.AutoModelForSemanticSegmentation;
P.AutoModelForSeq2SeqLM;
P.AutoModelForSequenceClassification;
P.AutoModelForSpeechSeq2Seq;
P.AutoModelForTextToSpectrogram;
P.AutoModelForTextToWaveform;
P.AutoModelForTokenClassification;
P.AutoModelForVision2Seq;
P.AutoModelForXVector;
P.AutoModelForZeroShotObjectDetection;
var FE = P.AutoProcessor;
P.AutoTokenizer;
P.AutomaticSpeechRecognitionPipeline;
P.BartForConditionalGeneration;
P.BartForSequenceClassification;
P.BartModel;
P.BartPretrainedModel;
P.BartTokenizer;
P.BaseModelOutput;
P.BaseStreamer;
P.BeitFeatureExtractor;
P.BeitForImageClassification;
P.BeitModel;
P.BeitPreTrainedModel;
P.BertForMaskedLM;
P.BertForQuestionAnswering;
P.BertForSequenceClassification;
P.BertForTokenClassification;
P.BertModel;
P.BertPreTrainedModel;
P.BertTokenizer;
P.BitImageProcessor;
P.BlenderbotForConditionalGeneration;
P.BlenderbotModel;
P.BlenderbotPreTrainedModel;
P.BlenderbotSmallForConditionalGeneration;
P.BlenderbotSmallModel;
P.BlenderbotSmallPreTrainedModel;
P.BlenderbotSmallTokenizer;
P.BlenderbotTokenizer;
P.BloomForCausalLM;
P.BloomModel;
P.BloomPreTrainedModel;
P.BloomTokenizer;
P.CLIPFeatureExtractor;
P.CLIPImageProcessor;
P.CLIPModel;
P.CLIPPreTrainedModel;
P.CLIPSegForImageSegmentation;
P.CLIPSegModel;
P.CLIPSegPreTrainedModel;
P.CLIPTextModelWithProjection;
P.CLIPTokenizer;
P.CLIPVisionModelWithProjection;
P.CamembertForMaskedLM;
P.CamembertForQuestionAnswering;
P.CamembertForSequenceClassification;
P.CamembertForTokenClassification;
P.CamembertModel;
P.CamembertPreTrainedModel;
P.CamembertTokenizer;
P.CausalLMOutput;
P.CausalLMOutputWithPast;
P.ChineseCLIPFeatureExtractor;
P.ChineseCLIPModel;
P.ChineseCLIPPreTrainedModel;
P.ClapAudioModelWithProjection;
P.ClapFeatureExtractor;
P.ClapModel;
P.ClapPreTrainedModel;
P.ClapTextModelWithProjection;
P.CodeGenForCausalLM;
P.CodeGenModel;
P.CodeGenPreTrainedModel;
P.CodeGenTokenizer;
P.CodeLlamaTokenizer;
P.CohereForCausalLM;
P.CohereModel;
P.CoherePreTrainedModel;
P.CohereTokenizer;
P.ConvBertForMaskedLM;
P.ConvBertForQuestionAnswering;
P.ConvBertForSequenceClassification;
P.ConvBertForTokenClassification;
P.ConvBertModel;
P.ConvBertPreTrainedModel;
P.ConvBertTokenizer;
P.ConvNextFeatureExtractor;
P.ConvNextForImageClassification;
P.ConvNextImageProcessor;
P.ConvNextModel;
P.ConvNextPreTrainedModel;
P.ConvNextV2ForImageClassification;
P.ConvNextV2Model;
P.ConvNextV2PreTrainedModel;
P.DPTFeatureExtractor;
P.DPTForDepthEstimation;
P.DPTImageProcessor;
P.DPTModel;
P.DPTPreTrainedModel;
P.DebertaForMaskedLM;
P.DebertaForQuestionAnswering;
P.DebertaForSequenceClassification;
P.DebertaForTokenClassification;
P.DebertaModel;
P.DebertaPreTrainedModel;
P.DebertaTokenizer;
P.DebertaV2ForMaskedLM;
P.DebertaV2ForQuestionAnswering;
P.DebertaV2ForSequenceClassification;
P.DebertaV2ForTokenClassification;
P.DebertaV2Model;
P.DebertaV2PreTrainedModel;
P.DebertaV2Tokenizer;
P.DeiTFeatureExtractor;
P.DeiTForImageClassification;
P.DeiTModel;
P.DeiTPreTrainedModel;
P.DepthAnythingForDepthEstimation;
P.DepthAnythingPreTrainedModel;
P.DepthEstimationPipeline;
P.DetrFeatureExtractor;
P.DetrForObjectDetection;
P.DetrForSegmentation;
P.DetrModel;
P.DetrObjectDetectionOutput;
P.DetrPreTrainedModel;
P.DetrSegmentationOutput;
P.Dinov2ForImageClassification;
P.Dinov2Model;
P.Dinov2PreTrainedModel;
P.DistilBertForMaskedLM;
P.DistilBertForQuestionAnswering;
P.DistilBertForSequenceClassification;
P.DistilBertForTokenClassification;
P.DistilBertModel;
P.DistilBertPreTrainedModel;
P.DistilBertTokenizer;
P.DocumentQuestionAnsweringPipeline;
P.DonutFeatureExtractor;
P.DonutSwinModel;
P.DonutSwinPreTrainedModel;
P.EfficientNetForImageClassification;
P.EfficientNetImageProcessor;
P.EfficientNetModel;
P.EfficientNetPreTrainedModel;
P.ElectraForMaskedLM;
P.ElectraForQuestionAnswering;
P.ElectraForSequenceClassification;
P.ElectraForTokenClassification;
P.ElectraModel;
P.ElectraPreTrainedModel;
P.ElectraTokenizer;
P.EosTokenCriteria;
P.EsmForMaskedLM;
P.EsmForSequenceClassification;
P.EsmForTokenClassification;
P.EsmModel;
P.EsmPreTrainedModel;
P.EsmTokenizer;
P.FFT;
P.FalconForCausalLM;
P.FalconModel;
P.FalconPreTrainedModel;
P.FalconTokenizer;
P.FastViTForImageClassification;
P.FastViTModel;
P.FastViTPreTrainedModel;
P.FeatureExtractionPipeline;
P.FeatureExtractor;
P.FillMaskPipeline;
P.Florence2ForConditionalGeneration;
P.Florence2PreTrainedModel;
P.Florence2Processor;
P.GLPNFeatureExtractor;
P.GLPNForDepthEstimation;
P.GLPNModel;
P.GLPNPreTrainedModel;
P.GPT2LMHeadModel;
P.GPT2Model;
P.GPT2PreTrainedModel;
P.GPT2Tokenizer;
P.GPTBigCodeForCausalLM;
P.GPTBigCodeModel;
P.GPTBigCodePreTrainedModel;
P.GPTJForCausalLM;
P.GPTJModel;
P.GPTJPreTrainedModel;
P.GPTNeoForCausalLM;
P.GPTNeoModel;
P.GPTNeoPreTrainedModel;
P.GPTNeoXForCausalLM;
P.GPTNeoXModel;
P.GPTNeoXPreTrainedModel;
P.GPTNeoXTokenizer;
P.Gemma2ForCausalLM;
P.Gemma2Model;
P.Gemma2PreTrainedModel;
P.GemmaForCausalLM;
P.GemmaModel;
P.GemmaPreTrainedModel;
P.GemmaTokenizer;
P.Grok1Tokenizer;
P.HerbertTokenizer;
P.HubertForCTC;
P.HubertForSequenceClassification;
P.HubertModel;
P.HubertPreTrainedModel;
P.ImageClassificationPipeline;
P.ImageFeatureExtractionPipeline;
P.ImageFeatureExtractor;
P.ImageMattingOutput;
P.ImageSegmentationPipeline;
P.ImageToImagePipeline;
P.ImageToTextPipeline;
P.InterruptableStoppingCriteria;
P.JAISLMHeadModel;
P.JAISModel;
P.JAISPreTrainedModel;
P.LlamaForCausalLM;
P.LlamaModel;
P.LlamaPreTrainedModel;
P.LlamaTokenizer;
P.LlavaForConditionalGeneration;
P.LlavaPreTrainedModel;
P.LongT5ForConditionalGeneration;
P.LongT5Model;
P.LongT5PreTrainedModel;
P.M2M100ForConditionalGeneration;
P.M2M100Model;
P.M2M100PreTrainedModel;
P.M2M100Tokenizer;
P.MBart50Tokenizer;
P.MBartForCausalLM;
P.MBartForConditionalGeneration;
P.MBartForSequenceClassification;
P.MBartModel;
P.MBartPreTrainedModel;
P.MBartTokenizer;
P.MPNetForMaskedLM;
P.MPNetForQuestionAnswering;
P.MPNetForSequenceClassification;
P.MPNetForTokenClassification;
P.MPNetModel;
P.MPNetPreTrainedModel;
P.MPNetTokenizer;
P.MT5ForConditionalGeneration;
P.MT5Model;
P.MT5PreTrainedModel;
P.MarianMTModel;
P.MarianModel;
P.MarianPreTrainedModel;
P.MarianTokenizer;
P.MaskedLMOutput;
P.MaxLengthCriteria;
P.MistralForCausalLM;
P.MistralModel;
P.MistralPreTrainedModel;
P.MobileBertForMaskedLM;
P.MobileBertForQuestionAnswering;
P.MobileBertForSequenceClassification;
P.MobileBertModel;
P.MobileBertPreTrainedModel;
P.MobileBertTokenizer;
P.MobileNetV1FeatureExtractor;
P.MobileNetV1ForImageClassification;
P.MobileNetV1Model;
P.MobileNetV1PreTrainedModel;
P.MobileNetV2FeatureExtractor;
P.MobileNetV2ForImageClassification;
P.MobileNetV2Model;
P.MobileNetV2PreTrainedModel;
P.MobileNetV3FeatureExtractor;
P.MobileNetV3ForImageClassification;
P.MobileNetV3Model;
P.MobileNetV3PreTrainedModel;
P.MobileNetV4FeatureExtractor;
P.MobileNetV4ForImageClassification;
P.MobileNetV4Model;
P.MobileNetV4PreTrainedModel;
P.MobileViTFeatureExtractor;
P.MobileViTForImageClassification;
P.MobileViTImageProcessor;
P.MobileViTModel;
P.MobileViTPreTrainedModel;
P.MobileViTV2ForImageClassification;
P.MobileViTV2Model;
P.MobileViTV2PreTrainedModel;
P.ModelOutput;
P.Moondream1ForConditionalGeneration;
P.MptForCausalLM;
P.MptModel;
P.MptPreTrainedModel;
P.MusicgenForCausalLM;
P.MusicgenForConditionalGeneration;
P.MusicgenModel;
P.MusicgenPreTrainedModel;
P.NllbTokenizer;
P.NomicBertModel;
P.NomicBertPreTrainedModel;
P.NougatImageProcessor;
P.NougatTokenizer;
P.OPTForCausalLM;
P.OPTModel;
P.OPTPreTrainedModel;
P.ObjectDetectionPipeline;
P.OpenELMForCausalLM;
P.OpenELMModel;
P.OpenELMPreTrainedModel;
P.OwlViTFeatureExtractor;
P.OwlViTForObjectDetection;
P.OwlViTModel;
P.OwlViTPreTrainedModel;
P.OwlViTProcessor;
P.Owlv2ForObjectDetection;
P.Owlv2ImageProcessor;
P.Owlv2Model;
P.Owlv2PreTrainedModel;
P.Phi3ForCausalLM;
P.Phi3Model;
P.Phi3PreTrainedModel;
P.PhiForCausalLM;
P.PhiModel;
P.PhiPreTrainedModel;
P.Pipeline;
P.PreTrainedModel;
P.PreTrainedTokenizer;
P.PretrainedConfig;
P.PretrainedMixin;
P.Processor;
P.PyAnnoteFeatureExtractor;
P.PyAnnoteForAudioFrameClassification;
P.PyAnnoteModel;
P.PyAnnotePreTrainedModel;
P.PyAnnoteProcessor;
P.QuestionAnsweringModelOutput;
P.QuestionAnsweringPipeline;
P.Qwen2ForCausalLM;
P.Qwen2Model;
P.Qwen2PreTrainedModel;
P.Qwen2Tokenizer;
P.RTDetrForObjectDetection;
P.RTDetrImageProcessor;
P.RTDetrModel;
P.RTDetrObjectDetectionOutput;
P.RTDetrPreTrainedModel;
var V1 = P.RawImage;
P.ResNetForImageClassification;
P.ResNetModel;
P.ResNetPreTrainedModel;
P.RoFormerForMaskedLM;
P.RoFormerForQuestionAnswering;
P.RoFormerForSequenceClassification;
P.RoFormerForTokenClassification;
P.RoFormerModel;
P.RoFormerPreTrainedModel;
P.RoFormerTokenizer;
P.RobertaForMaskedLM;
P.RobertaForQuestionAnswering;
P.RobertaForSequenceClassification;
P.RobertaForTokenClassification;
P.RobertaModel;
P.RobertaPreTrainedModel;
P.RobertaTokenizer;
P.SamImageProcessor;
P.SamImageSegmentationOutput;
P.SamModel;
P.SamPreTrainedModel;
P.SamProcessor;
P.SapiensFeatureExtractor;
P.SapiensForDepthEstimation;
P.SapiensForNormalEstimation;
P.SapiensForSemanticSegmentation;
P.SapiensPreTrainedModel;
P.SeamlessM4TFeatureExtractor;
P.SegformerFeatureExtractor;
P.SegformerForImageClassification;
P.SegformerForSemanticSegmentation;
P.SegformerModel;
P.SegformerPreTrainedModel;
P.Seq2SeqLMOutput;
P.SequenceClassifierOutput;
P.SiglipImageProcessor;
P.SiglipModel;
P.SiglipPreTrainedModel;
P.SiglipTextModel;
P.SiglipTokenizer;
P.SiglipVisionModel;
P.SpeechT5FeatureExtractor;
P.SpeechT5ForSpeechToText;
P.SpeechT5ForTextToSpeech;
P.SpeechT5HifiGan;
P.SpeechT5Model;
P.SpeechT5PreTrainedModel;
P.SpeechT5Processor;
P.SpeechT5Tokenizer;
P.SqueezeBertForMaskedLM;
P.SqueezeBertForQuestionAnswering;
P.SqueezeBertForSequenceClassification;
P.SqueezeBertModel;
P.SqueezeBertPreTrainedModel;
P.SqueezeBertTokenizer;
P.StableLmForCausalLM;
P.StableLmModel;
P.StableLmPreTrainedModel;
P.Starcoder2ForCausalLM;
P.Starcoder2Model;
P.Starcoder2PreTrainedModel;
P.StoppingCriteria;
P.StoppingCriteriaList;
P.SummarizationPipeline;
P.Swin2SRForImageSuperResolution;
P.Swin2SRImageProcessor;
P.Swin2SRModel;
P.Swin2SRPreTrainedModel;
P.SwinForImageClassification;
P.SwinModel;
P.SwinPreTrainedModel;
P.T5ForConditionalGeneration;
P.T5Model;
P.T5PreTrainedModel;
P.T5Tokenizer;
P.TableTransformerForObjectDetection;
P.TableTransformerModel;
P.TableTransformerObjectDetectionOutput;
P.TableTransformerPreTrainedModel;
P.Tensor;
P.Text2TextGenerationPipeline;
P.TextClassificationPipeline;
P.TextGenerationPipeline;
P.TextStreamer;
P.TextToAudioPipeline;
P.TokenClassificationPipeline;
P.TokenClassifierOutput;
P.TokenizerModel;
P.TrOCRForCausalLM;
P.TrOCRPreTrainedModel;
P.TranslationPipeline;
P.UniSpeechForCTC;
P.UniSpeechForSequenceClassification;
P.UniSpeechModel;
P.UniSpeechPreTrainedModel;
P.UniSpeechSatForAudioFrameClassification;
P.UniSpeechSatForCTC;
P.UniSpeechSatForSequenceClassification;
P.UniSpeechSatModel;
P.UniSpeechSatPreTrainedModel;
P.ViTFeatureExtractor;
P.ViTForImageClassification;
P.ViTImageProcessor;
P.ViTModel;
P.ViTPreTrainedModel;
P.VisionEncoderDecoderModel;
P.VitMatteForImageMatting;
P.VitMatteImageProcessor;
P.VitMattePreTrainedModel;
P.VitsModel;
P.VitsModelOutput;
P.VitsPreTrainedModel;
P.VitsTokenizer;
P.Wav2Vec2BertForCTC;
P.Wav2Vec2BertForSequenceClassification;
P.Wav2Vec2BertModel;
P.Wav2Vec2BertPreTrainedModel;
P.Wav2Vec2CTCTokenizer;
P.Wav2Vec2FeatureExtractor;
P.Wav2Vec2ForAudioFrameClassification;
P.Wav2Vec2ForCTC;
P.Wav2Vec2ForSequenceClassification;
P.Wav2Vec2Model;
P.Wav2Vec2PreTrainedModel;
P.Wav2Vec2ProcessorWithLM;
P.WavLMForAudioFrameClassification;
P.WavLMForCTC;
P.WavLMForSequenceClassification;
P.WavLMForXVector;
P.WavLMModel;
P.WavLMPreTrainedModel;
P.WeSpeakerFeatureExtractor;
P.WeSpeakerResNetModel;
P.WeSpeakerResNetPreTrainedModel;
P.WhisperFeatureExtractor;
P.WhisperForConditionalGeneration;
P.WhisperModel;
P.WhisperPreTrainedModel;
P.WhisperProcessor;
P.WhisperTextStreamer;
P.WhisperTokenizer;
P.XLMForQuestionAnswering;
P.XLMForSequenceClassification;
P.XLMForTokenClassification;
P.XLMModel;
P.XLMPreTrainedModel;
P.XLMRobertaForMaskedLM;
P.XLMRobertaForQuestionAnswering;
P.XLMRobertaForSequenceClassification;
P.XLMRobertaForTokenClassification;
P.XLMRobertaModel;
P.XLMRobertaPreTrainedModel;
P.XLMRobertaTokenizer;
P.XLMTokenizer;
P.XLMWithLMHeadModel;
P.XVectorOutput;
P.YolosFeatureExtractor;
P.YolosForObjectDetection;
P.YolosModel;
P.YolosObjectDetectionOutput;
P.YolosPreTrainedModel;
P.ZeroShotAudioClassificationPipeline;
P.ZeroShotClassificationPipeline;
P.ZeroShotImageClassificationPipeline;
P.ZeroShotObjectDetectionPipeline;
P.bankers_round;
P.cat;
P.cos_sim;
P.dot;
P.dynamic_time_warping;
var zE = P.env;
P.full;
P.full_like;
P.getKeyValueShapes;
P.hamming;
P.hanning;
P.interpolate;
P.interpolate_4d;
P.interpolate_data;
P.is_chinese_char;
P.layer_norm;
P.log_softmax;
P.magnitude;
P.matmul;
P.max;
P.mean;
P.mean_pooling;
P.medianFilter;
P.mel_filter_bank;
P.min;
P.ones;
P.ones_like;
P.permute;
P.permute_data;
P.pipeline;
P.quantize_embeddings;
P.read_audio;
P.rfft;
P.round;
P.softmax;
P.spectrogram;
P.stack;
P.std_mean;
P.topk;
P.window_function;
P.zeros;
P.zeros_like;
function Ph(e) {
  throw new Error(
    'Could not dynamically require "' +
      e +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
  );
}
var bx = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/ (function (e, t) {
  (function (n) {
    e.exports = n();
  })(function () {
    return (function n(o, a, l) {
      function f(g, M) {
        if (!a[g]) {
          if (!o[g]) {
            var v = typeof Ph == "function" && Ph;
            if (!M && v) return v(g, !0);
            if (_) return _(g, !0);
            var C = new Error("Cannot find module '" + g + "'");
            throw ((C.code = "MODULE_NOT_FOUND"), C);
          }
          var T = (a[g] = { exports: {} });
          o[g][0].call(
            T.exports,
            function (z) {
              var $ = o[g][1][z];
              return f($ || z);
            },
            T,
            T.exports,
            n,
            o,
            a,
            l
          );
        }
        return a[g].exports;
      }
      for (var _ = typeof Ph == "function" && Ph, m = 0; m < l.length; m++)
        f(l[m]);
      return f;
    })(
      {
        1: [
          function (n, o, a) {
            var l = n("./utils"),
              f = n("./support"),
              _ =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            (a.encode = function (m) {
              for (
                var g,
                  M,
                  v,
                  C,
                  T,
                  z,
                  $,
                  S = [],
                  y = 0,
                  x = m.length,
                  I = x,
                  V = l.getTypeOf(m) !== "string";
                y < m.length;

              )
                (I = x - y),
                  (v = V
                    ? ((g = m[y++]),
                      (M = y < x ? m[y++] : 0),
                      y < x ? m[y++] : 0)
                    : ((g = m.charCodeAt(y++)),
                      (M = y < x ? m.charCodeAt(y++) : 0),
                      y < x ? m.charCodeAt(y++) : 0)),
                  (C = g >> 2),
                  (T = ((3 & g) << 4) | (M >> 4)),
                  (z = 1 < I ? ((15 & M) << 2) | (v >> 6) : 64),
                  ($ = 2 < I ? 63 & v : 64),
                  S.push(_.charAt(C) + _.charAt(T) + _.charAt(z) + _.charAt($));
              return S.join("");
            }),
              (a.decode = function (m) {
                var g,
                  M,
                  v,
                  C,
                  T,
                  z,
                  $ = 0,
                  S = 0,
                  y = "data:";
                if (m.substr(0, y.length) === y)
                  throw new Error(
                    "Invalid base64 input, it looks like a data url."
                  );
                var x,
                  I = (3 * (m = m.replace(/[^A-Za-z0-9+/=]/g, "")).length) / 4;
                if (
                  (m.charAt(m.length - 1) === _.charAt(64) && I--,
                  m.charAt(m.length - 2) === _.charAt(64) && I--,
                  I % 1 != 0)
                )
                  throw new Error("Invalid base64 input, bad content length.");
                for (
                  x = f.uint8array ? new Uint8Array(0 | I) : new Array(0 | I);
                  $ < m.length;

                )
                  (g =
                    (_.indexOf(m.charAt($++)) << 2) |
                    ((C = _.indexOf(m.charAt($++))) >> 4)),
                    (M =
                      ((15 & C) << 4) | ((T = _.indexOf(m.charAt($++))) >> 2)),
                    (v = ((3 & T) << 6) | (z = _.indexOf(m.charAt($++)))),
                    (x[S++] = g),
                    T !== 64 && (x[S++] = M),
                    z !== 64 && (x[S++] = v);
                return x;
              });
          },
          { "./support": 30, "./utils": 32 }
        ],
        2: [
          function (n, o, a) {
            var l = n("./external"),
              f = n("./stream/DataWorker"),
              _ = n("./stream/Crc32Probe"),
              m = n("./stream/DataLengthProbe");
            function g(M, v, C, T, z) {
              (this.compressedSize = M),
                (this.uncompressedSize = v),
                (this.crc32 = C),
                (this.compression = T),
                (this.compressedContent = z);
            }
            (g.prototype = {
              getContentWorker: function () {
                var M = new f(l.Promise.resolve(this.compressedContent))
                    .pipe(this.compression.uncompressWorker())
                    .pipe(new m("data_length")),
                  v = this;
                return (
                  M.on("end", function () {
                    if (this.streamInfo.data_length !== v.uncompressedSize)
                      throw new Error("Bug : uncompressed data size mismatch");
                  }),
                  M
                );
              },
              getCompressedWorker: function () {
                return new f(l.Promise.resolve(this.compressedContent))
                  .withStreamInfo("compressedSize", this.compressedSize)
                  .withStreamInfo("uncompressedSize", this.uncompressedSize)
                  .withStreamInfo("crc32", this.crc32)
                  .withStreamInfo("compression", this.compression);
              }
            }),
              (g.createWorkerFrom = function (M, v, C) {
                return M.pipe(new _())
                  .pipe(new m("uncompressedSize"))
                  .pipe(v.compressWorker(C))
                  .pipe(new m("compressedSize"))
                  .withStreamInfo("compression", v);
              }),
              (o.exports = g);
          },
          {
            "./external": 6,
            "./stream/Crc32Probe": 25,
            "./stream/DataLengthProbe": 26,
            "./stream/DataWorker": 27
          }
        ],
        3: [
          function (n, o, a) {
            var l = n("./stream/GenericWorker");
            (a.STORE = {
              magic: "\0\0",
              compressWorker: function () {
                return new l("STORE compression");
              },
              uncompressWorker: function () {
                return new l("STORE decompression");
              }
            }),
              (a.DEFLATE = n("./flate"));
          },
          { "./flate": 7, "./stream/GenericWorker": 28 }
        ],
        4: [
          function (n, o, a) {
            var l = n("./utils"),
              f = (function () {
                for (var _, m = [], g = 0; g < 256; g++) {
                  _ = g;
                  for (var M = 0; M < 8; M++)
                    _ = 1 & _ ? 3988292384 ^ (_ >>> 1) : _ >>> 1;
                  m[g] = _;
                }
                return m;
              })();
            o.exports = function (_, m) {
              return _ !== void 0 && _.length
                ? l.getTypeOf(_) !== "string"
                  ? (function (g, M, v, C) {
                      var T = f,
                        z = C + v;
                      g ^= -1;
                      for (var $ = C; $ < z; $++)
                        g = (g >>> 8) ^ T[255 & (g ^ M[$])];
                      return -1 ^ g;
                    })(0 | m, _, _.length, 0)
                  : (function (g, M, v, C) {
                      var T = f,
                        z = C + v;
                      g ^= -1;
                      for (var $ = C; $ < z; $++)
                        g = (g >>> 8) ^ T[255 & (g ^ M.charCodeAt($))];
                      return -1 ^ g;
                    })(0 | m, _, _.length, 0)
                : 0;
            };
          },
          { "./utils": 32 }
        ],
        5: [
          function (n, o, a) {
            (a.base64 = !1),
              (a.binary = !1),
              (a.dir = !1),
              (a.createFolders = !0),
              (a.date = null),
              (a.compression = null),
              (a.compressionOptions = null),
              (a.comment = null),
              (a.unixPermissions = null),
              (a.dosPermissions = null);
          },
          {}
        ],
        6: [
          function (n, o, a) {
            var l = null;
            (l = typeof Promise < "u" ? Promise : n("lie")),
              (o.exports = { Promise: l });
          },
          { lie: 37 }
        ],
        7: [
          function (n, o, a) {
            var l =
                typeof Uint8Array < "u" &&
                typeof Uint16Array < "u" &&
                typeof Uint32Array < "u",
              f = n("pako"),
              _ = n("./utils"),
              m = n("./stream/GenericWorker"),
              g = l ? "uint8array" : "array";
            function M(v, C) {
              m.call(this, "FlateWorker/" + v),
                (this._pako = null),
                (this._pakoAction = v),
                (this._pakoOptions = C),
                (this.meta = {});
            }
            (a.magic = "\b\0"),
              _.inherits(M, m),
              (M.prototype.processChunk = function (v) {
                (this.meta = v.meta),
                  this._pako === null && this._createPako(),
                  this._pako.push(_.transformTo(g, v.data), !1);
              }),
              (M.prototype.flush = function () {
                m.prototype.flush.call(this),
                  this._pako === null && this._createPako(),
                  this._pako.push([], !0);
              }),
              (M.prototype.cleanUp = function () {
                m.prototype.cleanUp.call(this), (this._pako = null);
              }),
              (M.prototype._createPako = function () {
                this._pako = new f[this._pakoAction]({
                  raw: !0,
                  level: this._pakoOptions.level || -1
                });
                var v = this;
                this._pako.onData = function (C) {
                  v.push({ data: C, meta: v.meta });
                };
              }),
              (a.compressWorker = function (v) {
                return new M("Deflate", v);
              }),
              (a.uncompressWorker = function () {
                return new M("Inflate", {});
              });
          },
          { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }
        ],
        8: [
          function (n, o, a) {
            function l(T, z) {
              var $,
                S = "";
              for ($ = 0; $ < z; $++)
                (S += String.fromCharCode(255 & T)), (T >>>= 8);
              return S;
            }
            function f(T, z, $, S, y, x) {
              var I,
                V,
                O = T.file,
                B = T.compression,
                j = x !== g.utf8encode,
                N = _.transformTo("string", x(O.name)),
                se = _.transformTo("string", g.utf8encode(O.name)),
                de = O.comment,
                Me = _.transformTo("string", x(de)),
                J = _.transformTo("string", g.utf8encode(de)),
                ye = se.length !== O.name.length,
                L = J.length !== de.length,
                Ee = "",
                Qe = "",
                _e = "",
                X = O.dir,
                oe = O.date,
                xe = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
              (z && !$) ||
                ((xe.crc32 = T.crc32),
                (xe.compressedSize = T.compressedSize),
                (xe.uncompressedSize = T.uncompressedSize));
              var Y = 0;
              z && (Y |= 8), j || (!ye && !L) || (Y |= 2048);
              var ge = 0,
                qe = 0;
              X && (ge |= 16),
                y === "UNIX"
                  ? ((qe = 798),
                    (ge |= (function (Ne, We) {
                      var st = Ne;
                      return (
                        Ne || (st = We ? 16893 : 33204), (65535 & st) << 16
                      );
                    })(O.unixPermissions, X)))
                  : ((qe = 20),
                    (ge |= (function (Ne) {
                      return 63 & (Ne || 0);
                    })(O.dosPermissions))),
                (I = oe.getUTCHours()),
                (I <<= 6),
                (I |= oe.getUTCMinutes()),
                (I <<= 5),
                (I |= oe.getUTCSeconds() / 2),
                (V = oe.getUTCFullYear() - 1980),
                (V <<= 4),
                (V |= oe.getUTCMonth() + 1),
                (V <<= 5),
                (V |= oe.getUTCDate()),
                ye &&
                  ((Qe = l(1, 1) + l(M(N), 4) + se),
                  (Ee += "up" + l(Qe.length, 2) + Qe)),
                L &&
                  ((_e = l(1, 1) + l(M(Me), 4) + J),
                  (Ee += "uc" + l(_e.length, 2) + _e));
              var Be = "";
              return (
                (Be += `
\0`),
                (Be += l(Y, 2)),
                (Be += B.magic),
                (Be += l(I, 2)),
                (Be += l(V, 2)),
                (Be += l(xe.crc32, 4)),
                (Be += l(xe.compressedSize, 4)),
                (Be += l(xe.uncompressedSize, 4)),
                (Be += l(N.length, 2)),
                (Be += l(Ee.length, 2)),
                {
                  fileRecord: v.LOCAL_FILE_HEADER + Be + N + Ee,
                  dirRecord:
                    v.CENTRAL_FILE_HEADER +
                    l(qe, 2) +
                    Be +
                    l(Me.length, 2) +
                    "\0\0\0\0" +
                    l(ge, 4) +
                    l(S, 4) +
                    N +
                    Ee +
                    Me
                }
              );
            }
            var _ = n("../utils"),
              m = n("../stream/GenericWorker"),
              g = n("../utf8"),
              M = n("../crc32"),
              v = n("../signature");
            function C(T, z, $, S) {
              m.call(this, "ZipFileWorker"),
                (this.bytesWritten = 0),
                (this.zipComment = z),
                (this.zipPlatform = $),
                (this.encodeFileName = S),
                (this.streamFiles = T),
                (this.accumulate = !1),
                (this.contentBuffer = []),
                (this.dirRecords = []),
                (this.currentSourceOffset = 0),
                (this.entriesCount = 0),
                (this.currentFile = null),
                (this._sources = []);
            }
            _.inherits(C, m),
              (C.prototype.push = function (T) {
                var z = T.meta.percent || 0,
                  $ = this.entriesCount,
                  S = this._sources.length;
                this.accumulate
                  ? this.contentBuffer.push(T)
                  : ((this.bytesWritten += T.data.length),
                    m.prototype.push.call(this, {
                      data: T.data,
                      meta: {
                        currentFile: this.currentFile,
                        percent: $ ? (z + 100 * ($ - S - 1)) / $ : 100
                      }
                    }));
              }),
              (C.prototype.openedSource = function (T) {
                (this.currentSourceOffset = this.bytesWritten),
                  (this.currentFile = T.file.name);
                var z = this.streamFiles && !T.file.dir;
                if (z) {
                  var $ = f(
                    T,
                    z,
                    !1,
                    this.currentSourceOffset,
                    this.zipPlatform,
                    this.encodeFileName
                  );
                  this.push({ data: $.fileRecord, meta: { percent: 0 } });
                } else this.accumulate = !0;
              }),
              (C.prototype.closedSource = function (T) {
                this.accumulate = !1;
                var z = this.streamFiles && !T.file.dir,
                  $ = f(
                    T,
                    z,
                    !0,
                    this.currentSourceOffset,
                    this.zipPlatform,
                    this.encodeFileName
                  );
                if ((this.dirRecords.push($.dirRecord), z))
                  this.push({
                    data: (function (S) {
                      return (
                        v.DATA_DESCRIPTOR +
                        l(S.crc32, 4) +
                        l(S.compressedSize, 4) +
                        l(S.uncompressedSize, 4)
                      );
                    })(T),
                    meta: { percent: 100 }
                  });
                else
                  for (
                    this.push({ data: $.fileRecord, meta: { percent: 0 } });
                    this.contentBuffer.length;

                  )
                    this.push(this.contentBuffer.shift());
                this.currentFile = null;
              }),
              (C.prototype.flush = function () {
                for (
                  var T = this.bytesWritten, z = 0;
                  z < this.dirRecords.length;
                  z++
                )
                  this.push({
                    data: this.dirRecords[z],
                    meta: { percent: 100 }
                  });
                var $ = this.bytesWritten - T,
                  S = (function (y, x, I, V, O) {
                    var B = _.transformTo("string", O(V));
                    return (
                      v.CENTRAL_DIRECTORY_END +
                      "\0\0\0\0" +
                      l(y, 2) +
                      l(y, 2) +
                      l(x, 4) +
                      l(I, 4) +
                      l(B.length, 2) +
                      B
                    );
                  })(
                    this.dirRecords.length,
                    $,
                    T,
                    this.zipComment,
                    this.encodeFileName
                  );
                this.push({ data: S, meta: { percent: 100 } });
              }),
              (C.prototype.prepareNextSource = function () {
                (this.previous = this._sources.shift()),
                  this.openedSource(this.previous.streamInfo),
                  this.isPaused
                    ? this.previous.pause()
                    : this.previous.resume();
              }),
              (C.prototype.registerPrevious = function (T) {
                this._sources.push(T);
                var z = this;
                return (
                  T.on("data", function ($) {
                    z.processChunk($);
                  }),
                  T.on("end", function () {
                    z.closedSource(z.previous.streamInfo),
                      z._sources.length ? z.prepareNextSource() : z.end();
                  }),
                  T.on("error", function ($) {
                    z.error($);
                  }),
                  this
                );
              }),
              (C.prototype.resume = function () {
                return (
                  !!m.prototype.resume.call(this) &&
                  (!this.previous && this._sources.length
                    ? (this.prepareNextSource(), !0)
                    : this.previous ||
                      this._sources.length ||
                      this.generatedError
                    ? void 0
                    : (this.end(), !0))
                );
              }),
              (C.prototype.error = function (T) {
                var z = this._sources;
                if (!m.prototype.error.call(this, T)) return !1;
                for (var $ = 0; $ < z.length; $++)
                  try {
                    z[$].error(T);
                  } catch {}
                return !0;
              }),
              (C.prototype.lock = function () {
                m.prototype.lock.call(this);
                for (var T = this._sources, z = 0; z < T.length; z++)
                  T[z].lock();
              }),
              (o.exports = C);
          },
          {
            "../crc32": 4,
            "../signature": 23,
            "../stream/GenericWorker": 28,
            "../utf8": 31,
            "../utils": 32
          }
        ],
        9: [
          function (n, o, a) {
            var l = n("../compressions"),
              f = n("./ZipFileWorker");
            a.generateWorker = function (_, m, g) {
              var M = new f(m.streamFiles, g, m.platform, m.encodeFileName),
                v = 0;
              try {
                _.forEach(function (C, T) {
                  v++;
                  var z = (function (x, I) {
                      var V = x || I,
                        O = l[V];
                      if (!O)
                        throw new Error(
                          V + " is not a valid compression method !"
                        );
                      return O;
                    })(T.options.compression, m.compression),
                    $ =
                      T.options.compressionOptions ||
                      m.compressionOptions ||
                      {},
                    S = T.dir,
                    y = T.date;
                  T._compressWorker(z, $)
                    .withStreamInfo("file", {
                      name: C,
                      dir: S,
                      date: y,
                      comment: T.comment || "",
                      unixPermissions: T.unixPermissions,
                      dosPermissions: T.dosPermissions
                    })
                    .pipe(M);
                }),
                  (M.entriesCount = v);
              } catch (C) {
                M.error(C);
              }
              return M;
            };
          },
          { "../compressions": 3, "./ZipFileWorker": 8 }
        ],
        10: [
          function (n, o, a) {
            function l() {
              if (!(this instanceof l)) return new l();
              if (arguments.length)
                throw new Error(
                  "The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide."
                );
              (this.files = Object.create(null)),
                (this.comment = null),
                (this.root = ""),
                (this.clone = function () {
                  var f = new l();
                  for (var _ in this)
                    typeof this[_] != "function" && (f[_] = this[_]);
                  return f;
                });
            }
            ((l.prototype = n("./object")).loadAsync = n("./load")),
              (l.support = n("./support")),
              (l.defaults = n("./defaults")),
              (l.version = "3.10.1"),
              (l.loadAsync = function (f, _) {
                return new l().loadAsync(f, _);
              }),
              (l.external = n("./external")),
              (o.exports = l);
          },
          {
            "./defaults": 5,
            "./external": 6,
            "./load": 11,
            "./object": 15,
            "./support": 30
          }
        ],
        11: [
          function (n, o, a) {
            var l = n("./utils"),
              f = n("./external"),
              _ = n("./utf8"),
              m = n("./zipEntries"),
              g = n("./stream/Crc32Probe"),
              M = n("./nodejsUtils");
            function v(C) {
              return new f.Promise(function (T, z) {
                var $ = C.decompressed.getContentWorker().pipe(new g());
                $.on("error", function (S) {
                  z(S);
                })
                  .on("end", function () {
                    $.streamInfo.crc32 !== C.decompressed.crc32
                      ? z(new Error("Corrupted zip : CRC32 mismatch"))
                      : T();
                  })
                  .resume();
              });
            }
            o.exports = function (C, T) {
              var z = this;
              return (
                (T = l.extend(T || {}, {
                  base64: !1,
                  checkCRC32: !1,
                  optimizedBinaryString: !1,
                  createFolders: !1,
                  decodeFileName: _.utf8decode
                })),
                M.isNode && M.isStream(C)
                  ? f.Promise.reject(
                      new Error(
                        "JSZip can't accept a stream when loading a zip file."
                      )
                    )
                  : l
                      .prepareContent(
                        "the loaded zip file",
                        C,
                        !0,
                        T.optimizedBinaryString,
                        T.base64
                      )
                      .then(function ($) {
                        var S = new m(T);
                        return S.load($), S;
                      })
                      .then(function ($) {
                        var S = [f.Promise.resolve($)],
                          y = $.files;
                        if (T.checkCRC32)
                          for (var x = 0; x < y.length; x++) S.push(v(y[x]));
                        return f.Promise.all(S);
                      })
                      .then(function ($) {
                        for (
                          var S = $.shift(), y = S.files, x = 0;
                          x < y.length;
                          x++
                        ) {
                          var I = y[x],
                            V = I.fileNameStr,
                            O = l.resolve(I.fileNameStr);
                          z.file(O, I.decompressed, {
                            binary: !0,
                            optimizedBinaryString: !0,
                            date: I.date,
                            dir: I.dir,
                            comment: I.fileCommentStr.length
                              ? I.fileCommentStr
                              : null,
                            unixPermissions: I.unixPermissions,
                            dosPermissions: I.dosPermissions,
                            createFolders: T.createFolders
                          }),
                            I.dir || (z.file(O).unsafeOriginalName = V);
                        }
                        return (
                          S.zipComment.length && (z.comment = S.zipComment), z
                        );
                      })
              );
            };
          },
          {
            "./external": 6,
            "./nodejsUtils": 14,
            "./stream/Crc32Probe": 25,
            "./utf8": 31,
            "./utils": 32,
            "./zipEntries": 33
          }
        ],
        12: [
          function (n, o, a) {
            var l = n("../utils"),
              f = n("../stream/GenericWorker");
            function _(m, g) {
              f.call(this, "Nodejs stream input adapter for " + m),
                (this._upstreamEnded = !1),
                this._bindStream(g);
            }
            l.inherits(_, f),
              (_.prototype._bindStream = function (m) {
                var g = this;
                (this._stream = m).pause(),
                  m
                    .on("data", function (M) {
                      g.push({ data: M, meta: { percent: 0 } });
                    })
                    .on("error", function (M) {
                      g.isPaused ? (this.generatedError = M) : g.error(M);
                    })
                    .on("end", function () {
                      g.isPaused ? (g._upstreamEnded = !0) : g.end();
                    });
              }),
              (_.prototype.pause = function () {
                return (
                  !!f.prototype.pause.call(this) && (this._stream.pause(), !0)
                );
              }),
              (_.prototype.resume = function () {
                return (
                  !!f.prototype.resume.call(this) &&
                  (this._upstreamEnded ? this.end() : this._stream.resume(), !0)
                );
              }),
              (o.exports = _);
          },
          { "../stream/GenericWorker": 28, "../utils": 32 }
        ],
        13: [
          function (n, o, a) {
            var l = n("readable-stream").Readable;
            function f(_, m, g) {
              l.call(this, m), (this._helper = _);
              var M = this;
              _.on("data", function (v, C) {
                M.push(v) || M._helper.pause(), g && g(C);
              })
                .on("error", function (v) {
                  M.emit("error", v);
                })
                .on("end", function () {
                  M.push(null);
                });
            }
            n("../utils").inherits(f, l),
              (f.prototype._read = function () {
                this._helper.resume();
              }),
              (o.exports = f);
          },
          { "../utils": 32, "readable-stream": 16 }
        ],
        14: [
          function (n, o, a) {
            o.exports = {
              isNode: typeof Buffer < "u",
              newBufferFrom: function (l, f) {
                if (Buffer.from && Buffer.from !== Uint8Array.from)
                  return Buffer.from(l, f);
                if (typeof l == "number")
                  throw new Error('The "data" argument must not be a number');
                return new Buffer(l, f);
              },
              allocBuffer: function (l) {
                if (Buffer.alloc) return Buffer.alloc(l);
                var f = new Buffer(l);
                return f.fill(0), f;
              },
              isBuffer: function (l) {
                return Buffer.isBuffer(l);
              },
              isStream: function (l) {
                return (
                  l &&
                  typeof l.on == "function" &&
                  typeof l.pause == "function" &&
                  typeof l.resume == "function"
                );
              }
            };
          },
          {}
        ],
        15: [
          function (n, o, a) {
            function l(O, B, j) {
              var N,
                se = _.getTypeOf(B),
                de = _.extend(j || {}, M);
              (de.date = de.date || new Date()),
                de.compression !== null &&
                  (de.compression = de.compression.toUpperCase()),
                typeof de.unixPermissions == "string" &&
                  (de.unixPermissions = parseInt(de.unixPermissions, 8)),
                de.unixPermissions &&
                  16384 & de.unixPermissions &&
                  (de.dir = !0),
                de.dosPermissions && 16 & de.dosPermissions && (de.dir = !0),
                de.dir && (O = y(O)),
                de.createFolders && (N = S(O)) && x.call(this, N, !0);
              var Me = se === "string" && de.binary === !1 && de.base64 === !1;
              (j && j.binary !== void 0) || (de.binary = !Me),
                ((B instanceof v && B.uncompressedSize === 0) ||
                  de.dir ||
                  !B ||
                  B.length === 0) &&
                  ((de.base64 = !1),
                  (de.binary = !0),
                  (B = ""),
                  (de.compression = "STORE"),
                  (se = "string"));
              var J = null;
              J =
                B instanceof v || B instanceof m
                  ? B
                  : z.isNode && z.isStream(B)
                  ? new $(O, B)
                  : _.prepareContent(
                      O,
                      B,
                      de.binary,
                      de.optimizedBinaryString,
                      de.base64
                    );
              var ye = new C(O, J, de);
              this.files[O] = ye;
            }
            var f = n("./utf8"),
              _ = n("./utils"),
              m = n("./stream/GenericWorker"),
              g = n("./stream/StreamHelper"),
              M = n("./defaults"),
              v = n("./compressedObject"),
              C = n("./zipObject"),
              T = n("./generate"),
              z = n("./nodejsUtils"),
              $ = n("./nodejs/NodejsStreamInputAdapter"),
              S = function (O) {
                O.slice(-1) === "/" && (O = O.substring(0, O.length - 1));
                var B = O.lastIndexOf("/");
                return 0 < B ? O.substring(0, B) : "";
              },
              y = function (O) {
                return O.slice(-1) !== "/" && (O += "/"), O;
              },
              x = function (O, B) {
                return (
                  (B = B !== void 0 ? B : M.createFolders),
                  (O = y(O)),
                  this.files[O] ||
                    l.call(this, O, null, { dir: !0, createFolders: B }),
                  this.files[O]
                );
              };
            function I(O) {
              return Object.prototype.toString.call(O) === "[object RegExp]";
            }
            var V = {
              load: function () {
                throw new Error(
                  "This method has been removed in JSZip 3.0, please check the upgrade guide."
                );
              },
              forEach: function (O) {
                var B, j, N;
                for (B in this.files)
                  (N = this.files[B]),
                    (j = B.slice(this.root.length, B.length)) &&
                      B.slice(0, this.root.length) === this.root &&
                      O(j, N);
              },
              filter: function (O) {
                var B = [];
                return (
                  this.forEach(function (j, N) {
                    O(j, N) && B.push(N);
                  }),
                  B
                );
              },
              file: function (O, B, j) {
                if (arguments.length !== 1)
                  return (O = this.root + O), l.call(this, O, B, j), this;
                if (I(O)) {
                  var N = O;
                  return this.filter(function (de, Me) {
                    return !Me.dir && N.test(de);
                  });
                }
                var se = this.files[this.root + O];
                return se && !se.dir ? se : null;
              },
              folder: function (O) {
                if (!O) return this;
                if (I(O))
                  return this.filter(function (se, de) {
                    return de.dir && O.test(se);
                  });
                var B = this.root + O,
                  j = x.call(this, B),
                  N = this.clone();
                return (N.root = j.name), N;
              },
              remove: function (O) {
                O = this.root + O;
                var B = this.files[O];
                if (
                  (B ||
                    (O.slice(-1) !== "/" && (O += "/"), (B = this.files[O])),
                  B && !B.dir)
                )
                  delete this.files[O];
                else
                  for (
                    var j = this.filter(function (se, de) {
                        return de.name.slice(0, O.length) === O;
                      }),
                      N = 0;
                    N < j.length;
                    N++
                  )
                    delete this.files[j[N].name];
                return this;
              },
              generate: function () {
                throw new Error(
                  "This method has been removed in JSZip 3.0, please check the upgrade guide."
                );
              },
              generateInternalStream: function (O) {
                var B,
                  j = {};
                try {
                  if (
                    (((j = _.extend(O || {}, {
                      streamFiles: !1,
                      compression: "STORE",
                      compressionOptions: null,
                      type: "",
                      platform: "DOS",
                      comment: null,
                      mimeType: "application/zip",
                      encodeFileName: f.utf8encode
                    })).type = j.type.toLowerCase()),
                    (j.compression = j.compression.toUpperCase()),
                    j.type === "binarystring" && (j.type = "string"),
                    !j.type)
                  )
                    throw new Error("No output type specified.");
                  _.checkSupport(j.type),
                    (j.platform !== "darwin" &&
                      j.platform !== "freebsd" &&
                      j.platform !== "linux" &&
                      j.platform !== "sunos") ||
                      (j.platform = "UNIX"),
                    j.platform === "win32" && (j.platform = "DOS");
                  var N = j.comment || this.comment || "";
                  B = T.generateWorker(this, j, N);
                } catch (se) {
                  (B = new m("error")).error(se);
                }
                return new g(B, j.type || "string", j.mimeType);
              },
              generateAsync: function (O, B) {
                return this.generateInternalStream(O).accumulate(B);
              },
              generateNodeStream: function (O, B) {
                return (
                  (O = O || {}).type || (O.type = "nodebuffer"),
                  this.generateInternalStream(O).toNodejsStream(B)
                );
              }
            };
            o.exports = V;
          },
          {
            "./compressedObject": 2,
            "./defaults": 5,
            "./generate": 9,
            "./nodejs/NodejsStreamInputAdapter": 12,
            "./nodejsUtils": 14,
            "./stream/GenericWorker": 28,
            "./stream/StreamHelper": 29,
            "./utf8": 31,
            "./utils": 32,
            "./zipObject": 35
          }
        ],
        16: [
          function (n, o, a) {
            o.exports = n("stream");
          },
          { stream: void 0 }
        ],
        17: [
          function (n, o, a) {
            var l = n("./DataReader");
            function f(_) {
              l.call(this, _);
              for (var m = 0; m < this.data.length; m++) _[m] = 255 & _[m];
            }
            n("../utils").inherits(f, l),
              (f.prototype.byteAt = function (_) {
                return this.data[this.zero + _];
              }),
              (f.prototype.lastIndexOfSignature = function (_) {
                for (
                  var m = _.charCodeAt(0),
                    g = _.charCodeAt(1),
                    M = _.charCodeAt(2),
                    v = _.charCodeAt(3),
                    C = this.length - 4;
                  0 <= C;
                  --C
                )
                  if (
                    this.data[C] === m &&
                    this.data[C + 1] === g &&
                    this.data[C + 2] === M &&
                    this.data[C + 3] === v
                  )
                    return C - this.zero;
                return -1;
              }),
              (f.prototype.readAndCheckSignature = function (_) {
                var m = _.charCodeAt(0),
                  g = _.charCodeAt(1),
                  M = _.charCodeAt(2),
                  v = _.charCodeAt(3),
                  C = this.readData(4);
                return m === C[0] && g === C[1] && M === C[2] && v === C[3];
              }),
              (f.prototype.readData = function (_) {
                if ((this.checkOffset(_), _ === 0)) return [];
                var m = this.data.slice(
                  this.zero + this.index,
                  this.zero + this.index + _
                );
                return (this.index += _), m;
              }),
              (o.exports = f);
          },
          { "../utils": 32, "./DataReader": 18 }
        ],
        18: [
          function (n, o, a) {
            var l = n("../utils");
            function f(_) {
              (this.data = _),
                (this.length = _.length),
                (this.index = 0),
                (this.zero = 0);
            }
            (f.prototype = {
              checkOffset: function (_) {
                this.checkIndex(this.index + _);
              },
              checkIndex: function (_) {
                if (this.length < this.zero + _ || _ < 0)
                  throw new Error(
                    "End of data reached (data length = " +
                      this.length +
                      ", asked index = " +
                      _ +
                      "). Corrupted zip ?"
                  );
              },
              setIndex: function (_) {
                this.checkIndex(_), (this.index = _);
              },
              skip: function (_) {
                this.setIndex(this.index + _);
              },
              byteAt: function () {},
              readInt: function (_) {
                var m,
                  g = 0;
                for (
                  this.checkOffset(_), m = this.index + _ - 1;
                  m >= this.index;
                  m--
                )
                  g = (g << 8) + this.byteAt(m);
                return (this.index += _), g;
              },
              readString: function (_) {
                return l.transformTo("string", this.readData(_));
              },
              readData: function () {},
              lastIndexOfSignature: function () {},
              readAndCheckSignature: function () {},
              readDate: function () {
                var _ = this.readInt(4);
                return new Date(
                  Date.UTC(
                    1980 + ((_ >> 25) & 127),
                    ((_ >> 21) & 15) - 1,
                    (_ >> 16) & 31,
                    (_ >> 11) & 31,
                    (_ >> 5) & 63,
                    (31 & _) << 1
                  )
                );
              }
            }),
              (o.exports = f);
          },
          { "../utils": 32 }
        ],
        19: [
          function (n, o, a) {
            var l = n("./Uint8ArrayReader");
            function f(_) {
              l.call(this, _);
            }
            n("../utils").inherits(f, l),
              (f.prototype.readData = function (_) {
                this.checkOffset(_);
                var m = this.data.slice(
                  this.zero + this.index,
                  this.zero + this.index + _
                );
                return (this.index += _), m;
              }),
              (o.exports = f);
          },
          { "../utils": 32, "./Uint8ArrayReader": 21 }
        ],
        20: [
          function (n, o, a) {
            var l = n("./DataReader");
            function f(_) {
              l.call(this, _);
            }
            n("../utils").inherits(f, l),
              (f.prototype.byteAt = function (_) {
                return this.data.charCodeAt(this.zero + _);
              }),
              (f.prototype.lastIndexOfSignature = function (_) {
                return this.data.lastIndexOf(_) - this.zero;
              }),
              (f.prototype.readAndCheckSignature = function (_) {
                return _ === this.readData(4);
              }),
              (f.prototype.readData = function (_) {
                this.checkOffset(_);
                var m = this.data.slice(
                  this.zero + this.index,
                  this.zero + this.index + _
                );
                return (this.index += _), m;
              }),
              (o.exports = f);
          },
          { "../utils": 32, "./DataReader": 18 }
        ],
        21: [
          function (n, o, a) {
            var l = n("./ArrayReader");
            function f(_) {
              l.call(this, _);
            }
            n("../utils").inherits(f, l),
              (f.prototype.readData = function (_) {
                if ((this.checkOffset(_), _ === 0)) return new Uint8Array(0);
                var m = this.data.subarray(
                  this.zero + this.index,
                  this.zero + this.index + _
                );
                return (this.index += _), m;
              }),
              (o.exports = f);
          },
          { "../utils": 32, "./ArrayReader": 17 }
        ],
        22: [
          function (n, o, a) {
            var l = n("../utils"),
              f = n("../support"),
              _ = n("./ArrayReader"),
              m = n("./StringReader"),
              g = n("./NodeBufferReader"),
              M = n("./Uint8ArrayReader");
            o.exports = function (v) {
              var C = l.getTypeOf(v);
              return (
                l.checkSupport(C),
                C !== "string" || f.uint8array
                  ? C === "nodebuffer"
                    ? new g(v)
                    : f.uint8array
                    ? new M(l.transformTo("uint8array", v))
                    : new _(l.transformTo("array", v))
                  : new m(v)
              );
            };
          },
          {
            "../support": 30,
            "../utils": 32,
            "./ArrayReader": 17,
            "./NodeBufferReader": 19,
            "./StringReader": 20,
            "./Uint8ArrayReader": 21
          }
        ],
        23: [
          function (n, o, a) {
            (a.LOCAL_FILE_HEADER = "PK"),
              (a.CENTRAL_FILE_HEADER = "PK"),
              (a.CENTRAL_DIRECTORY_END = "PK"),
              (a.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07"),
              (a.ZIP64_CENTRAL_DIRECTORY_END = "PK"),
              (a.DATA_DESCRIPTOR = "PK\x07\b");
          },
          {}
        ],
        24: [
          function (n, o, a) {
            var l = n("./GenericWorker"),
              f = n("../utils");
            function _(m) {
              l.call(this, "ConvertWorker to " + m), (this.destType = m);
            }
            f.inherits(_, l),
              (_.prototype.processChunk = function (m) {
                this.push({
                  data: f.transformTo(this.destType, m.data),
                  meta: m.meta
                });
              }),
              (o.exports = _);
          },
          { "../utils": 32, "./GenericWorker": 28 }
        ],
        25: [
          function (n, o, a) {
            var l = n("./GenericWorker"),
              f = n("../crc32");
            function _() {
              l.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
            }
            n("../utils").inherits(_, l),
              (_.prototype.processChunk = function (m) {
                (this.streamInfo.crc32 = f(m.data, this.streamInfo.crc32 || 0)),
                  this.push(m);
              }),
              (o.exports = _);
          },
          { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }
        ],
        26: [
          function (n, o, a) {
            var l = n("../utils"),
              f = n("./GenericWorker");
            function _(m) {
              f.call(this, "DataLengthProbe for " + m),
                (this.propName = m),
                this.withStreamInfo(m, 0);
            }
            l.inherits(_, f),
              (_.prototype.processChunk = function (m) {
                if (m) {
                  var g = this.streamInfo[this.propName] || 0;
                  this.streamInfo[this.propName] = g + m.data.length;
                }
                f.prototype.processChunk.call(this, m);
              }),
              (o.exports = _);
          },
          { "../utils": 32, "./GenericWorker": 28 }
        ],
        27: [
          function (n, o, a) {
            var l = n("../utils"),
              f = n("./GenericWorker");
            function _(m) {
              f.call(this, "DataWorker");
              var g = this;
              (this.dataIsReady = !1),
                (this.index = 0),
                (this.max = 0),
                (this.data = null),
                (this.type = ""),
                (this._tickScheduled = !1),
                m.then(
                  function (M) {
                    (g.dataIsReady = !0),
                      (g.data = M),
                      (g.max = (M && M.length) || 0),
                      (g.type = l.getTypeOf(M)),
                      g.isPaused || g._tickAndRepeat();
                  },
                  function (M) {
                    g.error(M);
                  }
                );
            }
            l.inherits(_, f),
              (_.prototype.cleanUp = function () {
                f.prototype.cleanUp.call(this), (this.data = null);
              }),
              (_.prototype.resume = function () {
                return (
                  !!f.prototype.resume.call(this) &&
                  (!this._tickScheduled &&
                    this.dataIsReady &&
                    ((this._tickScheduled = !0),
                    l.delay(this._tickAndRepeat, [], this)),
                  !0)
                );
              }),
              (_.prototype._tickAndRepeat = function () {
                (this._tickScheduled = !1),
                  this.isPaused ||
                    this.isFinished ||
                    (this._tick(),
                    this.isFinished ||
                      (l.delay(this._tickAndRepeat, [], this),
                      (this._tickScheduled = !0)));
              }),
              (_.prototype._tick = function () {
                if (this.isPaused || this.isFinished) return !1;
                var m = null,
                  g = Math.min(this.max, this.index + 16384);
                if (this.index >= this.max) return this.end();
                switch (this.type) {
                  case "string":
                    m = this.data.substring(this.index, g);
                    break;
                  case "uint8array":
                    m = this.data.subarray(this.index, g);
                    break;
                  case "array":
                  case "nodebuffer":
                    m = this.data.slice(this.index, g);
                }
                return (
                  (this.index = g),
                  this.push({
                    data: m,
                    meta: {
                      percent: this.max ? (this.index / this.max) * 100 : 0
                    }
                  })
                );
              }),
              (o.exports = _);
          },
          { "../utils": 32, "./GenericWorker": 28 }
        ],
        28: [
          function (n, o, a) {
            function l(f) {
              (this.name = f || "default"),
                (this.streamInfo = {}),
                (this.generatedError = null),
                (this.extraStreamInfo = {}),
                (this.isPaused = !0),
                (this.isFinished = !1),
                (this.isLocked = !1),
                (this._listeners = { data: [], end: [], error: [] }),
                (this.previous = null);
            }
            (l.prototype = {
              push: function (f) {
                this.emit("data", f);
              },
              end: function () {
                if (this.isFinished) return !1;
                this.flush();
                try {
                  this.emit("end"), this.cleanUp(), (this.isFinished = !0);
                } catch (f) {
                  this.emit("error", f);
                }
                return !0;
              },
              error: function (f) {
                return (
                  !this.isFinished &&
                  (this.isPaused
                    ? (this.generatedError = f)
                    : ((this.isFinished = !0),
                      this.emit("error", f),
                      this.previous && this.previous.error(f),
                      this.cleanUp()),
                  !0)
                );
              },
              on: function (f, _) {
                return this._listeners[f].push(_), this;
              },
              cleanUp: function () {
                (this.streamInfo =
                  this.generatedError =
                  this.extraStreamInfo =
                    null),
                  (this._listeners = []);
              },
              emit: function (f, _) {
                if (this._listeners[f])
                  for (var m = 0; m < this._listeners[f].length; m++)
                    this._listeners[f][m].call(this, _);
              },
              pipe: function (f) {
                return f.registerPrevious(this);
              },
              registerPrevious: function (f) {
                if (this.isLocked)
                  throw new Error(
                    "The stream '" + this + "' has already been used."
                  );
                (this.streamInfo = f.streamInfo),
                  this.mergeStreamInfo(),
                  (this.previous = f);
                var _ = this;
                return (
                  f.on("data", function (m) {
                    _.processChunk(m);
                  }),
                  f.on("end", function () {
                    _.end();
                  }),
                  f.on("error", function (m) {
                    _.error(m);
                  }),
                  this
                );
              },
              pause: function () {
                return (
                  !this.isPaused &&
                  !this.isFinished &&
                  ((this.isPaused = !0),
                  this.previous && this.previous.pause(),
                  !0)
                );
              },
              resume: function () {
                if (!this.isPaused || this.isFinished) return !1;
                var f = (this.isPaused = !1);
                return (
                  this.generatedError &&
                    (this.error(this.generatedError), (f = !0)),
                  this.previous && this.previous.resume(),
                  !f
                );
              },
              flush: function () {},
              processChunk: function (f) {
                this.push(f);
              },
              withStreamInfo: function (f, _) {
                return (
                  (this.extraStreamInfo[f] = _), this.mergeStreamInfo(), this
                );
              },
              mergeStreamInfo: function () {
                for (var f in this.extraStreamInfo)
                  Object.prototype.hasOwnProperty.call(
                    this.extraStreamInfo,
                    f
                  ) && (this.streamInfo[f] = this.extraStreamInfo[f]);
              },
              lock: function () {
                if (this.isLocked)
                  throw new Error(
                    "The stream '" + this + "' has already been used."
                  );
                (this.isLocked = !0), this.previous && this.previous.lock();
              },
              toString: function () {
                var f = "Worker " + this.name;
                return this.previous ? this.previous + " -> " + f : f;
              }
            }),
              (o.exports = l);
          },
          {}
        ],
        29: [
          function (n, o, a) {
            var l = n("../utils"),
              f = n("./ConvertWorker"),
              _ = n("./GenericWorker"),
              m = n("../base64"),
              g = n("../support"),
              M = n("../external"),
              v = null;
            if (g.nodestream)
              try {
                v = n("../nodejs/NodejsStreamOutputAdapter");
              } catch {}
            function C(z, $) {
              return new M.Promise(function (S, y) {
                var x = [],
                  I = z._internalType,
                  V = z._outputType,
                  O = z._mimeType;
                z.on("data", function (B, j) {
                  x.push(B), $ && $(j);
                })
                  .on("error", function (B) {
                    (x = []), y(B);
                  })
                  .on("end", function () {
                    try {
                      var B = (function (j, N, se) {
                        switch (j) {
                          case "blob":
                            return l.newBlob(
                              l.transformTo("arraybuffer", N),
                              se
                            );
                          case "base64":
                            return m.encode(N);
                          default:
                            return l.transformTo(j, N);
                        }
                      })(
                        V,
                        (function (j, N) {
                          var se,
                            de = 0,
                            Me = null,
                            J = 0;
                          for (se = 0; se < N.length; se++) J += N[se].length;
                          switch (j) {
                            case "string":
                              return N.join("");
                            case "array":
                              return Array.prototype.concat.apply([], N);
                            case "uint8array":
                              for (
                                Me = new Uint8Array(J), se = 0;
                                se < N.length;
                                se++
                              )
                                Me.set(N[se], de), (de += N[se].length);
                              return Me;
                            case "nodebuffer":
                              return Buffer.concat(N);
                            default:
                              throw new Error(
                                "concat : unsupported type '" + j + "'"
                              );
                          }
                        })(I, x),
                        O
                      );
                      S(B);
                    } catch (j) {
                      y(j);
                    }
                    x = [];
                  })
                  .resume();
              });
            }
            function T(z, $, S) {
              var y = $;
              switch ($) {
                case "blob":
                case "arraybuffer":
                  y = "uint8array";
                  break;
                case "base64":
                  y = "string";
              }
              try {
                (this._internalType = y),
                  (this._outputType = $),
                  (this._mimeType = S),
                  l.checkSupport(y),
                  (this._worker = z.pipe(new f(y))),
                  z.lock();
              } catch (x) {
                (this._worker = new _("error")), this._worker.error(x);
              }
            }
            (T.prototype = {
              accumulate: function (z) {
                return C(this, z);
              },
              on: function (z, $) {
                var S = this;
                return (
                  z === "data"
                    ? this._worker.on(z, function (y) {
                        $.call(S, y.data, y.meta);
                      })
                    : this._worker.on(z, function () {
                        l.delay($, arguments, S);
                      }),
                  this
                );
              },
              resume: function () {
                return l.delay(this._worker.resume, [], this._worker), this;
              },
              pause: function () {
                return this._worker.pause(), this;
              },
              toNodejsStream: function (z) {
                if (
                  (l.checkSupport("nodestream"),
                  this._outputType !== "nodebuffer")
                )
                  throw new Error(
                    this._outputType + " is not supported by this method"
                  );
                return new v(
                  this,
                  { objectMode: this._outputType !== "nodebuffer" },
                  z
                );
              }
            }),
              (o.exports = T);
          },
          {
            "../base64": 1,
            "../external": 6,
            "../nodejs/NodejsStreamOutputAdapter": 13,
            "../support": 30,
            "../utils": 32,
            "./ConvertWorker": 24,
            "./GenericWorker": 28
          }
        ],
        30: [
          function (n, o, a) {
            if (
              ((a.base64 = !0),
              (a.array = !0),
              (a.string = !0),
              (a.arraybuffer =
                typeof ArrayBuffer < "u" && typeof Uint8Array < "u"),
              (a.nodebuffer = typeof Buffer < "u"),
              (a.uint8array = typeof Uint8Array < "u"),
              typeof ArrayBuffer > "u")
            )
              a.blob = !1;
            else {
              var l = new ArrayBuffer(0);
              try {
                a.blob = new Blob([l], { type: "application/zip" }).size === 0;
              } catch {
                try {
                  var f = new (self.BlobBuilder ||
                    self.WebKitBlobBuilder ||
                    self.MozBlobBuilder ||
                    self.MSBlobBuilder)();
                  f.append(l),
                    (a.blob = f.getBlob("application/zip").size === 0);
                } catch {
                  a.blob = !1;
                }
              }
            }
            try {
              a.nodestream = !!n("readable-stream").Readable;
            } catch {
              a.nodestream = !1;
            }
          },
          { "readable-stream": 16 }
        ],
        31: [
          function (n, o, a) {
            for (
              var l = n("./utils"),
                f = n("./support"),
                _ = n("./nodejsUtils"),
                m = n("./stream/GenericWorker"),
                g = new Array(256),
                M = 0;
              M < 256;
              M++
            )
              g[M] =
                252 <= M
                  ? 6
                  : 248 <= M
                  ? 5
                  : 240 <= M
                  ? 4
                  : 224 <= M
                  ? 3
                  : 192 <= M
                  ? 2
                  : 1;
            g[254] = g[254] = 1;
            function v() {
              m.call(this, "utf-8 decode"), (this.leftOver = null);
            }
            function C() {
              m.call(this, "utf-8 encode");
            }
            (a.utf8encode = function (T) {
              return f.nodebuffer
                ? _.newBufferFrom(T, "utf-8")
                : (function (z) {
                    var $,
                      S,
                      y,
                      x,
                      I,
                      V = z.length,
                      O = 0;
                    for (x = 0; x < V; x++)
                      (64512 & (S = z.charCodeAt(x))) == 55296 &&
                        x + 1 < V &&
                        (64512 & (y = z.charCodeAt(x + 1))) == 56320 &&
                        ((S = 65536 + ((S - 55296) << 10) + (y - 56320)), x++),
                        (O += S < 128 ? 1 : S < 2048 ? 2 : S < 65536 ? 3 : 4);
                    for (
                      $ = f.uint8array ? new Uint8Array(O) : new Array(O),
                        x = I = 0;
                      I < O;
                      x++
                    )
                      (64512 & (S = z.charCodeAt(x))) == 55296 &&
                        x + 1 < V &&
                        (64512 & (y = z.charCodeAt(x + 1))) == 56320 &&
                        ((S = 65536 + ((S - 55296) << 10) + (y - 56320)), x++),
                        S < 128
                          ? ($[I++] = S)
                          : (S < 2048
                              ? ($[I++] = 192 | (S >>> 6))
                              : (S < 65536
                                  ? ($[I++] = 224 | (S >>> 12))
                                  : (($[I++] = 240 | (S >>> 18)),
                                    ($[I++] = 128 | ((S >>> 12) & 63))),
                                ($[I++] = 128 | ((S >>> 6) & 63))),
                            ($[I++] = 128 | (63 & S)));
                    return $;
                  })(T);
            }),
              (a.utf8decode = function (T) {
                return f.nodebuffer
                  ? l.transformTo("nodebuffer", T).toString("utf-8")
                  : (function (z) {
                      var $,
                        S,
                        y,
                        x,
                        I = z.length,
                        V = new Array(2 * I);
                      for ($ = S = 0; $ < I; )
                        if ((y = z[$++]) < 128) V[S++] = y;
                        else if (4 < (x = g[y])) (V[S++] = 65533), ($ += x - 1);
                        else {
                          for (
                            y &= x === 2 ? 31 : x === 3 ? 15 : 7;
                            1 < x && $ < I;

                          )
                            (y = (y << 6) | (63 & z[$++])), x--;
                          1 < x
                            ? (V[S++] = 65533)
                            : y < 65536
                            ? (V[S++] = y)
                            : ((y -= 65536),
                              (V[S++] = 55296 | ((y >> 10) & 1023)),
                              (V[S++] = 56320 | (1023 & y)));
                        }
                      return (
                        V.length !== S &&
                          (V.subarray
                            ? (V = V.subarray(0, S))
                            : (V.length = S)),
                        l.applyFromCharCode(V)
                      );
                    })(
                      (T = l.transformTo(
                        f.uint8array ? "uint8array" : "array",
                        T
                      ))
                    );
              }),
              l.inherits(v, m),
              (v.prototype.processChunk = function (T) {
                var z = l.transformTo(
                  f.uint8array ? "uint8array" : "array",
                  T.data
                );
                if (this.leftOver && this.leftOver.length) {
                  if (f.uint8array) {
                    var $ = z;
                    (z = new Uint8Array($.length + this.leftOver.length)).set(
                      this.leftOver,
                      0
                    ),
                      z.set($, this.leftOver.length);
                  } else z = this.leftOver.concat(z);
                  this.leftOver = null;
                }
                var S = (function (x, I) {
                    var V;
                    for (
                      (I = I || x.length) > x.length && (I = x.length),
                        V = I - 1;
                      0 <= V && (192 & x[V]) == 128;

                    )
                      V--;
                    return V < 0 || V === 0 ? I : V + g[x[V]] > I ? V : I;
                  })(z),
                  y = z;
                S !== z.length &&
                  (f.uint8array
                    ? ((y = z.subarray(0, S)),
                      (this.leftOver = z.subarray(S, z.length)))
                    : ((y = z.slice(0, S)),
                      (this.leftOver = z.slice(S, z.length)))),
                  this.push({ data: a.utf8decode(y), meta: T.meta });
              }),
              (v.prototype.flush = function () {
                this.leftOver &&
                  this.leftOver.length &&
                  (this.push({ data: a.utf8decode(this.leftOver), meta: {} }),
                  (this.leftOver = null));
              }),
              (a.Utf8DecodeWorker = v),
              l.inherits(C, m),
              (C.prototype.processChunk = function (T) {
                this.push({ data: a.utf8encode(T.data), meta: T.meta });
              }),
              (a.Utf8EncodeWorker = C);
          },
          {
            "./nodejsUtils": 14,
            "./stream/GenericWorker": 28,
            "./support": 30,
            "./utils": 32
          }
        ],
        32: [
          function (n, o, a) {
            var l = n("./support"),
              f = n("./base64"),
              _ = n("./nodejsUtils"),
              m = n("./external");
            function g($) {
              return $;
            }
            function M($, S) {
              for (var y = 0; y < $.length; ++y) S[y] = 255 & $.charCodeAt(y);
              return S;
            }
            n("setimmediate"),
              (a.newBlob = function ($, S) {
                a.checkSupport("blob");
                try {
                  return new Blob([$], { type: S });
                } catch {
                  try {
                    var y = new (self.BlobBuilder ||
                      self.WebKitBlobBuilder ||
                      self.MozBlobBuilder ||
                      self.MSBlobBuilder)();
                    return y.append($), y.getBlob(S);
                  } catch {
                    throw new Error("Bug : can't construct the Blob.");
                  }
                }
              });
            var v = {
              stringifyByChunk: function ($, S, y) {
                var x = [],
                  I = 0,
                  V = $.length;
                if (V <= y) return String.fromCharCode.apply(null, $);
                for (; I < V; )
                  S === "array" || S === "nodebuffer"
                    ? x.push(
                        String.fromCharCode.apply(
                          null,
                          $.slice(I, Math.min(I + y, V))
                        )
                      )
                    : x.push(
                        String.fromCharCode.apply(
                          null,
                          $.subarray(I, Math.min(I + y, V))
                        )
                      ),
                    (I += y);
                return x.join("");
              },
              stringifyByChar: function ($) {
                for (var S = "", y = 0; y < $.length; y++)
                  S += String.fromCharCode($[y]);
                return S;
              },
              applyCanBeUsed: {
                uint8array: (function () {
                  try {
                    return (
                      l.uint8array &&
                      String.fromCharCode.apply(null, new Uint8Array(1))
                        .length === 1
                    );
                  } catch {
                    return !1;
                  }
                })(),
                nodebuffer: (function () {
                  try {
                    return (
                      l.nodebuffer &&
                      String.fromCharCode.apply(null, _.allocBuffer(1))
                        .length === 1
                    );
                  } catch {
                    return !1;
                  }
                })()
              }
            };
            function C($) {
              var S = 65536,
                y = a.getTypeOf($),
                x = !0;
              if (
                (y === "uint8array"
                  ? (x = v.applyCanBeUsed.uint8array)
                  : y === "nodebuffer" && (x = v.applyCanBeUsed.nodebuffer),
                x)
              )
                for (; 1 < S; )
                  try {
                    return v.stringifyByChunk($, y, S);
                  } catch {
                    S = Math.floor(S / 2);
                  }
              return v.stringifyByChar($);
            }
            function T($, S) {
              for (var y = 0; y < $.length; y++) S[y] = $[y];
              return S;
            }
            a.applyFromCharCode = C;
            var z = {};
            (z.string = {
              string: g,
              array: function ($) {
                return M($, new Array($.length));
              },
              arraybuffer: function ($) {
                return z.string.uint8array($).buffer;
              },
              uint8array: function ($) {
                return M($, new Uint8Array($.length));
              },
              nodebuffer: function ($) {
                return M($, _.allocBuffer($.length));
              }
            }),
              (z.array = {
                string: C,
                array: g,
                arraybuffer: function ($) {
                  return new Uint8Array($).buffer;
                },
                uint8array: function ($) {
                  return new Uint8Array($);
                },
                nodebuffer: function ($) {
                  return _.newBufferFrom($);
                }
              }),
              (z.arraybuffer = {
                string: function ($) {
                  return C(new Uint8Array($));
                },
                array: function ($) {
                  return T(new Uint8Array($), new Array($.byteLength));
                },
                arraybuffer: g,
                uint8array: function ($) {
                  return new Uint8Array($);
                },
                nodebuffer: function ($) {
                  return _.newBufferFrom(new Uint8Array($));
                }
              }),
              (z.uint8array = {
                string: C,
                array: function ($) {
                  return T($, new Array($.length));
                },
                arraybuffer: function ($) {
                  return $.buffer;
                },
                uint8array: g,
                nodebuffer: function ($) {
                  return _.newBufferFrom($);
                }
              }),
              (z.nodebuffer = {
                string: C,
                array: function ($) {
                  return T($, new Array($.length));
                },
                arraybuffer: function ($) {
                  return z.nodebuffer.uint8array($).buffer;
                },
                uint8array: function ($) {
                  return T($, new Uint8Array($.length));
                },
                nodebuffer: g
              }),
              (a.transformTo = function ($, S) {
                if (((S = S || ""), !$)) return S;
                a.checkSupport($);
                var y = a.getTypeOf(S);
                return z[y][$](S);
              }),
              (a.resolve = function ($) {
                for (var S = $.split("/"), y = [], x = 0; x < S.length; x++) {
                  var I = S[x];
                  I === "." ||
                    (I === "" && x !== 0 && x !== S.length - 1) ||
                    (I === ".." ? y.pop() : y.push(I));
                }
                return y.join("/");
              }),
              (a.getTypeOf = function ($) {
                return typeof $ == "string"
                  ? "string"
                  : Object.prototype.toString.call($) === "[object Array]"
                  ? "array"
                  : l.nodebuffer && _.isBuffer($)
                  ? "nodebuffer"
                  : l.uint8array && $ instanceof Uint8Array
                  ? "uint8array"
                  : l.arraybuffer && $ instanceof ArrayBuffer
                  ? "arraybuffer"
                  : void 0;
              }),
              (a.checkSupport = function ($) {
                if (!l[$.toLowerCase()])
                  throw new Error($ + " is not supported by this platform");
              }),
              (a.MAX_VALUE_16BITS = 65535),
              (a.MAX_VALUE_32BITS = -1),
              (a.pretty = function ($) {
                var S,
                  y,
                  x = "";
                for (y = 0; y < ($ || "").length; y++)
                  x +=
                    "\\x" +
                    ((S = $.charCodeAt(y)) < 16 ? "0" : "") +
                    S.toString(16).toUpperCase();
                return x;
              }),
              (a.delay = function ($, S, y) {
                setImmediate(function () {
                  $.apply(y || null, S || []);
                });
              }),
              (a.inherits = function ($, S) {
                function y() {}
                (y.prototype = S.prototype), ($.prototype = new y());
              }),
              (a.extend = function () {
                var $,
                  S,
                  y = {};
                for ($ = 0; $ < arguments.length; $++)
                  for (S in arguments[$])
                    Object.prototype.hasOwnProperty.call(arguments[$], S) &&
                      y[S] === void 0 &&
                      (y[S] = arguments[$][S]);
                return y;
              }),
              (a.prepareContent = function ($, S, y, x, I) {
                return m.Promise.resolve(S)
                  .then(function (V) {
                    return l.blob &&
                      (V instanceof Blob ||
                        ["[object File]", "[object Blob]"].indexOf(
                          Object.prototype.toString.call(V)
                        ) !== -1) &&
                      typeof FileReader < "u"
                      ? new m.Promise(function (O, B) {
                          var j = new FileReader();
                          (j.onload = function (N) {
                            O(N.target.result);
                          }),
                            (j.onerror = function (N) {
                              B(N.target.error);
                            }),
                            j.readAsArrayBuffer(V);
                        })
                      : V;
                  })
                  .then(function (V) {
                    var O = a.getTypeOf(V);
                    return O
                      ? (O === "arraybuffer"
                          ? (V = a.transformTo("uint8array", V))
                          : O === "string" &&
                            (I
                              ? (V = f.decode(V))
                              : y &&
                                x !== !0 &&
                                (V = (function (B) {
                                  return M(
                                    B,
                                    l.uint8array
                                      ? new Uint8Array(B.length)
                                      : new Array(B.length)
                                  );
                                })(V))),
                        V)
                      : m.Promise.reject(
                          new Error(
                            "Can't read the data of '" +
                              $ +
                              "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"
                          )
                        );
                  });
              });
          },
          {
            "./base64": 1,
            "./external": 6,
            "./nodejsUtils": 14,
            "./support": 30,
            setimmediate: 54
          }
        ],
        33: [
          function (n, o, a) {
            var l = n("./reader/readerFor"),
              f = n("./utils"),
              _ = n("./signature"),
              m = n("./zipEntry"),
              g = n("./support");
            function M(v) {
              (this.files = []), (this.loadOptions = v);
            }
            (M.prototype = {
              checkSignature: function (v) {
                if (!this.reader.readAndCheckSignature(v)) {
                  this.reader.index -= 4;
                  var C = this.reader.readString(4);
                  throw new Error(
                    "Corrupted zip or bug: unexpected signature (" +
                      f.pretty(C) +
                      ", expected " +
                      f.pretty(v) +
                      ")"
                  );
                }
              },
              isSignature: function (v, C) {
                var T = this.reader.index;
                this.reader.setIndex(v);
                var z = this.reader.readString(4) === C;
                return this.reader.setIndex(T), z;
              },
              readBlockEndOfCentral: function () {
                (this.diskNumber = this.reader.readInt(2)),
                  (this.diskWithCentralDirStart = this.reader.readInt(2)),
                  (this.centralDirRecordsOnThisDisk = this.reader.readInt(2)),
                  (this.centralDirRecords = this.reader.readInt(2)),
                  (this.centralDirSize = this.reader.readInt(4)),
                  (this.centralDirOffset = this.reader.readInt(4)),
                  (this.zipCommentLength = this.reader.readInt(2));
                var v = this.reader.readData(this.zipCommentLength),
                  C = g.uint8array ? "uint8array" : "array",
                  T = f.transformTo(C, v);
                this.zipComment = this.loadOptions.decodeFileName(T);
              },
              readBlockZip64EndOfCentral: function () {
                (this.zip64EndOfCentralSize = this.reader.readInt(8)),
                  this.reader.skip(4),
                  (this.diskNumber = this.reader.readInt(4)),
                  (this.diskWithCentralDirStart = this.reader.readInt(4)),
                  (this.centralDirRecordsOnThisDisk = this.reader.readInt(8)),
                  (this.centralDirRecords = this.reader.readInt(8)),
                  (this.centralDirSize = this.reader.readInt(8)),
                  (this.centralDirOffset = this.reader.readInt(8)),
                  (this.zip64ExtensibleData = {});
                for (var v, C, T, z = this.zip64EndOfCentralSize - 44; 0 < z; )
                  (v = this.reader.readInt(2)),
                    (C = this.reader.readInt(4)),
                    (T = this.reader.readData(C)),
                    (this.zip64ExtensibleData[v] = {
                      id: v,
                      length: C,
                      value: T
                    });
              },
              readBlockZip64EndOfCentralLocator: function () {
                if (
                  ((this.diskWithZip64CentralDirStart = this.reader.readInt(4)),
                  (this.relativeOffsetEndOfZip64CentralDir =
                    this.reader.readInt(8)),
                  (this.disksCount = this.reader.readInt(4)),
                  1 < this.disksCount)
                )
                  throw new Error("Multi-volumes zip are not supported");
              },
              readLocalFiles: function () {
                var v, C;
                for (v = 0; v < this.files.length; v++)
                  (C = this.files[v]),
                    this.reader.setIndex(C.localHeaderOffset),
                    this.checkSignature(_.LOCAL_FILE_HEADER),
                    C.readLocalPart(this.reader),
                    C.handleUTF8(),
                    C.processAttributes();
              },
              readCentralDir: function () {
                var v;
                for (
                  this.reader.setIndex(this.centralDirOffset);
                  this.reader.readAndCheckSignature(_.CENTRAL_FILE_HEADER);

                )
                  (v = new m(
                    { zip64: this.zip64 },
                    this.loadOptions
                  )).readCentralPart(this.reader),
                    this.files.push(v);
                if (
                  this.centralDirRecords !== this.files.length &&
                  this.centralDirRecords !== 0 &&
                  this.files.length === 0
                )
                  throw new Error(
                    "Corrupted zip or bug: expected " +
                      this.centralDirRecords +
                      " records in central dir, got " +
                      this.files.length
                  );
              },
              readEndOfCentral: function () {
                var v = this.reader.lastIndexOfSignature(
                  _.CENTRAL_DIRECTORY_END
                );
                if (v < 0)
                  throw this.isSignature(0, _.LOCAL_FILE_HEADER)
                    ? new Error(
                        "Corrupted zip: can't find end of central directory"
                      )
                    : new Error(
                        "Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"
                      );
                this.reader.setIndex(v);
                var C = v;
                if (
                  (this.checkSignature(_.CENTRAL_DIRECTORY_END),
                  this.readBlockEndOfCentral(),
                  this.diskNumber === f.MAX_VALUE_16BITS ||
                    this.diskWithCentralDirStart === f.MAX_VALUE_16BITS ||
                    this.centralDirRecordsOnThisDisk === f.MAX_VALUE_16BITS ||
                    this.centralDirRecords === f.MAX_VALUE_16BITS ||
                    this.centralDirSize === f.MAX_VALUE_32BITS ||
                    this.centralDirOffset === f.MAX_VALUE_32BITS)
                ) {
                  if (
                    ((this.zip64 = !0),
                    (v = this.reader.lastIndexOfSignature(
                      _.ZIP64_CENTRAL_DIRECTORY_LOCATOR
                    )) < 0)
                  )
                    throw new Error(
                      "Corrupted zip: can't find the ZIP64 end of central directory locator"
                    );
                  if (
                    (this.reader.setIndex(v),
                    this.checkSignature(_.ZIP64_CENTRAL_DIRECTORY_LOCATOR),
                    this.readBlockZip64EndOfCentralLocator(),
                    !this.isSignature(
                      this.relativeOffsetEndOfZip64CentralDir,
                      _.ZIP64_CENTRAL_DIRECTORY_END
                    ) &&
                      ((this.relativeOffsetEndOfZip64CentralDir =
                        this.reader.lastIndexOfSignature(
                          _.ZIP64_CENTRAL_DIRECTORY_END
                        )),
                      this.relativeOffsetEndOfZip64CentralDir < 0))
                  )
                    throw new Error(
                      "Corrupted zip: can't find the ZIP64 end of central directory"
                    );
                  this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),
                    this.checkSignature(_.ZIP64_CENTRAL_DIRECTORY_END),
                    this.readBlockZip64EndOfCentral();
                }
                var T = this.centralDirOffset + this.centralDirSize;
                this.zip64 &&
                  ((T += 20), (T += 12 + this.zip64EndOfCentralSize));
                var z = C - T;
                if (0 < z)
                  this.isSignature(C, _.CENTRAL_FILE_HEADER) ||
                    (this.reader.zero = z);
                else if (z < 0)
                  throw new Error(
                    "Corrupted zip: missing " + Math.abs(z) + " bytes."
                  );
              },
              prepareReader: function (v) {
                this.reader = l(v);
              },
              load: function (v) {
                this.prepareReader(v),
                  this.readEndOfCentral(),
                  this.readCentralDir(),
                  this.readLocalFiles();
              }
            }),
              (o.exports = M);
          },
          {
            "./reader/readerFor": 22,
            "./signature": 23,
            "./support": 30,
            "./utils": 32,
            "./zipEntry": 34
          }
        ],
        34: [
          function (n, o, a) {
            var l = n("./reader/readerFor"),
              f = n("./utils"),
              _ = n("./compressedObject"),
              m = n("./crc32"),
              g = n("./utf8"),
              M = n("./compressions"),
              v = n("./support");
            function C(T, z) {
              (this.options = T), (this.loadOptions = z);
            }
            (C.prototype = {
              isEncrypted: function () {
                return (1 & this.bitFlag) == 1;
              },
              useUTF8: function () {
                return (2048 & this.bitFlag) == 2048;
              },
              readLocalPart: function (T) {
                var z, $;
                if (
                  (T.skip(22),
                  (this.fileNameLength = T.readInt(2)),
                  ($ = T.readInt(2)),
                  (this.fileName = T.readData(this.fileNameLength)),
                  T.skip($),
                  this.compressedSize === -1 || this.uncompressedSize === -1)
                )
                  throw new Error(
                    "Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)"
                  );
                if (
                  (z = (function (S) {
                    for (var y in M)
                      if (
                        Object.prototype.hasOwnProperty.call(M, y) &&
                        M[y].magic === S
                      )
                        return M[y];
                    return null;
                  })(this.compressionMethod)) === null
                )
                  throw new Error(
                    "Corrupted zip : compression " +
                      f.pretty(this.compressionMethod) +
                      " unknown (inner file : " +
                      f.transformTo("string", this.fileName) +
                      ")"
                  );
                this.decompressed = new _(
                  this.compressedSize,
                  this.uncompressedSize,
                  this.crc32,
                  z,
                  T.readData(this.compressedSize)
                );
              },
              readCentralPart: function (T) {
                (this.versionMadeBy = T.readInt(2)),
                  T.skip(2),
                  (this.bitFlag = T.readInt(2)),
                  (this.compressionMethod = T.readString(2)),
                  (this.date = T.readDate()),
                  (this.crc32 = T.readInt(4)),
                  (this.compressedSize = T.readInt(4)),
                  (this.uncompressedSize = T.readInt(4));
                var z = T.readInt(2);
                if (
                  ((this.extraFieldsLength = T.readInt(2)),
                  (this.fileCommentLength = T.readInt(2)),
                  (this.diskNumberStart = T.readInt(2)),
                  (this.internalFileAttributes = T.readInt(2)),
                  (this.externalFileAttributes = T.readInt(4)),
                  (this.localHeaderOffset = T.readInt(4)),
                  this.isEncrypted())
                )
                  throw new Error("Encrypted zip are not supported");
                T.skip(z),
                  this.readExtraFields(T),
                  this.parseZIP64ExtraField(T),
                  (this.fileComment = T.readData(this.fileCommentLength));
              },
              processAttributes: function () {
                (this.unixPermissions = null), (this.dosPermissions = null);
                var T = this.versionMadeBy >> 8;
                (this.dir = !!(16 & this.externalFileAttributes)),
                  T == 0 &&
                    (this.dosPermissions = 63 & this.externalFileAttributes),
                  T == 3 &&
                    (this.unixPermissions =
                      (this.externalFileAttributes >> 16) & 65535),
                  this.dir ||
                    this.fileNameStr.slice(-1) !== "/" ||
                    (this.dir = !0);
              },
              parseZIP64ExtraField: function () {
                if (this.extraFields[1]) {
                  var T = l(this.extraFields[1].value);
                  this.uncompressedSize === f.MAX_VALUE_32BITS &&
                    (this.uncompressedSize = T.readInt(8)),
                    this.compressedSize === f.MAX_VALUE_32BITS &&
                      (this.compressedSize = T.readInt(8)),
                    this.localHeaderOffset === f.MAX_VALUE_32BITS &&
                      (this.localHeaderOffset = T.readInt(8)),
                    this.diskNumberStart === f.MAX_VALUE_32BITS &&
                      (this.diskNumberStart = T.readInt(4));
                }
              },
              readExtraFields: function (T) {
                var z,
                  $,
                  S,
                  y = T.index + this.extraFieldsLength;
                for (
                  this.extraFields || (this.extraFields = {});
                  T.index + 4 < y;

                )
                  (z = T.readInt(2)),
                    ($ = T.readInt(2)),
                    (S = T.readData($)),
                    (this.extraFields[z] = { id: z, length: $, value: S });
                T.setIndex(y);
              },
              handleUTF8: function () {
                var T = v.uint8array ? "uint8array" : "array";
                if (this.useUTF8())
                  (this.fileNameStr = g.utf8decode(this.fileName)),
                    (this.fileCommentStr = g.utf8decode(this.fileComment));
                else {
                  var z = this.findExtraFieldUnicodePath();
                  if (z !== null) this.fileNameStr = z;
                  else {
                    var $ = f.transformTo(T, this.fileName);
                    this.fileNameStr = this.loadOptions.decodeFileName($);
                  }
                  var S = this.findExtraFieldUnicodeComment();
                  if (S !== null) this.fileCommentStr = S;
                  else {
                    var y = f.transformTo(T, this.fileComment);
                    this.fileCommentStr = this.loadOptions.decodeFileName(y);
                  }
                }
              },
              findExtraFieldUnicodePath: function () {
                var T = this.extraFields[28789];
                if (T) {
                  var z = l(T.value);
                  return z.readInt(1) !== 1 || m(this.fileName) !== z.readInt(4)
                    ? null
                    : g.utf8decode(z.readData(T.length - 5));
                }
                return null;
              },
              findExtraFieldUnicodeComment: function () {
                var T = this.extraFields[25461];
                if (T) {
                  var z = l(T.value);
                  return z.readInt(1) !== 1 ||
                    m(this.fileComment) !== z.readInt(4)
                    ? null
                    : g.utf8decode(z.readData(T.length - 5));
                }
                return null;
              }
            }),
              (o.exports = C);
          },
          {
            "./compressedObject": 2,
            "./compressions": 3,
            "./crc32": 4,
            "./reader/readerFor": 22,
            "./support": 30,
            "./utf8": 31,
            "./utils": 32
          }
        ],
        35: [
          function (n, o, a) {
            function l(z, $, S) {
              (this.name = z),
                (this.dir = S.dir),
                (this.date = S.date),
                (this.comment = S.comment),
                (this.unixPermissions = S.unixPermissions),
                (this.dosPermissions = S.dosPermissions),
                (this._data = $),
                (this._dataBinary = S.binary),
                (this.options = {
                  compression: S.compression,
                  compressionOptions: S.compressionOptions
                });
            }
            var f = n("./stream/StreamHelper"),
              _ = n("./stream/DataWorker"),
              m = n("./utf8"),
              g = n("./compressedObject"),
              M = n("./stream/GenericWorker");
            l.prototype = {
              internalStream: function (z) {
                var $ = null,
                  S = "string";
                try {
                  if (!z) throw new Error("No output type specified.");
                  var y = (S = z.toLowerCase()) === "string" || S === "text";
                  (S !== "binarystring" && S !== "text") || (S = "string"),
                    ($ = this._decompressWorker());
                  var x = !this._dataBinary;
                  x && !y && ($ = $.pipe(new m.Utf8EncodeWorker())),
                    !x && y && ($ = $.pipe(new m.Utf8DecodeWorker()));
                } catch (I) {
                  ($ = new M("error")).error(I);
                }
                return new f($, S, "");
              },
              async: function (z, $) {
                return this.internalStream(z).accumulate($);
              },
              nodeStream: function (z, $) {
                return this.internalStream(z || "nodebuffer").toNodejsStream($);
              },
              _compressWorker: function (z, $) {
                if (
                  this._data instanceof g &&
                  this._data.compression.magic === z.magic
                )
                  return this._data.getCompressedWorker();
                var S = this._decompressWorker();
                return (
                  this._dataBinary || (S = S.pipe(new m.Utf8EncodeWorker())),
                  g.createWorkerFrom(S, z, $)
                );
              },
              _decompressWorker: function () {
                return this._data instanceof g
                  ? this._data.getContentWorker()
                  : this._data instanceof M
                  ? this._data
                  : new _(this._data);
              }
            };
            for (
              var v = [
                  "asText",
                  "asBinary",
                  "asNodeBuffer",
                  "asUint8Array",
                  "asArrayBuffer"
                ],
                C = function () {
                  throw new Error(
                    "This method has been removed in JSZip 3.0, please check the upgrade guide."
                  );
                },
                T = 0;
              T < v.length;
              T++
            )
              l.prototype[v[T]] = C;
            o.exports = l;
          },
          {
            "./compressedObject": 2,
            "./stream/DataWorker": 27,
            "./stream/GenericWorker": 28,
            "./stream/StreamHelper": 29,
            "./utf8": 31
          }
        ],
        36: [
          function (n, o, a) {
            (function (l) {
              var f,
                _,
                m = l.MutationObserver || l.WebKitMutationObserver;
              if (m) {
                var g = 0,
                  M = new m(z),
                  v = l.document.createTextNode("");
                M.observe(v, { characterData: !0 }),
                  (f = function () {
                    v.data = g = ++g % 2;
                  });
              } else if (l.setImmediate || l.MessageChannel === void 0)
                f =
                  "document" in l &&
                  "onreadystatechange" in l.document.createElement("script")
                    ? function () {
                        var $ = l.document.createElement("script");
                        ($.onreadystatechange = function () {
                          z(),
                            ($.onreadystatechange = null),
                            $.parentNode.removeChild($),
                            ($ = null);
                        }),
                          l.document.documentElement.appendChild($);
                      }
                    : function () {
                        setTimeout(z, 0);
                      };
              else {
                var C = new l.MessageChannel();
                (C.port1.onmessage = z),
                  (f = function () {
                    C.port2.postMessage(0);
                  });
              }
              var T = [];
              function z() {
                var $, S;
                _ = !0;
                for (var y = T.length; y; ) {
                  for (S = T, T = [], $ = -1; ++$ < y; ) S[$]();
                  y = T.length;
                }
                _ = !1;
              }
              o.exports = function ($) {
                T.push($) !== 1 || _ || f();
              };
            }).call(
              this,
              typeof Fo < "u"
                ? Fo
                : typeof self < "u"
                ? self
                : typeof window < "u"
                ? window
                : {}
            );
          },
          {}
        ],
        37: [
          function (n, o, a) {
            var l = n("immediate");
            function f() {}
            var _ = {},
              m = ["REJECTED"],
              g = ["FULFILLED"],
              M = ["PENDING"];
            function v(y) {
              if (typeof y != "function")
                throw new TypeError("resolver must be a function");
              (this.state = M),
                (this.queue = []),
                (this.outcome = void 0),
                y !== f && $(this, y);
            }
            function C(y, x, I) {
              (this.promise = y),
                typeof x == "function" &&
                  ((this.onFulfilled = x),
                  (this.callFulfilled = this.otherCallFulfilled)),
                typeof I == "function" &&
                  ((this.onRejected = I),
                  (this.callRejected = this.otherCallRejected));
            }
            function T(y, x, I) {
              l(function () {
                var V;
                try {
                  V = x(I);
                } catch (O) {
                  return _.reject(y, O);
                }
                V === y
                  ? _.reject(
                      y,
                      new TypeError("Cannot resolve promise with itself")
                    )
                  : _.resolve(y, V);
              });
            }
            function z(y) {
              var x = y && y.then;
              if (
                y &&
                (typeof y == "object" || typeof y == "function") &&
                typeof x == "function"
              )
                return function () {
                  x.apply(y, arguments);
                };
            }
            function $(y, x) {
              var I = !1;
              function V(j) {
                I || ((I = !0), _.reject(y, j));
              }
              function O(j) {
                I || ((I = !0), _.resolve(y, j));
              }
              var B = S(function () {
                x(O, V);
              });
              B.status === "error" && V(B.value);
            }
            function S(y, x) {
              var I = {};
              try {
                (I.value = y(x)), (I.status = "success");
              } catch (V) {
                (I.status = "error"), (I.value = V);
              }
              return I;
            }
            ((o.exports = v).prototype.finally = function (y) {
              if (typeof y != "function") return this;
              var x = this.constructor;
              return this.then(
                function (I) {
                  return x.resolve(y()).then(function () {
                    return I;
                  });
                },
                function (I) {
                  return x.resolve(y()).then(function () {
                    throw I;
                  });
                }
              );
            }),
              (v.prototype.catch = function (y) {
                return this.then(null, y);
              }),
              (v.prototype.then = function (y, x) {
                if (
                  (typeof y != "function" && this.state === g) ||
                  (typeof x != "function" && this.state === m)
                )
                  return this;
                var I = new this.constructor(f);
                return (
                  this.state !== M
                    ? T(I, this.state === g ? y : x, this.outcome)
                    : this.queue.push(new C(I, y, x)),
                  I
                );
              }),
              (C.prototype.callFulfilled = function (y) {
                _.resolve(this.promise, y);
              }),
              (C.prototype.otherCallFulfilled = function (y) {
                T(this.promise, this.onFulfilled, y);
              }),
              (C.prototype.callRejected = function (y) {
                _.reject(this.promise, y);
              }),
              (C.prototype.otherCallRejected = function (y) {
                T(this.promise, this.onRejected, y);
              }),
              (_.resolve = function (y, x) {
                var I = S(z, x);
                if (I.status === "error") return _.reject(y, I.value);
                var V = I.value;
                if (V) $(y, V);
                else {
                  (y.state = g), (y.outcome = x);
                  for (var O = -1, B = y.queue.length; ++O < B; )
                    y.queue[O].callFulfilled(x);
                }
                return y;
              }),
              (_.reject = function (y, x) {
                (y.state = m), (y.outcome = x);
                for (var I = -1, V = y.queue.length; ++I < V; )
                  y.queue[I].callRejected(x);
                return y;
              }),
              (v.resolve = function (y) {
                return y instanceof this ? y : _.resolve(new this(f), y);
              }),
              (v.reject = function (y) {
                var x = new this(f);
                return _.reject(x, y);
              }),
              (v.all = function (y) {
                var x = this;
                if (Object.prototype.toString.call(y) !== "[object Array]")
                  return this.reject(new TypeError("must be an array"));
                var I = y.length,
                  V = !1;
                if (!I) return this.resolve([]);
                for (
                  var O = new Array(I), B = 0, j = -1, N = new this(f);
                  ++j < I;

                )
                  se(y[j], j);
                return N;
                function se(de, Me) {
                  x.resolve(de).then(
                    function (J) {
                      (O[Me] = J),
                        ++B !== I || V || ((V = !0), _.resolve(N, O));
                    },
                    function (J) {
                      V || ((V = !0), _.reject(N, J));
                    }
                  );
                }
              }),
              (v.race = function (y) {
                var x = this;
                if (Object.prototype.toString.call(y) !== "[object Array]")
                  return this.reject(new TypeError("must be an array"));
                var I = y.length,
                  V = !1;
                if (!I) return this.resolve([]);
                for (var O = -1, B = new this(f); ++O < I; )
                  (j = y[O]),
                    x.resolve(j).then(
                      function (N) {
                        V || ((V = !0), _.resolve(B, N));
                      },
                      function (N) {
                        V || ((V = !0), _.reject(B, N));
                      }
                    );
                var j;
                return B;
              });
          },
          { immediate: 36 }
        ],
        38: [
          function (n, o, a) {
            var l = {};
            (0, n("./lib/utils/common").assign)(
              l,
              n("./lib/deflate"),
              n("./lib/inflate"),
              n("./lib/zlib/constants")
            ),
              (o.exports = l);
          },
          {
            "./lib/deflate": 39,
            "./lib/inflate": 40,
            "./lib/utils/common": 41,
            "./lib/zlib/constants": 44
          }
        ],
        39: [
          function (n, o, a) {
            var l = n("./zlib/deflate"),
              f = n("./utils/common"),
              _ = n("./utils/strings"),
              m = n("./zlib/messages"),
              g = n("./zlib/zstream"),
              M = Object.prototype.toString,
              v = 0,
              C = -1,
              T = 0,
              z = 8;
            function $(y) {
              if (!(this instanceof $)) return new $(y);
              this.options = f.assign(
                {
                  level: C,
                  method: z,
                  chunkSize: 16384,
                  windowBits: 15,
                  memLevel: 8,
                  strategy: T,
                  to: ""
                },
                y || {}
              );
              var x = this.options;
              x.raw && 0 < x.windowBits
                ? (x.windowBits = -x.windowBits)
                : x.gzip &&
                  0 < x.windowBits &&
                  x.windowBits < 16 &&
                  (x.windowBits += 16),
                (this.err = 0),
                (this.msg = ""),
                (this.ended = !1),
                (this.chunks = []),
                (this.strm = new g()),
                (this.strm.avail_out = 0);
              var I = l.deflateInit2(
                this.strm,
                x.level,
                x.method,
                x.windowBits,
                x.memLevel,
                x.strategy
              );
              if (I !== v) throw new Error(m[I]);
              if (
                (x.header && l.deflateSetHeader(this.strm, x.header),
                x.dictionary)
              ) {
                var V;
                if (
                  ((V =
                    typeof x.dictionary == "string"
                      ? _.string2buf(x.dictionary)
                      : M.call(x.dictionary) === "[object ArrayBuffer]"
                      ? new Uint8Array(x.dictionary)
                      : x.dictionary),
                  (I = l.deflateSetDictionary(this.strm, V)) !== v)
                )
                  throw new Error(m[I]);
                this._dict_set = !0;
              }
            }
            function S(y, x) {
              var I = new $(x);
              if ((I.push(y, !0), I.err)) throw I.msg || m[I.err];
              return I.result;
            }
            ($.prototype.push = function (y, x) {
              var I,
                V,
                O = this.strm,
                B = this.options.chunkSize;
              if (this.ended) return !1;
              (V = x === ~~x ? x : x === !0 ? 4 : 0),
                typeof y == "string"
                  ? (O.input = _.string2buf(y))
                  : M.call(y) === "[object ArrayBuffer]"
                  ? (O.input = new Uint8Array(y))
                  : (O.input = y),
                (O.next_in = 0),
                (O.avail_in = O.input.length);
              do {
                if (
                  (O.avail_out === 0 &&
                    ((O.output = new f.Buf8(B)),
                    (O.next_out = 0),
                    (O.avail_out = B)),
                  (I = l.deflate(O, V)) !== 1 && I !== v)
                )
                  return this.onEnd(I), !(this.ended = !0);
                (O.avail_out !== 0 &&
                  (O.avail_in !== 0 || (V !== 4 && V !== 2))) ||
                  (this.options.to === "string"
                    ? this.onData(
                        _.buf2binstring(f.shrinkBuf(O.output, O.next_out))
                      )
                    : this.onData(f.shrinkBuf(O.output, O.next_out)));
              } while ((0 < O.avail_in || O.avail_out === 0) && I !== 1);
              return V === 4
                ? ((I = l.deflateEnd(this.strm)),
                  this.onEnd(I),
                  (this.ended = !0),
                  I === v)
                : V !== 2 || (this.onEnd(v), !(O.avail_out = 0));
            }),
              ($.prototype.onData = function (y) {
                this.chunks.push(y);
              }),
              ($.prototype.onEnd = function (y) {
                y === v &&
                  (this.options.to === "string"
                    ? (this.result = this.chunks.join(""))
                    : (this.result = f.flattenChunks(this.chunks))),
                  (this.chunks = []),
                  (this.err = y),
                  (this.msg = this.strm.msg);
              }),
              (a.Deflate = $),
              (a.deflate = S),
              (a.deflateRaw = function (y, x) {
                return ((x = x || {}).raw = !0), S(y, x);
              }),
              (a.gzip = function (y, x) {
                return ((x = x || {}).gzip = !0), S(y, x);
              });
          },
          {
            "./utils/common": 41,
            "./utils/strings": 42,
            "./zlib/deflate": 46,
            "./zlib/messages": 51,
            "./zlib/zstream": 53
          }
        ],
        40: [
          function (n, o, a) {
            var l = n("./zlib/inflate"),
              f = n("./utils/common"),
              _ = n("./utils/strings"),
              m = n("./zlib/constants"),
              g = n("./zlib/messages"),
              M = n("./zlib/zstream"),
              v = n("./zlib/gzheader"),
              C = Object.prototype.toString;
            function T($) {
              if (!(this instanceof T)) return new T($);
              this.options = f.assign(
                { chunkSize: 16384, windowBits: 0, to: "" },
                $ || {}
              );
              var S = this.options;
              S.raw &&
                0 <= S.windowBits &&
                S.windowBits < 16 &&
                ((S.windowBits = -S.windowBits),
                S.windowBits === 0 && (S.windowBits = -15)),
                !(0 <= S.windowBits && S.windowBits < 16) ||
                  ($ && $.windowBits) ||
                  (S.windowBits += 32),
                15 < S.windowBits &&
                  S.windowBits < 48 &&
                  !(15 & S.windowBits) &&
                  (S.windowBits |= 15),
                (this.err = 0),
                (this.msg = ""),
                (this.ended = !1),
                (this.chunks = []),
                (this.strm = new M()),
                (this.strm.avail_out = 0);
              var y = l.inflateInit2(this.strm, S.windowBits);
              if (y !== m.Z_OK) throw new Error(g[y]);
              (this.header = new v()),
                l.inflateGetHeader(this.strm, this.header);
            }
            function z($, S) {
              var y = new T(S);
              if ((y.push($, !0), y.err)) throw y.msg || g[y.err];
              return y.result;
            }
            (T.prototype.push = function ($, S) {
              var y,
                x,
                I,
                V,
                O,
                B,
                j = this.strm,
                N = this.options.chunkSize,
                se = this.options.dictionary,
                de = !1;
              if (this.ended) return !1;
              (x = S === ~~S ? S : S === !0 ? m.Z_FINISH : m.Z_NO_FLUSH),
                typeof $ == "string"
                  ? (j.input = _.binstring2buf($))
                  : C.call($) === "[object ArrayBuffer]"
                  ? (j.input = new Uint8Array($))
                  : (j.input = $),
                (j.next_in = 0),
                (j.avail_in = j.input.length);
              do {
                if (
                  (j.avail_out === 0 &&
                    ((j.output = new f.Buf8(N)),
                    (j.next_out = 0),
                    (j.avail_out = N)),
                  (y = l.inflate(j, m.Z_NO_FLUSH)) === m.Z_NEED_DICT &&
                    se &&
                    ((B =
                      typeof se == "string"
                        ? _.string2buf(se)
                        : C.call(se) === "[object ArrayBuffer]"
                        ? new Uint8Array(se)
                        : se),
                    (y = l.inflateSetDictionary(this.strm, B))),
                  y === m.Z_BUF_ERROR && de === !0 && ((y = m.Z_OK), (de = !1)),
                  y !== m.Z_STREAM_END && y !== m.Z_OK)
                )
                  return this.onEnd(y), !(this.ended = !0);
                j.next_out &&
                  ((j.avail_out !== 0 &&
                    y !== m.Z_STREAM_END &&
                    (j.avail_in !== 0 ||
                      (x !== m.Z_FINISH && x !== m.Z_SYNC_FLUSH))) ||
                    (this.options.to === "string"
                      ? ((I = _.utf8border(j.output, j.next_out)),
                        (V = j.next_out - I),
                        (O = _.buf2string(j.output, I)),
                        (j.next_out = V),
                        (j.avail_out = N - V),
                        V && f.arraySet(j.output, j.output, I, V, 0),
                        this.onData(O))
                      : this.onData(f.shrinkBuf(j.output, j.next_out)))),
                  j.avail_in === 0 && j.avail_out === 0 && (de = !0);
              } while (
                (0 < j.avail_in || j.avail_out === 0) &&
                y !== m.Z_STREAM_END
              );
              return (
                y === m.Z_STREAM_END && (x = m.Z_FINISH),
                x === m.Z_FINISH
                  ? ((y = l.inflateEnd(this.strm)),
                    this.onEnd(y),
                    (this.ended = !0),
                    y === m.Z_OK)
                  : x !== m.Z_SYNC_FLUSH ||
                    (this.onEnd(m.Z_OK), !(j.avail_out = 0))
              );
            }),
              (T.prototype.onData = function ($) {
                this.chunks.push($);
              }),
              (T.prototype.onEnd = function ($) {
                $ === m.Z_OK &&
                  (this.options.to === "string"
                    ? (this.result = this.chunks.join(""))
                    : (this.result = f.flattenChunks(this.chunks))),
                  (this.chunks = []),
                  (this.err = $),
                  (this.msg = this.strm.msg);
              }),
              (a.Inflate = T),
              (a.inflate = z),
              (a.inflateRaw = function ($, S) {
                return ((S = S || {}).raw = !0), z($, S);
              }),
              (a.ungzip = z);
          },
          {
            "./utils/common": 41,
            "./utils/strings": 42,
            "./zlib/constants": 44,
            "./zlib/gzheader": 47,
            "./zlib/inflate": 49,
            "./zlib/messages": 51,
            "./zlib/zstream": 53
          }
        ],
        41: [
          function (n, o, a) {
            var l =
              typeof Uint8Array < "u" &&
              typeof Uint16Array < "u" &&
              typeof Int32Array < "u";
            (a.assign = function (m) {
              for (
                var g = Array.prototype.slice.call(arguments, 1);
                g.length;

              ) {
                var M = g.shift();
                if (M) {
                  if (typeof M != "object")
                    throw new TypeError(M + "must be non-object");
                  for (var v in M) M.hasOwnProperty(v) && (m[v] = M[v]);
                }
              }
              return m;
            }),
              (a.shrinkBuf = function (m, g) {
                return m.length === g
                  ? m
                  : m.subarray
                  ? m.subarray(0, g)
                  : ((m.length = g), m);
              });
            var f = {
                arraySet: function (m, g, M, v, C) {
                  if (g.subarray && m.subarray) m.set(g.subarray(M, M + v), C);
                  else for (var T = 0; T < v; T++) m[C + T] = g[M + T];
                },
                flattenChunks: function (m) {
                  var g, M, v, C, T, z;
                  for (g = v = 0, M = m.length; g < M; g++) v += m[g].length;
                  for (
                    z = new Uint8Array(v), g = C = 0, M = m.length;
                    g < M;
                    g++
                  )
                    (T = m[g]), z.set(T, C), (C += T.length);
                  return z;
                }
              },
              _ = {
                arraySet: function (m, g, M, v, C) {
                  for (var T = 0; T < v; T++) m[C + T] = g[M + T];
                },
                flattenChunks: function (m) {
                  return [].concat.apply([], m);
                }
              };
            (a.setTyped = function (m) {
              m
                ? ((a.Buf8 = Uint8Array),
                  (a.Buf16 = Uint16Array),
                  (a.Buf32 = Int32Array),
                  a.assign(a, f))
                : ((a.Buf8 = Array),
                  (a.Buf16 = Array),
                  (a.Buf32 = Array),
                  a.assign(a, _));
            }),
              a.setTyped(l);
          },
          {}
        ],
        42: [
          function (n, o, a) {
            var l = n("./common"),
              f = !0,
              _ = !0;
            try {
              String.fromCharCode.apply(null, [0]);
            } catch {
              f = !1;
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              _ = !1;
            }
            for (var m = new l.Buf8(256), g = 0; g < 256; g++)
              m[g] =
                252 <= g
                  ? 6
                  : 248 <= g
                  ? 5
                  : 240 <= g
                  ? 4
                  : 224 <= g
                  ? 3
                  : 192 <= g
                  ? 2
                  : 1;
            function M(v, C) {
              if (C < 65537 && ((v.subarray && _) || (!v.subarray && f)))
                return String.fromCharCode.apply(null, l.shrinkBuf(v, C));
              for (var T = "", z = 0; z < C; z++)
                T += String.fromCharCode(v[z]);
              return T;
            }
            (m[254] = m[254] = 1),
              (a.string2buf = function (v) {
                var C,
                  T,
                  z,
                  $,
                  S,
                  y = v.length,
                  x = 0;
                for ($ = 0; $ < y; $++)
                  (64512 & (T = v.charCodeAt($))) == 55296 &&
                    $ + 1 < y &&
                    (64512 & (z = v.charCodeAt($ + 1))) == 56320 &&
                    ((T = 65536 + ((T - 55296) << 10) + (z - 56320)), $++),
                    (x += T < 128 ? 1 : T < 2048 ? 2 : T < 65536 ? 3 : 4);
                for (C = new l.Buf8(x), $ = S = 0; S < x; $++)
                  (64512 & (T = v.charCodeAt($))) == 55296 &&
                    $ + 1 < y &&
                    (64512 & (z = v.charCodeAt($ + 1))) == 56320 &&
                    ((T = 65536 + ((T - 55296) << 10) + (z - 56320)), $++),
                    T < 128
                      ? (C[S++] = T)
                      : (T < 2048
                          ? (C[S++] = 192 | (T >>> 6))
                          : (T < 65536
                              ? (C[S++] = 224 | (T >>> 12))
                              : ((C[S++] = 240 | (T >>> 18)),
                                (C[S++] = 128 | ((T >>> 12) & 63))),
                            (C[S++] = 128 | ((T >>> 6) & 63))),
                        (C[S++] = 128 | (63 & T)));
                return C;
              }),
              (a.buf2binstring = function (v) {
                return M(v, v.length);
              }),
              (a.binstring2buf = function (v) {
                for (
                  var C = new l.Buf8(v.length), T = 0, z = C.length;
                  T < z;
                  T++
                )
                  C[T] = v.charCodeAt(T);
                return C;
              }),
              (a.buf2string = function (v, C) {
                var T,
                  z,
                  $,
                  S,
                  y = C || v.length,
                  x = new Array(2 * y);
                for (T = z = 0; T < y; )
                  if (($ = v[T++]) < 128) x[z++] = $;
                  else if (4 < (S = m[$])) (x[z++] = 65533), (T += S - 1);
                  else {
                    for ($ &= S === 2 ? 31 : S === 3 ? 15 : 7; 1 < S && T < y; )
                      ($ = ($ << 6) | (63 & v[T++])), S--;
                    1 < S
                      ? (x[z++] = 65533)
                      : $ < 65536
                      ? (x[z++] = $)
                      : (($ -= 65536),
                        (x[z++] = 55296 | (($ >> 10) & 1023)),
                        (x[z++] = 56320 | (1023 & $)));
                  }
                return M(x, z);
              }),
              (a.utf8border = function (v, C) {
                var T;
                for (
                  (C = C || v.length) > v.length && (C = v.length), T = C - 1;
                  0 <= T && (192 & v[T]) == 128;

                )
                  T--;
                return T < 0 || T === 0 ? C : T + m[v[T]] > C ? T : C;
              });
          },
          { "./common": 41 }
        ],
        43: [
          function (n, o, a) {
            o.exports = function (l, f, _, m) {
              for (
                var g = (65535 & l) | 0, M = ((l >>> 16) & 65535) | 0, v = 0;
                _ !== 0;

              ) {
                for (
                  _ -= v = 2e3 < _ ? 2e3 : _;
                  (M = (M + (g = (g + f[m++]) | 0)) | 0), --v;

                );
                (g %= 65521), (M %= 65521);
              }
              return g | (M << 16) | 0;
            };
          },
          {}
        ],
        44: [
          function (n, o, a) {
            o.exports = {
              Z_NO_FLUSH: 0,
              Z_PARTIAL_FLUSH: 1,
              Z_SYNC_FLUSH: 2,
              Z_FULL_FLUSH: 3,
              Z_FINISH: 4,
              Z_BLOCK: 5,
              Z_TREES: 6,
              Z_OK: 0,
              Z_STREAM_END: 1,
              Z_NEED_DICT: 2,
              Z_ERRNO: -1,
              Z_STREAM_ERROR: -2,
              Z_DATA_ERROR: -3,
              Z_BUF_ERROR: -5,
              Z_NO_COMPRESSION: 0,
              Z_BEST_SPEED: 1,
              Z_BEST_COMPRESSION: 9,
              Z_DEFAULT_COMPRESSION: -1,
              Z_FILTERED: 1,
              Z_HUFFMAN_ONLY: 2,
              Z_RLE: 3,
              Z_FIXED: 4,
              Z_DEFAULT_STRATEGY: 0,
              Z_BINARY: 0,
              Z_TEXT: 1,
              Z_UNKNOWN: 2,
              Z_DEFLATED: 8
            };
          },
          {}
        ],
        45: [
          function (n, o, a) {
            var l = (function () {
              for (var f, _ = [], m = 0; m < 256; m++) {
                f = m;
                for (var g = 0; g < 8; g++)
                  f = 1 & f ? 3988292384 ^ (f >>> 1) : f >>> 1;
                _[m] = f;
              }
              return _;
            })();
            o.exports = function (f, _, m, g) {
              var M = l,
                v = g + m;
              f ^= -1;
              for (var C = g; C < v; C++) f = (f >>> 8) ^ M[255 & (f ^ _[C])];
              return -1 ^ f;
            };
          },
          {}
        ],
        46: [
          function (n, o, a) {
            var l,
              f = n("../utils/common"),
              _ = n("./trees"),
              m = n("./adler32"),
              g = n("./crc32"),
              M = n("./messages"),
              v = 0,
              C = 4,
              T = 0,
              z = -2,
              $ = -1,
              S = 4,
              y = 2,
              x = 8,
              I = 9,
              V = 286,
              O = 30,
              B = 19,
              j = 2 * V + 1,
              N = 15,
              se = 3,
              de = 258,
              Me = de + se + 1,
              J = 42,
              ye = 113,
              L = 1,
              Ee = 2,
              Qe = 3,
              _e = 4;
            function X(A, Ae) {
              return (A.msg = M[Ae]), Ae;
            }
            function oe(A) {
              return (A << 1) - (4 < A ? 9 : 0);
            }
            function xe(A) {
              for (var Ae = A.length; 0 <= --Ae; ) A[Ae] = 0;
            }
            function Y(A) {
              var Ae = A.state,
                $e = Ae.pending;
              $e > A.avail_out && ($e = A.avail_out),
                $e !== 0 &&
                  (f.arraySet(
                    A.output,
                    Ae.pending_buf,
                    Ae.pending_out,
                    $e,
                    A.next_out
                  ),
                  (A.next_out += $e),
                  (Ae.pending_out += $e),
                  (A.total_out += $e),
                  (A.avail_out -= $e),
                  (Ae.pending -= $e),
                  Ae.pending === 0 && (Ae.pending_out = 0));
            }
            function ge(A, Ae) {
              _._tr_flush_block(
                A,
                0 <= A.block_start ? A.block_start : -1,
                A.strstart - A.block_start,
                Ae
              ),
                (A.block_start = A.strstart),
                Y(A.strm);
            }
            function qe(A, Ae) {
              A.pending_buf[A.pending++] = Ae;
            }
            function Be(A, Ae) {
              (A.pending_buf[A.pending++] = (Ae >>> 8) & 255),
                (A.pending_buf[A.pending++] = 255 & Ae);
            }
            function Ne(A, Ae) {
              var $e,
                ae,
                ne = A.max_chain_length,
                ve = A.strstart,
                R = A.prev_length,
                te = A.nice_match,
                D =
                  A.strstart > A.w_size - Me ? A.strstart - (A.w_size - Me) : 0,
                ce = A.window,
                ue = A.w_mask,
                ke = A.prev,
                Re = A.strstart + de,
                ht = ce[ve + R - 1],
                tt = ce[ve + R];
              A.prev_length >= A.good_match && (ne >>= 2),
                te > A.lookahead && (te = A.lookahead);
              do
                if (
                  ce[($e = Ae) + R] === tt &&
                  ce[$e + R - 1] === ht &&
                  ce[$e] === ce[ve] &&
                  ce[++$e] === ce[ve + 1]
                ) {
                  (ve += 2), $e++;
                  do;
                  while (
                    ce[++ve] === ce[++$e] &&
                    ce[++ve] === ce[++$e] &&
                    ce[++ve] === ce[++$e] &&
                    ce[++ve] === ce[++$e] &&
                    ce[++ve] === ce[++$e] &&
                    ce[++ve] === ce[++$e] &&
                    ce[++ve] === ce[++$e] &&
                    ce[++ve] === ce[++$e] &&
                    ve < Re
                  );
                  if (((ae = de - (Re - ve)), (ve = Re - de), R < ae)) {
                    if (((A.match_start = Ae), te <= (R = ae))) break;
                    (ht = ce[ve + R - 1]), (tt = ce[ve + R]);
                  }
                }
              while ((Ae = ke[Ae & ue]) > D && --ne != 0);
              return R <= A.lookahead ? R : A.lookahead;
            }
            function We(A) {
              var Ae,
                $e,
                ae,
                ne,
                ve,
                R,
                te,
                D,
                ce,
                ue,
                ke = A.w_size;
              do {
                if (
                  ((ne = A.window_size - A.lookahead - A.strstart),
                  A.strstart >= ke + (ke - Me))
                ) {
                  for (
                    f.arraySet(A.window, A.window, ke, ke, 0),
                      A.match_start -= ke,
                      A.strstart -= ke,
                      A.block_start -= ke,
                      Ae = $e = A.hash_size;
                    (ae = A.head[--Ae]),
                      (A.head[Ae] = ke <= ae ? ae - ke : 0),
                      --$e;

                  );
                  for (
                    Ae = $e = ke;
                    (ae = A.prev[--Ae]),
                      (A.prev[Ae] = ke <= ae ? ae - ke : 0),
                      --$e;

                  );
                  ne += ke;
                }
                if (A.strm.avail_in === 0) break;
                if (
                  ((R = A.strm),
                  (te = A.window),
                  (D = A.strstart + A.lookahead),
                  (ce = ne),
                  (ue = void 0),
                  (ue = R.avail_in),
                  ce < ue && (ue = ce),
                  ($e =
                    ue === 0
                      ? 0
                      : ((R.avail_in -= ue),
                        f.arraySet(te, R.input, R.next_in, ue, D),
                        R.state.wrap === 1
                          ? (R.adler = m(R.adler, te, ue, D))
                          : R.state.wrap === 2 &&
                            (R.adler = g(R.adler, te, ue, D)),
                        (R.next_in += ue),
                        (R.total_in += ue),
                        ue)),
                  (A.lookahead += $e),
                  A.lookahead + A.insert >= se)
                )
                  for (
                    ve = A.strstart - A.insert,
                      A.ins_h = A.window[ve],
                      A.ins_h =
                        ((A.ins_h << A.hash_shift) ^ A.window[ve + 1]) &
                        A.hash_mask;
                    A.insert &&
                    ((A.ins_h =
                      ((A.ins_h << A.hash_shift) ^ A.window[ve + se - 1]) &
                      A.hash_mask),
                    (A.prev[ve & A.w_mask] = A.head[A.ins_h]),
                    (A.head[A.ins_h] = ve),
                    ve++,
                    A.insert--,
                    !(A.lookahead + A.insert < se));

                  );
              } while (A.lookahead < Me && A.strm.avail_in !== 0);
            }
            function st(A, Ae) {
              for (var $e, ae; ; ) {
                if (A.lookahead < Me) {
                  if ((We(A), A.lookahead < Me && Ae === v)) return L;
                  if (A.lookahead === 0) break;
                }
                if (
                  (($e = 0),
                  A.lookahead >= se &&
                    ((A.ins_h =
                      ((A.ins_h << A.hash_shift) ^
                        A.window[A.strstart + se - 1]) &
                      A.hash_mask),
                    ($e = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h]),
                    (A.head[A.ins_h] = A.strstart)),
                  $e !== 0 &&
                    A.strstart - $e <= A.w_size - Me &&
                    (A.match_length = Ne(A, $e)),
                  A.match_length >= se)
                )
                  if (
                    ((ae = _._tr_tally(
                      A,
                      A.strstart - A.match_start,
                      A.match_length - se
                    )),
                    (A.lookahead -= A.match_length),
                    A.match_length <= A.max_lazy_match && A.lookahead >= se)
                  ) {
                    for (
                      A.match_length--;
                      A.strstart++,
                        (A.ins_h =
                          ((A.ins_h << A.hash_shift) ^
                            A.window[A.strstart + se - 1]) &
                          A.hash_mask),
                        ($e = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h]),
                        (A.head[A.ins_h] = A.strstart),
                        --A.match_length != 0;

                    );
                    A.strstart++;
                  } else
                    (A.strstart += A.match_length),
                      (A.match_length = 0),
                      (A.ins_h = A.window[A.strstart]),
                      (A.ins_h =
                        ((A.ins_h << A.hash_shift) ^ A.window[A.strstart + 1]) &
                        A.hash_mask);
                else
                  (ae = _._tr_tally(A, 0, A.window[A.strstart])),
                    A.lookahead--,
                    A.strstart++;
                if (ae && (ge(A, !1), A.strm.avail_out === 0)) return L;
              }
              return (
                (A.insert = A.strstart < se - 1 ? A.strstart : se - 1),
                Ae === C
                  ? (ge(A, !0), A.strm.avail_out === 0 ? Qe : _e)
                  : A.last_lit && (ge(A, !1), A.strm.avail_out === 0)
                  ? L
                  : Ee
              );
            }
            function pt(A, Ae) {
              for (var $e, ae, ne; ; ) {
                if (A.lookahead < Me) {
                  if ((We(A), A.lookahead < Me && Ae === v)) return L;
                  if (A.lookahead === 0) break;
                }
                if (
                  (($e = 0),
                  A.lookahead >= se &&
                    ((A.ins_h =
                      ((A.ins_h << A.hash_shift) ^
                        A.window[A.strstart + se - 1]) &
                      A.hash_mask),
                    ($e = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h]),
                    (A.head[A.ins_h] = A.strstart)),
                  (A.prev_length = A.match_length),
                  (A.prev_match = A.match_start),
                  (A.match_length = se - 1),
                  $e !== 0 &&
                    A.prev_length < A.max_lazy_match &&
                    A.strstart - $e <= A.w_size - Me &&
                    ((A.match_length = Ne(A, $e)),
                    A.match_length <= 5 &&
                      (A.strategy === 1 ||
                        (A.match_length === se &&
                          4096 < A.strstart - A.match_start)) &&
                      (A.match_length = se - 1)),
                  A.prev_length >= se && A.match_length <= A.prev_length)
                ) {
                  for (
                    ne = A.strstart + A.lookahead - se,
                      ae = _._tr_tally(
                        A,
                        A.strstart - 1 - A.prev_match,
                        A.prev_length - se
                      ),
                      A.lookahead -= A.prev_length - 1,
                      A.prev_length -= 2;
                    ++A.strstart <= ne &&
                      ((A.ins_h =
                        ((A.ins_h << A.hash_shift) ^
                          A.window[A.strstart + se - 1]) &
                        A.hash_mask),
                      ($e = A.prev[A.strstart & A.w_mask] = A.head[A.ins_h]),
                      (A.head[A.ins_h] = A.strstart)),
                      --A.prev_length != 0;

                  );
                  if (
                    ((A.match_available = 0),
                    (A.match_length = se - 1),
                    A.strstart++,
                    ae && (ge(A, !1), A.strm.avail_out === 0))
                  )
                    return L;
                } else if (A.match_available) {
                  if (
                    ((ae = _._tr_tally(A, 0, A.window[A.strstart - 1])) &&
                      ge(A, !1),
                    A.strstart++,
                    A.lookahead--,
                    A.strm.avail_out === 0)
                  )
                    return L;
                } else (A.match_available = 1), A.strstart++, A.lookahead--;
              }
              return (
                A.match_available &&
                  ((ae = _._tr_tally(A, 0, A.window[A.strstart - 1])),
                  (A.match_available = 0)),
                (A.insert = A.strstart < se - 1 ? A.strstart : se - 1),
                Ae === C
                  ? (ge(A, !0), A.strm.avail_out === 0 ? Qe : _e)
                  : A.last_lit && (ge(A, !1), A.strm.avail_out === 0)
                  ? L
                  : Ee
              );
            }
            function Ge(A, Ae, $e, ae, ne) {
              (this.good_length = A),
                (this.max_lazy = Ae),
                (this.nice_length = $e),
                (this.max_chain = ae),
                (this.func = ne);
            }
            function Te() {
              (this.strm = null),
                (this.status = 0),
                (this.pending_buf = null),
                (this.pending_buf_size = 0),
                (this.pending_out = 0),
                (this.pending = 0),
                (this.wrap = 0),
                (this.gzhead = null),
                (this.gzindex = 0),
                (this.method = x),
                (this.last_flush = -1),
                (this.w_size = 0),
                (this.w_bits = 0),
                (this.w_mask = 0),
                (this.window = null),
                (this.window_size = 0),
                (this.prev = null),
                (this.head = null),
                (this.ins_h = 0),
                (this.hash_size = 0),
                (this.hash_bits = 0),
                (this.hash_mask = 0),
                (this.hash_shift = 0),
                (this.block_start = 0),
                (this.match_length = 0),
                (this.prev_match = 0),
                (this.match_available = 0),
                (this.strstart = 0),
                (this.match_start = 0),
                (this.lookahead = 0),
                (this.prev_length = 0),
                (this.max_chain_length = 0),
                (this.max_lazy_match = 0),
                (this.level = 0),
                (this.strategy = 0),
                (this.good_match = 0),
                (this.nice_match = 0),
                (this.dyn_ltree = new f.Buf16(2 * j)),
                (this.dyn_dtree = new f.Buf16(2 * (2 * O + 1))),
                (this.bl_tree = new f.Buf16(2 * (2 * B + 1))),
                xe(this.dyn_ltree),
                xe(this.dyn_dtree),
                xe(this.bl_tree),
                (this.l_desc = null),
                (this.d_desc = null),
                (this.bl_desc = null),
                (this.bl_count = new f.Buf16(N + 1)),
                (this.heap = new f.Buf16(2 * V + 1)),
                xe(this.heap),
                (this.heap_len = 0),
                (this.heap_max = 0),
                (this.depth = new f.Buf16(2 * V + 1)),
                xe(this.depth),
                (this.l_buf = 0),
                (this.lit_bufsize = 0),
                (this.last_lit = 0),
                (this.d_buf = 0),
                (this.opt_len = 0),
                (this.static_len = 0),
                (this.matches = 0),
                (this.insert = 0),
                (this.bi_buf = 0),
                (this.bi_valid = 0);
            }
            function je(A) {
              var Ae;
              return A && A.state
                ? ((A.total_in = A.total_out = 0),
                  (A.data_type = y),
                  ((Ae = A.state).pending = 0),
                  (Ae.pending_out = 0),
                  Ae.wrap < 0 && (Ae.wrap = -Ae.wrap),
                  (Ae.status = Ae.wrap ? J : ye),
                  (A.adler = Ae.wrap === 2 ? 0 : 1),
                  (Ae.last_flush = v),
                  _._tr_init(Ae),
                  T)
                : X(A, z);
            }
            function Ye(A) {
              var Ae = je(A);
              return (
                Ae === T &&
                  (function ($e) {
                    ($e.window_size = 2 * $e.w_size),
                      xe($e.head),
                      ($e.max_lazy_match = l[$e.level].max_lazy),
                      ($e.good_match = l[$e.level].good_length),
                      ($e.nice_match = l[$e.level].nice_length),
                      ($e.max_chain_length = l[$e.level].max_chain),
                      ($e.strstart = 0),
                      ($e.block_start = 0),
                      ($e.lookahead = 0),
                      ($e.insert = 0),
                      ($e.match_length = $e.prev_length = se - 1),
                      ($e.match_available = 0),
                      ($e.ins_h = 0);
                  })(A.state),
                Ae
              );
            }
            function et(A, Ae, $e, ae, ne, ve) {
              if (!A) return z;
              var R = 1;
              if (
                (Ae === $ && (Ae = 6),
                ae < 0
                  ? ((R = 0), (ae = -ae))
                  : 15 < ae && ((R = 2), (ae -= 16)),
                ne < 1 ||
                  I < ne ||
                  $e !== x ||
                  ae < 8 ||
                  15 < ae ||
                  Ae < 0 ||
                  9 < Ae ||
                  ve < 0 ||
                  S < ve)
              )
                return X(A, z);
              ae === 8 && (ae = 9);
              var te = new Te();
              return (
                ((A.state = te).strm = A),
                (te.wrap = R),
                (te.gzhead = null),
                (te.w_bits = ae),
                (te.w_size = 1 << te.w_bits),
                (te.w_mask = te.w_size - 1),
                (te.hash_bits = ne + 7),
                (te.hash_size = 1 << te.hash_bits),
                (te.hash_mask = te.hash_size - 1),
                (te.hash_shift = ~~((te.hash_bits + se - 1) / se)),
                (te.window = new f.Buf8(2 * te.w_size)),
                (te.head = new f.Buf16(te.hash_size)),
                (te.prev = new f.Buf16(te.w_size)),
                (te.lit_bufsize = 1 << (ne + 6)),
                (te.pending_buf_size = 4 * te.lit_bufsize),
                (te.pending_buf = new f.Buf8(te.pending_buf_size)),
                (te.d_buf = 1 * te.lit_bufsize),
                (te.l_buf = 3 * te.lit_bufsize),
                (te.level = Ae),
                (te.strategy = ve),
                (te.method = $e),
                Ye(A)
              );
            }
            (l = [
              new Ge(0, 0, 0, 0, function (A, Ae) {
                var $e = 65535;
                for (
                  $e > A.pending_buf_size - 5 && ($e = A.pending_buf_size - 5);
                  ;

                ) {
                  if (A.lookahead <= 1) {
                    if ((We(A), A.lookahead === 0 && Ae === v)) return L;
                    if (A.lookahead === 0) break;
                  }
                  (A.strstart += A.lookahead), (A.lookahead = 0);
                  var ae = A.block_start + $e;
                  if (
                    ((A.strstart === 0 || A.strstart >= ae) &&
                      ((A.lookahead = A.strstart - ae),
                      (A.strstart = ae),
                      ge(A, !1),
                      A.strm.avail_out === 0)) ||
                    (A.strstart - A.block_start >= A.w_size - Me &&
                      (ge(A, !1), A.strm.avail_out === 0))
                  )
                    return L;
                }
                return (
                  (A.insert = 0),
                  Ae === C
                    ? (ge(A, !0), A.strm.avail_out === 0 ? Qe : _e)
                    : (A.strstart > A.block_start &&
                        (ge(A, !1), A.strm.avail_out),
                      L)
                );
              }),
              new Ge(4, 4, 8, 4, st),
              new Ge(4, 5, 16, 8, st),
              new Ge(4, 6, 32, 32, st),
              new Ge(4, 4, 16, 16, pt),
              new Ge(8, 16, 32, 32, pt),
              new Ge(8, 16, 128, 128, pt),
              new Ge(8, 32, 128, 256, pt),
              new Ge(32, 128, 258, 1024, pt),
              new Ge(32, 258, 258, 4096, pt)
            ]),
              (a.deflateInit = function (A, Ae) {
                return et(A, Ae, x, 15, 8, 0);
              }),
              (a.deflateInit2 = et),
              (a.deflateReset = Ye),
              (a.deflateResetKeep = je),
              (a.deflateSetHeader = function (A, Ae) {
                return A && A.state
                  ? A.state.wrap !== 2
                    ? z
                    : ((A.state.gzhead = Ae), T)
                  : z;
              }),
              (a.deflate = function (A, Ae) {
                var $e, ae, ne, ve;
                if (!A || !A.state || 5 < Ae || Ae < 0) return A ? X(A, z) : z;
                if (
                  ((ae = A.state),
                  !A.output ||
                    (!A.input && A.avail_in !== 0) ||
                    (ae.status === 666 && Ae !== C))
                )
                  return X(A, A.avail_out === 0 ? -5 : z);
                if (
                  ((ae.strm = A),
                  ($e = ae.last_flush),
                  (ae.last_flush = Ae),
                  ae.status === J)
                )
                  if (ae.wrap === 2)
                    (A.adler = 0),
                      qe(ae, 31),
                      qe(ae, 139),
                      qe(ae, 8),
                      ae.gzhead
                        ? (qe(
                            ae,
                            (ae.gzhead.text ? 1 : 0) +
                              (ae.gzhead.hcrc ? 2 : 0) +
                              (ae.gzhead.extra ? 4 : 0) +
                              (ae.gzhead.name ? 8 : 0) +
                              (ae.gzhead.comment ? 16 : 0)
                          ),
                          qe(ae, 255 & ae.gzhead.time),
                          qe(ae, (ae.gzhead.time >> 8) & 255),
                          qe(ae, (ae.gzhead.time >> 16) & 255),
                          qe(ae, (ae.gzhead.time >> 24) & 255),
                          qe(
                            ae,
                            ae.level === 9
                              ? 2
                              : 2 <= ae.strategy || ae.level < 2
                              ? 4
                              : 0
                          ),
                          qe(ae, 255 & ae.gzhead.os),
                          ae.gzhead.extra &&
                            ae.gzhead.extra.length &&
                            (qe(ae, 255 & ae.gzhead.extra.length),
                            qe(ae, (ae.gzhead.extra.length >> 8) & 255)),
                          ae.gzhead.hcrc &&
                            (A.adler = g(
                              A.adler,
                              ae.pending_buf,
                              ae.pending,
                              0
                            )),
                          (ae.gzindex = 0),
                          (ae.status = 69))
                        : (qe(ae, 0),
                          qe(ae, 0),
                          qe(ae, 0),
                          qe(ae, 0),
                          qe(ae, 0),
                          qe(
                            ae,
                            ae.level === 9
                              ? 2
                              : 2 <= ae.strategy || ae.level < 2
                              ? 4
                              : 0
                          ),
                          qe(ae, 3),
                          (ae.status = ye));
                  else {
                    var R = (x + ((ae.w_bits - 8) << 4)) << 8;
                    (R |=
                      (2 <= ae.strategy || ae.level < 2
                        ? 0
                        : ae.level < 6
                        ? 1
                        : ae.level === 6
                        ? 2
                        : 3) << 6),
                      ae.strstart !== 0 && (R |= 32),
                      (R += 31 - (R % 31)),
                      (ae.status = ye),
                      Be(ae, R),
                      ae.strstart !== 0 &&
                        (Be(ae, A.adler >>> 16), Be(ae, 65535 & A.adler)),
                      (A.adler = 1);
                  }
                if (ae.status === 69)
                  if (ae.gzhead.extra) {
                    for (
                      ne = ae.pending;
                      ae.gzindex < (65535 & ae.gzhead.extra.length) &&
                      (ae.pending !== ae.pending_buf_size ||
                        (ae.gzhead.hcrc &&
                          ae.pending > ne &&
                          (A.adler = g(
                            A.adler,
                            ae.pending_buf,
                            ae.pending - ne,
                            ne
                          )),
                        Y(A),
                        (ne = ae.pending),
                        ae.pending !== ae.pending_buf_size));

                    )
                      qe(ae, 255 & ae.gzhead.extra[ae.gzindex]), ae.gzindex++;
                    ae.gzhead.hcrc &&
                      ae.pending > ne &&
                      (A.adler = g(
                        A.adler,
                        ae.pending_buf,
                        ae.pending - ne,
                        ne
                      )),
                      ae.gzindex === ae.gzhead.extra.length &&
                        ((ae.gzindex = 0), (ae.status = 73));
                  } else ae.status = 73;
                if (ae.status === 73)
                  if (ae.gzhead.name) {
                    ne = ae.pending;
                    do {
                      if (
                        ae.pending === ae.pending_buf_size &&
                        (ae.gzhead.hcrc &&
                          ae.pending > ne &&
                          (A.adler = g(
                            A.adler,
                            ae.pending_buf,
                            ae.pending - ne,
                            ne
                          )),
                        Y(A),
                        (ne = ae.pending),
                        ae.pending === ae.pending_buf_size)
                      ) {
                        ve = 1;
                        break;
                      }
                      (ve =
                        ae.gzindex < ae.gzhead.name.length
                          ? 255 & ae.gzhead.name.charCodeAt(ae.gzindex++)
                          : 0),
                        qe(ae, ve);
                    } while (ve !== 0);
                    ae.gzhead.hcrc &&
                      ae.pending > ne &&
                      (A.adler = g(
                        A.adler,
                        ae.pending_buf,
                        ae.pending - ne,
                        ne
                      )),
                      ve === 0 && ((ae.gzindex = 0), (ae.status = 91));
                  } else ae.status = 91;
                if (ae.status === 91)
                  if (ae.gzhead.comment) {
                    ne = ae.pending;
                    do {
                      if (
                        ae.pending === ae.pending_buf_size &&
                        (ae.gzhead.hcrc &&
                          ae.pending > ne &&
                          (A.adler = g(
                            A.adler,
                            ae.pending_buf,
                            ae.pending - ne,
                            ne
                          )),
                        Y(A),
                        (ne = ae.pending),
                        ae.pending === ae.pending_buf_size)
                      ) {
                        ve = 1;
                        break;
                      }
                      (ve =
                        ae.gzindex < ae.gzhead.comment.length
                          ? 255 & ae.gzhead.comment.charCodeAt(ae.gzindex++)
                          : 0),
                        qe(ae, ve);
                    } while (ve !== 0);
                    ae.gzhead.hcrc &&
                      ae.pending > ne &&
                      (A.adler = g(
                        A.adler,
                        ae.pending_buf,
                        ae.pending - ne,
                        ne
                      )),
                      ve === 0 && (ae.status = 103);
                  } else ae.status = 103;
                if (
                  (ae.status === 103 &&
                    (ae.gzhead.hcrc
                      ? (ae.pending + 2 > ae.pending_buf_size && Y(A),
                        ae.pending + 2 <= ae.pending_buf_size &&
                          (qe(ae, 255 & A.adler),
                          qe(ae, (A.adler >> 8) & 255),
                          (A.adler = 0),
                          (ae.status = ye)))
                      : (ae.status = ye)),
                  ae.pending !== 0)
                ) {
                  if ((Y(A), A.avail_out === 0)) return (ae.last_flush = -1), T;
                } else if (A.avail_in === 0 && oe(Ae) <= oe($e) && Ae !== C)
                  return X(A, -5);
                if (ae.status === 666 && A.avail_in !== 0) return X(A, -5);
                if (
                  A.avail_in !== 0 ||
                  ae.lookahead !== 0 ||
                  (Ae !== v && ae.status !== 666)
                ) {
                  var te =
                    ae.strategy === 2
                      ? (function (D, ce) {
                          for (var ue; ; ) {
                            if (
                              D.lookahead === 0 &&
                              (We(D), D.lookahead === 0)
                            ) {
                              if (ce === v) return L;
                              break;
                            }
                            if (
                              ((D.match_length = 0),
                              (ue = _._tr_tally(D, 0, D.window[D.strstart])),
                              D.lookahead--,
                              D.strstart++,
                              ue && (ge(D, !1), D.strm.avail_out === 0))
                            )
                              return L;
                          }
                          return (
                            (D.insert = 0),
                            ce === C
                              ? (ge(D, !0), D.strm.avail_out === 0 ? Qe : _e)
                              : D.last_lit &&
                                (ge(D, !1), D.strm.avail_out === 0)
                              ? L
                              : Ee
                          );
                        })(ae, Ae)
                      : ae.strategy === 3
                      ? (function (D, ce) {
                          for (var ue, ke, Re, ht, tt = D.window; ; ) {
                            if (D.lookahead <= de) {
                              if ((We(D), D.lookahead <= de && ce === v))
                                return L;
                              if (D.lookahead === 0) break;
                            }
                            if (
                              ((D.match_length = 0),
                              D.lookahead >= se &&
                                0 < D.strstart &&
                                (ke = tt[(Re = D.strstart - 1)]) === tt[++Re] &&
                                ke === tt[++Re] &&
                                ke === tt[++Re])
                            ) {
                              ht = D.strstart + de;
                              do;
                              while (
                                ke === tt[++Re] &&
                                ke === tt[++Re] &&
                                ke === tt[++Re] &&
                                ke === tt[++Re] &&
                                ke === tt[++Re] &&
                                ke === tt[++Re] &&
                                ke === tt[++Re] &&
                                ke === tt[++Re] &&
                                Re < ht
                              );
                              (D.match_length = de - (ht - Re)),
                                D.match_length > D.lookahead &&
                                  (D.match_length = D.lookahead);
                            }
                            if (
                              (D.match_length >= se
                                ? ((ue = _._tr_tally(
                                    D,
                                    1,
                                    D.match_length - se
                                  )),
                                  (D.lookahead -= D.match_length),
                                  (D.strstart += D.match_length),
                                  (D.match_length = 0))
                                : ((ue = _._tr_tally(
                                    D,
                                    0,
                                    D.window[D.strstart]
                                  )),
                                  D.lookahead--,
                                  D.strstart++),
                              ue && (ge(D, !1), D.strm.avail_out === 0))
                            )
                              return L;
                          }
                          return (
                            (D.insert = 0),
                            ce === C
                              ? (ge(D, !0), D.strm.avail_out === 0 ? Qe : _e)
                              : D.last_lit &&
                                (ge(D, !1), D.strm.avail_out === 0)
                              ? L
                              : Ee
                          );
                        })(ae, Ae)
                      : l[ae.level].func(ae, Ae);
                  if (
                    ((te !== Qe && te !== _e) || (ae.status = 666),
                    te === L || te === Qe)
                  )
                    return A.avail_out === 0 && (ae.last_flush = -1), T;
                  if (
                    te === Ee &&
                    (Ae === 1
                      ? _._tr_align(ae)
                      : Ae !== 5 &&
                        (_._tr_stored_block(ae, 0, 0, !1),
                        Ae === 3 &&
                          (xe(ae.head),
                          ae.lookahead === 0 &&
                            ((ae.strstart = 0),
                            (ae.block_start = 0),
                            (ae.insert = 0)))),
                    Y(A),
                    A.avail_out === 0)
                  )
                    return (ae.last_flush = -1), T;
                }
                return Ae !== C
                  ? T
                  : ae.wrap <= 0
                  ? 1
                  : (ae.wrap === 2
                      ? (qe(ae, 255 & A.adler),
                        qe(ae, (A.adler >> 8) & 255),
                        qe(ae, (A.adler >> 16) & 255),
                        qe(ae, (A.adler >> 24) & 255),
                        qe(ae, 255 & A.total_in),
                        qe(ae, (A.total_in >> 8) & 255),
                        qe(ae, (A.total_in >> 16) & 255),
                        qe(ae, (A.total_in >> 24) & 255))
                      : (Be(ae, A.adler >>> 16), Be(ae, 65535 & A.adler)),
                    Y(A),
                    0 < ae.wrap && (ae.wrap = -ae.wrap),
                    ae.pending !== 0 ? T : 1);
              }),
              (a.deflateEnd = function (A) {
                var Ae;
                return A && A.state
                  ? (Ae = A.state.status) !== J &&
                    Ae !== 69 &&
                    Ae !== 73 &&
                    Ae !== 91 &&
                    Ae !== 103 &&
                    Ae !== ye &&
                    Ae !== 666
                    ? X(A, z)
                    : ((A.state = null), Ae === ye ? X(A, -3) : T)
                  : z;
              }),
              (a.deflateSetDictionary = function (A, Ae) {
                var $e,
                  ae,
                  ne,
                  ve,
                  R,
                  te,
                  D,
                  ce,
                  ue = Ae.length;
                if (
                  !A ||
                  !A.state ||
                  (ve = ($e = A.state).wrap) === 2 ||
                  (ve === 1 && $e.status !== J) ||
                  $e.lookahead
                )
                  return z;
                for (
                  ve === 1 && (A.adler = m(A.adler, Ae, ue, 0)),
                    $e.wrap = 0,
                    ue >= $e.w_size &&
                      (ve === 0 &&
                        (xe($e.head),
                        ($e.strstart = 0),
                        ($e.block_start = 0),
                        ($e.insert = 0)),
                      (ce = new f.Buf8($e.w_size)),
                      f.arraySet(ce, Ae, ue - $e.w_size, $e.w_size, 0),
                      (Ae = ce),
                      (ue = $e.w_size)),
                    R = A.avail_in,
                    te = A.next_in,
                    D = A.input,
                    A.avail_in = ue,
                    A.next_in = 0,
                    A.input = Ae,
                    We($e);
                  $e.lookahead >= se;

                ) {
                  for (
                    ae = $e.strstart, ne = $e.lookahead - (se - 1);
                    ($e.ins_h =
                      (($e.ins_h << $e.hash_shift) ^ $e.window[ae + se - 1]) &
                      $e.hash_mask),
                      ($e.prev[ae & $e.w_mask] = $e.head[$e.ins_h]),
                      ($e.head[$e.ins_h] = ae),
                      ae++,
                      --ne;

                  );
                  ($e.strstart = ae), ($e.lookahead = se - 1), We($e);
                }
                return (
                  ($e.strstart += $e.lookahead),
                  ($e.block_start = $e.strstart),
                  ($e.insert = $e.lookahead),
                  ($e.lookahead = 0),
                  ($e.match_length = $e.prev_length = se - 1),
                  ($e.match_available = 0),
                  (A.next_in = te),
                  (A.input = D),
                  (A.avail_in = R),
                  ($e.wrap = ve),
                  T
                );
              }),
              (a.deflateInfo = "pako deflate (from Nodeca project)");
          },
          {
            "../utils/common": 41,
            "./adler32": 43,
            "./crc32": 45,
            "./messages": 51,
            "./trees": 52
          }
        ],
        47: [
          function (n, o, a) {
            o.exports = function () {
              (this.text = 0),
                (this.time = 0),
                (this.xflags = 0),
                (this.os = 0),
                (this.extra = null),
                (this.extra_len = 0),
                (this.name = ""),
                (this.comment = ""),
                (this.hcrc = 0),
                (this.done = !1);
            };
          },
          {}
        ],
        48: [
          function (n, o, a) {
            o.exports = function (l, f) {
              var _,
                m,
                g,
                M,
                v,
                C,
                T,
                z,
                $,
                S,
                y,
                x,
                I,
                V,
                O,
                B,
                j,
                N,
                se,
                de,
                Me,
                J,
                ye,
                L,
                Ee;
              (_ = l.state),
                (m = l.next_in),
                (L = l.input),
                (g = m + (l.avail_in - 5)),
                (M = l.next_out),
                (Ee = l.output),
                (v = M - (f - l.avail_out)),
                (C = M + (l.avail_out - 257)),
                (T = _.dmax),
                (z = _.wsize),
                ($ = _.whave),
                (S = _.wnext),
                (y = _.window),
                (x = _.hold),
                (I = _.bits),
                (V = _.lencode),
                (O = _.distcode),
                (B = (1 << _.lenbits) - 1),
                (j = (1 << _.distbits) - 1);
              e: do {
                I < 15 &&
                  ((x += L[m++] << I), (I += 8), (x += L[m++] << I), (I += 8)),
                  (N = V[x & B]);
                t: for (;;) {
                  if (
                    ((x >>>= se = N >>> 24),
                    (I -= se),
                    (se = (N >>> 16) & 255) === 0)
                  )
                    Ee[M++] = 65535 & N;
                  else {
                    if (!(16 & se)) {
                      if (!(64 & se)) {
                        N = V[(65535 & N) + (x & ((1 << se) - 1))];
                        continue t;
                      }
                      if (32 & se) {
                        _.mode = 12;
                        break e;
                      }
                      (l.msg = "invalid literal/length code"), (_.mode = 30);
                      break e;
                    }
                    (de = 65535 & N),
                      (se &= 15) &&
                        (I < se && ((x += L[m++] << I), (I += 8)),
                        (de += x & ((1 << se) - 1)),
                        (x >>>= se),
                        (I -= se)),
                      I < 15 &&
                        ((x += L[m++] << I),
                        (I += 8),
                        (x += L[m++] << I),
                        (I += 8)),
                      (N = O[x & j]);
                    r: for (;;) {
                      if (
                        ((x >>>= se = N >>> 24),
                        (I -= se),
                        !(16 & (se = (N >>> 16) & 255)))
                      ) {
                        if (!(64 & se)) {
                          N = O[(65535 & N) + (x & ((1 << se) - 1))];
                          continue r;
                        }
                        (l.msg = "invalid distance code"), (_.mode = 30);
                        break e;
                      }
                      if (
                        ((Me = 65535 & N),
                        I < (se &= 15) &&
                          ((x += L[m++] << I),
                          (I += 8) < se && ((x += L[m++] << I), (I += 8))),
                        T < (Me += x & ((1 << se) - 1)))
                      ) {
                        (l.msg = "invalid distance too far back"),
                          (_.mode = 30);
                        break e;
                      }
                      if (((x >>>= se), (I -= se), (se = M - v) < Me)) {
                        if ($ < (se = Me - se) && _.sane) {
                          (l.msg = "invalid distance too far back"),
                            (_.mode = 30);
                          break e;
                        }
                        if (((ye = y), (J = 0) === S)) {
                          if (((J += z - se), se < de)) {
                            for (de -= se; (Ee[M++] = y[J++]), --se; );
                            (J = M - Me), (ye = Ee);
                          }
                        } else if (S < se) {
                          if (((J += z + S - se), (se -= S) < de)) {
                            for (de -= se; (Ee[M++] = y[J++]), --se; );
                            if (((J = 0), S < de)) {
                              for (de -= se = S; (Ee[M++] = y[J++]), --se; );
                              (J = M - Me), (ye = Ee);
                            }
                          }
                        } else if (((J += S - se), se < de)) {
                          for (de -= se; (Ee[M++] = y[J++]), --se; );
                          (J = M - Me), (ye = Ee);
                        }
                        for (; 2 < de; )
                          (Ee[M++] = ye[J++]),
                            (Ee[M++] = ye[J++]),
                            (Ee[M++] = ye[J++]),
                            (de -= 3);
                        de &&
                          ((Ee[M++] = ye[J++]), 1 < de && (Ee[M++] = ye[J++]));
                      } else {
                        for (
                          J = M - Me;
                          (Ee[M++] = Ee[J++]),
                            (Ee[M++] = Ee[J++]),
                            (Ee[M++] = Ee[J++]),
                            2 < (de -= 3);

                        );
                        de &&
                          ((Ee[M++] = Ee[J++]), 1 < de && (Ee[M++] = Ee[J++]));
                      }
                      break;
                    }
                  }
                  break;
                }
              } while (m < g && M < C);
              (m -= de = I >> 3),
                (x &= (1 << (I -= de << 3)) - 1),
                (l.next_in = m),
                (l.next_out = M),
                (l.avail_in = m < g ? g - m + 5 : 5 - (m - g)),
                (l.avail_out = M < C ? C - M + 257 : 257 - (M - C)),
                (_.hold = x),
                (_.bits = I);
            };
          },
          {}
        ],
        49: [
          function (n, o, a) {
            var l = n("../utils/common"),
              f = n("./adler32"),
              _ = n("./crc32"),
              m = n("./inffast"),
              g = n("./inftrees"),
              M = 1,
              v = 2,
              C = 0,
              T = -2,
              z = 1,
              $ = 852,
              S = 592;
            function y(J) {
              return (
                ((J >>> 24) & 255) +
                ((J >>> 8) & 65280) +
                ((65280 & J) << 8) +
                ((255 & J) << 24)
              );
            }
            function x() {
              (this.mode = 0),
                (this.last = !1),
                (this.wrap = 0),
                (this.havedict = !1),
                (this.flags = 0),
                (this.dmax = 0),
                (this.check = 0),
                (this.total = 0),
                (this.head = null),
                (this.wbits = 0),
                (this.wsize = 0),
                (this.whave = 0),
                (this.wnext = 0),
                (this.window = null),
                (this.hold = 0),
                (this.bits = 0),
                (this.length = 0),
                (this.offset = 0),
                (this.extra = 0),
                (this.lencode = null),
                (this.distcode = null),
                (this.lenbits = 0),
                (this.distbits = 0),
                (this.ncode = 0),
                (this.nlen = 0),
                (this.ndist = 0),
                (this.have = 0),
                (this.next = null),
                (this.lens = new l.Buf16(320)),
                (this.work = new l.Buf16(288)),
                (this.lendyn = null),
                (this.distdyn = null),
                (this.sane = 0),
                (this.back = 0),
                (this.was = 0);
            }
            function I(J) {
              var ye;
              return J && J.state
                ? ((ye = J.state),
                  (J.total_in = J.total_out = ye.total = 0),
                  (J.msg = ""),
                  ye.wrap && (J.adler = 1 & ye.wrap),
                  (ye.mode = z),
                  (ye.last = 0),
                  (ye.havedict = 0),
                  (ye.dmax = 32768),
                  (ye.head = null),
                  (ye.hold = 0),
                  (ye.bits = 0),
                  (ye.lencode = ye.lendyn = new l.Buf32($)),
                  (ye.distcode = ye.distdyn = new l.Buf32(S)),
                  (ye.sane = 1),
                  (ye.back = -1),
                  C)
                : T;
            }
            function V(J) {
              var ye;
              return J && J.state
                ? (((ye = J.state).wsize = 0),
                  (ye.whave = 0),
                  (ye.wnext = 0),
                  I(J))
                : T;
            }
            function O(J, ye) {
              var L, Ee;
              return J && J.state
                ? ((Ee = J.state),
                  ye < 0
                    ? ((L = 0), (ye = -ye))
                    : ((L = 1 + (ye >> 4)), ye < 48 && (ye &= 15)),
                  ye && (ye < 8 || 15 < ye)
                    ? T
                    : (Ee.window !== null &&
                        Ee.wbits !== ye &&
                        (Ee.window = null),
                      (Ee.wrap = L),
                      (Ee.wbits = ye),
                      V(J)))
                : T;
            }
            function B(J, ye) {
              var L, Ee;
              return J
                ? ((Ee = new x()),
                  ((J.state = Ee).window = null),
                  (L = O(J, ye)) !== C && (J.state = null),
                  L)
                : T;
            }
            var j,
              N,
              se = !0;
            function de(J) {
              if (se) {
                var ye;
                for (
                  j = new l.Buf32(512), N = new l.Buf32(32), ye = 0;
                  ye < 144;

                )
                  J.lens[ye++] = 8;
                for (; ye < 256; ) J.lens[ye++] = 9;
                for (; ye < 280; ) J.lens[ye++] = 7;
                for (; ye < 288; ) J.lens[ye++] = 8;
                for (
                  g(M, J.lens, 0, 288, j, 0, J.work, { bits: 9 }), ye = 0;
                  ye < 32;

                )
                  J.lens[ye++] = 5;
                g(v, J.lens, 0, 32, N, 0, J.work, { bits: 5 }), (se = !1);
              }
              (J.lencode = j),
                (J.lenbits = 9),
                (J.distcode = N),
                (J.distbits = 5);
            }
            function Me(J, ye, L, Ee) {
              var Qe,
                _e = J.state;
              return (
                _e.window === null &&
                  ((_e.wsize = 1 << _e.wbits),
                  (_e.wnext = 0),
                  (_e.whave = 0),
                  (_e.window = new l.Buf8(_e.wsize))),
                Ee >= _e.wsize
                  ? (l.arraySet(_e.window, ye, L - _e.wsize, _e.wsize, 0),
                    (_e.wnext = 0),
                    (_e.whave = _e.wsize))
                  : (Ee < (Qe = _e.wsize - _e.wnext) && (Qe = Ee),
                    l.arraySet(_e.window, ye, L - Ee, Qe, _e.wnext),
                    (Ee -= Qe)
                      ? (l.arraySet(_e.window, ye, L - Ee, Ee, 0),
                        (_e.wnext = Ee),
                        (_e.whave = _e.wsize))
                      : ((_e.wnext += Qe),
                        _e.wnext === _e.wsize && (_e.wnext = 0),
                        _e.whave < _e.wsize && (_e.whave += Qe))),
                0
              );
            }
            (a.inflateReset = V),
              (a.inflateReset2 = O),
              (a.inflateResetKeep = I),
              (a.inflateInit = function (J) {
                return B(J, 15);
              }),
              (a.inflateInit2 = B),
              (a.inflate = function (J, ye) {
                var L,
                  Ee,
                  Qe,
                  _e,
                  X,
                  oe,
                  xe,
                  Y,
                  ge,
                  qe,
                  Be,
                  Ne,
                  We,
                  st,
                  pt,
                  Ge,
                  Te,
                  je,
                  Ye,
                  et,
                  A,
                  Ae,
                  $e,
                  ae,
                  ne = 0,
                  ve = new l.Buf8(4),
                  R = [
                    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14,
                    1, 15
                  ];
                if (
                  !J ||
                  !J.state ||
                  !J.output ||
                  (!J.input && J.avail_in !== 0)
                )
                  return T;
                (L = J.state).mode === 12 && (L.mode = 13),
                  (X = J.next_out),
                  (Qe = J.output),
                  (xe = J.avail_out),
                  (_e = J.next_in),
                  (Ee = J.input),
                  (oe = J.avail_in),
                  (Y = L.hold),
                  (ge = L.bits),
                  (qe = oe),
                  (Be = xe),
                  (Ae = C);
                e: for (;;)
                  switch (L.mode) {
                    case z:
                      if (L.wrap === 0) {
                        L.mode = 13;
                        break;
                      }
                      for (; ge < 16; ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      if (2 & L.wrap && Y === 35615) {
                        (ve[(L.check = 0)] = 255 & Y),
                          (ve[1] = (Y >>> 8) & 255),
                          (L.check = _(L.check, ve, 2, 0)),
                          (ge = Y = 0),
                          (L.mode = 2);
                        break;
                      }
                      if (
                        ((L.flags = 0),
                        L.head && (L.head.done = !1),
                        !(1 & L.wrap) || (((255 & Y) << 8) + (Y >> 8)) % 31)
                      ) {
                        (J.msg = "incorrect header check"), (L.mode = 30);
                        break;
                      }
                      if ((15 & Y) != 8) {
                        (J.msg = "unknown compression method"), (L.mode = 30);
                        break;
                      }
                      if (
                        ((ge -= 4), (A = 8 + (15 & (Y >>>= 4))), L.wbits === 0)
                      )
                        L.wbits = A;
                      else if (A > L.wbits) {
                        (J.msg = "invalid window size"), (L.mode = 30);
                        break;
                      }
                      (L.dmax = 1 << A),
                        (J.adler = L.check = 1),
                        (L.mode = 512 & Y ? 10 : 12),
                        (ge = Y = 0);
                      break;
                    case 2:
                      for (; ge < 16; ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      if (((L.flags = Y), (255 & L.flags) != 8)) {
                        (J.msg = "unknown compression method"), (L.mode = 30);
                        break;
                      }
                      if (57344 & L.flags) {
                        (J.msg = "unknown header flags set"), (L.mode = 30);
                        break;
                      }
                      L.head && (L.head.text = (Y >> 8) & 1),
                        512 & L.flags &&
                          ((ve[0] = 255 & Y),
                          (ve[1] = (Y >>> 8) & 255),
                          (L.check = _(L.check, ve, 2, 0))),
                        (ge = Y = 0),
                        (L.mode = 3);
                    case 3:
                      for (; ge < 32; ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      L.head && (L.head.time = Y),
                        512 & L.flags &&
                          ((ve[0] = 255 & Y),
                          (ve[1] = (Y >>> 8) & 255),
                          (ve[2] = (Y >>> 16) & 255),
                          (ve[3] = (Y >>> 24) & 255),
                          (L.check = _(L.check, ve, 4, 0))),
                        (ge = Y = 0),
                        (L.mode = 4);
                    case 4:
                      for (; ge < 16; ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      L.head &&
                        ((L.head.xflags = 255 & Y), (L.head.os = Y >> 8)),
                        512 & L.flags &&
                          ((ve[0] = 255 & Y),
                          (ve[1] = (Y >>> 8) & 255),
                          (L.check = _(L.check, ve, 2, 0))),
                        (ge = Y = 0),
                        (L.mode = 5);
                    case 5:
                      if (1024 & L.flags) {
                        for (; ge < 16; ) {
                          if (oe === 0) break e;
                          oe--, (Y += Ee[_e++] << ge), (ge += 8);
                        }
                        (L.length = Y),
                          L.head && (L.head.extra_len = Y),
                          512 & L.flags &&
                            ((ve[0] = 255 & Y),
                            (ve[1] = (Y >>> 8) & 255),
                            (L.check = _(L.check, ve, 2, 0))),
                          (ge = Y = 0);
                      } else L.head && (L.head.extra = null);
                      L.mode = 6;
                    case 6:
                      if (
                        1024 & L.flags &&
                        (oe < (Ne = L.length) && (Ne = oe),
                        Ne &&
                          (L.head &&
                            ((A = L.head.extra_len - L.length),
                            L.head.extra ||
                              (L.head.extra = new Array(L.head.extra_len)),
                            l.arraySet(L.head.extra, Ee, _e, Ne, A)),
                          512 & L.flags && (L.check = _(L.check, Ee, Ne, _e)),
                          (oe -= Ne),
                          (_e += Ne),
                          (L.length -= Ne)),
                        L.length)
                      )
                        break e;
                      (L.length = 0), (L.mode = 7);
                    case 7:
                      if (2048 & L.flags) {
                        if (oe === 0) break e;
                        for (
                          Ne = 0;
                          (A = Ee[_e + Ne++]),
                            L.head &&
                              A &&
                              L.length < 65536 &&
                              (L.head.name += String.fromCharCode(A)),
                            A && Ne < oe;

                        );
                        if (
                          (512 & L.flags && (L.check = _(L.check, Ee, Ne, _e)),
                          (oe -= Ne),
                          (_e += Ne),
                          A)
                        )
                          break e;
                      } else L.head && (L.head.name = null);
                      (L.length = 0), (L.mode = 8);
                    case 8:
                      if (4096 & L.flags) {
                        if (oe === 0) break e;
                        for (
                          Ne = 0;
                          (A = Ee[_e + Ne++]),
                            L.head &&
                              A &&
                              L.length < 65536 &&
                              (L.head.comment += String.fromCharCode(A)),
                            A && Ne < oe;

                        );
                        if (
                          (512 & L.flags && (L.check = _(L.check, Ee, Ne, _e)),
                          (oe -= Ne),
                          (_e += Ne),
                          A)
                        )
                          break e;
                      } else L.head && (L.head.comment = null);
                      L.mode = 9;
                    case 9:
                      if (512 & L.flags) {
                        for (; ge < 16; ) {
                          if (oe === 0) break e;
                          oe--, (Y += Ee[_e++] << ge), (ge += 8);
                        }
                        if (Y !== (65535 & L.check)) {
                          (J.msg = "header crc mismatch"), (L.mode = 30);
                          break;
                        }
                        ge = Y = 0;
                      }
                      L.head &&
                        ((L.head.hcrc = (L.flags >> 9) & 1),
                        (L.head.done = !0)),
                        (J.adler = L.check = 0),
                        (L.mode = 12);
                      break;
                    case 10:
                      for (; ge < 32; ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      (J.adler = L.check = y(Y)), (ge = Y = 0), (L.mode = 11);
                    case 11:
                      if (L.havedict === 0)
                        return (
                          (J.next_out = X),
                          (J.avail_out = xe),
                          (J.next_in = _e),
                          (J.avail_in = oe),
                          (L.hold = Y),
                          (L.bits = ge),
                          2
                        );
                      (J.adler = L.check = 1), (L.mode = 12);
                    case 12:
                      if (ye === 5 || ye === 6) break e;
                    case 13:
                      if (L.last) {
                        (Y >>>= 7 & ge), (ge -= 7 & ge), (L.mode = 27);
                        break;
                      }
                      for (; ge < 3; ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      switch (((L.last = 1 & Y), (ge -= 1), 3 & (Y >>>= 1))) {
                        case 0:
                          L.mode = 14;
                          break;
                        case 1:
                          if ((de(L), (L.mode = 20), ye !== 6)) break;
                          (Y >>>= 2), (ge -= 2);
                          break e;
                        case 2:
                          L.mode = 17;
                          break;
                        case 3:
                          (J.msg = "invalid block type"), (L.mode = 30);
                      }
                      (Y >>>= 2), (ge -= 2);
                      break;
                    case 14:
                      for (Y >>>= 7 & ge, ge -= 7 & ge; ge < 32; ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      if ((65535 & Y) != ((Y >>> 16) ^ 65535)) {
                        (J.msg = "invalid stored block lengths"), (L.mode = 30);
                        break;
                      }
                      if (
                        ((L.length = 65535 & Y),
                        (ge = Y = 0),
                        (L.mode = 15),
                        ye === 6)
                      )
                        break e;
                    case 15:
                      L.mode = 16;
                    case 16:
                      if ((Ne = L.length)) {
                        if (
                          (oe < Ne && (Ne = oe), xe < Ne && (Ne = xe), Ne === 0)
                        )
                          break e;
                        l.arraySet(Qe, Ee, _e, Ne, X),
                          (oe -= Ne),
                          (_e += Ne),
                          (xe -= Ne),
                          (X += Ne),
                          (L.length -= Ne);
                        break;
                      }
                      L.mode = 12;
                      break;
                    case 17:
                      for (; ge < 14; ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      if (
                        ((L.nlen = 257 + (31 & Y)),
                        (Y >>>= 5),
                        (ge -= 5),
                        (L.ndist = 1 + (31 & Y)),
                        (Y >>>= 5),
                        (ge -= 5),
                        (L.ncode = 4 + (15 & Y)),
                        (Y >>>= 4),
                        (ge -= 4),
                        286 < L.nlen || 30 < L.ndist)
                      ) {
                        (J.msg = "too many length or distance symbols"),
                          (L.mode = 30);
                        break;
                      }
                      (L.have = 0), (L.mode = 18);
                    case 18:
                      for (; L.have < L.ncode; ) {
                        for (; ge < 3; ) {
                          if (oe === 0) break e;
                          oe--, (Y += Ee[_e++] << ge), (ge += 8);
                        }
                        (L.lens[R[L.have++]] = 7 & Y), (Y >>>= 3), (ge -= 3);
                      }
                      for (; L.have < 19; ) L.lens[R[L.have++]] = 0;
                      if (
                        ((L.lencode = L.lendyn),
                        (L.lenbits = 7),
                        ($e = { bits: L.lenbits }),
                        (Ae = g(0, L.lens, 0, 19, L.lencode, 0, L.work, $e)),
                        (L.lenbits = $e.bits),
                        Ae)
                      ) {
                        (J.msg = "invalid code lengths set"), (L.mode = 30);
                        break;
                      }
                      (L.have = 0), (L.mode = 19);
                    case 19:
                      for (; L.have < L.nlen + L.ndist; ) {
                        for (
                          ;
                          (Ge =
                            ((ne = L.lencode[Y & ((1 << L.lenbits) - 1)]) >>>
                              16) &
                            255),
                            (Te = 65535 & ne),
                            !((pt = ne >>> 24) <= ge);

                        ) {
                          if (oe === 0) break e;
                          oe--, (Y += Ee[_e++] << ge), (ge += 8);
                        }
                        if (Te < 16)
                          (Y >>>= pt), (ge -= pt), (L.lens[L.have++] = Te);
                        else {
                          if (Te === 16) {
                            for (ae = pt + 2; ge < ae; ) {
                              if (oe === 0) break e;
                              oe--, (Y += Ee[_e++] << ge), (ge += 8);
                            }
                            if (((Y >>>= pt), (ge -= pt), L.have === 0)) {
                              (J.msg = "invalid bit length repeat"),
                                (L.mode = 30);
                              break;
                            }
                            (A = L.lens[L.have - 1]),
                              (Ne = 3 + (3 & Y)),
                              (Y >>>= 2),
                              (ge -= 2);
                          } else if (Te === 17) {
                            for (ae = pt + 3; ge < ae; ) {
                              if (oe === 0) break e;
                              oe--, (Y += Ee[_e++] << ge), (ge += 8);
                            }
                            (ge -= pt),
                              (A = 0),
                              (Ne = 3 + (7 & (Y >>>= pt))),
                              (Y >>>= 3),
                              (ge -= 3);
                          } else {
                            for (ae = pt + 7; ge < ae; ) {
                              if (oe === 0) break e;
                              oe--, (Y += Ee[_e++] << ge), (ge += 8);
                            }
                            (ge -= pt),
                              (A = 0),
                              (Ne = 11 + (127 & (Y >>>= pt))),
                              (Y >>>= 7),
                              (ge -= 7);
                          }
                          if (L.have + Ne > L.nlen + L.ndist) {
                            (J.msg = "invalid bit length repeat"),
                              (L.mode = 30);
                            break;
                          }
                          for (; Ne--; ) L.lens[L.have++] = A;
                        }
                      }
                      if (L.mode === 30) break;
                      if (L.lens[256] === 0) {
                        (J.msg = "invalid code -- missing end-of-block"),
                          (L.mode = 30);
                        break;
                      }
                      if (
                        ((L.lenbits = 9),
                        ($e = { bits: L.lenbits }),
                        (Ae = g(
                          M,
                          L.lens,
                          0,
                          L.nlen,
                          L.lencode,
                          0,
                          L.work,
                          $e
                        )),
                        (L.lenbits = $e.bits),
                        Ae)
                      ) {
                        (J.msg = "invalid literal/lengths set"), (L.mode = 30);
                        break;
                      }
                      if (
                        ((L.distbits = 6),
                        (L.distcode = L.distdyn),
                        ($e = { bits: L.distbits }),
                        (Ae = g(
                          v,
                          L.lens,
                          L.nlen,
                          L.ndist,
                          L.distcode,
                          0,
                          L.work,
                          $e
                        )),
                        (L.distbits = $e.bits),
                        Ae)
                      ) {
                        (J.msg = "invalid distances set"), (L.mode = 30);
                        break;
                      }
                      if (((L.mode = 20), ye === 6)) break e;
                    case 20:
                      L.mode = 21;
                    case 21:
                      if (6 <= oe && 258 <= xe) {
                        (J.next_out = X),
                          (J.avail_out = xe),
                          (J.next_in = _e),
                          (J.avail_in = oe),
                          (L.hold = Y),
                          (L.bits = ge),
                          m(J, Be),
                          (X = J.next_out),
                          (Qe = J.output),
                          (xe = J.avail_out),
                          (_e = J.next_in),
                          (Ee = J.input),
                          (oe = J.avail_in),
                          (Y = L.hold),
                          (ge = L.bits),
                          L.mode === 12 && (L.back = -1);
                        break;
                      }
                      for (
                        L.back = 0;
                        (Ge =
                          ((ne = L.lencode[Y & ((1 << L.lenbits) - 1)]) >>>
                            16) &
                          255),
                          (Te = 65535 & ne),
                          !((pt = ne >>> 24) <= ge);

                      ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      if (Ge && !(240 & Ge)) {
                        for (
                          je = pt, Ye = Ge, et = Te;
                          (Ge =
                            ((ne =
                              L.lencode[
                                et + ((Y & ((1 << (je + Ye)) - 1)) >> je)
                              ]) >>>
                              16) &
                            255),
                            (Te = 65535 & ne),
                            !(je + (pt = ne >>> 24) <= ge);

                        ) {
                          if (oe === 0) break e;
                          oe--, (Y += Ee[_e++] << ge), (ge += 8);
                        }
                        (Y >>>= je), (ge -= je), (L.back += je);
                      }
                      if (
                        ((Y >>>= pt),
                        (ge -= pt),
                        (L.back += pt),
                        (L.length = Te),
                        Ge === 0)
                      ) {
                        L.mode = 26;
                        break;
                      }
                      if (32 & Ge) {
                        (L.back = -1), (L.mode = 12);
                        break;
                      }
                      if (64 & Ge) {
                        (J.msg = "invalid literal/length code"), (L.mode = 30);
                        break;
                      }
                      (L.extra = 15 & Ge), (L.mode = 22);
                    case 22:
                      if (L.extra) {
                        for (ae = L.extra; ge < ae; ) {
                          if (oe === 0) break e;
                          oe--, (Y += Ee[_e++] << ge), (ge += 8);
                        }
                        (L.length += Y & ((1 << L.extra) - 1)),
                          (Y >>>= L.extra),
                          (ge -= L.extra),
                          (L.back += L.extra);
                      }
                      (L.was = L.length), (L.mode = 23);
                    case 23:
                      for (
                        ;
                        (Ge =
                          ((ne = L.distcode[Y & ((1 << L.distbits) - 1)]) >>>
                            16) &
                          255),
                          (Te = 65535 & ne),
                          !((pt = ne >>> 24) <= ge);

                      ) {
                        if (oe === 0) break e;
                        oe--, (Y += Ee[_e++] << ge), (ge += 8);
                      }
                      if (!(240 & Ge)) {
                        for (
                          je = pt, Ye = Ge, et = Te;
                          (Ge =
                            ((ne =
                              L.distcode[
                                et + ((Y & ((1 << (je + Ye)) - 1)) >> je)
                              ]) >>>
                              16) &
                            255),
                            (Te = 65535 & ne),
                            !(je + (pt = ne >>> 24) <= ge);

                        ) {
                          if (oe === 0) break e;
                          oe--, (Y += Ee[_e++] << ge), (ge += 8);
                        }
                        (Y >>>= je), (ge -= je), (L.back += je);
                      }
                      if (((Y >>>= pt), (ge -= pt), (L.back += pt), 64 & Ge)) {
                        (J.msg = "invalid distance code"), (L.mode = 30);
                        break;
                      }
                      (L.offset = Te), (L.extra = 15 & Ge), (L.mode = 24);
                    case 24:
                      if (L.extra) {
                        for (ae = L.extra; ge < ae; ) {
                          if (oe === 0) break e;
                          oe--, (Y += Ee[_e++] << ge), (ge += 8);
                        }
                        (L.offset += Y & ((1 << L.extra) - 1)),
                          (Y >>>= L.extra),
                          (ge -= L.extra),
                          (L.back += L.extra);
                      }
                      if (L.offset > L.dmax) {
                        (J.msg = "invalid distance too far back"),
                          (L.mode = 30);
                        break;
                      }
                      L.mode = 25;
                    case 25:
                      if (xe === 0) break e;
                      if (((Ne = Be - xe), L.offset > Ne)) {
                        if ((Ne = L.offset - Ne) > L.whave && L.sane) {
                          (J.msg = "invalid distance too far back"),
                            (L.mode = 30);
                          break;
                        }
                        (We =
                          Ne > L.wnext
                            ? ((Ne -= L.wnext), L.wsize - Ne)
                            : L.wnext - Ne),
                          Ne > L.length && (Ne = L.length),
                          (st = L.window);
                      } else (st = Qe), (We = X - L.offset), (Ne = L.length);
                      for (
                        xe < Ne && (Ne = xe), xe -= Ne, L.length -= Ne;
                        (Qe[X++] = st[We++]), --Ne;

                      );
                      L.length === 0 && (L.mode = 21);
                      break;
                    case 26:
                      if (xe === 0) break e;
                      (Qe[X++] = L.length), xe--, (L.mode = 21);
                      break;
                    case 27:
                      if (L.wrap) {
                        for (; ge < 32; ) {
                          if (oe === 0) break e;
                          oe--, (Y |= Ee[_e++] << ge), (ge += 8);
                        }
                        if (
                          ((Be -= xe),
                          (J.total_out += Be),
                          (L.total += Be),
                          Be &&
                            (J.adler = L.check =
                              L.flags
                                ? _(L.check, Qe, Be, X - Be)
                                : f(L.check, Qe, Be, X - Be)),
                          (Be = xe),
                          (L.flags ? Y : y(Y)) !== L.check)
                        ) {
                          (J.msg = "incorrect data check"), (L.mode = 30);
                          break;
                        }
                        ge = Y = 0;
                      }
                      L.mode = 28;
                    case 28:
                      if (L.wrap && L.flags) {
                        for (; ge < 32; ) {
                          if (oe === 0) break e;
                          oe--, (Y += Ee[_e++] << ge), (ge += 8);
                        }
                        if (Y !== (4294967295 & L.total)) {
                          (J.msg = "incorrect length check"), (L.mode = 30);
                          break;
                        }
                        ge = Y = 0;
                      }
                      L.mode = 29;
                    case 29:
                      Ae = 1;
                      break e;
                    case 30:
                      Ae = -3;
                      break e;
                    case 31:
                      return -4;
                    case 32:
                    default:
                      return T;
                  }
                return (
                  (J.next_out = X),
                  (J.avail_out = xe),
                  (J.next_in = _e),
                  (J.avail_in = oe),
                  (L.hold = Y),
                  (L.bits = ge),
                  (L.wsize ||
                    (Be !== J.avail_out &&
                      L.mode < 30 &&
                      (L.mode < 27 || ye !== 4))) &&
                  Me(J, J.output, J.next_out, Be - J.avail_out)
                    ? ((L.mode = 31), -4)
                    : ((qe -= J.avail_in),
                      (Be -= J.avail_out),
                      (J.total_in += qe),
                      (J.total_out += Be),
                      (L.total += Be),
                      L.wrap &&
                        Be &&
                        (J.adler = L.check =
                          L.flags
                            ? _(L.check, Qe, Be, J.next_out - Be)
                            : f(L.check, Qe, Be, J.next_out - Be)),
                      (J.data_type =
                        L.bits +
                        (L.last ? 64 : 0) +
                        (L.mode === 12 ? 128 : 0) +
                        (L.mode === 20 || L.mode === 15 ? 256 : 0)),
                      ((qe == 0 && Be === 0) || ye === 4) &&
                        Ae === C &&
                        (Ae = -5),
                      Ae)
                );
              }),
              (a.inflateEnd = function (J) {
                if (!J || !J.state) return T;
                var ye = J.state;
                return ye.window && (ye.window = null), (J.state = null), C;
              }),
              (a.inflateGetHeader = function (J, ye) {
                var L;
                return J && J.state && 2 & (L = J.state).wrap
                  ? (((L.head = ye).done = !1), C)
                  : T;
              }),
              (a.inflateSetDictionary = function (J, ye) {
                var L,
                  Ee = ye.length;
                return J && J.state
                  ? (L = J.state).wrap !== 0 && L.mode !== 11
                    ? T
                    : L.mode === 11 && f(1, ye, Ee, 0) !== L.check
                    ? -3
                    : Me(J, ye, Ee, Ee)
                    ? ((L.mode = 31), -4)
                    : ((L.havedict = 1), C)
                  : T;
              }),
              (a.inflateInfo = "pako inflate (from Nodeca project)");
          },
          {
            "../utils/common": 41,
            "./adler32": 43,
            "./crc32": 45,
            "./inffast": 48,
            "./inftrees": 50
          }
        ],
        50: [
          function (n, o, a) {
            var l = n("../utils/common"),
              f = [
                3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43,
                51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
              ],
              _ = [
                16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
                19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
              ],
              m = [
                1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257,
                385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289,
                16385, 24577, 0, 0
              ],
              g = [
                16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
                23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64
              ];
            o.exports = function (M, v, C, T, z, $, S, y) {
              var x,
                I,
                V,
                O,
                B,
                j,
                N,
                se,
                de,
                Me = y.bits,
                J = 0,
                ye = 0,
                L = 0,
                Ee = 0,
                Qe = 0,
                _e = 0,
                X = 0,
                oe = 0,
                xe = 0,
                Y = 0,
                ge = null,
                qe = 0,
                Be = new l.Buf16(16),
                Ne = new l.Buf16(16),
                We = null,
                st = 0;
              for (J = 0; J <= 15; J++) Be[J] = 0;
              for (ye = 0; ye < T; ye++) Be[v[C + ye]]++;
              for (Qe = Me, Ee = 15; 1 <= Ee && Be[Ee] === 0; Ee--);
              if ((Ee < Qe && (Qe = Ee), Ee === 0))
                return (
                  (z[$++] = 20971520), (z[$++] = 20971520), (y.bits = 1), 0
                );
              for (L = 1; L < Ee && Be[L] === 0; L++);
              for (Qe < L && (Qe = L), J = oe = 1; J <= 15; J++)
                if (((oe <<= 1), (oe -= Be[J]) < 0)) return -1;
              if (0 < oe && (M === 0 || Ee !== 1)) return -1;
              for (Ne[1] = 0, J = 1; J < 15; J++) Ne[J + 1] = Ne[J] + Be[J];
              for (ye = 0; ye < T; ye++)
                v[C + ye] !== 0 && (S[Ne[v[C + ye]]++] = ye);
              if (
                ((j =
                  M === 0
                    ? ((ge = We = S), 19)
                    : M === 1
                    ? ((ge = f), (qe -= 257), (We = _), (st -= 257), 256)
                    : ((ge = m), (We = g), -1)),
                (J = L),
                (B = $),
                (X = ye = Y = 0),
                (V = -1),
                (O = (xe = 1 << (_e = Qe)) - 1),
                (M === 1 && 852 < xe) || (M === 2 && 592 < xe))
              )
                return 1;
              for (;;) {
                for (
                  N = J - X,
                    de =
                      S[ye] < j
                        ? ((se = 0), S[ye])
                        : S[ye] > j
                        ? ((se = We[st + S[ye]]), ge[qe + S[ye]])
                        : ((se = 96), 0),
                    x = 1 << (J - X),
                    L = I = 1 << _e;
                  (z[B + (Y >> X) + (I -= x)] =
                    (N << 24) | (se << 16) | de | 0),
                    I !== 0;

                );
                for (x = 1 << (J - 1); Y & x; ) x >>= 1;
                if (
                  (x !== 0 ? ((Y &= x - 1), (Y += x)) : (Y = 0),
                  ye++,
                  --Be[J] == 0)
                ) {
                  if (J === Ee) break;
                  J = v[C + S[ye]];
                }
                if (Qe < J && (Y & O) !== V) {
                  for (
                    X === 0 && (X = Qe), B += L, oe = 1 << (_e = J - X);
                    _e + X < Ee && !((oe -= Be[_e + X]) <= 0);

                  )
                    _e++, (oe <<= 1);
                  if (
                    ((xe += 1 << _e),
                    (M === 1 && 852 < xe) || (M === 2 && 592 < xe))
                  )
                    return 1;
                  z[(V = Y & O)] = (Qe << 24) | (_e << 16) | (B - $) | 0;
                }
              }
              return (
                Y !== 0 && (z[B + Y] = ((J - X) << 24) | (64 << 16) | 0),
                (y.bits = Qe),
                0
              );
            };
          },
          { "../utils/common": 41 }
        ],
        51: [
          function (n, o, a) {
            o.exports = {
              2: "need dictionary",
              1: "stream end",
              0: "",
              "-1": "file error",
              "-2": "stream error",
              "-3": "data error",
              "-4": "insufficient memory",
              "-5": "buffer error",
              "-6": "incompatible version"
            };
          },
          {}
        ],
        52: [
          function (n, o, a) {
            var l = n("../utils/common"),
              f = 0,
              _ = 1;
            function m(ne) {
              for (var ve = ne.length; 0 <= --ve; ) ne[ve] = 0;
            }
            var g = 0,
              M = 29,
              v = 256,
              C = v + 1 + M,
              T = 30,
              z = 19,
              $ = 2 * C + 1,
              S = 15,
              y = 16,
              x = 7,
              I = 256,
              V = 16,
              O = 17,
              B = 18,
              j = [
                0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4,
                4, 4, 4, 5, 5, 5, 5, 0
              ],
              N = [
                0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9,
                9, 10, 10, 11, 11, 12, 12, 13, 13
              ],
              se = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
              de = [
                16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
              ],
              Me = new Array(2 * (C + 2));
            m(Me);
            var J = new Array(2 * T);
            m(J);
            var ye = new Array(512);
            m(ye);
            var L = new Array(256);
            m(L);
            var Ee = new Array(M);
            m(Ee);
            var Qe,
              _e,
              X,
              oe = new Array(T);
            function xe(ne, ve, R, te, D) {
              (this.static_tree = ne),
                (this.extra_bits = ve),
                (this.extra_base = R),
                (this.elems = te),
                (this.max_length = D),
                (this.has_stree = ne && ne.length);
            }
            function Y(ne, ve) {
              (this.dyn_tree = ne), (this.max_code = 0), (this.stat_desc = ve);
            }
            function ge(ne) {
              return ne < 256 ? ye[ne] : ye[256 + (ne >>> 7)];
            }
            function qe(ne, ve) {
              (ne.pending_buf[ne.pending++] = 255 & ve),
                (ne.pending_buf[ne.pending++] = (ve >>> 8) & 255);
            }
            function Be(ne, ve, R) {
              ne.bi_valid > y - R
                ? ((ne.bi_buf |= (ve << ne.bi_valid) & 65535),
                  qe(ne, ne.bi_buf),
                  (ne.bi_buf = ve >> (y - ne.bi_valid)),
                  (ne.bi_valid += R - y))
                : ((ne.bi_buf |= (ve << ne.bi_valid) & 65535),
                  (ne.bi_valid += R));
            }
            function Ne(ne, ve, R) {
              Be(ne, R[2 * ve], R[2 * ve + 1]);
            }
            function We(ne, ve) {
              for (
                var R = 0;
                (R |= 1 & ne), (ne >>>= 1), (R <<= 1), 0 < --ve;

              );
              return R >>> 1;
            }
            function st(ne, ve, R) {
              var te,
                D,
                ce = new Array(S + 1),
                ue = 0;
              for (te = 1; te <= S; te++) ce[te] = ue = (ue + R[te - 1]) << 1;
              for (D = 0; D <= ve; D++) {
                var ke = ne[2 * D + 1];
                ke !== 0 && (ne[2 * D] = We(ce[ke]++, ke));
              }
            }
            function pt(ne) {
              var ve;
              for (ve = 0; ve < C; ve++) ne.dyn_ltree[2 * ve] = 0;
              for (ve = 0; ve < T; ve++) ne.dyn_dtree[2 * ve] = 0;
              for (ve = 0; ve < z; ve++) ne.bl_tree[2 * ve] = 0;
              (ne.dyn_ltree[2 * I] = 1),
                (ne.opt_len = ne.static_len = 0),
                (ne.last_lit = ne.matches = 0);
            }
            function Ge(ne) {
              8 < ne.bi_valid
                ? qe(ne, ne.bi_buf)
                : 0 < ne.bi_valid && (ne.pending_buf[ne.pending++] = ne.bi_buf),
                (ne.bi_buf = 0),
                (ne.bi_valid = 0);
            }
            function Te(ne, ve, R, te) {
              var D = 2 * ve,
                ce = 2 * R;
              return ne[D] < ne[ce] || (ne[D] === ne[ce] && te[ve] <= te[R]);
            }
            function je(ne, ve, R) {
              for (
                var te = ne.heap[R], D = R << 1;
                D <= ne.heap_len &&
                (D < ne.heap_len &&
                  Te(ve, ne.heap[D + 1], ne.heap[D], ne.depth) &&
                  D++,
                !Te(ve, te, ne.heap[D], ne.depth));

              )
                (ne.heap[R] = ne.heap[D]), (R = D), (D <<= 1);
              ne.heap[R] = te;
            }
            function Ye(ne, ve, R) {
              var te,
                D,
                ce,
                ue,
                ke = 0;
              if (ne.last_lit !== 0)
                for (
                  ;
                  (te =
                    (ne.pending_buf[ne.d_buf + 2 * ke] << 8) |
                    ne.pending_buf[ne.d_buf + 2 * ke + 1]),
                    (D = ne.pending_buf[ne.l_buf + ke]),
                    ke++,
                    te === 0
                      ? Ne(ne, D, ve)
                      : (Ne(ne, (ce = L[D]) + v + 1, ve),
                        (ue = j[ce]) !== 0 && Be(ne, (D -= Ee[ce]), ue),
                        Ne(ne, (ce = ge(--te)), R),
                        (ue = N[ce]) !== 0 && Be(ne, (te -= oe[ce]), ue)),
                    ke < ne.last_lit;

                );
              Ne(ne, I, ve);
            }
            function et(ne, ve) {
              var R,
                te,
                D,
                ce = ve.dyn_tree,
                ue = ve.stat_desc.static_tree,
                ke = ve.stat_desc.has_stree,
                Re = ve.stat_desc.elems,
                ht = -1;
              for (ne.heap_len = 0, ne.heap_max = $, R = 0; R < Re; R++)
                ce[2 * R] !== 0
                  ? ((ne.heap[++ne.heap_len] = ht = R), (ne.depth[R] = 0))
                  : (ce[2 * R + 1] = 0);
              for (; ne.heap_len < 2; )
                (ce[2 * (D = ne.heap[++ne.heap_len] = ht < 2 ? ++ht : 0)] = 1),
                  (ne.depth[D] = 0),
                  ne.opt_len--,
                  ke && (ne.static_len -= ue[2 * D + 1]);
              for (ve.max_code = ht, R = ne.heap_len >> 1; 1 <= R; R--)
                je(ne, ce, R);
              for (
                D = Re;
                (R = ne.heap[1]),
                  (ne.heap[1] = ne.heap[ne.heap_len--]),
                  je(ne, ce, 1),
                  (te = ne.heap[1]),
                  (ne.heap[--ne.heap_max] = R),
                  (ne.heap[--ne.heap_max] = te),
                  (ce[2 * D] = ce[2 * R] + ce[2 * te]),
                  (ne.depth[D] =
                    (ne.depth[R] >= ne.depth[te] ? ne.depth[R] : ne.depth[te]) +
                    1),
                  (ce[2 * R + 1] = ce[2 * te + 1] = D),
                  (ne.heap[1] = D++),
                  je(ne, ce, 1),
                  2 <= ne.heap_len;

              );
              (ne.heap[--ne.heap_max] = ne.heap[1]),
                (function (tt, wt) {
                  var bt,
                    Ke,
                    fe,
                    Ie,
                    Ve,
                    ot,
                    Xe = wt.dyn_tree,
                    ft = wt.max_code,
                    xt = wt.stat_desc.static_tree,
                    vt = wt.stat_desc.has_stree,
                    $t = wt.stat_desc.extra_bits,
                    Tt = wt.stat_desc.extra_base,
                    rt = wt.stat_desc.max_length,
                    Nt = 0;
                  for (Ie = 0; Ie <= S; Ie++) tt.bl_count[Ie] = 0;
                  for (
                    Xe[2 * tt.heap[tt.heap_max] + 1] = 0, bt = tt.heap_max + 1;
                    bt < $;
                    bt++
                  )
                    rt <
                      (Ie = Xe[2 * Xe[2 * (Ke = tt.heap[bt]) + 1] + 1] + 1) &&
                      ((Ie = rt), Nt++),
                      (Xe[2 * Ke + 1] = Ie),
                      ft < Ke ||
                        (tt.bl_count[Ie]++,
                        (Ve = 0),
                        Tt <= Ke && (Ve = $t[Ke - Tt]),
                        (ot = Xe[2 * Ke]),
                        (tt.opt_len += ot * (Ie + Ve)),
                        vt && (tt.static_len += ot * (xt[2 * Ke + 1] + Ve)));
                  if (Nt !== 0) {
                    do {
                      for (Ie = rt - 1; tt.bl_count[Ie] === 0; ) Ie--;
                      tt.bl_count[Ie]--,
                        (tt.bl_count[Ie + 1] += 2),
                        tt.bl_count[rt]--,
                        (Nt -= 2);
                    } while (0 < Nt);
                    for (Ie = rt; Ie !== 0; Ie--)
                      for (Ke = tt.bl_count[Ie]; Ke !== 0; )
                        ft < (fe = tt.heap[--bt]) ||
                          (Xe[2 * fe + 1] !== Ie &&
                            ((tt.opt_len += (Ie - Xe[2 * fe + 1]) * Xe[2 * fe]),
                            (Xe[2 * fe + 1] = Ie)),
                          Ke--);
                  }
                })(ne, ve),
                st(ce, ht, ne.bl_count);
            }
            function A(ne, ve, R) {
              var te,
                D,
                ce = -1,
                ue = ve[1],
                ke = 0,
                Re = 7,
                ht = 4;
              for (
                ue === 0 && ((Re = 138), (ht = 3)),
                  ve[2 * (R + 1) + 1] = 65535,
                  te = 0;
                te <= R;
                te++
              )
                (D = ue),
                  (ue = ve[2 * (te + 1) + 1]),
                  (++ke < Re && D === ue) ||
                    (ke < ht
                      ? (ne.bl_tree[2 * D] += ke)
                      : D !== 0
                      ? (D !== ce && ne.bl_tree[2 * D]++, ne.bl_tree[2 * V]++)
                      : ke <= 10
                      ? ne.bl_tree[2 * O]++
                      : ne.bl_tree[2 * B]++,
                    (ce = D),
                    (ht =
                      (ke = 0) === ue
                        ? ((Re = 138), 3)
                        : D === ue
                        ? ((Re = 6), 3)
                        : ((Re = 7), 4)));
            }
            function Ae(ne, ve, R) {
              var te,
                D,
                ce = -1,
                ue = ve[1],
                ke = 0,
                Re = 7,
                ht = 4;
              for (ue === 0 && ((Re = 138), (ht = 3)), te = 0; te <= R; te++)
                if (
                  ((D = ue),
                  (ue = ve[2 * (te + 1) + 1]),
                  !(++ke < Re && D === ue))
                ) {
                  if (ke < ht) for (; Ne(ne, D, ne.bl_tree), --ke != 0; );
                  else
                    D !== 0
                      ? (D !== ce && (Ne(ne, D, ne.bl_tree), ke--),
                        Ne(ne, V, ne.bl_tree),
                        Be(ne, ke - 3, 2))
                      : ke <= 10
                      ? (Ne(ne, O, ne.bl_tree), Be(ne, ke - 3, 3))
                      : (Ne(ne, B, ne.bl_tree), Be(ne, ke - 11, 7));
                  (ce = D),
                    (ht =
                      (ke = 0) === ue
                        ? ((Re = 138), 3)
                        : D === ue
                        ? ((Re = 6), 3)
                        : ((Re = 7), 4));
                }
            }
            m(oe);
            var $e = !1;
            function ae(ne, ve, R, te) {
              Be(ne, (g << 1) + (te ? 1 : 0), 3),
                (function (D, ce, ue, ke) {
                  Ge(D),
                    qe(D, ue),
                    qe(D, ~ue),
                    l.arraySet(D.pending_buf, D.window, ce, ue, D.pending),
                    (D.pending += ue);
                })(ne, ve, R);
            }
            (a._tr_init = function (ne) {
              $e ||
                ((function () {
                  var ve,
                    R,
                    te,
                    D,
                    ce,
                    ue = new Array(S + 1);
                  for (D = te = 0; D < M - 1; D++)
                    for (Ee[D] = te, ve = 0; ve < 1 << j[D]; ve++) L[te++] = D;
                  for (L[te - 1] = D, D = ce = 0; D < 16; D++)
                    for (oe[D] = ce, ve = 0; ve < 1 << N[D]; ve++) ye[ce++] = D;
                  for (ce >>= 7; D < T; D++)
                    for (oe[D] = ce << 7, ve = 0; ve < 1 << (N[D] - 7); ve++)
                      ye[256 + ce++] = D;
                  for (R = 0; R <= S; R++) ue[R] = 0;
                  for (ve = 0; ve <= 143; ) (Me[2 * ve + 1] = 8), ve++, ue[8]++;
                  for (; ve <= 255; ) (Me[2 * ve + 1] = 9), ve++, ue[9]++;
                  for (; ve <= 279; ) (Me[2 * ve + 1] = 7), ve++, ue[7]++;
                  for (; ve <= 287; ) (Me[2 * ve + 1] = 8), ve++, ue[8]++;
                  for (st(Me, C + 1, ue), ve = 0; ve < T; ve++)
                    (J[2 * ve + 1] = 5), (J[2 * ve] = We(ve, 5));
                  (Qe = new xe(Me, j, v + 1, C, S)),
                    (_e = new xe(J, N, 0, T, S)),
                    (X = new xe(new Array(0), se, 0, z, x));
                })(),
                ($e = !0)),
                (ne.l_desc = new Y(ne.dyn_ltree, Qe)),
                (ne.d_desc = new Y(ne.dyn_dtree, _e)),
                (ne.bl_desc = new Y(ne.bl_tree, X)),
                (ne.bi_buf = 0),
                (ne.bi_valid = 0),
                pt(ne);
            }),
              (a._tr_stored_block = ae),
              (a._tr_flush_block = function (ne, ve, R, te) {
                var D,
                  ce,
                  ue = 0;
                0 < ne.level
                  ? (ne.strm.data_type === 2 &&
                      (ne.strm.data_type = (function (ke) {
                        var Re,
                          ht = 4093624447;
                        for (Re = 0; Re <= 31; Re++, ht >>>= 1)
                          if (1 & ht && ke.dyn_ltree[2 * Re] !== 0) return f;
                        if (
                          ke.dyn_ltree[18] !== 0 ||
                          ke.dyn_ltree[20] !== 0 ||
                          ke.dyn_ltree[26] !== 0
                        )
                          return _;
                        for (Re = 32; Re < v; Re++)
                          if (ke.dyn_ltree[2 * Re] !== 0) return _;
                        return f;
                      })(ne)),
                    et(ne, ne.l_desc),
                    et(ne, ne.d_desc),
                    (ue = (function (ke) {
                      var Re;
                      for (
                        A(ke, ke.dyn_ltree, ke.l_desc.max_code),
                          A(ke, ke.dyn_dtree, ke.d_desc.max_code),
                          et(ke, ke.bl_desc),
                          Re = z - 1;
                        3 <= Re && ke.bl_tree[2 * de[Re] + 1] === 0;
                        Re--
                      );
                      return (ke.opt_len += 3 * (Re + 1) + 5 + 5 + 4), Re;
                    })(ne)),
                    (D = (ne.opt_len + 3 + 7) >>> 3),
                    (ce = (ne.static_len + 3 + 7) >>> 3) <= D && (D = ce))
                  : (D = ce = R + 5),
                  R + 4 <= D && ve !== -1
                    ? ae(ne, ve, R, te)
                    : ne.strategy === 4 || ce === D
                    ? (Be(ne, 2 + (te ? 1 : 0), 3), Ye(ne, Me, J))
                    : (Be(ne, 4 + (te ? 1 : 0), 3),
                      (function (ke, Re, ht, tt) {
                        var wt;
                        for (
                          Be(ke, Re - 257, 5),
                            Be(ke, ht - 1, 5),
                            Be(ke, tt - 4, 4),
                            wt = 0;
                          wt < tt;
                          wt++
                        )
                          Be(ke, ke.bl_tree[2 * de[wt] + 1], 3);
                        Ae(ke, ke.dyn_ltree, Re - 1),
                          Ae(ke, ke.dyn_dtree, ht - 1);
                      })(
                        ne,
                        ne.l_desc.max_code + 1,
                        ne.d_desc.max_code + 1,
                        ue + 1
                      ),
                      Ye(ne, ne.dyn_ltree, ne.dyn_dtree)),
                  pt(ne),
                  te && Ge(ne);
              }),
              (a._tr_tally = function (ne, ve, R) {
                return (
                  (ne.pending_buf[ne.d_buf + 2 * ne.last_lit] =
                    (ve >>> 8) & 255),
                  (ne.pending_buf[ne.d_buf + 2 * ne.last_lit + 1] = 255 & ve),
                  (ne.pending_buf[ne.l_buf + ne.last_lit] = 255 & R),
                  ne.last_lit++,
                  ve === 0
                    ? ne.dyn_ltree[2 * R]++
                    : (ne.matches++,
                      ve--,
                      ne.dyn_ltree[2 * (L[R] + v + 1)]++,
                      ne.dyn_dtree[2 * ge(ve)]++),
                  ne.last_lit === ne.lit_bufsize - 1
                );
              }),
              (a._tr_align = function (ne) {
                Be(ne, 2, 3),
                  Ne(ne, I, Me),
                  (function (ve) {
                    ve.bi_valid === 16
                      ? (qe(ve, ve.bi_buf), (ve.bi_buf = 0), (ve.bi_valid = 0))
                      : 8 <= ve.bi_valid &&
                        ((ve.pending_buf[ve.pending++] = 255 & ve.bi_buf),
                        (ve.bi_buf >>= 8),
                        (ve.bi_valid -= 8));
                  })(ne);
              });
          },
          { "../utils/common": 41 }
        ],
        53: [
          function (n, o, a) {
            o.exports = function () {
              (this.input = null),
                (this.next_in = 0),
                (this.avail_in = 0),
                (this.total_in = 0),
                (this.output = null),
                (this.next_out = 0),
                (this.avail_out = 0),
                (this.total_out = 0),
                (this.msg = ""),
                (this.state = null),
                (this.data_type = 2),
                (this.adler = 0);
            };
          },
          {}
        ],
        54: [
          function (n, o, a) {
            (function (l) {
              (function (f, _) {
                if (!f.setImmediate) {
                  var m,
                    g,
                    M,
                    v,
                    C = 1,
                    T = {},
                    z = !1,
                    $ = f.document,
                    S = Object.getPrototypeOf && Object.getPrototypeOf(f);
                  (S = S && S.setTimeout ? S : f),
                    (m =
                      {}.toString.call(f.process) === "[object process]"
                        ? function (V) {
                            process.nextTick(function () {
                              x(V);
                            });
                          }
                        : (function () {
                            if (f.postMessage && !f.importScripts) {
                              var V = !0,
                                O = f.onmessage;
                              return (
                                (f.onmessage = function () {
                                  V = !1;
                                }),
                                f.postMessage("", "*"),
                                (f.onmessage = O),
                                V
                              );
                            }
                          })()
                        ? ((v = "setImmediate$" + Math.random() + "$"),
                          f.addEventListener
                            ? f.addEventListener("message", I, !1)
                            : f.attachEvent("onmessage", I),
                          function (V) {
                            f.postMessage(v + V, "*");
                          })
                        : f.MessageChannel
                        ? (((M = new MessageChannel()).port1.onmessage =
                            function (V) {
                              x(V.data);
                            }),
                          function (V) {
                            M.port2.postMessage(V);
                          })
                        : $ && "onreadystatechange" in $.createElement("script")
                        ? ((g = $.documentElement),
                          function (V) {
                            var O = $.createElement("script");
                            (O.onreadystatechange = function () {
                              x(V),
                                (O.onreadystatechange = null),
                                g.removeChild(O),
                                (O = null);
                            }),
                              g.appendChild(O);
                          })
                        : function (V) {
                            setTimeout(x, 0, V);
                          }),
                    (S.setImmediate = function (V) {
                      typeof V != "function" && (V = new Function("" + V));
                      for (
                        var O = new Array(arguments.length - 1), B = 0;
                        B < O.length;
                        B++
                      )
                        O[B] = arguments[B + 1];
                      var j = { callback: V, args: O };
                      return (T[C] = j), m(C), C++;
                    }),
                    (S.clearImmediate = y);
                }
                function y(V) {
                  delete T[V];
                }
                function x(V) {
                  if (z) setTimeout(x, 0, V);
                  else {
                    var O = T[V];
                    if (O) {
                      z = !0;
                      try {
                        (function (B) {
                          var j = B.callback,
                            N = B.args;
                          switch (N.length) {
                            case 0:
                              j();
                              break;
                            case 1:
                              j(N[0]);
                              break;
                            case 2:
                              j(N[0], N[1]);
                              break;
                            case 3:
                              j(N[0], N[1], N[2]);
                              break;
                            default:
                              j.apply(_, N);
                          }
                        })(O);
                      } finally {
                        y(V), (z = !1);
                      }
                    }
                  }
                }
                function I(V) {
                  V.source === f &&
                    typeof V.data == "string" &&
                    V.data.indexOf(v) === 0 &&
                    x(+V.data.slice(v.length));
                }
              })(typeof self > "u" ? (l === void 0 ? this : l) : self);
            }).call(
              this,
              typeof Fo < "u"
                ? Fo
                : typeof self < "u"
                ? self
                : typeof window < "u"
                ? window
                : {}
            );
          },
          {}
        ]
      },
      {},
      [10]
    )(10);
  });
})(bx);
var OE = bx.exports;
const DE = W_(OE);
var xx = { exports: {} };
(function (e, t) {
  (function (n, o) {
    o();
  })(Fo, function () {
    function n(g, M) {
      return (
        typeof M > "u"
          ? (M = { autoBom: !1 })
          : typeof M != "object" &&
            (console.warn("Deprecated: Expected third argument to be a object"),
            (M = { autoBom: !M })),
        M.autoBom &&
        /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(
          g.type
        )
          ? new Blob(["\uFEFF", g], { type: g.type })
          : g
      );
    }
    function o(g, M, v) {
      var C = new XMLHttpRequest();
      C.open("GET", g),
        (C.responseType = "blob"),
        (C.onload = function () {
          m(C.response, M, v);
        }),
        (C.onerror = function () {
          console.error("could not download file");
        }),
        C.send();
    }
    function a(g) {
      var M = new XMLHttpRequest();
      M.open("HEAD", g, !1);
      try {
        M.send();
      } catch {}
      return 200 <= M.status && 299 >= M.status;
    }
    function l(g) {
      try {
        g.dispatchEvent(new MouseEvent("click"));
      } catch {
        var M = document.createEvent("MouseEvents");
        M.initMouseEvent(
          "click",
          !0,
          !0,
          window,
          0,
          0,
          0,
          80,
          20,
          !1,
          !1,
          !1,
          !1,
          0,
          null
        ),
          g.dispatchEvent(M);
      }
    }
    var f =
        typeof window == "object" && window.window === window
          ? window
          : typeof self == "object" && self.self === self
          ? self
          : typeof Fo == "object" && Fo.global === Fo
          ? Fo
          : void 0,
      _ =
        f.navigator &&
        /Macintosh/.test(navigator.userAgent) &&
        /AppleWebKit/.test(navigator.userAgent) &&
        !/Safari/.test(navigator.userAgent),
      m =
        f.saveAs ||
        (typeof window != "object" || window !== f
          ? function () {}
          : "download" in HTMLAnchorElement.prototype && !_
          ? function (g, M, v) {
              var C = f.URL || f.webkitURL,
                T = document.createElement("a");
              (M = M || g.name || "download"),
                (T.download = M),
                (T.rel = "noopener"),
                typeof g == "string"
                  ? ((T.href = g),
                    T.origin === location.origin
                      ? l(T)
                      : a(T.href)
                      ? o(g, M, v)
                      : l(T, (T.target = "_blank")))
                  : ((T.href = C.createObjectURL(g)),
                    setTimeout(function () {
                      C.revokeObjectURL(T.href);
                    }, 4e4),
                    setTimeout(function () {
                      l(T);
                    }, 0));
            }
          : "msSaveOrOpenBlob" in navigator
          ? function (g, M, v) {
              if (((M = M || g.name || "download"), typeof g != "string"))
                navigator.msSaveOrOpenBlob(n(g, v), M);
              else if (a(g)) o(g, M, v);
              else {
                var C = document.createElement("a");
                (C.href = g),
                  (C.target = "_blank"),
                  setTimeout(function () {
                    l(C);
                  });
              }
            }
          : function (g, M, v, C) {
              if (
                ((C = C || open("", "_blank")),
                C &&
                  (C.document.title = C.document.body.innerText =
                    "downloading..."),
                typeof g == "string")
              )
                return o(g, M, v);
              var T = g.type === "application/octet-stream",
                z = /constructor/i.test(f.HTMLElement) || f.safari,
                $ = /CriOS\/[\d]+/.test(navigator.userAgent);
              if (($ || (T && z) || _) && typeof FileReader < "u") {
                var S = new FileReader();
                (S.onloadend = function () {
                  var I = S.result;
                  (I = $
                    ? I
                    : I.replace(/^data:[^;]*;/, "data:attachment/file;")),
                    C ? (C.location.href = I) : (location = I),
                    (C = null);
                }),
                  S.readAsDataURL(g);
              } else {
                var y = f.URL || f.webkitURL,
                  x = y.createObjectURL(g);
                C ? (C.location = x) : (location.href = x),
                  (C = null),
                  setTimeout(function () {
                    y.revokeObjectURL(x);
                  }, 4e4);
              }
            });
    (f.saveAs = m.saveAs = m), (e.exports = m);
  });
})(xx);
var LE = xx.exports;
const BE = "/background-remover/assets/logo-ChZQEIpf.png";
function RE() {
  const [e, t] = yr.useState([]),
    [n, o] = yr.useState([]),
    [a, l] = yr.useState(!1),
    [f, _] = yr.useState(!1),
    [m, g] = yr.useState(!0),
    [M, v] = yr.useState(null),
    C = yr.useRef(null),
    T = yr.useRef(null);
  yr.useEffect(() => {
    (async () => {
      try {
        if (!navigator.gpu)
          throw new Error("WebGPU is not supported in this browser.");
        const de = "Xenova/modnet";
        (zE.backends.onnx.wasm.proxy = !1),
          C.current ??
            (C.current = await IE.from_pretrained(de, { device: "webgpu" })),
          T.current ?? (T.current = await FE.from_pretrained(de));
      } catch (de) {
        v(de);
      }
      g(!1);
    })();
  }, []);
  const z = yr.useCallback((de) => {
      t((Me) => [...Me, ...de.map((J) => URL.createObjectURL(J))]);
    }, []),
    {
      getRootProps: $,
      getInputProps: S,
      isDragActive: y,
      isDragAccept: x,
      isDragReject: I
    } = gx({ onDrop: z, accept: { "image/*": [".jpeg", ".jpg", ".png"] } }),
    V = (de) => {
      t((Me) => Me.filter((J, ye) => ye !== de)),
        o((Me) => Me.filter((J, ye) => ye !== de));
    },
    O = async () => {
      l(!0), o([]);
      const de = C.current,
        Me = T.current;
      for (let J = 0; J < e.length; ++J) {
        const ye = await V1.fromURL(e[J]),
          { pixel_values: L } = await Me(ye),
          { output: Ee } = await de({ input: L }),
          Qe = (
            await V1.fromTensor(Ee[0].mul(255).to("uint8")).resize(
              ye.width,
              ye.height
            )
          ).data,
          _e = document.createElement("canvas");
        (_e.width = ye.width), (_e.height = ye.height);
        const X = _e.getContext("2d");
        X.drawImage(ye.toCanvas(), 0, 0);
        const oe = X.getImageData(0, 0, ye.width, ye.height);
        for (let xe = 0; xe < Qe.length; ++xe) oe.data[4 * xe + 3] = Qe[xe];
        X.putImageData(oe, 0, 0), o((xe) => [...xe, _e.toDataURL("image/png")]);
      }
      l(!1), _(!0);
    },
    B = async () => {
      const de = new DE(),
        Me = e.map(
          (ye, L) =>
            new Promise((Ee) => {
              const Qe = document.createElement("canvas"),
                _e = Qe.getContext("2d"),
                X = new Image();
              (X.src = n[L] || ye),
                (X.onload = () => {
                  (Qe.width = X.width),
                    (Qe.height = X.height),
                    _e.drawImage(X, 0, 0),
                    Qe.toBlob((oe) => {
                      oe && de.file(`image-${L + 1}.png`, oe), Ee(null);
                    }, "image/png");
                });
            })
        );
      await Promise.all(Me);
      const J = await de.generateAsync({ type: "blob" });
      LE.saveAs(J, "images.zip");
    },
    j = () => {
      t([]), o([]), _(!1);
    },
    N = async (de) => {
      try {
        const J = await (await fetch(de)).blob(),
          ye = new ClipboardItem({ [J.type]: J });
        await navigator.clipboard.write([ye]),
          console.log("Image copied to clipboard");
      } catch (Me) {
        console.error("Failed to copy image: ", Me);
      }
    },
    se = (de) => {
      const Me = document.createElement("a");
      (Me.href = de),
        (Me.download = "image.png"),
        document.body.appendChild(Me),
        Me.click(),
        document.body.removeChild(Me);
    };
  return M
    ? Br.jsx("div", {
        className:
          "min-h-screen bg-black text-white flex items-center justify-center",
        children: Br.jsxs("div", {
          className: "text-center",
          children: [
            Br.jsx("h2", { className: "text-4xl mb-2", children: "ERROR" }),
            Br.jsx("p", {
              className: "text-xl max-w-[500px]",
              children: M.message
            })
          ]
        })
      })
    : m
    ? Br.jsx("div", {
        className:
          "min-h-screen bg-black text-white flex items-center justify-center",
        children: Br.jsxs("div", {
          className: "text-center",
          children: [
            Br.jsx("div", {
              className:
                "inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-white mb-4"
            }),
            Br.jsx("p", { className: "text-lg", children: "Cargando..." })
          ]
        })
      })
    : Br.jsxs("div", {
        className: "min-h-screen bg-[#16244F] text-white p-8",
        children: [
          Br.jsx("img", { src: BE, className: "logo" }),
          Br.jsx("h3", { children: "LCD Placas" }),
          Br.jsx("p", { className: "desc", children: "Borrador de fondos" }),
          Br.jsxs("div", {
            className: "max-w-4xl mx-auto",
            children: [
              Br.jsxs("div", {
                ...$(),
                className: `p-8 mb-8 border-2 border-dashed rounded-lg text-center cursor-pointer transition-colors duration-300 ease-in-out
            ${x ? "border-green-500 bg-green-900/20" : ""}
            ${I ? "border-red-500 bg-red-900/20" : ""}
            ${
              y
                ? "border-blue-500 bg-blue-900/20"
                : "border-gray-700 hover:border-blue-500 hover:bg-blue-900/10"
            }
          `,
                children: [
                  Br.jsx("input", { ...S(), className: "hidden" }),
                  Br.jsx("p", {
                    className: "text-lg mb-2",
                    children: y
                      ? "Soltar imagenes..."
                      : "Para subir fotos, hacer click aca..."
                  }),
                  Br.jsx("p", {
                    className: "text-sm text-gray-400",
                    children: "o arrastrar y soltar fotos aca"
                  })
                ]
              }),
              e.length
                ? Br.jsxs("div", {
                    className: "flex flex-col items-center gap-4 mb-8",
                    children: [
                      Br.jsx("button", {
                        onClick: O,
                        disabled: a || e.length === 0,
                        className:
                          "px-6 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-black disabled:bg-gray-700 disabled:cursor-not-allowed transition-colors duration-200 text-lg font-semibold",
                        children: a ? "Borrando fondos..." : "Borrar fondos"
                      }),
                      Br.jsxs("div", {
                        className: "flex gap-4",
                        children: [
                          Br.jsx("button", {
                            onClick: B,
                            disabled: !f,
                            className:
                              "px-3 py-1 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-black disabled:bg-gray-700 disabled:cursor-not-allowed transition-colors duration-200 text-sm",
                            children: "Descargar como ZIP"
                          }),
                          Br.jsx("button", {
                            onClick: j,
                            className:
                              "px-3 py-1 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-black transition-colors duration-200 text-sm",
                            children: "Borrar fotos"
                          })
                        ]
                      })
                    ]
                  })
                : Br.jsx(Br.Fragment, {}),
              Br.jsx("div", {
                className:
                  "grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6",
                children: e.map((de, Me) =>
                  Br.jsxs(
                    "div",
                    {
                      className: "relative group",
                      children: [
                        Br.jsx("img", {
                          src: n[Me] || de,
                          alt: `Image ${Me + 1}`,
                          className: "rounded-lg object-cover w-full h-48"
                        }),
                        n[Me] &&
                          Br.jsxs("div", {
                            className:
                              "absolute inset-0 bg-black bg-opacity-70 opacity-0 group-hover:opacity-100 transition-opacity duration-300 rounded-lg flex items-center justify-center",
                            children: [
                              Br.jsx("button", {
                                onClick: () => N(n[Me] || de),
                                className:
                                  "mx-2 px-3 py-1 bg-white text-gray-900 rounded-md hover:bg-gray-200 transition-colors duration-200 text-sm",
                                "aria-label": `Copy image ${
                                  Me + 1
                                } to clipboard`,
                                children: "Copiar imagen"
                              }),
                              Br.jsx("button", {
                                onClick: () => se(n[Me] || de),
                                className:
                                  "mx-2 px-3 py-1 bg-white text-gray-900 rounded-md hover:bg-gray-200 transition-colors duration-200 text-sm",
                                "aria-label": `Download image ${Me + 1}`,
                                children: "Descargar imagen"
                              })
                            ]
                          }),
                        Br.jsx("button", {
                          onClick: () => V(Me),
                          className:
                            "absolute top-2 right-2 bg-black bg-opacity-50 text-white w-6 h-6 rounded-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300 hover:bg-opacity-70",
                          "aria-label": `Remove image ${Me + 1}`,
                          children: "✕"
                        })
                      ]
                    },
                    Me
                  )
                )
              })
            ]
          })
        ]
      });
}
rx(document.getElementById("root")).render(
  Br.jsx(yr.StrictMode, { children: Br.jsx(RE, {}) })
);
